id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/v632/civetweb_8c_source.html:570548,Availability,alive,alive,570548,"al(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:570565,Availability,alive,alive,570565,"al(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:570625,Availability,down,down,570625,"al(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:580851,Availability,error,error,580851,"andlers = tmp_rh->next;; 19451 mg_free(tmp_rh->uri);; 19452 mg_free(tmp_rh);; 19453 }; 19454 ; 19455#if defined(USE_MBEDTLS); 19456 if (ctx->dd.ssl_ctx != NULL) {; 19457 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19458 mg_free(ctx->dd.ssl_ctx);; 19459 ctx->dd.ssl_ctx = NULL;; 19460 }; 19461 ; 19462#elif !defined(NO_SSL); 19463 /* Deallocate SSL context */; 19464 if (ctx->dd.ssl_ctx != NULL) {; 19465 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19466 int callback_ret =; 19467 (ctx->callbacks.external_ssl_ctx == NULL); 19468 ? 0; 19469 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19470 ; 19471 if (callback_ret == 0) {; 19472 SSL_CTX_free(ctx->dd.ssl_ctx);; 19473 }; 19474 /* else: ignore error and ommit SSL_CTX_free in case; 19475 * callback_ret is 1 */; 19476 }; 19477#endif /* !NO_SSL */; 19478 ; 19479 /* Deallocate worker thread ID array */; 19480 mg_free(ctx->worker_threadids);; 19481 ; 19482 /* Deallocate worker thread ID array */; 19483 mg_free(ctx->worker_connections);; 19484 ; 19485 /* deallocate system name string */; 19486 mg_free(ctx->systemName);; 19487 ; 19488 /* Deallocate context itself */; 19489 mg_free(ctx);; 19490}; 19491 ; 19492 ; 19493void; 19494mg_stop(struct mg_context *ctx); 19495{; 19496 pthread_t mt;; 19497 if (!ctx) {; 19498 return;; 19499 }; 19500 ; 19501 /* We don't use a lock here. Calling mg_stop with the same ctx from; 19502 * two threads is not allowed. */; 19503 mt = ctx->masterthreadid;; 19504 if (mt == 0) {; 19505 return;; 19506 }; 19507 ; 19508 ctx->masterthreadid = 0;; 19509 ; 19510 /* Set stop flag, so all threads know they have to exit. */; 19511 STOP_FLAG_ASSIGN(&ctx->stop_flag, 1);; 19512 ; 19513 /* Join timer thread */; 19514#if defined(USE_TIMERS); 19515 timers_exit(ctx);; 19516#endif; 19517 ; 19518 /* Wait until everything has stopped. */; 19519 while (!STOP_FLAG_IS_TWO(&ctx->stop_flag)) {; 19520 (void)mg_sleep(10);; 19521 }; 19522 ; 19523 /* Wait to stop master thread */; 19524 mg_join_thread(mt);; 19525 ; 19526 /* ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:584522,Availability,error,error,584522,"; 19578 uname(&name);; 19579 *sysName = mg_strdup(name.sysname);; 19580#endif; 19581}; 19582 ; 19583 ; 19584static void; 19585legacy_init(const char **options); 19586{; 19587 const char *ports_option = config_options[LISTENING_PORTS].default_value;; 19588 ; 19589 if (options) {; 19590 const char **run_options = options;; 19591 const char *optname = config_options[LISTENING_PORTS].name;; 19592 ; 19593 /* Try to find the ""listening_ports"" option */; 19594 while (*run_options) {; 19595 if (!strcmp(*run_options, optname)) {; 19596 ports_option = run_options[1];; 19597 }; 19598 run_options += 2;; 19599 }; 19600 }; 19601 ; 19602 if (is_ssl_port_used(ports_option)) {; 19603 /* Initialize with SSL support */; 19604 mg_init_library(MG_FEATURES_TLS);; 19605 } else {; 19606 /* Initialize without SSL support */; 19607 mg_init_library(MG_FEATURES_DEFAULT);; 19608 }; 19609}; 19610 ; 19611 ; 19612struct mg_context *; 19613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:584915,Availability,error,error,584915,"; 19578 uname(&name);; 19579 *sysName = mg_strdup(name.sysname);; 19580#endif; 19581}; 19582 ; 19583 ; 19584static void; 19585legacy_init(const char **options); 19586{; 19587 const char *ports_option = config_options[LISTENING_PORTS].default_value;; 19588 ; 19589 if (options) {; 19590 const char **run_options = options;; 19591 const char *optname = config_options[LISTENING_PORTS].name;; 19592 ; 19593 /* Try to find the ""listening_ports"" option */; 19594 while (*run_options) {; 19595 if (!strcmp(*run_options, optname)) {; 19596 ports_option = run_options[1];; 19597 }; 19598 run_options += 2;; 19599 }; 19600 }; 19601 ; 19602 if (is_ssl_port_used(ports_option)) {; 19603 /* Initialize with SSL support */; 19604 mg_init_library(MG_FEATURES_TLS);; 19605 } else {; 19606 /* Initialize without SSL support */; 19607 mg_init_library(MG_FEATURES_DEFAULT);; 19608 }; 19609}; 19610 ; 19611 ; 19612struct mg_context *; 19613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:584939,Availability,error,error,584939,"; 19578 uname(&name);; 19579 *sysName = mg_strdup(name.sysname);; 19580#endif; 19581}; 19582 ; 19583 ; 19584static void; 19585legacy_init(const char **options); 19586{; 19587 const char *ports_option = config_options[LISTENING_PORTS].default_value;; 19588 ; 19589 if (options) {; 19590 const char **run_options = options;; 19591 const char *optname = config_options[LISTENING_PORTS].name;; 19592 ; 19593 /* Try to find the ""listening_ports"" option */; 19594 while (*run_options) {; 19595 if (!strcmp(*run_options, optname)) {; 19596 ports_option = run_options[1];; 19597 }; 19598 run_options += 2;; 19599 }; 19600 }; 19601 ; 19602 if (is_ssl_port_used(ports_option)) {; 19603 /* Initialize with SSL support */; 19604 mg_init_library(MG_FEATURES_TLS);; 19605 } else {; 19606 /* Initialize without SSL support */; 19607 mg_init_library(MG_FEATURES_DEFAULT);; 19608 }; 19609}; 19610 ; 19611 ; 19612struct mg_context *; 19613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:584967,Availability,error,error,584967,"; 19578 uname(&name);; 19579 *sysName = mg_strdup(name.sysname);; 19580#endif; 19581}; 19582 ; 19583 ; 19584static void; 19585legacy_init(const char **options); 19586{; 19587 const char *ports_option = config_options[LISTENING_PORTS].default_value;; 19588 ; 19589 if (options) {; 19590 const char **run_options = options;; 19591 const char *optname = config_options[LISTENING_PORTS].name;; 19592 ; 19593 /* Try to find the ""listening_ports"" option */; 19594 while (*run_options) {; 19595 if (!strcmp(*run_options, optname)) {; 19596 ports_option = run_options[1];; 19597 }; 19598 run_options += 2;; 19599 }; 19600 }; 19601 ; 19602 if (is_ssl_port_used(ports_option)) {; 19603 /* Initialize with SSL support */; 19604 mg_init_library(MG_FEATURES_TLS);; 19605 } else {; 19606 /* Initialize without SSL support */; 19607 mg_init_library(MG_FEATURES_DEFAULT);; 19608 }; 19609}; 19610 ; 19611 ; 19612struct mg_context *; 19613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585006,Availability,error,error,585006,"; 19578 uname(&name);; 19579 *sysName = mg_strdup(name.sysname);; 19580#endif; 19581}; 19582 ; 19583 ; 19584static void; 19585legacy_init(const char **options); 19586{; 19587 const char *ports_option = config_options[LISTENING_PORTS].default_value;; 19588 ; 19589 if (options) {; 19590 const char **run_options = options;; 19591 const char *optname = config_options[LISTENING_PORTS].name;; 19592 ; 19593 /* Try to find the ""listening_ports"" option */; 19594 while (*run_options) {; 19595 if (!strcmp(*run_options, optname)) {; 19596 ports_option = run_options[1];; 19597 }; 19598 run_options += 2;; 19599 }; 19600 }; 19601 ; 19602 if (is_ssl_port_used(ports_option)) {; 19603 /* Initialize with SSL support */; 19604 mg_init_library(MG_FEATURES_TLS);; 19605 } else {; 19606 /* Initialize without SSL support */; 19607 mg_init_library(MG_FEATURES_DEFAULT);; 19608 }; 19609}; 19610 ; 19611 ; 19612struct mg_context *; 19613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585336,Availability,error,error,585336,"613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx =",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585355,Availability,error,error,585355,"613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx =",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585452,Availability,error,error,585452,"613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx =",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585476,Availability,error,error,585476,"613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx =",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585496,Availability,error,error,585496,"613mg_start2(struct mg_init_data *init, struct mg_error_data *error); 19614{; 19615 struct mg_context *ctx;; 19616 const char *name, *value, *default_value;; 19617 int idx, ok, workerthreadcount;; 19618 unsigned int i;; 19619 int itmp;; 19620 void (*exit_callback)(const struct mg_context *ctx) = 0;; 19621 const char **options =; 19622 ((init != NULL) ? (init->configuration_options) : (NULL));; 19623 ; 19624 struct mg_workerTLS tls;; 19625 ; 19626 if (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx =",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585782,Availability,error,error,585782,"f (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585801,Availability,error,error,585801,"f (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585898,Availability,error,error,585898,"f (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585922,Availability,error,error,585922,"f (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:585942,Availability,error,error,585942,"f (error != NULL) {; 19627 error->code = 0;; 19628 if (error->text_buffer_size > 0) {; 19629 *error->text = 0;; 19630 }; 19631 }; 19632 ; 19633 if (mg_init_library_called == 0) {; 19634 /* Legacy INIT, if mg_start is called without mg_init_library.; 19635 * Note: This will cause a memory leak when unloading the library.; 19636 */; 19637 legacy_init(options);; 19638 }; 19639 if (mg_init_library_called == 0) {; 19640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587348,Availability,error,error,587348,"9660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callba",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587505,Availability,error,error,587505,"endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid opti",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587524,Availability,error,error,587524,"endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid opti",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587621,Availability,error,error,587621,"endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid opti",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587645,Availability,error,error,587645,"endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid opti",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587665,Availability,error,error,587665,"endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid opti",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588717,Availability,error,error,588717,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588736,Availability,error,error,588736,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588833,Availability,error,error,588833,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588857,Availability,error,error,588857,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588877,Availability,error,error,588877,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589193,Availability,error,error,589193,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589212,Availability,error,error,589212,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589309,Availability,error,error,589309,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589333,Availability,error,error,589333,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589353,Availability,error,error,589353,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589643,Availability,error,error,589643,"e)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590478,Availability,error,error,590478,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590497,Availability,error,error,590497,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590594,Availability,error,error,590594,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590618,Availability,error,error,590618,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590638,Availability,error,error,590638,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591186,Availability,error,error,591186,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591205,Availability,error,error,591205,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591302,Availability,error,error,591302,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591326,Availability,error,error,591326,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591346,Availability,error,error,591346,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591852,Availability,error,error,591852,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591871,Availability,error,error,591871,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591968,Availability,error,error,591968,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591992,Availability,error,error,591992,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592012,Availability,error,error,592012,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592697,Availability,error,error,592697," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592716,Availability,error,error,592716," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592813,Availability,error,error,592813," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592837,Availability,error,error,592837," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592857,Availability,error,error,592857," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593279,Availability,error,error,593279,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593298,Availability,error,error,593298,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593395,Availability,error,error,593395,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593419,Availability,error,error,593419,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593439,Availability,error,error,593439,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594431,Availability,error,error,594431,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594469,Availability,error,error,594469,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594488,Availability,error,error,594488,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594585,Availability,error,error,594585,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594609,Availability,error,error,594609,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594629,Availability,error,error,594629,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595778,Availability,error,error,595778,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595816,Availability,error,error,595816,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595835,Availability,error,error,595835,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595932,Availability,error,error,595932,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595956,Availability,error,error,595956,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595976,Availability,error,error,595976,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596719,Availability,error,error,596719,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596811,Availability,error,error,596811,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596830,Availability,error,error,596830,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596927,Availability,error,error,596927,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596951,Availability,error,error,596951,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596971,Availability,error,error,596971,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597305,Availability,error,error,597305,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597397,Availability,error,error,597397,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597416,Availability,error,error,597416,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597513,Availability,error,error,597513,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597537,Availability,error,error,597537,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597557,Availability,error,error,597557,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597874,Availability,error,error,597874,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597966,Availability,error,error,597966,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597985,Availability,error,error,597985,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598082,Availability,error,error,598082,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598106,Availability,error,error,598106,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598126,Availability,error,error,598126,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598423,Availability,error,error,598423,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598515,Availability,error,error,598515,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598534,Availability,error,error,598534,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598631,Availability,error,error,598631,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598655,Availability,error,error,598655,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598675,Availability,error,error,598675,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599020,Availability,error,error,599020,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599112,Availability,error,error,599112,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599131,Availability,error,error,599131,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599228,Availability,error,error,599228,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599252,Availability,error,error,599252,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599272,Availability,error,error,599272,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599574,Availability,error,error,599574,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599666,Availability,error,error,599666,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599685,Availability,error,error,599685,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599782,Availability,error,error,599782,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599806,Availability,error,error,599806,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599826,Availability,error,error,599826,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:600385,Availability,error,error,600385,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:600404,Availability,error,error,600404,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:600501,Availability,error,error,600501,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:600525,Availability,error,error,600525,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:600545,Availability,error,error,600545,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601066,Availability,error,error,601066,"082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601085,Availability,error,error,601085,"eadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601182,Availability,error,error,601182,");; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)m",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601206,Availability,error,error,601206,"x->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_wo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601226,Availability,error,error,601226,"== NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601803,Availability,error,error,601803,"ds,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspe",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601822,Availability,error,error,601822,"truct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601919,Availability,error,error,601919,"r *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601943,Availability,error,error,601943," enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->clie",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:601963,Availability,error,error,601963,"orker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:602535,Availability,error,error,602535,"->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_b",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:602554,Availability,error,error,602554,"s[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:602651,Availability,error,error,602651,"ot enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:602675,Availability,error,error,602675,"ker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:602695,Availability,error,error,602695,"0131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 2019",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603365,Availability,error,error,603365," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603384,Availability,error,error,603384," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603481,Availability,error,error,603481," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603505,Availability,error,error,603505," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603525,Availability,error,error,603525," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603902,Availability,error,error,603902," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:603921,Availability,error,error,603921," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:604018,Availability,error,error,604018," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:604042,Availability,error,error,604042," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:604062,Availability,error,error,604062," *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 20196#endif; 20197 ; 20198#if defined(USE_TIMERS); 20199 if (timers_init(ctx) != 0) {; 20200 const char *err_msg = ""Error creating timers"";; 20201 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20202 ; 20203 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20204 mg_snprintf(NULL,; 20205 NULL, /* No truncation check for error buffers */; 20206 error->text,; 20207 error->text_buffer_size,; 20208 ""%s"",; 20209 err_msg);; 20210 }; 20211 free_context(ctx);; 20212 pthread_setspecific(sTlsKey, NULL);; 20213 return NULL;; 20214 }; 20215#endif; 20216 ; 20217 /* Context has been created - init user libraries */; 20218 if (ctx->callbacks.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605268,Availability,error,error,605268," {; 20219 ctx->callbacks.init_context(ctx);; 20220 }; 20221 ; 20222 /* From now, the context is successfully created.; 20223 * When it is destroyed, the exit callback should be called. */; 20224 ctx->callbacks.exit_context = exit_callback;; 20225 ctx->context_type = CONTEXT_SERVER; /* server context */; 20226 ; 20227 /* Start worker threads */; 20228 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 20229 /* worker_thread sets up the other fields */; 20230 ctx->worker_connections[i].phys_ctx = ctx;; 20231 if (mg_start_thread_with_id(worker_thread,; 20232 &ctx->worker_connections[i],; 20233 &ctx->worker_threadids[i]); 20234 != 0) {; 20235 ; 20236 long error_no = (long)ERRNO;; 20237 ; 20238 /* thread was not created */; 20239 if (i > 0) {; 20240 /* If the second, third, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605717,Availability,error,error,605717,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605767,Availability,error,error,605767,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605786,Availability,error,error,605786,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605891,Availability,error,error,605891,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605915,Availability,error,error,605915,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:605935,Availability,error,error,605935,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:606003,Availability,error,error,606003,"ird, ... thread cannot be created, set a; 20241 * warning, but keep running. */; 20242 mg_cry_ctx_internal(ctx,; 20243 ""Cannot start worker thread %i: error %ld"",; 20244 i + 1,; 20245 error_no);; 20246 ; 20247 /* If the server initialization should stop here, all; 20248 * threads that have already been created must be stopped; 20249 * first, before any free_context(ctx) call.; 20250 */; 20251 ; 20252 } else {; 20253 /* If the first worker thread cannot be created, stop; 20254 * initialization and free the entire server context. */; 20255 mg_cry_ctx_internal(ctx,; 20256 ""Cannot create threads: error %ld"",; 20257 error_no);; 20258 ; 20259 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20260 mg_snprintf(; 20261 NULL,; 20262 NULL, /* No truncation check for error buffers */; 20263 error->text,; 20264 error->text_buffer_size,; 20265 ""Cannot create first worker thread: error %ld"",; 20266 error_no);; 20267 }; 20268 free_context(ctx);; 20269 pthread_setspecific(sTlsKey, NULL);; 20270 return NULL;; 20271 }; 20272 break;; 20273 }; 20274 }; 20275 ; 20276 /* Start master (listening) thread */; 20277 mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);; 20278 ; 20279 pthread_setspecific(sTlsKey, NULL);; 20280 return ctx;; 20281}; 20282 ; 20283 ; 20284struct mg_context *; 20285mg_start(const struct mg_callbacks *callbacks,; 20286 void *user_data,; 20287 const char **options); 20288{; 20289 struct mg_init_data init = {0};; 20290 init.callbacks = callbacks;; 20291 init.user_data = user_data;; 20292 init.configuration_options = options;; 20293 ; 20294 return mg_start2(&init, NULL);; 20295}; 20296 ; 20297 ; 20298/* Add an additional domain to an already running web server. */; 20299int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:606943,Availability,error,error,606943,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607161,Availability,error,error,607161,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607185,Availability,error,error,607185,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607213,Availability,error,error,607213,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607252,Availability,error,error,607252,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607356,Availability,error,error,607356,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607375,Availability,error,error,607375,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607472,Availability,error,error,607472,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607496,Availability,error,error,607496,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607516,Availability,error,error,607516,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607690,Availability,error,error,607690,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607709,Availability,error,error,607709,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607806,Availability,error,error,607806,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607830,Availability,error,error,607830,"9int; 20300mg_start_domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context *dom;; 20309 int idx, i;; 20310 ; 20311 if (error != NULL) {; 20312 error->code = 0;; 20313 if (error->text_buffer_size > 0) {; 20314 *error->text = 0;; 20315 }; 20316 }; 20317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:607850,Availability,error,error,607850,"domain2(struct mg_context *ctx,; 20301 const char **options,; 20302 struct mg_error_data *error); 20303{; 20304 const char *name;; 20305 const char *value;; 20306 const char *default_value;; 20307 struct mg_domain_context *new_dom;; 20308 struct mg_domain_context *dom;; 20309 int idx, i;; 20310 ; 20311 if (error != NULL) {; 20312 error->code = 0;; 20313 if (error->text_buffer_size > 0) {; 20314 *error->text = 0;; 20315 }; 20316 }; 20317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid opt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608146,Availability,error,error,608146,"; 20311 if (error != NULL) {; 20312 error->code = 0;; 20313 if (error->text_buffer_size > 0) {; 20314 *error->text = 0;; 20315 }; 20316 }; 20317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608165,Availability,error,error,608165,"= NULL) {; 20312 error->code = 0;; 20313 if (error->text_buffer_size > 0) {; 20314 *error->text = 0;; 20315 }; 20316 }; 20317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncati",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608262,Availability,error,error,608262," 0;; 20315 }; 20316 }; 20317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608286,Availability,error,error,608286,"0317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 203",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608306,Availability,error,error,608306,"x == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608649,Availability,error,error,608649,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608668,Availability,error,error,608668,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608765,Availability,error,error,608765,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608789,Availability,error,error,608789,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:608809,Availability,error,error,608809,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609065,Availability,error,error,609065,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609084,Availability,error,error,609084,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609181,Availability,error,error,609181,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609205,Availability,error,error,609205,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609225,Availability,error,error,609225,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609952,Availability,error,error,609952,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609971,Availability,error,error,609971,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610068,Availability,error,error,610068,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610092,Availability,error,error,610092,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610112,Availability,error,error,610112,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611113,Availability,error,error,611113,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611132,Availability,error,error,611132,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611229,Availability,error,error,611229,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611253,Availability,error,error,611253,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611273,Availability,error,error,611273,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611842,Availability,error,error,611842,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611861,Availability,error,error,611861,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611958,Availability,error,error,611958,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611982,Availability,error,error,611982,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:612002,Availability,error,error,612002,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:612912,Availability,avail,available,612912,";;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsigned feature); 20498{; 20499 static const unsigned feature_set = 0; 20500 /* Set bits for available features according to API documentation.; 20501 * This bit mask is created at compile time, according to the active; 20502 * preprocessor defines. It is a single const value at runtime. */; 20503#if !defined(NO_FILES); 20504 | MG_FEATURES_FILES; 20505#endif; 20506#if !defined(NO_SSL) || defined(USE_MBEDTLS); 20507 | MG_FEATURES_SSL; 20508#endif; 20509#if !defined(NO_CGI); 20510 | MG_FEATURES_CGI; 20511#endif; 20512#if defined(USE_IPV6); 20513 | MG_FEATURES_IPV6; 20514#endif; 20515#if defined(USE_WEBSOCKET); 20516 | MG_FEATURES_WEBSOCKET; 20517#endif; 20518#if defined(USE_LUA); 20519 | MG_FEATURES_LUA; 20520#endif; 20521#if defined(USE_DUK",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:612981,Availability,mask,mask,612981,"uffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsigned feature); 20498{; 20499 static const unsigned feature_set = 0; 20500 /* Set bits for available features according to API documentation.; 20501 * This bit mask is created at compile time, according to the active; 20502 * preprocessor defines. It is a single const value at runtime. */; 20503#if !defined(NO_FILES); 20504 | MG_FEATURES_FILES; 20505#endif; 20506#if !defined(NO_SSL) || defined(USE_MBEDTLS); 20507 | MG_FEATURES_SSL; 20508#endif; 20509#if !defined(NO_CGI); 20510 | MG_FEATURES_CGI; 20511#endif; 20512#if defined(USE_IPV6); 20513 | MG_FEATURES_IPV6; 20514#endif; 20515#if defined(USE_WEBSOCKET); 20516 | MG_FEATURES_WEBSOCKET; 20517#endif; 20518#if defined(USE_LUA); 20519 | MG_FEATURES_LUA; 20520#endif; 20521#if defined(USE_DUKTAPE); 20522 | MG_FEATURES_SSJS; 20523#endif; 20524#if !defined(NO_CACHING); 20525 | MG_FEATURES_CACHE; 20526#endif; 20527#if defined(USE_SERVER_STATS); 20528 | MG_FEATURES_STATS; 20529#endif; 20530#if defined(USE_ZLIB); 20531 | MG_FEATURES_COMPRESSION; 20532#endif; 20533#if defined(USE_HTTP2); 20534 | MG_FEATURES_HTTP2; 20535#endif; 20536#if defined(USE_X_DOM_SOCKET); 20537 | MG_FEATURES_X_DOMAIN_SOCKET; 20538#endif; 20539 ; 20540 /* Set some",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:614983,Availability,avail,available,614983,"538#endif; 20539 ; 20540 /* Set some extra bits not defined in the API documentation.; 20541 * These bits may change without further notice. */; 20542#if defined(MG_LEGACY_INTERFACE); 20543 | 0x80000000u; 20544#endif; 20545#if defined(MG_EXPERIMENTAL_INTERFACES); 20546 | 0x40000000u; 20547#endif; 20548#if !defined(NO_RESPONSE_BUFFERING); 20549 | 0x20000000u; 20550#endif; 20551#if defined(MEMORY_DEBUGGING); 20552 | 0x10000000u; 20553#endif; 20554 ;; 20555 return (feature & feature_set);; 20556}; 20557 ; 20558 ; 20559static size_t; 20560mg_str_append(char **dst, char *end, const char *src); 20561{; 20562 size_t len = strlen(src);; 20563 if (*dst != end) {; 20564 /* Append src if enough space, or close dst. */; 20565 if ((size_t)(end - *dst) > len) {; 20566 strcpy(*dst, src);; 20567 *dst += len;; 20568 } else {; 20569 *dst = end;; 20570 }; 20571 }; 20572 return len;; 20573}; 20574 ; 20575 ; 20576/* Get system information. It can be printed or stored by the caller.; 20577 * Return the size of available information. */; 20578int; 20579mg_get_system_info(char *buffer, int buflen); 20580{; 20581 char *end, *append_eoobj = NULL, block[256];; 20582 size_t system_info_length = 0;; 20583 ; 20584#if defined(_WIN32); 20585 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 20586#else; 20587 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 20588#endif; 20589 ; 20590 if ((buffer == NULL) || (buflen < 1)) {; 20591 buflen = 0;; 20592 end = buffer;; 20593 } else {; 20594 *buffer = 0;; 20595 end = buffer + buflen;; 20596 }; 20597 if (buflen > (int)(sizeof(eoobj) - 1)) {; 20598 /* has enough space to append eoobj */; 20599 append_eoobj = buffer;; 20600 if (end) {; 20601 end -= sizeof(eoobj) - 1;; 20602 }; 20603 }; 20604 ; 20605 system_info_length += mg_str_append(&buffer, end, ""{"");; 20606 ; 20607 /* Server version */; 20608 {; 20609 const char *version = mg_version();; 20610 mg_snprintf(NULL,; 20611 NULL,; 20612 block,; 20613 sizeof(block),; 20614 ""%s\""version\"" : \""%s\"""",; 2",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:617083,Availability,mask,mask,617083,": \""%s\"""",; 20615 eol,; 20616 version);; 20617 system_info_length += mg_str_append(&buffer, end, block);; 20618 }; 20619 ; 20620 /* System info */; 20621 {; 20622#if defined(_WIN32); 20623 DWORD dwVersion = 0;; 20624 DWORD dwMajorVersion = 0;; 20625 DWORD dwMinorVersion = 0;; 20626 SYSTEM_INFO si;; 20627 ; 20628 GetSystemInfo(&si);; 20629 ; 20630#if defined(_MSC_VER); 20631#pragma warning(push); 20632 /* GetVersion was declared deprecated */; 20633#pragma warning(disable : 4996); 20634#endif; 20635 dwVersion = GetVersion();; 20636#if defined(_MSC_VER); 20637#pragma warning(pop); 20638#endif; 20639 ; 20640 dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));; 20641 dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));; 20642 ; 20643 mg_snprintf(NULL,; 20644 NULL,; 20645 block,; 20646 sizeof(block),; 20647 "",%s\""os\"" : \""Windows %u.%u\"""",; 20648 eol,; 20649 (unsigned)dwMajorVersion,; 20650 (unsigned)dwMinorVersion);; 20651 system_info_length += mg_str_append(&buffer, end, block);; 20652 ; 20653 mg_snprintf(NULL,; 20654 NULL,; 20655 block,; 20656 sizeof(block),; 20657 "",%s\""cpu\"" : \""type %u, cores %u, mask %x\"""",; 20658 eol,; 20659 (unsigned)si.wProcessorArchitecture,; 20660 (unsigned)si.dwNumberOfProcessors,; 20661 (unsigned)si.dwActiveProcessorMask);; 20662 system_info_length += mg_str_append(&buffer, end, block);; 20663#elif defined(__ZEPHYR__); 20664 mg_snprintf(NULL,; 20665 NULL,; 20666 block,; 20667 sizeof(block),; 20668 "",%s\""os\"" : \""%s %s\"""",; 20669 eol,; 20670 ""Zephyr OS"",; 20671 ZEPHYR_VERSION);; 20672 system_info_length += mg_str_append(&buffer, end, block);; 20673#else; 20674 struct utsname name;; 20675 memset(&name, 0, sizeof(name));; 20676 uname(&name);; 20677 ; 20678 mg_snprintf(NULL,; 20679 NULL,; 20680 block,; 20681 sizeof(block),; 20682 "",%s\""os\"" : \""%s %s (%s) - %s\"""",; 20683 eol,; 20684 name.sysname,; 20685 name.version,; 20686 name.release,; 20687 name.machine);; 20688 system_info_length += mg_str_append(&buffer, end, block);; 20689#endif; 20690 }",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:624593,Availability,avail,available,624593,"nprintf(NULL,; 20876 NULL,; 20877 block,; 20878 sizeof(block),; 20879 "",%s\""data_model\"" : \""int:%u/%u/%u/%u, float:%u/%u/%u, ""; 20880 ""char:%u/%u, ""; 20881 ""ptr:%u, size:%u, time:%u\"""",; 20882 eol,; 20883 (unsigned)sizeof(short),; 20884 (unsigned)sizeof(int),; 20885 (unsigned)sizeof(long),; 20886 (unsigned)sizeof(long long),; 20887 (unsigned)sizeof(float),; 20888 (unsigned)sizeof(double),; 20889 (unsigned)sizeof(long double),; 20890 (unsigned)sizeof(char),; 20891 (unsigned)sizeof(wchar_t),; 20892 (unsigned)sizeof(void *),; 20893 (unsigned)sizeof(size_t),; 20894 (unsigned)sizeof(time_t));; 20895 system_info_length += mg_str_append(&buffer, end, block);; 20896 }; 20897 ; 20898 /* Terminate string */; 20899 if (append_eoobj) {; 20900 strcat(append_eoobj, eoobj);; 20901 }; 20902 system_info_length += sizeof(eoobj) - 1;; 20903 ; 20904 return (int)system_info_length;; 20905}; 20906 ; 20907 ; 20908/* Get context information. It can be printed or stored by the caller.; 20909 * Return the size of available information. */; 20910int; 20911mg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen); 20912{; 20913#if defined(USE_SERVER_STATS); 20914 char *end, *append_eoobj = NULL, block[256];; 20915 size_t context_info_length = 0;; 20916 ; 20917#if defined(_WIN32); 20918 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 20919#else; 20920 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 20921#endif; 20922 struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);; 20923 ; 20924 if ((buffer == NULL) || (buflen < 1)) {; 20925 buflen = 0;; 20926 end = buffer;; 20927 } else {; 20928 *buffer = 0;; 20929 end = buffer + buflen;; 20930 }; 20931 if (buflen > (int)(sizeof(eoobj) - 1)) {; 20932 /* has enough space to append eoobj */; 20933 append_eoobj = buffer;; 20934 end -= sizeof(eoobj) - 1;; 20935 }; 20936 ; 20937 context_info_length += mg_str_append(&buffer, end, ""{"");; 20938 ; 20939 if (ms) { /* <-- should be always true */; 20940 /* Memory inf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:630332,Availability,avail,available,630332,"1079 ""\""now\"" : \""%s\""%s""; 21080 ""}"",; 21081 eol,; 21082 eol,; 21083 difftime(now, start_time),; 21084 eol,; 21085 start_time_str,; 21086 eol,; 21087 now_str,; 21088 eol);; 21089 context_info_length += mg_str_append(&buffer, end, block);; 21090 }; 21091 ; 21092 /* Terminate string */; 21093 if (append_eoobj) {; 21094 strcat(append_eoobj, eoobj);; 21095 }; 21096 context_info_length += sizeof(eoobj) - 1;; 21097 ; 21098 return (int)context_info_length;; 21099#else; 21100 (void)ctx;; 21101 if ((buffer != NULL) && (buflen > 0)) {; 21102 *buffer = 0;; 21103 }; 21104 return 0;; 21105#endif; 21106}; 21107 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:631317,Availability,error,error,631317,"07 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21156 return 0;; 21157 }; 21158 ; 21159 if ((unsigned)idx >= ctx->cfg_worker_threads) {; 21160 /* Out of range */; 21161 return 0;; 21162 }; 21163 ; 21164 /* Take connection [idx]. This connection is not locked in; 21165 * any way, so some other thread might use it. */; 21166 conn = (ctx->worker_connections) + idx;; 21167 ; 21168 /* Initialize output string */; 21169 connection_info_length += mg_str_append(&buffer, end, ""{"");; 21170 ; 21171 /* Init variables */; 21172 ri = &(conn->request_info);; 21173 ; 21174#if defined(USE_SERVER_STATS); 21175 state = conn->conn_state;; 21176 ; 21177 /* State as",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:641451,Availability,mask,maskDefinition,641451, 1;; 21511 }; 21512 ; 21513 mg_global_unlock();; 21514 return 1;; 21515}; 21516 ; 21517 ; 21518/* End of civetweb.c */; escstatic int esc(const char **)Map escape sequences into their equivalent symbols.Definition Match.cxx:438; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Poin,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:658420,Availability,error,error,658420," prepare_cgi_environment(struct mg_connection *conn, const char *prog, struct cgi_environment *env, unsigned char cgi_config_idx)Definition civetweb.c:11046; month_namesstatic const char month_names[][4]Definition civetweb.c:1807; mg_get_response_infoconst struct mg_response_info * mg_get_response_info(const struct mg_connection *conn)Definition civetweb.c:3528; mg_reallocstatic __inline void * mg_realloc(void *a, size_t b)Definition civetweb.c:1483; accept_new_connectionstatic void accept_new_connection(const struct socket *listener, struct mg_context *ctx)Definition civetweb.c:19106; cryptolib_usersstatic volatile ptrdiff_t cryptolib_usersDefinition civetweb.c:16029; get_messagestatic int get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err)Definition civetweb.c:17727; CRYPTO_LIB#define CRYPTO_LIBDefinition civetweb.c:908; global_lock_mutexstatic pthread_mutex_t global_lock_mutexDefinition civetweb.c:1086; mg_start2struct mg_context * mg_start2(struct mg_init_data *init, struct mg_error_data *error)Definition civetweb.c:19613; CGI_ENVIRONMENT_SIZE#define CGI_ENVIRONMENT_SIZEDefinition civetweb.c:486; parse_http_headersstatic int parse_http_headers(char **buf, struct mg_header hdr[(64)])Definition civetweb.c:10421; mg_get_option#define mg_get_optionDefinition civetweb.c:3150; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16231; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3167; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10318; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18032; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char *",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:676746,Availability,error,error,676746,"ix(const char *pattern, size_t pattern_len, const char *str)Definition civetweb.c:3922; mg_send_chunkint mg_send_chunk(struct mg_connection *conn, const char *chunk, unsigned int chunk_len)Definition civetweb.c:6777; remove_dot_segmentsstatic void remove_dot_segments(char *inout)Definition civetweb.c:7873; get_request_handlerstatic int get_request_handler(struct mg_connection *conn, int handler_type, mg_request_handler *handler, struct mg_websocket_subprotocols **subprotocols, mg_websocket_connect_handler *connect_handler, mg_websocket_ready_handler *ready_handler, mg_websocket_data_handler *data_handler, mg_websocket_close_handler *close_handler, mg_authorization_handler *auth_handler, void **cbdata, struct mg_handler_info **handler_info)Definition civetweb.c:13869; mg_set_auth_handlervoid mg_set_auth_handler(struct mg_context *ctx, const char *uri, mg_authorization_handler handler, void *cbdata)Definition civetweb.c:13847; mg_start_domain2int mg_start_domain2(struct mg_context *ctx, const char **options, struct mg_error_data *error)Definition civetweb.c:20300; mg_pollfd#define mg_pollfdDefinition civetweb.c:945; MG_BUF_LEN#define MG_BUF_LENDefinition civetweb.c:496; alloc_vprintf2static int alloc_vprintf2(char **buf, const char *fmt, va_list ap)Definition civetweb.c:6823; builtin_mime_typesstatic const struct @142 builtin_mime_types[]; extention_matches_template_textstatic int extention_matches_template_text(struct mg_connection *conn, const char *filename)Definition civetweb.c:7366; is_in_script_pathstatic int is_in_script_path(const struct mg_connection *conn, const char *path)Definition civetweb.c:13954; should_decode_query_stringstatic int should_decode_query_string(const struct mg_connection *conn)Definition civetweb.c:4030; mg_difftimespecstatic double mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before)Definition civetweb.c:3331; free_contextstatic void free_context(struct mg_context *ctx)Definition civetweb.c:19397; sslizestatic",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5691,Deployability,configurat,configuration,5691,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:12074,Deployability,release,release,12074,"with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:12088,Deployability,configurat,configuration,12088,"with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:14440,Deployability,release,release,14440,"-macro""; 362#endif; 363#endif; 364 ; 365#ifndef CLOCK_MONOTONIC; 366#define CLOCK_MONOTONIC (1); 367#endif; 368#ifndef CLOCK_REALTIME; 369#define CLOCK_REALTIME (2); 370#endif; 371 ; 372#include <mach/clock.h>; 373#include <mach/mach.h>; 374#include <mach/mach_time.h>; 375#include <sys/errno.h>; 376#include <sys/time.h>; 377 ; 378/* clock_gettime is not implemented on OSX prior to 10.12 */; 379static int; 380_civet_clock_gettime(int clk_id, struct timespec *t); 381{; 382 memset(t, 0, sizeof(*t));; 383 if (clk_id == CLOCK_REALTIME) {; 384 struct timeval now;; 385 int rv = gettimeofday(&now, NULL);; 386 if (rv) {; 387 return rv;; 388 }; 389 t->tv_sec = now.tv_sec;; 390 t->tv_nsec = now.tv_usec * 1000;; 391 return 0;; 392 ; 393 } else if (clk_id == CLOCK_MONOTONIC) {; 394 static uint64_t clock_start_time = 0;; 395 static mach_timebase_info_data_t timebase_ifo = {0, 0};; 396 ; 397 uint64_t now = mach_absolute_time();; 398 ; 399 if (clock_start_time == 0) {; 400 kern_return_t mach_status = mach_timebase_info(&timebase_ifo);; 401 DEBUG_ASSERT(mach_status == KERN_SUCCESS);; 402 ; 403 /* appease ""unused variable"" warning for release builds */; 404 (void)mach_status;; 405 ; 406 clock_start_time = now;; 407 }; 408 ; 409 now = (uint64_t)((double)(now - clock_start_time); 410 * (double)timebase_ifo.numer; 411 / (double)timebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16026,Deployability,configurat,configuration,16026,"L at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16271,Deployability,configurat,configuration,16271," 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16542,Deployability,configurat,configuration,16542,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:55264,Deployability,install,installation,55264,"L, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767 * the standard memory functions.; 1768 *; 1769 * #define OPENSSL_free free */; 1770#define free free; 1771// disable for boringssl; 1772#define CONF_modules_unload(a) ((void)0); 1773#define ENGINE_cleanup() ((void)0); 1774#endif; 1775 ; 1776/* If OpenSSL headers are included, automatically select the API version */; 1777#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1778#if !defined(OPENSSL_API_3_0); 1779#define OPENSSL_API_3_0; 1780#endif; 1781#define OPENSSL_REMOVE_THREAD_STATE(); 1782#else; 1783#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1784#if !defined(OPENSSL_API_1_1); 1785#define OPENSSL_API_1_1; 1786#endif; 1787#define OPENSSL_REMOVE_THREAD_STATE(); 1788#else; 1789#if !defined(OPENSSL_API_1_0); 1790#define OPENSSL_API_1_0; 1791#endif; 1792#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1793#endif; 1794#endif; 1795 ; 1796 ; 1797#else; 1798/* SSL loaded dynamically from DLL / shared object */; 1799/* Add all prototypes here, to be independent from OpenSSL source; 1800 * installation. */; 1801#include ""openssl_dl.inl""; 1802 ; 1803#endif /* Various SSL bindings */; 1804 ; 1805 ; 1806#if !defined(NO_CACHING); 1807static const char month_names[][4] = {""Jan"",; 1808 ""Feb"",; 1809 ""Mar"",; 1810 ""Apr"",; 1811 ""May"",; 1812 ""Jun"",; 1813 ""Jul"",; 1814 ""Aug"",; 1815 ""Sep"",; 1816 ""Oct"",; 1817 ""Nov"",; 1818 ""Dec""};; 1819#endif /* !NO_CACHING */; 1820 ; 1821 ; 1822/* Unified socket address. For IPv6 support, add IPv6 address structure in; 1823 * the union u. */; 1824union usa {; 1825 struct sockadd",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:69678,Deployability,configurat,configuration,69678,"equests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120790,Deployability,configurat,configuration,120790,"d obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:133542,Deployability,configurat,configuration,133542,"ror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; 4484 path_buf);; 4485 page_handler_found = 1;; 4486 break;; 4487 }; 4488 DEBUG_TRACE(""Check error page %s - not found"",; 4489 path_buf);; 4490 ; 4491 /* Continue with the next file extenstion from the; 4492 * configurat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:134420,Deployability,configurat,configuration,134420," 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; 4484 path_buf);; 4485 page_handler_found = 1;; 4486 break;; 4487 }; 4488 DEBUG_TRACE(""Check error page %s - not found"",; 4489 path_buf);; 4490 ; 4491 /* Continue with the next file extenstion from the; 4492 * configuration (if there is a next one). */; 4493 tstr = strchr(tstr + i, '.');; 4494 }; 4495 }; 4496 }; 4497 ; 4498 if (page_handler_found) {; 4499 conn->in_error_handler = 1;; 4500 handle_file_based_request(conn, path_buf, &error_page_file);; 4501 conn->in_error_handler = 0;; 4502 return 0;; 4503 }; 4504#endif /* NO_FILESYSTEMS */; 4505 }; 4506 ; 4507 /* No custom error page. Send default error page. */; 4508 conn->must_close = 1;; 4509 mg_response_header_start(conn, status);; 4510 send_no_cache_header(conn);; 4511 send_additional_header(conn);; 4512 if (has_body) {; 4513 mg_response_header_add(conn,; 4514 ""Content-Type"",; 4515 ""text/plain; charset=utf-8"",; 4516 -1);; 4517 }; 4518 mg_response_header_send(conn);; 4519 ; 4520 /* HTTP responses 1xx, 204 and 304 MUST NOT send a body */; 4521 if (has_body) {; 4522 /* For other errors, send a generic error message. */; 4523 cons",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:148521,Deployability,configurat,configuration,148521,"4964 ; 4965 /* Convert to Unicode and back. If doubly-converted string does not; 4966 * match the original, something is fishy, reject. */; 4967 memset(wbuf, 0, wbuf_len * sizeof(wchar_t));; 4968 MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);; 4969 WideCharToMultiByte(; 4970 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4971 if (strcmp(buf, buf2) != 0) {; 4972 wbuf[0] = L'\0';; 4973 }; 4974 ; 4975 /* Windows file systems are not case sensitive, but you can still use; 4976 * uppercase and lowercase letters (on all modern file systems).; 4977 * The server can check if the URI uses the same upper/lowercase; 4978 * letters an the file system, effectively making Windows servers; 4979 * case sensitive (like Linux servers are). It is still not possible; 4980 * to use two files with the same name in different cases on Windows; 4981 * (like /a and /A) - this would be possible in Linux.; 4982 * As a default, Windows is not case sensitive, but the case sensitive; 4983 * file name check can be activated by an additional configuration. */; 4984 if (conn) {; 4985 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4986 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4987 ""yes"")) {; 4988 /* Use case sensitive compare function */; 4989 fcompare = wcscmp;; 4990 }; 4991 }; 4992 (void)conn; /* conn is currently unused */; 4993 ; 4994 /* Only accept a full file path, not a Windows short (8.3) path. */; 4995 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4996 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4997 if (long_len == 0) {; 4998 err = GetLastError();; 4999 if (err == ERROR_FILE_NOT_FOUND) {; 5000 /* File does not exist. This is not always a problem here. */; 5001 return;; 5002 }; 5003 }; 5004 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5005 /* Short name is used. */; 5006 wbuf[0] = L'\0';; 5007 }; 5008}; 5009 ; 5010 ; 5011#if !defined(NO_FILESYSTEMS); 5012/* Get file informat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:190280,Deployability,update,update,190280,"ed_len = len64;; 6507 }; 6508 body = conn->buf + conn->request_len + conn->consumed_content;; 6509 memcpy(buf, body, (size_t)buffered_len);; 6510 len64 -= buffered_len;; 6511 conn->consumed_content += buffered_len;; 6512 nread += buffered_len;; 6513 buf = (char *)buf + buffered_len;; 6514 }; 6515 ; 6516 /* We have returned all buffered data. Read new data from the remote; 6517 * socket.; 6518 */; 6519 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6520 conn->consumed_content += n;; 6521 nread += n;; 6522 } else {; 6523 nread = ((nread > 0) ? nread : n);; 6524 }; 6525 }; 6526 return (int)nread;; 6527}; 6528 ; 6529 ; 6530/* Forward declarations */; 6531static void handle_request(struct mg_connection *);; 6532static void log_access(const struct mg_connection *);; 6533 ; 6534 ; 6535/* Handle request, update statistics and call access log */; 6536static void; 6537handle_request_stat_log(struct mg_connection *conn); 6538{; 6539#if defined(USE_SERVER_STATS); 6540 struct timespec tnow;; 6541 conn->conn_state = 4; /* processing */; 6542#endif; 6543 ; 6544 handle_request(conn);; 6545 ; 6546 ; 6547#if defined(USE_SERVER_STATS); 6548 conn->conn_state = 5; /* processed */; 6549 ; 6550 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6551 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6552 ; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6554 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6555 conn->num_bytes_sent);; 6556#endif; 6557 ; 6558 DEBUG_TRACE(""%s"", ""handle_request done"");; 6559 ; 6560 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6561 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6562 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6563 }; 6564 log_access(conn);; 6565}; 6566 ; 6567 ; 6568#if defined(USE_HTTP2); 6569#if defined(NO_SSL); 6570#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6571#endif; 6572#define USE_ALPN; 6573#include ""mod_http2.inl""; 6574/* Not sup",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:312271,Deployability,update,update,312271,"000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10863 > request_timeout) {; 10864 /* Timeout */; 10865 return -1;; 10866 }; 10867 }; 10868 }; 10869 ; 10870 return request_len;; 10871}; 10872 ; 10873 ; 10874#if !defined(NO_CGI) || !defined(NO_FILES); 10875static int; 10876forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10877{; 10878 const char *expect;; 10879 char buf[MG_BUF_LEN];; 10880 int success = 0;; 10881 ; 10882 if (!conn) {; 10883 return 0;; 10884 }; 10885 ; 10886 expect = mg_get_header(conn, ""Expect"");; 10887 DEBUG_ASSERT(fp != NULL);; 10888 if (!fp) {; 10889 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10890 return 0;; 10891 }; 10892 ; 10893 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10894 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10895 */; 10896 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10897 } else {; 10898 if (expect != NULL) {; 10899 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10900 conn->status_code = 100;; 10901 } else {; 10902 conn->status",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:359841,Deployability,upgrade,upgrade,359841," 12396 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12397 mg_printf(conn,; 12398 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12399 conn->request_info.acceptedWebSocketSubprotocol);; 12400 } else {; 12401 mg_printf(conn, ""%s"", ""\r\n"");; 12402 }; 12403 ; 12404 return 1;; 12405}; 12406 ; 12407 ; 12408#if !defined(MG_MAX_UNANSWERED_PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361991,Deployability,continuous,continuously,361991,"e timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:379929,Deployability,upgrade,upgrade,379929,"; 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13012 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13013 ptrdiff_t lua_websock = 0;; 13014 ; 13015#if !defined(USE_LUA); 13016 (void)path;; 13017#endif; 13018 ; 13019 /* Step 1: Check websocket protocol version. */; 13020 /* Step 1.1: Check Sec-WebSocket-Key. */; 13021 if (!websock_key) {; 13022 /* The RFC standard version (https://tools.ietf.org/html/rfc6455); 13023 * requires a Sec-WebSocket-Key header.; 13024 */; 13025 /* It could be the hixie draft version; 13026 * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).; 13027 */; 13028 const char *key1 = mg_get_header(conn, ""Sec-WebSocket-Key1"");; 13029 const char *key2 = mg_get_header(conn, ""Sec-WebSocket-Key2"");; 13030 char key3[8];; 13031 ; 13032 if ((key1 != NULL) && (key2 != NULL)) {; 13033 /* This version uses 8 byte body data in a GET request */; 13034 conn->content_len = 8;; 13035 if (8 == mg_read(conn, key3, 8)) {; 13036 /* This is the hixie version */; 13037 mg_send_http_error(conn,; 13038 426,; 13039 ""%s"",; 13040 ""Protocol upgrade to RFC 6455 required"");; 13041 return;; 13042 }; 13043 }; 13044 /* This is an unknown version */; 13045 mg_send_http_error(conn, 400, ""%s"", ""Malformed websocket request"");; 13046 return;; 13047 }; 13048 ; 13049 /* Step 1.2: Check websocket protocol version. */; 13050 /* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */; 13051 if ((version == NULL) || (strcmp(version, ""13"") != 0)) {; 13052 /* Reject wrong versions */; 13053 mg_send_http_error(conn, 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 header",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:380424,Deployability,upgrade,upgrade,380424," 13026 * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).; 13027 */; 13028 const char *key1 = mg_get_header(conn, ""Sec-WebSocket-Key1"");; 13029 const char *key2 = mg_get_header(conn, ""Sec-WebSocket-Key2"");; 13030 char key3[8];; 13031 ; 13032 if ((key1 != NULL) && (key2 != NULL)) {; 13033 /* This version uses 8 byte body data in a GET request */; 13034 conn->content_len = 8;; 13035 if (8 == mg_read(conn, key3, 8)) {; 13036 /* This is the hixie version */; 13037 mg_send_http_error(conn,; 13038 426,; 13039 ""%s"",; 13040 ""Protocol upgrade to RFC 6455 required"");; 13041 return;; 13042 }; 13043 }; 13044 /* This is an unknown version */; 13045 mg_send_http_error(conn, 400, ""%s"", ""Malformed websocket request"");; 13046 return;; 13047 }; 13048 ; 13049 /* Step 1.2: Check websocket protocol version. */; 13050 /* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */; 13051 if ((version == NULL) || (strcmp(version, ""13"") != 0)) {; 13052 /* Reject wrong versions */; 13053 mg_send_http_error(conn, 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386210,Deployability,upgrade,upgrade,386210," and Lua is not responsible either. */; 13172 /* Reply with a 404 Not Found. We are still at a standard; 13173 * HTTP request here, before the websocket handshake, so; 13174 * we can still send standard HTTP error replies. */; 13175 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 13176 return;; 13177 }; 13178 ; 13179 /* Step 5: The websocket connection has been accepted */; 13180 if (!send_websocket_handshake(conn, websock_key)) {; 13181 mg_send_http_error(conn, 500, ""%s"", ""Websocket handshake failed"");; 13182 return;; 13183 }; 13184 ; 13185 /* Step 6: Call the ready handler */; 13186 if (is_callback_resource) {; 13187 if (ws_ready_handler != NULL) {; 13188 ws_ready_handler(conn, cbData);; 13189 }; 13190#if defined(USE_LUA); 13191 } else if (lua_websock) {; 13192 if (!lua_websocket_ready(conn, conn->lua_websocket_state)) {; 13193 /* the ready handler returned false */; 13194 return;; 13195 }; 13196#endif; 13197 }; 13198 ; 13199 /* Step 7: Enter the read loop */; 13200 if (is_callback_resource) {; 13201 read_websocket(conn, ws_data_handler, cbData);; 13202#if defined(USE_LUA); 13203 } else if (lua_websock) {; 13204 read_websocket(conn, lua_websocket_data, conn->lua_websocket_state);; 13205#endif; 13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386290,Deployability,upgrade,upgrade,386290,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386324,Deployability,upgrade,upgrade,386324,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386356,Deployability,upgrade,upgrade,386356,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386504,Deployability,upgrade,upgrade,386504,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386853,Deployability,upgrade,upgrade,386853,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386925,Deployability,upgrade,upgrade,386925,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386978,Deployability,upgrade,upgrade,386978,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:387160,Deployability,upgrade,upgrade,387160,"uest:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; /* Websocket */; 13267 }; 13268 ; 13269 /* Upgrade to another protocol */; 13270 return -1;; 13271}; 13272 ; 13273 ; 13274static int; 13275parse_match_net(const struct vec *vec, const union usa *sa, int no_strict); 13276{; 13277 int n;; 13278 unsigned int a, b, c, d, slash;; 13279 ; 13280 if (sscanf(vec->ptr, ""%u.%u.%u.%u/%u%n"", &a, &b, &c, &d, &slash, &n); 13281 != 5) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to an; 13282 // integer value, but function will not report conversion; 13283 // errors; cons",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:387643,Deployability,upgrade,upgrade,387643,"43 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; /* Websocket */; 13267 }; 13268 ; 13269 /* Upgrade to another protocol */; 13270 return -1;; 13271}; 13272 ; 13273 ; 13274static int; 13275parse_match_net(const struct vec *vec, const union usa *sa, int no_strict); 13276{; 13277 int n;; 13278 unsigned int a, b, c, d, slash;; 13279 ; 13280 if (sscanf(vec->ptr, ""%u.%u.%u.%u/%u%n"", &a, &b, &c, &d, &slash, &n); 13281 != 5) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to an; 13282 // integer value, but function will not report conversion; 13283 // errors; consider using 'strtol' instead; 13284 slash = 32;; 13285 if (sscanf(vec->ptr, ""%u.%u.%u.%u%n"", &a, &b, &c, &d, &n); 13286 != 4) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to; 13287 // an integer value, but function will not report conversion; 13288 // errors; consider using 'strtol' instead; 13289 n = 0;; 13290 }; 13291 }; 13292 ; 13293 if ((n > 0) && ((size_t)n == vec->len)) {; 13294 if ((a < 256) && (b < 256) && (c < 256) && (d < 256) && (slash < 33)) {; 13295 /* IPv4 format */; 13296 if (sa->sa.sa_family == AF_INET) {; 13297 uint32",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:400210,Deployability,update,update,400210,"e == AUTH_HANDLER) {; 13643 DEBUG_ASSERT(handler == NULL);; 13644 DEBUG_ASSERT(connect_handler == NULL && ready_handler == NULL; 13645 && data_handler == NULL && close_handler == NULL);; 13646 DEBUG_ASSERT(is_delete_request || (auth_handler != NULL));; 13647 if (handler != NULL) {; 13648 return;; 13649 }; 13650 if ((connect_handler != NULL) || (ready_handler != NULL); 13651 || (data_handler != NULL) || (close_handler != NULL)) {; 13652 return;; 13653 }; 13654 if (!is_delete_request && (auth_handler == NULL)) {; 13655 return;; 13656 }; 13657 } else {; 13658 /* Unknown handler type. */; 13659 return;; 13660 }; 13661 ; 13662 if (!phys_ctx || !dom_ctx) {; 13663 /* no context available */; 13664 return;; 13665 }; 13666 ; 13667 mg_lock_context(phys_ctx);; 13668 ; 13669 /* first try to find an existing handler */; 13670 do {; 13671 lastref = &(dom_ctx->handlers);; 13672 for (tmp_rh = dom_ctx->handlers; tmp_rh != NULL;; 13673 tmp_rh = tmp_rh->next) {; 13674 if (tmp_rh->handler_type == handler_type; 13675 && (urilen == tmp_rh->uri_len) && !strcmp(tmp_rh->uri, uri)) {; 13676 if (!is_delete_request) {; 13677 /* update existing handler */; 13678 if (handler_type == REQUEST_HANDLER) {; 13679 /* Wait for end of use before updating */; 13680 if (tmp_rh->refcount) {; 13681 mg_unlock_context(phys_ctx);; 13682 mg_sleep(1);; 13683 mg_lock_context(phys_ctx);; 13684 /* tmp_rh might have been freed, search again. */; 13685 break;; 13686 }; 13687 /* Ok, the handler is no more use -> Update it */; 13688 tmp_rh->handler = handler;; 13689 } else if (handler_type == WEBSOCKET_HANDLER) {; 13690 tmp_rh->subprotocols = subprotocols;; 13691 tmp_rh->connect_handler = connect_handler;; 13692 tmp_rh->ready_handler = ready_handler;; 13693 tmp_rh->data_handler = data_handler;; 13694 tmp_rh->close_handler = close_handler;; 13695 } else { /* AUTH_HANDLER */; 13696 tmp_rh->auth_handler = auth_handler;; 13697 }; 13698 tmp_rh->cbdata = cbdata;; 13699 } else {; 13700 /* remove existing handler */; 13701 if (",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:412620,Deployability,configurat,configuration,412620,"_string++) = '\0';; 14048 }; 14049 ; 14050 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14051 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14052 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14053 if (ssl_index >= 0) {; 14054 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14055 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14056 redirect_to_https_port(conn, port);; 14057 } else {; 14058 /* A http to https forward port has been specified,; 14059 * but no https port to forward to. */; 14060 mg_send_http_error(conn,; 14061 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:416990,Deployability,configurat,configuration,416990,"nfigured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:417059,Deployability,configurat,configuration,417059," =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14215#else; 14216 handler_type = REQUEST_HANDLER;; 1421",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:419421,Deployability,install,installed,419421,"l handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script_resource = 1;; 14240 is_put_or_delete_request = is_put_or_delete_method(conn);; 14241 } else {; 14242 no_callback_resource:; 14243 ; 14244 /* 5.2.2. No callback is responsible for this request. The URI; 14245 * addresses a file based resource (static content or Lua/cgi; 14246 * scripts in the file system). */; 14247 is_callback_resource = 0;; 14248 interpret_uri(conn,; 14249 path,; 14250 sizeof(path),; 14251 &file.stat,; 14252 &is_found,; 14253 &is_script_resource,; 14254 &is_websocket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 ret",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:504628,Deployability,configurat,configuration,504628,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:539591,Deployability,upgrade,upgrade,539591,"3 /* The websocket_client context has only this thread. If it runs out,; 18134 set the stop_flag to 2 (= ""stopped""). */; 18135 STOP_FLAG_ASSIGN(&cdata->conn->phys_ctx->stop_flag, 2);; 18136 ; 18137 if (cdata->conn->phys_ctx->callbacks.exit_thread) {; 18138 cdata->conn->phys_ctx->callbacks.exit_thread(cdata->conn->phys_ctx,; 18139 3,; 18140 user_thread_ptr);; 18141 }; 18142 ; 18143 mg_free((void *)cdata);; 18144 ; 18145#if defined(_WIN32); 18146 return 0;; 18147#else; 18148 return NULL;; 18149#endif; 18150}; 18151#endif; 18152 ; 18153 ; 18154static struct mg_connection *; 18155mg_connect_websocket_client_impl(const struct mg_client_options *client_options,; 18156 int use_ssl,; 18157 char *error_buffer,; 18158 size_t error_buffer_size,; 18159 const char *path,; 18160 const char *origin,; 18161 const char *extensions,; 18162 mg_websocket_data_handler data_func,; 18163 mg_websocket_close_handler close_func,; 18164 void *user_data); 18165{; 18166 struct mg_connection *conn = NULL;; 18167 ; 18168#if defined(USE_WEBSOCKET); 18169 struct websocket_client_thread_data *thread_data;; 18170 static const char *magic = ""x3JJHMbDL1EzLkh9GBhXDw=="";; 18171 ; 18172 const char *host = client_options->host;; 18173 int i;; 18174 ; 18175#if defined(__clang__); 18176#pragma clang diagnostic push; 18177#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 18178#endif; 18179 ; 18180 /* Establish the client connection and request upgrade */; 18181 conn = mg_connect_client_impl(client_options,; 18182 use_ssl,; 18183 error_buffer,; 18184 error_buffer_size);; 18185 ; 18186 /* Connection object will be null if something goes wrong */; 18187 if (conn == NULL) {; 18188 /* error_buffer should be already filled ... */; 18189 if (!error_buffer[0]) {; 18190 /* ... if not add an error message */; 18191 mg_snprintf(conn,; 18192 NULL, /* No truncation check for ebuf */; 18193 error_buffer,; 18194 error_buffer_size,; 18195 ""Unexpected error"");; 18196 }; 18197 return NULL;; 18198 }; 18199 ; 18200 if (ori",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:542350,Deployability,upgrade,upgrade,542350," mg_printf(conn,; 18250 ""GET %s HTTP/1.1\r\n""; 18251 ""Host: %s\r\n""; 18252 ""Upgrade: websocket\r\n""; 18253 ""Connection: Upgrade\r\n""; 18254 ""Sec-WebSocket-Key: %s\r\n""; 18255 ""Sec-WebSocket-Version: 13\r\n""; 18256 ""\r\n"",; 18257 path,; 18258 host,; 18259 magic);; 18260 }; 18261 }; 18262 if (i <= 0) {; 18263 mg_snprintf(conn,; 18264 NULL, /* No truncation check for ebuf */; 18265 error_buffer,; 18266 error_buffer_size,; 18267 ""%s"",; 18268 ""Error sending request"");; 18269 mg_close_connection(conn);; 18270 return NULL;; 18271 }; 18272 ; 18273 conn->data_len = 0;; 18274 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18275 mg_close_connection(conn);; 18276 return NULL;; 18277 }; 18278 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18279 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18280 ; 18281#if defined(__clang__); 18282#pragma clang diagnostic pop; 18283#endif; 18284 ; 18285 if (conn->response_info.status_code != 101) {; 18286 /* We sent an ""upgrade"" request. For a correct websocket; 18287 * protocol handshake, we expect a ""101 Continue"" response.; 18288 * Otherwise it is a protocol violation. Maybe the HTTP; 18289 * Server does not know websockets. */; 18290 if (!*error_buffer) {; 18291 /* set an error, if not yet set */; 18292 mg_snprintf(conn,; 18293 NULL, /* No truncation check for ebuf */; 18294 error_buffer,; 18295 error_buffer_size,; 18296 ""Unexpected server reply"");; 18297 }; 18298 ; 18299 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18300 mg_close_connection(conn);; 18301 return NULL;; 18302 }; 18303 ; 18304 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18305 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18306 if (!thread_data) {; 18307 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18308 mg_close_connection(conn);; 18309 return NULL;; 18310 }; 18311 ; 18312 thread_data->conn = conn;; 18313 thread_data->data_handler = data_func;; 18314 thre",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:543753,Deployability,upgrade,upgrade,543753,"18296 ""Unexpected server reply"");; 18297 }; 18298 ; 18299 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18300 mg_close_connection(conn);; 18301 return NULL;; 18302 }; 18303 ; 18304 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18305 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18306 if (!thread_data) {; 18307 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18308 mg_close_connection(conn);; 18309 return NULL;; 18310 }; 18311 ; 18312 thread_data->conn = conn;; 18313 thread_data->data_handler = data_func;; 18314 thread_data->close_handler = close_func;; 18315 thread_data->callback_data = user_data;; 18316 ; 18317 conn->phys_ctx->worker_threadids =; 18318 (pthread_t *)mg_calloc_ctx(1, sizeof(pthread_t), conn->phys_ctx);; 18319 if (!conn->phys_ctx->worker_threadids) {; 18320 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18321 mg_free(thread_data);; 18322 mg_close_connection(conn);; 18323 return NULL;; 18324 }; 18325 ; 18326 /* Now upgrade to ws/wss client context */; 18327 conn->phys_ctx->user_data = user_data;; 18328 conn->phys_ctx->context_type = CONTEXT_WS_CLIENT;; 18329 conn->phys_ctx->cfg_worker_threads = 1; /* one worker thread */; 18330 ; 18331 /* Start a thread to read the websocket client connection; 18332 * This thread will automatically stop when mg_disconnect is; 18333 * called on the client connection */; 18334 if (mg_start_thread_with_id(websocket_client_thread,; 18335 thread_data,; 18336 conn->phys_ctx->worker_threadids); 18337 != 0) {; 18338 conn->phys_ctx->cfg_worker_threads = 0;; 18339 mg_free(thread_data);; 18340 mg_close_connection(conn);; 18341 conn = NULL;; 18342 DEBUG_TRACE(""%s"",; 18343 ""Websocket client connect thread could not be started\r\n"");; 18344 }; 18345 ; 18346#else; 18347 /* Appease ""unused parameter"" warnings */; 18348 (void)client_options;; 18349 (void)use_ssl;; 18350 (void)error_buffer;; 18351 (void)error_buffer_size;; 18352 (void)path;; 18353 (void)origin;; 18354 (void)extensions",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:552104,Deployability,upgrade,upgrade,552104,"eal with '*'. */; 18572 break;; 18573 case 2:; 18574 /* relative uri */; 18575 conn->request_info.local_uri_raw =; 18576 conn->request_info.request_uri;; 18577 break;; 18578 case 3:; 18579 case 4:; 18580 /* absolute uri (with/without port) */; 18581 hostend = get_rel_url_at_current_server(; 18582 conn->request_info.request_uri, conn);; 18583 if (hostend) {; 18584 conn->request_info.local_uri_raw = hostend;; 18585 } else {; 18586 conn->request_info.local_uri_raw = NULL;; 18587 }; 18588 break;; 18589 default:; 18590 mg_snprintf(conn,; 18591 NULL, /* No truncation check for ebuf */; 18592 ebuf,; 18593 sizeof(ebuf),; 18594 ""Invalid URI"");; 18595 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18596 conn->request_info.local_uri_raw = NULL;; 18597 break;; 18598 }; 18599 conn->request_info.local_uri =; 18600 (char *)conn->request_info.local_uri_raw;; 18601 }; 18602 ; 18603 if (ebuf[0] != '\0') {; 18604 conn->protocol_type = -1;; 18605 ; 18606 } else {; 18607 /* HTTP/1 allows protocol upgrade */; 18608 conn->protocol_type = should_switch_to_protocol(conn);; 18609 ; 18610 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18611 /* This will occur, if a HTTP/1.1 request should be upgraded; 18612 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18613 * Since most (all?) major browsers only support HTTP/2 using; 18614 * ALPN, this is hard to test and very low priority.; 18615 * Deactivate it (at least for now).; 18616 */; 18617 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18618 }; 18619 }; 18620 ; 18621 DEBUG_TRACE(""http: %s, error: %s"",; 18622 (ri->http_version ? ri->http_version : ""none""),; 18623 (ebuf[0] ? ebuf : ""none""));; 18624 ; 18625 if (ebuf[0] == '\0') {; 18626 if (conn->request_info.local_uri) {; 18627 ; 18628 /* handle request to local server */; 18629 handle_request_stat_log(conn);; 18630 ; 18631 } else {; 18632 /* TODO: handle non-local request (PROXY) */; 18633 conn->must_close = 1;; 18634 }; 18635 } else {; 18636 conn->must_close = 1;; 18637 }; 18638 ; 18639 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:552301,Deployability,upgrade,upgraded,552301,"lute uri (with/without port) */; 18581 hostend = get_rel_url_at_current_server(; 18582 conn->request_info.request_uri, conn);; 18583 if (hostend) {; 18584 conn->request_info.local_uri_raw = hostend;; 18585 } else {; 18586 conn->request_info.local_uri_raw = NULL;; 18587 }; 18588 break;; 18589 default:; 18590 mg_snprintf(conn,; 18591 NULL, /* No truncation check for ebuf */; 18592 ebuf,; 18593 sizeof(ebuf),; 18594 ""Invalid URI"");; 18595 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18596 conn->request_info.local_uri_raw = NULL;; 18597 break;; 18598 }; 18599 conn->request_info.local_uri =; 18600 (char *)conn->request_info.local_uri_raw;; 18601 }; 18602 ; 18603 if (ebuf[0] != '\0') {; 18604 conn->protocol_type = -1;; 18605 ; 18606 } else {; 18607 /* HTTP/1 allows protocol upgrade */; 18608 conn->protocol_type = should_switch_to_protocol(conn);; 18609 ; 18610 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18611 /* This will occur, if a HTTP/1.1 request should be upgraded; 18612 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18613 * Since most (all?) major browsers only support HTTP/2 using; 18614 * ALPN, this is hard to test and very low priority.; 18615 * Deactivate it (at least for now).; 18616 */; 18617 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18618 }; 18619 }; 18620 ; 18621 DEBUG_TRACE(""http: %s, error: %s"",; 18622 (ri->http_version ? ri->http_version : ""none""),; 18623 (ebuf[0] ? ebuf : ""none""));; 18624 ; 18625 if (ebuf[0] == '\0') {; 18626 if (conn->request_info.local_uri) {; 18627 ; 18628 /* handle request to local server */; 18629 handle_request_stat_log(conn);; 18630 ; 18631 } else {; 18632 /* TODO: handle non-local request (PROXY) */; 18633 conn->must_close = 1;; 18634 }; 18635 } else {; 18636 conn->must_close = 1;; 18637 }; 18638 ; 18639 /* Response complete. Free header buffer */; 18640 free_buffered_response_header_list(conn);; 18641 ; 18642 if (ri->remote_user != NULL) {; 18643 mg_free((void *)ri->remote_user);; 18644 /* Important! When havin",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:563432,Deployability,patch,patch,563432,"quest handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, thread_index)) {; 18925 ; 18926 /* New connections must start with new protocol negotiation */; 18927 tls.alpn_proto = NULL;; 18928 ; 18929#if defined(USE_SERVER_STATS); 18930 conn->conn_close_time = 0;; 18931#endif; 18932 conn->conn_birth_time = time(NULL);; 18933 ; 18934 /* Fill in IP, port info early so even if SSL setup below fails,; 18935 * error handler would have the corresponding info.; 18936 * Thanks to Johannes Winkelmann for the patch.; 18937 */; 18938 conn->request_info.remote_port =; 18939 ntohs(USA_IN_PORT_UNSAFE(&conn->client.rsa));; 18940 ; 18941 conn->request_info.server_port =; 18942 ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18943 ; 18944 sockaddr_to_string(conn->request_info.remote_addr,; 18945 sizeof(conn->request_info.remote_addr),; 18946 &conn->client.rsa);; 18947 ; 18948 DEBUG_TRACE(""Incomming %sconnection from %s"",; 18949 (conn->client.is_ssl ? ""SSL "" : """"),; 18950 conn->request_info.remote_addr);; 18951 ; 18952 conn->request_info.is_ssl = conn->client.is_ssl;; 18953 ; 18954 if (conn->client.is_ssl) {; 18955 ; 18956#if defined(USE_MBEDTLS); 18957 /* HTTPS connection */; 18958 if (mbed_ssl_accept(&(conn->ssl),; 18959 conn->dom_ctx->ssl_ctx,; 18960 (int *)&(conn->client.sock),; 18961 conn->phys_ctx); 18962 == 0) {; 18963 /* conn->dom_ctx is set in get_request */; 18964 /* process HTTPS connection */; 18965 init_connection(conn);; 18966 conn->connection_type = CONNECTION_TYP",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:565769,Deployability,upgrade,upgrade,565769,"t */; 18978 ; 18979 /* Get SSL client certificate information (if set) */; 18980 struct mg_client_cert client_cert;; 18981 if (ssl_get_client_cert_info(conn, &client_cert)) {; 18982 conn->request_info.client_cert = &client_cert;; 18983 }; 18984 ; 18985 /* process HTTPS connection */; 18986#if defined(USE_HTTP2); 18987 if ((tls.alpn_proto != NULL); 18988 && (!memcmp(tls.alpn_proto, ""\x02h2"", 3))) {; 18989 /* process HTTPS/2 connection */; 18990 init_connection(conn);; 18991 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18992 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18993 conn->content_len =; 18994 -1; /* content length is not predefined */; 18995 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18996 process_new_http2_connection(conn);; 18997 } else; 18998#endif; 18999 {; 19000 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19001 init_connection(conn);; 19002 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19003 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19004 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19005 process_new_connection(conn);; 19006 }; 19007 ; 19008 /* Free client certificate info */; 19009 if (conn->request_info.client_cert) {; 19010 mg_free((void *)(conn->request_info.client_cert->subject));; 19011 mg_free((void *)(conn->request_info.client_cert->issuer));; 19012 mg_free((void *)(conn->request_info.client_cert->serial));; 19013 mg_free((void *)(conn->request_info.client_cert->finger));; 19014 /* Free certificate memory */; 19015 X509_free(; 19016 (X509 *)conn->request_info.client_cert->peer_cert);; 19017 conn->request_info.client_cert->peer_cert = 0;; 19018 conn->request_info.client_cert->subject = 0;; 19019 conn->request_info.client_cert->issuer = 0;; 19020 conn->request_info.client_cert->serial = 0;; 19021 conn->request_info.client_cert->finger = 0;; 19022 conn->request_info.client_cert = 0;; 19023 }; 19024 } else {; 19025 /* make sure the connection is cleaned up on SSL failure */; 19026 close_connection(conn)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:567001,Deployability,upgrade,upgrade,567001,"*)(conn->request_info.client_cert->subject));; 19011 mg_free((void *)(conn->request_info.client_cert->issuer));; 19012 mg_free((void *)(conn->request_info.client_cert->serial));; 19013 mg_free((void *)(conn->request_info.client_cert->finger));; 19014 /* Free certificate memory */; 19015 X509_free(; 19016 (X509 *)conn->request_info.client_cert->peer_cert);; 19017 conn->request_info.client_cert->peer_cert = 0;; 19018 conn->request_info.client_cert->subject = 0;; 19019 conn->request_info.client_cert->issuer = 0;; 19020 conn->request_info.client_cert->serial = 0;; 19021 conn->request_info.client_cert->finger = 0;; 19022 conn->request_info.client_cert = 0;; 19023 }; 19024 } else {; 19025 /* make sure the connection is cleaned up on SSL failure */; 19026 close_connection(conn);; 19027 }; 19028#endif; 19029 ; 19030 } else {; 19031 /* process HTTP connection */; 19032 init_connection(conn);; 19033 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19034 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19035 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19036 process_new_connection(conn);; 19037 }; 19038 ; 19039 DEBUG_TRACE(""%s"", ""Connection closed"");; 19040 ; 19041#if defined(USE_SERVER_STATS); 19042 conn->conn_close_time = time(NULL);; 19043#endif; 19044 }; 19045 ; 19046 /* Call exit thread user callback */; 19047 if (ctx->callbacks.exit_thread) {; 19048 ctx->callbacks.exit_thread(ctx, 1, tls.user_ptr);; 19049 }; 19050 ; 19051 /* delete thread local storage objects */; 19052 pthread_setspecific(sTlsKey, NULL);; 19053#if defined(_WIN32); 19054 CloseHandle(tls.pthread_cond_helper_mutex);; 19055#endif; 19056 pthread_mutex_destroy(&conn->mutex);; 19057 ; 19058 /* Free the request buffer. */; 19059 conn->buf_size = 0;; 19060 mg_free(conn->buf);; 19061 conn->buf = NULL;; 19062 ; 19063 /* Free cleaned URI (if any) */; 19064 if (conn->request_info.local_uri != conn->request_info.local_uri_raw) {; 19065 mg_free((void *)conn->request_info.local_uri);; 19066 conn->request_in",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:570710,Deployability,patch,patch,570710,"sesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588918,Deployability,configurat,configuration,588918,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589394,Deployability,configurat,configuration,589394,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589612,Deployability,configurat,configuration,589612,"e)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590679,Deployability,configurat,configuration,590679,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591387,Deployability,configurat,configuration,591387,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592898,Deployability,configurat,configuration,592898," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593480,Deployability,configurat,configuration,593480,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:617851,Deployability,release,release,617851,"20650 (unsigned)dwMinorVersion);; 20651 system_info_length += mg_str_append(&buffer, end, block);; 20652 ; 20653 mg_snprintf(NULL,; 20654 NULL,; 20655 block,; 20656 sizeof(block),; 20657 "",%s\""cpu\"" : \""type %u, cores %u, mask %x\"""",; 20658 eol,; 20659 (unsigned)si.wProcessorArchitecture,; 20660 (unsigned)si.dwNumberOfProcessors,; 20661 (unsigned)si.dwActiveProcessorMask);; 20662 system_info_length += mg_str_append(&buffer, end, block);; 20663#elif defined(__ZEPHYR__); 20664 mg_snprintf(NULL,; 20665 NULL,; 20666 block,; 20667 sizeof(block),; 20668 "",%s\""os\"" : \""%s %s\"""",; 20669 eol,; 20670 ""Zephyr OS"",; 20671 ZEPHYR_VERSION);; 20672 system_info_length += mg_str_append(&buffer, end, block);; 20673#else; 20674 struct utsname name;; 20675 memset(&name, 0, sizeof(name));; 20676 uname(&name);; 20677 ; 20678 mg_snprintf(NULL,; 20679 NULL,; 20680 block,; 20681 sizeof(block),; 20682 "",%s\""os\"" : \""%s %s (%s) - %s\"""",; 20683 eol,; 20684 name.sysname,; 20685 name.version,; 20686 name.release,; 20687 name.machine);; 20688 system_info_length += mg_str_append(&buffer, end, block);; 20689#endif; 20690 }; 20691 ; 20692 /* Features */; 20693 {; 20694 mg_snprintf(NULL,; 20695 NULL,; 20696 block,; 20697 sizeof(block),; 20698 "",%s\""features\"" : %lu""; 20699 "",%s\""feature_list\"" : \""Server:%s%s%s%s%s%s%s%s%s\"""",; 20700 eol,; 20701 (unsigned long)mg_check_feature(0xFFFFFFFFu),; 20702 eol,; 20703 mg_check_feature(MG_FEATURES_FILES) ? "" Files"" : """",; 20704 mg_check_feature(MG_FEATURES_SSL) ? "" HTTPS"" : """",; 20705 mg_check_feature(MG_FEATURES_CGI) ? "" CGI"" : """",; 20706 mg_check_feature(MG_FEATURES_IPV6) ? "" IPv6"" : """",; 20707 mg_check_feature(MG_FEATURES_WEBSOCKET) ? "" WebSockets""; 20708 : """",; 20709 mg_check_feature(MG_FEATURES_LUA) ? "" Lua"" : """",; 20710 mg_check_feature(MG_FEATURES_SSJS) ? "" JavaScript"" : """",; 20711 mg_check_feature(MG_FEATURES_CACHE) ? "" Cache"" : """",; 20712 mg_check_feature(MG_FEATURES_STATS) ? "" Stats"" : """");; 20713 system_info_length += mg_str_append(&buffer, end, bloc",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:323,Energy Efficiency,charge,charge,323,". ROOT: net/http/civetweb/civetweb.c Source File. ; ROOT  ; . v6-32. Reference Guide ; .  . Loading...; Searching...; No Matches. civetweb.c. Go to the documentation of this file. 1/* Copyright (c) 2013-2021 the Civetweb developers; 2 * Copyright (c) 2004-2013 Sergey Lyubka; 3 *; 4 * Permission is hereby granted, free of charge, to any person obtaining a copy; 5 * of this software and associated documentation files (the ""Software""), to deal; 6 * in the Software without restriction, including without limitation the rights; 7 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; 8 * copies of the Software, and to permit persons to whom the Software is; 9 * furnished to do so, subject to the following conditions:; 10 *; 11 * The above copyright notice and this permission notice shall be included in; 12 * all copies or substantial portions of the Software.; 13 *; 14 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; 15 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; 16 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; 17 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; 18 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; 19 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; 20 * THE SOFTWARE.; 21 */; 22 ; 23#if defined(__GNUC__) || defined(__MINGW32__); 24#define GCC_VERSION \; 25 (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__); 26#if GCC_VERSION >= 40500; 27/* gcc diagnostic pragmas available */; 28#define GCC_DIAGNOSTIC; 29#endif; 30#endif; 31 ; 32#if defined(GCC_DIAGNOSTIC); 33/* Disable unused macros warnings - not all defines are required; 34 * for all systems and all compilers. */; 35#pragma GCC diagnostic ignored ""-Wunused-macros""; 36/* A padding warning is just plain useless */; 37#pragma GCC diagnostic ignored ""-Wpadded""; 38#endif; 39 ; 40#if defined(__clang__)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16660,Energy Efficiency,reduce,reduces,16660," both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:17236,Energy Efficiency,allocate,allocated,17236,"hreads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_static_assert(MAX_WORKER_THREADS >= 1,; 519 ""worker threads must be a positive n",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:71868,Energy Efficiency,allocate,allocated,71868,"2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdiff_t active_connections;; 2332 volatile ptrdiff_t max_active_connections;; 2333 volatile ptrdiff_t total_connections;; 2334 volatile ptrdiff_t total_requests;; 2335 volatile int64_t total_data_read;; 2336 volatile int64_t total_data_written;; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198177,Energy Efficiency,allocate,allocate,198177," strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198242,Energy Efficiency,allocate,allocated,198242," strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:199303,Energy Efficiency,allocate,allocated,199303,"54 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6896 va_end(ap_copy);; 6897 ; 6898 } else {; 6899 /* The pre-allocated buffer is large enough.; 6900 * Use it to store the string and return the address. */; 6901 va_copy(ap_copy, ap);; 6902 IGNORE_UNUSED_RESULT(; 6903 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6904 va_end(ap_copy);; 6905 *out_buf = prealloc_buf;; 6906 }; 6907 ; 6908 return len;; 6909}; 6910 ; 6911 ; 6912#if defined(GCC_DIAGNOSTIC); 6913/* Enable format-nonliteral warning again. */; 6914#pragma GCC diag",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:199796,Energy Efficiency,allocate,allocated,199796,"passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6896 va_end(ap_copy);; 6897 ; 6898 } else {; 6899 /* The pre-allocated buffer is large enough.; 6900 * Use it to store the string and return the address. */; 6901 va_copy(ap_copy, ap);; 6902 IGNORE_UNUSED_RESULT(; 6903 vsnprintf_impl(prealloc_buf, prealloc_size, fmt, ap_copy));; 6904 va_end(ap_copy);; 6905 *out_buf = prealloc_buf;; 6906 }; 6907 ; 6908 return len;; 6909}; 6910 ; 6911 ; 6912#if defined(GCC_DIAGNOSTIC); 6913/* Enable format-nonliteral warning again. */; 6914#pragma GCC diagnostic pop; 6915#endif; 6916 ; 6917 ; 6918static int; 6919mg_vprintf(struct mg_connection *conn, const char *fmt, va_list ap); 6920{; 6921 char mem[MG_BUF_LEN];; 6922 char *buf = NULL;; 6923 int len;; 6924 ; 6925 if ((len = alloc_vprintf(&buf, mem, sizeof(mem), fmt, ap)) > 0) {; 6926 len = mg_write(conn, buf, (size_t)len);; 6927 }; 6928 if (buf != mem) {; 6929 mg_free(buf);; 6930 }; 6931 ; 6932 return len;; 6933}; 6934 ; 6935 ; 6936int; 6937mg_printf(struct mg_connection *conn, const cha",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:316902,Energy Efficiency,allocate,allocate,316902,"Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is always needed. */; 10996 if (space <= 2) {; 10997 /* Allocate new buffer */; 10998 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10999 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 11000 if (!added) {; 11001 /* Out of memory */; 11002 mg_cry_internal(; 11003 env->conn,; 11004 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11005 __func__,; 11006 fmt);; 11007 return;; 11008 }; 11009 /* Retarget pointers */; 11010 env->buf = added;; 11011 env->buflen = n;; 11012 for (i = 0, n = 0; i < env->varused; i++) {; 11013 env->var[i] = added + n;; 11014 n += strlen(added + n) + 1;; 11015 }; 11016 space = (env->buflen - env->bufused);; 11017 }; 11018 ; 11019 /* Make a pointer to the free space int the buffer */; 11020 added = env->buf + env->bufused;; 11021 ; 11022 /* Copy VARIABLE=VALUE\0 string into the free space */; 11023 va_start(ap, fmt);; 11024 mg_vsnprintf(env->conn, &truncated, added, space - 1, fmt, ap);; 11025 va_end(ap);; 11026 ; 11027 /* Do not add truncated strings to the environment */; 11028 if (truncated) {; 11029 /* Reallocate the buffer */; 11030 space = 0;; 11031 }; 11032 } while (truncated);; 11033 ; 11034 /* Calculate number of bytes added to the environment */; 11035 n = strlen(added) + 1;; 11036 env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360790,Energy Efficiency,allocate,allocated,360790,"socket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360971,Energy Efficiency,monitor,monitoring,360971,"2427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_h",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:368313,Energy Efficiency,allocate,allocate,368313,"40) {; 12637 /* Inflate the data received if bit RSV1 is set. */; 12638 if (!conn->websocket_deflate_initialized) {; 12639 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12640 exit_by_callback = 1;; 12641 }; 12642 if (!exit_by_callback) {; 12643 size_t inflate_buf_size_old = 0;; 12644 size_t inflate_buf_size =; 12645 data_len; 12646 * 4; // Initial guess of the inflated message; 12647 // size. We double the memory when needed.; 12648 Bytef *inflated = NULL;; 12649 Bytef *new_mem = NULL;; 12650 conn->websocket_inflate_state.avail_in =; 12651 (uInt)(data_len + 4);; 12652 conn->websocket_inflate_state.next_in = data;; 12653 // Add trailing 0x00 0x00 0xff 0xff bytes; 12654 data[data_len] = '\x00';; 12655 data[data_len + 1] = '\x00';; 12656 data[data_len + 2] = '\xff';; 12657 data[data_len + 3] = '\xff';; 12658 do {; 12659 if (inflate_buf_size_old == 0) {; 12660 new_mem =; 12661 (Bytef *)mg_calloc(inflate_buf_size,; 12662 sizeof(Bytef));; 12663 } else {; 12664 inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes"",; 12674 (unsigned long)inflate_buf_size);; 12675 exit_by_callback = 1;; 12676 break;; 12677 }; 12678 inflated = new_mem;; 12679 conn->websocket_inflate_state.avail_out =; 12680 (uInt)(inflate_buf_size; 12681 - inflate_buf_size_old);; 12682 conn->websocket_inflate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:369731,Energy Efficiency,allocate,allocated,369731,"flate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inflate_buf_size;; 12699 ; 12700 } while (conn->websocket_inflate_state.avail_out; 12701 == 0);; 12702 inflate_buf_size -=; 12703 conn->websocket_inflate_state.avail_out;; 12704 if (!ws_data_handler(conn,; 12705 mop,; 12706 (char *)inflated,; 12707 inflate_buf_size,; 12708 callback_data)) {; 12709 exit_by_callback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:374254,Energy Efficiency,allocate,allocate,374254," 12835 * conn read/written by more than one thread, no matter if; 12836 * it is a websocket or regular connection. */; 12837 (void)mg_lock_connection(conn);; 12838 ; 12839#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12840 size_t deflated_size = 0;; 12841 Bytef *deflated = 0;; 12842 // Deflate websocket messages over 100kb; 12843 int use_deflate = dataLen > 100 * 1024 && conn->accept_gzip;; 12844 ; 12845 if (use_deflate) {; 12846 if (!conn->websocket_deflate_initialized) {; 12847 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12848 return 0;; 12849 }; 12850 ; 12851 // Deflating the message; 12852 header[0] = 0xC0u | (unsigned char)((unsigned)opcode & 0xf);; 12853 conn->websocket_deflate_state.avail_in = (uInt)dataLen;; 12854 conn->websocket_deflate_state.next_in = (unsigned char *)data;; 12855 deflated_size = (Bytef *)compressBound((uLong)dataLen);; 12856 deflated = mg_calloc(deflated_size, sizeof(Bytef));; 12857 if (deflated == NULL) {; 12858 mg_cry_internal(; 12859 conn,; 12860 ""Out of memory: Cannot allocate deflate buffer of %lu bytes"",; 12861 (unsigned long)deflated_size);; 12862 mg_unlock_connection(conn);; 12863 return -1;; 12864 }; 12865 conn->websocket_deflate_state.avail_out = (uInt)deflated_size;; 12866 conn->websocket_deflate_state.next_out = deflated;; 12867 deflate(&conn->websocket_deflate_state, conn->websocket_deflate_flush);; 12868 dataLen = deflated_size - conn->websocket_deflate_state.avail_out; 12869 - 4; // Strip trailing 0x00 0x00 0xff 0xff bytes; 12870 } else; 12871#endif; 12872 header[0] = 0x80u | (unsigned char)((unsigned)opcode & 0xf);; 12873 ; 12874#if defined(GCC_DIAGNOSTIC); 12875#pragma GCC diagnostic pop; 12876#endif; 12877 ; 12878 /* Frame format: http://tools.ietf.org/html/rfc6455#section-5.2 */; 12879 if (dataLen < 126) {; 12880 /* inline 7-bit length field */; 12881 header[1] = (unsigned char)dataLen;; 12882 headerLen = 2;; 12883 } else if (dataLen <= 0xFFFF) {; 12884 /* 16-bit length field */; 12885 uint16_t le",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:377886,Energy Efficiency,allocate,allocate,377886,"n > 3) && ((ptrdiff_t)in % 4) == 0) {; 12946 /* Convert in 32 bit words, if data is 4 byte aligned */; 12947 while (i < (in_len - 3)) {; 12948 *(uint32_t *)(void *)(out + i) =; 12949 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12950 i += 4;; 12951 }; 12952 }; 12953 if (i != in_len) {; 12954 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12955 while (i < in_len) {; 12956 *(uint8_t *)(void *)(out + i) =; 12957 *(uint8_t *)(void *)(in + i); 12958 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12959 i++;; 12960 }; 12961 }; 12962}; 12963 ; 12964 ; 12965int; 12966mg_websocket_client_write(struct mg_connection *conn,; 12967 int opcode,; 12968 const char *data,; 12969 size_t dataLen); 12970{; 12971 int retval = -1;; 12972 char *masked_data =; 12973 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12974 uint32_t masking_key = 0;; 12975 ; 12976 if (masked_data == NULL) {; 12977 /* Return -1 in an error case */; 12978 mg_cry_internal(conn,; 12979 ""%s"",; 12980 ""Cannot allocate buffer for masked websocket response: ""; 12981 ""Out of memory"");; 12982 return -1;; 12983 }; 12984 ; 12985 do {; 12986 /* Get a masking key - but not 0 */; 12987 masking_key = (uint32_t)get_random();; 12988 } while (masking_key == 0);; 12989 ; 12990 mask_data(data, dataLen, masking_key, masked_data);; 12991 ; 12992 retval = mg_websocket_write_exec(; 12993 conn, opcode, masked_data, dataLen, masking_key);; 12994 mg_free(masked_data);; 12995 ; 12996 return retval;; 12997}; 12998 ; 12999 ; 13000static void; 13001handle_websocket_request(struct mg_connection *conn,; 13002 const char *path,; 13003 int is_callback_resource,; 13004 struct mg_websocket_subprotocols *subprotocols,; 13005 mg_websocket_connect_handler ws_connect_handler,; 13006 mg_websocket_ready_handler ws_ready_handler,; 13007 mg_websocket_data_handler ws_data_handler,; 13008 mg_websocket_close_handler ws_close_handler,; 13009 void *cbData); 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:413102,Energy Efficiency,allocate,allocated,413102," 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:474839,Energy Efficiency,allocate,allocate,474839,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:475018,Energy Efficiency,allocate,allocate,475018,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:475277,Energy Efficiency,allocate,allocate,475277,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:561250,Energy Efficiency,allocate,allocated,561250,"hys_ctx;; 18856 int thread_index;; 18857 struct mg_workerTLS tls;; 18858 ; 18859 mg_set_thread_name(""worker"");; 18860 ; 18861 tls.is_master = 0;; 18862 tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 18863#if defined(_WIN32); 18864 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 18865#endif; 18866 ; 18867 /* Initialize thread local storage before calling any callback */; 18868 pthread_setspecific(sTlsKey, &tls);; 18869 ; 18870 /* Check if there is a user callback */; 18871 if (ctx->callbacks.init_thread) {; 18872 /* call init_thread for a worker thread (type 1), and store the; 18873 * return value */; 18874 tls.user_ptr = ctx->callbacks.init_thread(ctx, 1);; 18875 } else {; 18876 /* No callback: set user pointer to NULL */; 18877 tls.user_ptr = NULL;; 18878 }; 18879 ; 18880 /* Connection structure has been pre-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 189",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:561603,Energy Efficiency,allocate,allocated,561603,"hys_ctx;; 18856 int thread_index;; 18857 struct mg_workerTLS tls;; 18858 ; 18859 mg_set_thread_name(""worker"");; 18860 ; 18861 tls.is_master = 0;; 18862 tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 18863#if defined(_WIN32); 18864 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 18865#endif; 18866 ; 18867 /* Initialize thread local storage before calling any callback */; 18868 pthread_setspecific(sTlsKey, &tls);; 18869 ; 18870 /* Check if there is a user callback */; 18871 if (ctx->callbacks.init_thread) {; 18872 /* call init_thread for a worker thread (type 1), and store the; 18873 * return value */; 18874 tls.user_ptr = ctx->callbacks.init_thread(ctx, 1);; 18875 } else {; 18876 /* No callback: set user pointer to NULL */; 18877 tls.user_ptr = NULL;; 18878 }; 18879 ; 18880 /* Connection structure has been pre-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 189",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:561954,Energy Efficiency,allocate,allocate,561954,"type 1), and store the; 18873 * return value */; 18874 tls.user_ptr = ctx->callbacks.init_thread(ctx, 1);; 18875 } else {; 18876 /* No callback: set user pointer to NULL */; 18877 tls.user_ptr = NULL;; 18878 }; 18879 ; 18880 /* Connection structure has been pre-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:571188,Energy Efficiency,reduce,reduce,571188,"efined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591774,Energy Efficiency,allocate,allocate,591774,"_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", """,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592067,Energy Efficiency,allocate,allocate,592067,"UEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:8801,Integrability,interface,interface,8801,"mbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""Symbian is no longer maintained. CivetWeb no longer supports Symbian.""; 182#endif /* __SYMBIAN32__ */; 183 ; 184#if defined(__ZEPHYR__); 185#include <time.h>; 186 ; 187#include <ctype.h>; 188#include <net/socket.h>; 189#include <posix/pthread.h>; 190#include <posix/time.h>; 191#include <stdio.h>; 192#include <stdlib.h>; 193#include <string.h>; 194#include <zephyr.h>; 195 ; 196#include <fcntl.h>; 197 ; 198#include <libc_extensions.h>; 199 ; 200/* Max worker threads is the max of pthreads minus the main application thread; 201 * and minus the main civetweb thread, thus -2; 202 */; 203#define MAX_WORKER_THREADS (CONFIG_MAX_PTHREAD_COUNT - 2); 204 ; 205#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1); 206#define ZEPHYR_STACK_SIZE USE_STACK_SIZE; 207#else; 208#define ZEPHYR_STACK_SIZE (1024 * 16); 209#endif; 210 ; 211K_THREAD_STACK_DEFINE(civetweb_main_stack, ZEPHYR_STACK_SIZE);; 212K_THREAD_STACK_ARRAY_DEFINE(civetweb_worker_stacks,; 213 MAX_WORKER_THREADS,; 214 ZEPHYR_STACK_SIZE);; 215 ; 216static int zephyr_worker_stack_index;; 217 ; 218#endif; 219 ; 220#if !defined(CIVETWEB_HEADER_INCLUDED); 221/* Include the header file here, so the CivetWeb interface is defined for the; 222 * entire implementation, including the following forward definitions. */; 223#include ""civetweb.h""; 224#endif; 225 ; 226#if !defined(DEBUG_TRACE); 227#if defined(DEBUG); 228static void DEBUG_TRACE_FUNC(const char *func,; 229 unsigned line,; 230 PRINTF_FORMAT_STRING(const char *fmt),; 231 ...) PRINTF_ARGS(3, 4);; 232 ; 233#define DEBUG_TRACE(fmt, ...) \; 234 DEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__); 235 ; 236#define NEED_DEBUG_TRACE_FUNC; 237#if !defined(DEBUG_TRACE_STREAM); 238#define DEBUG_TRACE_STREAM stdout; 239#endif; 240 ; 241#else; 242#define DEBUG_TRACE(fmt, ...) \; 243 do { \; 244 } while (0); 245#endif /* DEBUG */; 246#end",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16235,Integrability,depend,depends,16235," 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16517,Integrability,depend,depend,16517,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:27490,Integrability,interface,interface,27490,"sec = (long)(li.QuadPart % 10000000) * 100;; 794 ok = TRUE;; 795 }; 796 /* END: CLOCK_PROCESS */; 797 ; 798 } else {; 799 ; 800 /* BEGIN: unknown clock */; 801 /* ok = FALSE; already set by init */; 802 /* END: unknown clock */; 803 }; 804 }; 805 ; 806 return ok ? 0 : -1;; 807}; 808#endif; 809 ; 810 ; 811#define pid_t HANDLE /* MINGW typedefs pid_t to int. Using #define here. */; 812 ; 813static int pthread_mutex_lock(pthread_mutex_t *);; 814static int pthread_mutex_unlock(pthread_mutex_t *);; 815static void path_to_unicode(const struct mg_connection *conn,; 816 const char *path,; 817 wchar_t *wbuf,; 818 size_t wbuf_len);; 819 ; 820/* All file operations need to be rewritten to solve #246. */; 821 ; 822struct mg_file;; 823 ; 824static const char *mg_fgets(char *buf, size_t size, struct mg_file *filep);; 825 ; 826 ; 827/* POSIX dirent interface */; 828struct dirent {; 829 char d_name[UTF8_PATH_MAX];; 830};; 831 ; 832typedef struct DIR {; 833 HANDLE handle;; 834 WIN32_FIND_DATAW info;; 835 struct dirent result;; 836} DIR;; 837 ; 838#if defined(HAVE_POLL); 839#define mg_pollfd pollfd; 840#else; 841struct mg_pollfd {; 842 SOCKET fd;; 843 short events;; 844 short revents;; 845};; 846#endif; 847 ; 848/* Mark required libraries */; 849#if defined(_MSC_VER); 850#pragma comment(lib, ""Ws2_32.lib""); 851#endif; 852 ; 853#else /* defined(_WIN32) - WINDOWS vs UNIX include block */; 854 ; 855#include <inttypes.h>; 856 ; 857/* Linux & co. internally use UTF8 */; 858#define UTF8_PATH_MAX (PATH_MAX); 859 ; 860typedef const void *SOCK_OPT_TYPE;; 861 ; 862#if defined(ANDROID); 863typedef unsigned short int in_port_t;; 864#endif; 865 ; 866#if !defined(__ZEPHYR__); 867#include <arpa/inet.h>; 868#include <ctype.h>; 869#include <dirent.h>; 870#include <grp.h>; 871#include <limits.h>; 872#include <netdb.h>; 873#include <netinet/in.h>; 874#include <netinet/tcp.h>; 875#include <pthread.h>; 876#include <pwd.h>; 877#include <stdarg.h>; 878#include <stddef.h>; 879#include <stdio.h>; 880#include <",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:50813,Integrability,depend,depending,50813,"ostic ignored ""-Wunreachable-code""; 1627 /* For every compiler, either ""sizeof(pthread_t) > sizeof(unsigned long)""; 1628 * or not, so one of the two conditions will be unreachable by construction.; 1629 * Unfortunately the C standard does not define a way to check this at; 1630 * compile time, since the #if preprocessor conditions can not use the; 1631 * sizeof operator as an argument. */; 1632#endif; 1633 ; 1634 if (sizeof(pthread_t) > sizeof(unsigned long)) {; 1635 /* This is the problematic case for CRYPTO_set_id_callback:; 1636 * The OS pthread_t can not be cast to unsigned long. */; 1637 struct mg_workerTLS *tls =; 1638 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 1639 if (tls == NULL) {; 1640 /* SSL called from an unknown thread: Create some thread index.; 1641 */; 1642 tls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));; 1643 tls->is_master = -2; /* -2 means ""3rd party thread"" */; 1644 tls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 1645 pthread_setspecific(sTlsKey, tls);; 1646 }; 1647 return tls->thread_idx;; 1648 } else {; 1649 /* pthread_t may be any data type, so a simple cast to unsigned long; 1650 * can rise a warning/error, depending on the platform.; 1651 * Here memcpy is used as an anything-to-anything cast. */; 1652 unsigned long ret = 0;; 1653 pthread_t t = pthread_self();; 1654 memcpy(&ret, &t, sizeof(pthread_t));; 1655 return ret;; 1656 }; 1657 ; 1658#if defined(__clang__); 1659#pragma clang diagnostic pop; 1660#endif; 1661 ; 1662#endif; 1663}; 1664 ; 1665 ; 1666FUNCTION_MAY_BE_UNUSED; 1667static uint64_t; 1668mg_get_current_time_ns(void); 1669{; 1670 struct timespec tsnow;; 1671 clock_gettime(CLOCK_REALTIME, &tsnow);; 1672 return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;; 1673}; 1674 ; 1675 ; 1676#if defined(GCC_DIAGNOSTIC); 1677/* Show no warning in case system functions are not used. */; 1678#pragma GCC diagnostic pop; 1679#endif /* defined(GCC_DIAGNOSTIC) */; 1680#if defined(__cla",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:96934,Integrability,protocol,protocol,96934,"mg_get_user_connection_data(const struct mg_connection *conn); 3204{; 3205 if (conn != NULL) {; 3206 return conn->request_info.conn_data;; 3207 }; 3208 return NULL;; 3209}; 3210 ; 3211 ; 3212int; 3213mg_get_server_ports(const struct mg_context *ctx,; 3214 int size,; 3215 struct mg_server_port *ports); 3216{; 3217 int i, cnt = 0;; 3218 ; 3219 if (size <= 0) {; 3220 return -1;; 3221 }; 3222 memset(ports, 0, sizeof(*ports) * (size_t)size);; 3223 if (!ctx) {; 3224 return -1;; 3225 }; 3226 if (!ctx->listening_sockets) {; 3227 return -1;; 3228 }; 3229 ; 3230 for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {; 3231 ; 3232 ports[cnt].port =; 3233 ntohs(USA_IN_PORT_UNSAFE(&(ctx->listening_sockets[i].lsa)));; 3234 ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;; 3235 ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;; 3236 ; 3237 if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {; 3238 /* IPv4 */; 3239 ports[cnt].protocol = 1;; 3240 cnt++;; 3241 } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {; 3242 /* IPv6 */; 3243 ports[cnt].protocol = 3;; 3244 cnt++;; 3245 }; 3246 }; 3247 ; 3248 return cnt;; 3249}; 3250 ; 3251 ; 3252#if defined(USE_X_DOM_SOCKET) && !defined(UNIX_DOMAIN_SOCKET_SERVER_NAME); 3253#define UNIX_DOMAIN_SOCKET_SERVER_NAME ""*""; 3254#endif; 3255 ; 3256static void; 3257sockaddr_to_string(char *buf, size_t len, const union usa *usa); 3258{; 3259 buf[0] = '\0';; 3260 ; 3261 if (!usa) {; 3262 return;; 3263 }; 3264 ; 3265 if (usa->sa.sa_family == AF_INET) {; 3266 getnameinfo(&usa->sa,; 3267 sizeof(usa->sin),; 3268 buf,; 3269 (unsigned)len,; 3270 NULL,; 3271 0,; 3272 NI_NUMERICHOST);; 3273 }; 3274#if defined(USE_IPV6); 3275 else if (usa->sa.sa_family == AF_INET6) {; 3276 getnameinfo(&usa->sa,; 3277 sizeof(usa->sin6),; 3278 buf,; 3279 (unsigned)len,; 3280 NULL,; 3281 0,; 3282 NI_NUMERICHOST);; 3283 }; 3284#endif; 3285#if defined(USE_X_DOM_SOCKET); 3286 else if (usa->sa.sa_family == AF_UNIX) {; 3287 /* TOD",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:97070,Integrability,protocol,protocol,97070,"217 int i, cnt = 0;; 3218 ; 3219 if (size <= 0) {; 3220 return -1;; 3221 }; 3222 memset(ports, 0, sizeof(*ports) * (size_t)size);; 3223 if (!ctx) {; 3224 return -1;; 3225 }; 3226 if (!ctx->listening_sockets) {; 3227 return -1;; 3228 }; 3229 ; 3230 for (i = 0; (i < size) && (i < (int)ctx->num_listening_sockets); i++) {; 3231 ; 3232 ports[cnt].port =; 3233 ntohs(USA_IN_PORT_UNSAFE(&(ctx->listening_sockets[i].lsa)));; 3234 ports[cnt].is_ssl = ctx->listening_sockets[i].is_ssl;; 3235 ports[cnt].is_redirect = ctx->listening_sockets[i].ssl_redir;; 3236 ; 3237 if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET) {; 3238 /* IPv4 */; 3239 ports[cnt].protocol = 1;; 3240 cnt++;; 3241 } else if (ctx->listening_sockets[i].lsa.sa.sa_family == AF_INET6) {; 3242 /* IPv6 */; 3243 ports[cnt].protocol = 3;; 3244 cnt++;; 3245 }; 3246 }; 3247 ; 3248 return cnt;; 3249}; 3250 ; 3251 ; 3252#if defined(USE_X_DOM_SOCKET) && !defined(UNIX_DOMAIN_SOCKET_SERVER_NAME); 3253#define UNIX_DOMAIN_SOCKET_SERVER_NAME ""*""; 3254#endif; 3255 ; 3256static void; 3257sockaddr_to_string(char *buf, size_t len, const union usa *usa); 3258{; 3259 buf[0] = '\0';; 3260 ; 3261 if (!usa) {; 3262 return;; 3263 }; 3264 ; 3265 if (usa->sa.sa_family == AF_INET) {; 3266 getnameinfo(&usa->sa,; 3267 sizeof(usa->sin),; 3268 buf,; 3269 (unsigned)len,; 3270 NULL,; 3271 0,; 3272 NI_NUMERICHOST);; 3273 }; 3274#if defined(USE_IPV6); 3275 else if (usa->sa.sa_family == AF_INET6) {; 3276 getnameinfo(&usa->sa,; 3277 sizeof(usa->sin6),; 3278 buf,; 3279 (unsigned)len,; 3280 NULL,; 3281 0,; 3282 NI_NUMERICHOST);; 3283 }; 3284#endif; 3285#if defined(USE_X_DOM_SOCKET); 3286 else if (usa->sa.sa_family == AF_UNIX) {; 3287 /* TODO: Define a remote address for unix domain sockets.; 3288 * This code will always return ""localhost"", identical to http+tcp:; 3289 getnameinfo(&usa->sa,; 3290 sizeof(usa->sun),; 3291 buf,; 3292 (unsigned)len,; 3293 NULL,; 3294 0,; 3295 NI_NUMERICHOST);; 3296 */; 3297 strncpy(buf, UNIX_DOMAIN_SOCKET_SERVER_NAME,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:99695,Integrability,message,message,99695,"ULL);; 3313 if (tm != NULL) {; 3314#else; 3315 struct tm _tm;; 3316 struct tm *tm = &_tm;; 3317 ; 3318 if (t != NULL) {; 3319 gmtime_r(t, tm);; 3320#endif; 3321 strftime(buf, buf_len, ""%a, %d %b %Y %H:%M:%S GMT"", tm);; 3322 } else {; 3323 mg_strlcpy(buf, ""Thu, 01 Jan 1970 00:00:00 GMT"", buf_len);; 3324 buf[buf_len - 1] = '\0';; 3325 }; 3326}; 3327 ; 3328 ; 3329/* difftime for struct timespec. Return value is in seconds. */; 3330static double; 3331mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before); 3332{; 3333 return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9; 3334 + (double)(ts_now->tv_sec - ts_before->tv_sec);; 3335}; 3336 ; 3337 ; 3338#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl); 3339static void mg_cry_internal_impl(const struct mg_connection *conn,; 3340 const char *func,; 3341 unsigned line,; 3342 const char *fmt,; 3343 va_list ap);; 3344#include ""external_mg_cry_internal_impl.inl""; 3345#elif !defined(NO_FILESYSTEMS); 3346 ; 3347/* Print error message to the opened error log stream. */; 3348static void; 3349mg_cry_internal_impl(const struct mg_connection *conn,; 3350 const char *func,; 3351 unsigned line,; 3352 const char *fmt,; 3353 va_list ap); 3354{; 3355 char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];; 3356 struct mg_file fi;; 3357 time_t timestamp;; 3358 ; 3359 /* Unused, in the RELEASE build */; 3360 (void)func;; 3361 (void)line;; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:105399,Integrability,protocol,protocols,105399,"struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma clang diagnostic push; 3545#pragma clang diagnostic ignored ""-Wunreachable-code""; 3546 /* Depending on USE_WEBSOCKET and NO_SSL, some oft the protocols might be; 3547 * not supported. Clang raises an ""unreachable code"" warning for parts of ?:; 3548 * unreachable, but splitting into four different #ifdef clauses here is; 3549 * more complicated.; 3550 */; 3551#endif; 3552 ; 3553 const struct mg_request_info *ri = &conn->request_info;; 3554 ; 3555 const char *proto = ((conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET); 3556 ? (ri->is_ssl ? ""wss"" : ""ws""); 3557 : (ri->is_ssl ? ""https"" : ""http""));; 3558 ; 3559 return proto;; 3560 ; 3561#if defined(__clang__); 3562#pragma clang diagnostic pop; 3563#endif; 3564}; 3565 ; 3566 ; 3567static int; 3568mg_construct_local_link(const struct mg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:107079,Integrability,protocol,protocol,107079,"buflen,; 3571 const char *define_proto,; 3572 int define_port,; 3573 const char *define_uri); 3574{; 3575 if ((buflen < 1) || (buf == 0) || (conn == 0)) {; 3576 return -1;; 3577 } else {; 3578 int truncated = 0;; 3579 const struct mg_request_info *ri = &conn->request_info;; 3580 ; 3581 const char *proto =; 3582 (define_proto != NULL) ? define_proto : get_proto_name(conn);; 3583 const char *uri =; 3584 (define_uri != NULL); 3585 ? define_uri; 3586 : ((ri->request_uri != NULL) ? ri->request_uri : ri->local_uri);; 3587 int port = (define_port > 0) ? define_port : ri->server_port;; 3588 int default_port = 80;; 3589 ; 3590 if (uri == NULL) {; 3591 return -1;; 3592 }; 3593 ; 3594#if defined(USE_X_DOM_SOCKET); 3595 if (conn->client.lsa.sa.sa_family == AF_UNIX) {; 3596 /* TODO: Define and document a link for UNIX domain sockets. */; 3597 /* There seems to be no official standard for this.; 3598 * Common uses seem to be ""httpunix://"", ""http.unix://"" or; 3599 * ""http+unix://"" as a protocol definition string, followed by; 3600 * ""localhost"" or ""127.0.0.1"" or ""/tmp/unix/path"" or; 3601 * ""%2Ftmp%2Funix%2Fpath"" (url % encoded) or; 3602 * ""localhost:%2Ftmp%2Funix%2Fpath"" (domain socket path as port) or; 3603 * """" (completely skipping the server name part). In any case, the; 3604 * last part is the server local path. */; 3605 const char *server_name = UNIX_DOMAIN_SOCKET_SERVER_NAME;; 3606 mg_snprintf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:107742,Integrability,protocol,protocol,107742,";; 3588 int default_port = 80;; 3589 ; 3590 if (uri == NULL) {; 3591 return -1;; 3592 }; 3593 ; 3594#if defined(USE_X_DOM_SOCKET); 3595 if (conn->client.lsa.sa.sa_family == AF_UNIX) {; 3596 /* TODO: Define and document a link for UNIX domain sockets. */; 3597 /* There seems to be no official standard for this.; 3598 * Common uses seem to be ""httpunix://"", ""http.unix://"" or; 3599 * ""http+unix://"" as a protocol definition string, followed by; 3600 * ""localhost"" or ""127.0.0.1"" or ""/tmp/unix/path"" or; 3601 * ""%2Ftmp%2Funix%2Fpath"" (url % encoded) or; 3602 * ""localhost:%2Ftmp%2Funix%2Fpath"" (domain socket path as port) or; 3603 * """" (completely skipping the server name part). In any case, the; 3604 * last part is the server local path. */; 3605 const char *server_name = UNIX_DOMAIN_SOCKET_SERVER_NAME;; 3606 mg_snprintf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3631 {; 3632#if defined(USE_IPV6); 3633 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3634#endif; 3635 int auth_domain_check_enabled =; 3636 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3637 && (!mg_strcasecmp(; 3638 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3639 ; 3640 const char *server_domain =; 3641 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3642 ; 3643 char portstr[16];; 3644 char server_ip[48];; 3645 ; 3646 if (port != default_port) {; 3647 sprintf(portstr, "":%u"", (unsigned)port);; 3648 } else {; 3649 portstr[0] = 0;; 3650 }; 3651 ;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:107982,Integrability,protocol,protocol,107982,"ockets. */; 3597 /* There seems to be no official standard for this.; 3598 * Common uses seem to be ""httpunix://"", ""http.unix://"" or; 3599 * ""http+unix://"" as a protocol definition string, followed by; 3600 * ""localhost"" or ""127.0.0.1"" or ""/tmp/unix/path"" or; 3601 * ""%2Ftmp%2Funix%2Fpath"" (url % encoded) or; 3602 * ""localhost:%2Ftmp%2Funix%2Fpath"" (domain socket path as port) or; 3603 * """" (completely skipping the server name part). In any case, the; 3604 * last part is the server local path. */; 3605 const char *server_name = UNIX_DOMAIN_SOCKET_SERVER_NAME;; 3606 mg_snprintf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3631 {; 3632#if defined(USE_IPV6); 3633 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3634#endif; 3635 int auth_domain_check_enabled =; 3636 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3637 && (!mg_strcasecmp(; 3638 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3639 ; 3640 const char *server_domain =; 3641 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3642 ; 3643 char portstr[16];; 3644 char server_ip[48];; 3645 ; 3646 if (port != default_port) {; 3647 sprintf(portstr, "":%u"", (unsigned)port);; 3648 } else {; 3649 portstr[0] = 0;; 3650 }; 3651 ; 3652 if (!auth_domain_check_enabled || !server_domain) {; 3653 ; 3654 sockaddr_to_string(server_ip,; 3655 sizeof(server_ip),; 3656 &conn->client.lsa);; 3657 ; 3658 server_domain = server_ip;; 3659 }; 3660 ; 3661 mg_snprintf(conn,; 3662 &trunc",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:130740,Integrability,message,message,130740,"ode: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server error code */; 4341 return ""Server Error"";; 4342 }; 4343 ; 4344 /* Response code not even within reasonable range */; 4345 return """";; 4346 }; 4347}; 4348 ; 4349 ; 4350static int; 4351mg_send_http_error_impl(struct mg_connection *conn,; 4352 int status,; 4353 const char *fmt,; 4354 va_list args); 4355{; 4356 char errmsg_buf[MG_BUF_LEN];; 4357 va_list ap;; 4358 int has_body;; 4359 ; 4360#if !defined(NO_FILESYSTEMS); 4361 char path_buf[UTF8_PATH_MAX];; 4362 int len, i, page_handler_found, scope, truncated;; 4363 const char *error_handler = NULL;; 4364 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4365 const char *error_page_file_ext, *tstr;; 4366#endif /* NO_FILESYSTEMS */; 4367 int handled_by_callback = 0;; 4368 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:130905,Integrability,message,message,130905,"357 va_list ap;; 4358 int has_body;; 4359 ; 4360#if !defined(NO_FILESYSTEMS); 4361 char path_buf[UTF8_PATH_MAX];; 4362 int len, i, page_handler_found, scope, truncated;; 4363 const char *error_handler = NULL;; 4364 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4365 const char *error_page_file_ext, *tstr;; 4366#endif /* NO_FILESYSTEMS */; 4367 int handled_by_callback = 0;; 4368 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:135284,Integrability,message,message,135284,"*/; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; 4484 path_buf);; 4485 page_handler_found = 1;; 4486 break;; 4487 }; 4488 DEBUG_TRACE(""Check error page %s - not found"",; 4489 path_buf);; 4490 ; 4491 /* Continue with the next file extenstion from the; 4492 * configuration (if there is a next one). */; 4493 tstr = strchr(tstr + i, '.');; 4494 }; 4495 }; 4496 }; 4497 ; 4498 if (page_handler_found) {; 4499 conn->in_error_handler = 1;; 4500 handle_file_based_request(conn, path_buf, &error_page_file);; 4501 conn->in_error_handler = 0;; 4502 return 0;; 4503 }; 4504#endif /* NO_FILESYSTEMS */; 4505 }; 4506 ; 4507 /* No custom error page. Send default error page. */; 4508 conn->must_close = 1;; 4509 mg_response_header_start(conn, status);; 4510 send_no_cache_header(conn);; 4511 send_additional_header(conn);; 4512 if (has_body) {; 4513 mg_response_header_add(conn,; 4514 ""Content-Type"",; 4515 ""text/plain; charset=utf-8"",; 4516 -1);; 4517 }; 4518 mg_response_header_send(conn);; 4519 ; 4520 /* HTTP responses 1xx, 204 and 304 MUST NOT send a body */; 4521 if (has_body) {; 4522 /* For other errors, send a generic error message. */; 4523 const char *status_text = mg_get_response_code_text(conn, status);; 4524 mg_printf(conn, ""Error %d: %s\n"", status, status_text);; 4525 mg_write(conn, errmsg_buf, strlen(errmsg_buf));; 4526 ; 4527 } else {; 4528 /* No body allowed. Close the connection. */; 4529 DEBUG_TRACE(""Error %i"", status);; 4530 }; 4531 }; 4532 return 0;; 4533}; 4534 ; 4535 ; 4536int; 4537mg_send_http_error(struct mg_connection *conn, int status, const char *fmt, ...); 4538{; 4539 va_list ap;; 4540 int ret;; 4541 ; 4542 va_start(ap, fmt);; 4543 ret = mg_send_http_error_impl(conn, status, fmt, ap);; 4544 va_end(ap);; 4545 ; 4546 return ret;; 4547}; 4548 ; 4549 ; 4550int; 4551mg_send_http_ok(struct mg_connection *conn,; 4552 const char *mime_type,; 4553 long long content_length",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:177924,Integrability,depend,depending,177924,"down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6012 if (n <= 0) {; 6013 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6014 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6015 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6016 n = 0;; 6017 } else {; 6018 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6019 return -2;; 6020 }; 6021 } else {; 6022 err = 0;; 6023 }; 6024 } else; 6025#elif !defined(NO_SSL); 6026 if (ssl != NULL) {; 6027 ERR_clear_error();; 6028 n = SSL_write(ssl, buf, len);; 6029 if (n <= 0) {; 6030 err = SSL_get_error(ssl, n);; 6031 if ((err == SSL_ERROR_SYSCALL) && (n == -1)) {; 6032 err = ERRNO;; 6033 } else if ((err == SSL_ERROR_WANT_READ); 6034 || (err == SSL_ERROR_WANT_WRITE)) {; 6035 n = 0;; 6036 } else {; 6037 DEBUG_TRACE(""SSL_write() failed, error %d"", err);; 6038 ERR_clear_error();; 6039 return -2;; 6040 }; 6041 ERR_clear_error();; 6042 } else {; 6043 err = 0;; 6044 }; 6045 } else; 6046#endif; 6047 ; 6048 if (fp != NULL) {; 6049 n = (int)fwrite(buf, 1, (size_t)len, fp);; 6050 if (ferror(fp)) {; 6051 n = -1;; 6052 err = ERRNO;; 6053 } else {; 6054 err = 0;; 6055 }; 6056 } else {; 6057 n = (int)send(sock, buf, (len_t)len, MSG_NOSIGNAL);; 6058 err = (n < 0) ? ERRNO : 0;; 6059#if defined(_WIN32); 6060 if (err == WSAEWOULDBLOCK) {; 6061 err = 0;; 6062 n = 0;; 6063 }; 6064#else; 6065 if (ERROR_TRY_AGAIN(err)) {; 6066 err = 0;; 6067 n = 0;; 6068 }; 6069#endif; 6070 if (n < 0) {; 6071 /* shutdown of the socket at client side */; 6072 return -2;; 6073 }; 6074 }; 6075 ; 6076 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6077 return -2;; 6078 }; 6079 ; 6080 if ((n > 0) || ((n == 0) && (len == 0))) {; 6081 /* some data has been read, or no data was requested */; 6082 return n;; 6083 }; 6084 if (n < 0) {; 6085 /* socket error - check errno */; 6086 DEBUG_TRACE(""send() failed, error %d"", err);; 6087 ; 6088 /* TODO (mid): error handling depending on the error code.; 608",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198065,Integrability,message,message,198065,"ormation, chunk and terminating \r\n. */; 6791 ret = mg_write(conn, lenbuf, lenbuf_len);; 6792 if (ret != (int)lenbuf_len) {; 6793 return -1;; 6794 }; 6795 t = ret;; 6796 ; 6797 ret = mg_write(conn, chunk, chunk_len);; 6798 if (ret != (int)chunk_len) {; 6799 return -1;; 6800 }; 6801 t += ret;; 6802 ; 6803 ret = mg_write(conn, ""\r\n"", 2);; 6804 if (ret != 2) {; 6805 return -1;; 6806 }; 6807 t += ret;; 6808 ; 6809 return t;; 6810}; 6811 ; 6812 ; 6813#if defined(GCC_DIAGNOSTIC); 6814/* This block forwards format strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198122,Integrability,message,message,198122," 6810}; 6811 ; 6812 ; 6813#if defined(GCC_DIAGNOSTIC); 6814/* This block forwards format strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198754,Integrability,message,message,198754,"free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy))",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:198821,Integrability,message,message,198821,"oc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; 6879 */; 6880 va_copy(ap_copy, ap);; 6881 len = alloc_vprintf2(out_buf, fmt, ap_copy);; 6882 va_end(ap_copy);; 6883 ; 6884 } else if ((size_t)(len) >= prealloc_size) {; 6885 /* The pre-allocated buffer not large enough. */; 6886 /* Allocate a new buffer. */; 6887 *out_buf = (char *)mg_malloc((size_t)(len) + 1);; 6888 if (!*out_buf) {; 6889 /* Allocation failed. Return -1 as ""out of memory"" error. */; 6890 return -1;; 6891 }; 6892 /* Buffer allocation successful. Store the string there. */; 6893 va_copy(ap_copy, ap);; 6894 IGNORE_UNUSED_RESULT(; 6895 vsnprintf_impl(*out_buf, (size_t)(len) + 1, fmt, ap_copy));; 6896 va_end(ap_copy);; 6897 ; 6898 } else {; 6899 /* The pre-allocat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302687,Integrability,message,message,302687," 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302718,Integrability,message,message,302718," 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:331995,Integrability,message,message,331995,"n[1] = -1;; 11443 ; 11444 /* Now read CGI reply into a buffer. We need to set correct; 11445 * status code, thus we need to see all HTTP headers first.; 11446 * Do not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 500,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 bu",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:332172,Integrability,message,message,332172,"o not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 500,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:332287,Integrability,message,message,332287,"o not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 500,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:332372,Integrability,message,message,332372,"0,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:359794,Integrability,message,message,359794,"r\n"",; 12389 b64_sha);; 12390 ; 12391#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12392 // Send negotiated compression extension parameters; 12393 websocket_deflate_response(conn);; 12394#endif; 12395 ; 12396 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12397 mg_printf(conn,; 12398 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12399 conn->request_info.acceptedWebSocketSubprotocol);; 12400 } else {; 12401 mg_printf(conn, ""%s"", ""\r\n"");; 12402 }; 12403 ; 12404 return 1;; 12405}; 12406 ; 12407 ; 12408#if !defined(MG_MAX_UNANSWERED_PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to th",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360160,Integrability,message,message,360160,"PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360215,Integrability,message,message,360215,"PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360287,Integrability,message,message,360287,"PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360660,Integrability,message,message,360660,"nn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = a",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:362013,Integrability,message,messages,362013,"e timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:364131,Integrability,message,message,364131,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:365288,Integrability,message,message,365288,"t of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place. */; 12541 DEBUG_ASSERT(body_len >= header_len);; 12542 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12543 mop = buf[0]; /* current mask and opcode */; 12544 /* Overflow case */; 12545 len = body_len - header_len;; 12546 memcpy(data, buf + header_len, len);; 12547 error = 0;; 12548 while ((uint64_t)len < data_len) {; 12549 n = pull_inner(NULL,; 12550 conn,; 12551 (char *)(data + len),; 12552 (int)(data_len - len),; 12553 timeout);; 12554 if (n <= -2) {; 12555 error = 1;; 12556 break;; 12557 } else if (n > 0) {; 12558 len += (size_t)n;; 12559 } else {; 12560 /* Timeout: should retry */; 12561 /* TODO: retry condition */; 12562 }; 12563 }; 12564 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Ma",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:366159,Integrability,message,messages,366159,"4 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:366459,Integrability,message,messages,366459," */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit the loop if callback signals to exit (server side),; 12633 * or ""connection close"" opcode received (client side). */; 12634 if (ws_data_handler != NULL) {; 12635#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12636 if (mop & 0x40) {; 12637 /* Inflate the data received if bit RSV1 is set. */; 12638 if (!conn->websocket_deflate_initialized) {; 12639 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12640 exit_by_callback = 1;; 12641 }; 12642 if (!exit_by_callback) {; 12643 size_t inflate_buf_size_old ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:367507,Integrability,message,message,367507,"e if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit the loop if callback signals to exit (server side),; 12633 * or ""connection close"" opcode received (client side). */; 12634 if (ws_data_handler != NULL) {; 12635#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12636 if (mop & 0x40) {; 12637 /* Inflate the data received if bit RSV1 is set. */; 12638 if (!conn->websocket_deflate_initialized) {; 12639 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12640 exit_by_callback = 1;; 12641 }; 12642 if (!exit_by_callback) {; 12643 size_t inflate_buf_size_old = 0;; 12644 size_t inflate_buf_size =; 12645 data_len; 12646 * 4; // Initial guess of the inflated message; 12647 // size. We double the memory when needed.; 12648 Bytef *inflated = NULL;; 12649 Bytef *new_mem = NULL;; 12650 conn->websocket_inflate_state.avail_in =; 12651 (uInt)(data_len + 4);; 12652 conn->websocket_inflate_state.next_in = data;; 12653 // Add trailing 0x00 0x00 0xff 0xff bytes; 12654 data[data_len] = '\x00';; 12655 data[data_len + 1] = '\x00';; 12656 data[data_len + 2] = '\xff';; 12657 data[data_len + 3] = '\xff';; 12658 do {; 12659 if (inflate_buf_size_old == 0) {; 12660 new_mem =; 12661 (Bytef *)mg_calloc(inflate_buf_size,; 12662 sizeof(Bytef));; 12663 } else {; 12664 inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes""",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:369032,Integrability,message,message,369032," inflate_buf_size *= 2;; 12665 new_mem =; 12666 (Bytef *)mg_realloc(inflated,; 12667 inflate_buf_size);; 12668 }; 12669 if (new_mem == NULL) {; 12670 mg_cry_internal(; 12671 conn,; 12672 ""Out of memory: Cannot allocate ""; 12673 ""inflate buffer of %lu bytes"",; 12674 (unsigned long)inflate_buf_size);; 12675 exit_by_callback = 1;; 12676 break;; 12677 }; 12678 inflated = new_mem;; 12679 conn->websocket_inflate_state.avail_out =; 12680 (uInt)(inflate_buf_size; 12681 - inflate_buf_size_old);; 12682 conn->websocket_inflate_state.next_out =; 12683 inflated + inflate_buf_size_old;; 12684 ret = inflate(&conn->websocket_inflate_state,; 12685 Z_SYNC_FLUSH);; 12686 if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR; 12687 || ret == Z_MEM_ERROR) {; 12688 mg_cry_internal(; 12689 conn,; 12690 ""ZLIB inflate error: %i %s"",; 12691 ret,; 12692 (conn->websocket_inflate_state.msg; 12693 ? conn->websocket_inflate_state.msg; 12694 : ""<no error message>""));; 12695 exit_by_callback = 1;; 12696 break;; 12697 }; 12698 inflate_buf_size_old = inflate_buf_size;; 12699 ; 12700 } while (conn->websocket_inflate_state.avail_out; 12701 == 0);; 12702 inflate_buf_size -=; 12703 conn->websocket_inflate_state.avail_out;; 12704 if (!ws_data_handler(conn,; 12705 mop,; 12706 (char *)inflated,; 12707 inflate_buf_size,; 12708 callback_data)) {; 12709 exit_by_callback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:370479,Integrability,message,message,370479,"llback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PIN",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:371402,Integrability,message,message,371402," } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 12785 ; 12786 if (ret <= 0) {; 12787 /* Error: send failed */; 12788 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12789 break;; 12790 }; 12791 ping_count++;; 12792 }; 12793 }; 12794 /* Timeout: should retry */; 12795 /* TODO: get timeout def */; 12796 }; 12797 }; 12798 }; 12799 ; 12800 /* Leave data processing loop */; 12801 mg_set_thread_name(""worker"");; 12802 conn->in_websocket_handling = 0;; 12803 DEBUG_TRACE(""Websocket connection %s:%u left data processing loop"",; 12804 conn->request_info.remote_addr,; 12805 conn->request_info.remote_port);; 12806}; 12807 ; 12808 ; 12809static int; 12810mg_websocket_write_exec(struct mg_connection *conn,; 12811 int opcode,; 12812 const char *data,; 12813 size_t dataLen,; 12814 uint32_t masking_key); 12815{; 12816 unsign",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:373536,Integrability,message,messages,373536,"sion""; 12824#endif; 12825 ; 12826 /* Note that POSIX/Winsock's send() is threadsafe; 12827 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid; 12828 * but mongoose's mg_printf/mg_write is not (because of the loop in; 12829 * push(), although that is only a problem if the packet is large or; 12830 * outgoing buffer is full). */; 12831 ; 12832 /* TODO: Check if this lock should be moved to user land.; 12833 * Currently the server sets this lock for websockets, but; 12834 * not for any other connection. It must be set for every; 12835 * conn read/written by more than one thread, no matter if; 12836 * it is a websocket or regular connection. */; 12837 (void)mg_lock_connection(conn);; 12838 ; 12839#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12840 size_t deflated_size = 0;; 12841 Bytef *deflated = 0;; 12842 // Deflate websocket messages over 100kb; 12843 int use_deflate = dataLen > 100 * 1024 && conn->accept_gzip;; 12844 ; 12845 if (use_deflate) {; 12846 if (!conn->websocket_deflate_initialized) {; 12847 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12848 return 0;; 12849 }; 12850 ; 12851 // Deflating the message; 12852 header[0] = 0xC0u | (unsigned char)((unsigned)opcode & 0xf);; 12853 conn->websocket_deflate_state.avail_in = (uInt)dataLen;; 12854 conn->websocket_deflate_state.next_in = (unsigned char *)data;; 12855 deflated_size = (Bytef *)compressBound((uLong)dataLen);; 12856 deflated = mg_calloc(deflated_size, sizeof(Bytef));; 12857 if (deflated == NULL) {; 12858 mg_cry_internal(; 12859 conn,; 12860 ""Out of memory: Cannot allocate deflate buffer of %lu bytes"",; 12861 (unsigned long)deflated_size);; 12862 mg_unlock_connection(conn);; 12863 return -1;; 12864 }; 12865 conn->websocket_deflate_state.avail_out = (uInt)deflated_size;; 12866 conn->websocket_deflate_state.next_out = deflated;; 12867 deflate(&conn->websocket_deflate_state, conn->websocket_deflate_flush);; 12868 dataLen = deflated_size - c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:373825,Integrability,message,message,373825,"sion""; 12824#endif; 12825 ; 12826 /* Note that POSIX/Winsock's send() is threadsafe; 12827 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid; 12828 * but mongoose's mg_printf/mg_write is not (because of the loop in; 12829 * push(), although that is only a problem if the packet is large or; 12830 * outgoing buffer is full). */; 12831 ; 12832 /* TODO: Check if this lock should be moved to user land.; 12833 * Currently the server sets this lock for websockets, but; 12834 * not for any other connection. It must be set for every; 12835 * conn read/written by more than one thread, no matter if; 12836 * it is a websocket or regular connection. */; 12837 (void)mg_lock_connection(conn);; 12838 ; 12839#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12840 size_t deflated_size = 0;; 12841 Bytef *deflated = 0;; 12842 // Deflate websocket messages over 100kb; 12843 int use_deflate = dataLen > 100 * 1024 && conn->accept_gzip;; 12844 ; 12845 if (use_deflate) {; 12846 if (!conn->websocket_deflate_initialized) {; 12847 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12848 return 0;; 12849 }; 12850 ; 12851 // Deflating the message; 12852 header[0] = 0xC0u | (unsigned char)((unsigned)opcode & 0xf);; 12853 conn->websocket_deflate_state.avail_in = (uInt)dataLen;; 12854 conn->websocket_deflate_state.next_in = (unsigned char *)data;; 12855 deflated_size = (Bytef *)compressBound((uLong)dataLen);; 12856 deflated = mg_calloc(deflated_size, sizeof(Bytef));; 12857 if (deflated == NULL) {; 12858 mg_cry_internal(; 12859 conn,; 12860 ""Out of memory: Cannot allocate deflate buffer of %lu bytes"",; 12861 (unsigned long)deflated_size);; 12862 mg_unlock_connection(conn);; 12863 return -1;; 12864 }; 12865 conn->websocket_deflate_state.avail_out = (uInt)deflated_size;; 12866 conn->websocket_deflate_state.next_out = deflated;; 12867 deflate(&conn->websocket_deflate_state, conn->websocket_deflate_flush);; 12868 dataLen = deflated_size - c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:379109,Integrability,protocol,protocol,379109,"i += 4;; 12951 }; 12952 }; 12953 if (i != in_len) {; 12954 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12955 while (i < in_len) {; 12956 *(uint8_t *)(void *)(out + i) =; 12957 *(uint8_t *)(void *)(in + i); 12958 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12959 i++;; 12960 }; 12961 }; 12962}; 12963 ; 12964 ; 12965int; 12966mg_websocket_client_write(struct mg_connection *conn,; 12967 int opcode,; 12968 const char *data,; 12969 size_t dataLen); 12970{; 12971 int retval = -1;; 12972 char *masked_data =; 12973 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12974 uint32_t masking_key = 0;; 12975 ; 12976 if (masked_data == NULL) {; 12977 /* Return -1 in an error case */; 12978 mg_cry_internal(conn,; 12979 ""%s"",; 12980 ""Cannot allocate buffer for masked websocket response: ""; 12981 ""Out of memory"");; 12982 return -1;; 12983 }; 12984 ; 12985 do {; 12986 /* Get a masking key - but not 0 */; 12987 masking_key = (uint32_t)get_random();; 12988 } while (masking_key == 0);; 12989 ; 12990 mask_data(data, dataLen, masking_key, masked_data);; 12991 ; 12992 retval = mg_websocket_write_exec(; 12993 conn, opcode, masked_data, dataLen, masking_key);; 12994 mg_free(masked_data);; 12995 ; 12996 return retval;; 12997}; 12998 ; 12999 ; 13000static void; 13001handle_websocket_request(struct mg_connection *conn,; 13002 const char *path,; 13003 int is_callback_resource,; 13004 struct mg_websocket_subprotocols *subprotocols,; 13005 mg_websocket_connect_handler ws_connect_handler,; 13006 mg_websocket_ready_handler ws_ready_handler,; 13007 mg_websocket_data_handler ws_data_handler,; 13008 mg_websocket_close_handler ws_close_handler,; 13009 void *cbData); 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13012 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13013 ptrdiff_t lua_websock = 0;; 13014 ; 13015#if !defined(USE_LUA); 13016 (void)path;; 13017#endif; 13018 ; 13019 /* Step 1: Check websocket protocol version.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:380177,Integrability,protocol,protocol,380177,"/; 13021 if (!websock_key) {; 13022 /* The RFC standard version (https://tools.ietf.org/html/rfc6455); 13023 * requires a Sec-WebSocket-Key header.; 13024 */; 13025 /* It could be the hixie draft version; 13026 * (http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76).; 13027 */; 13028 const char *key1 = mg_get_header(conn, ""Sec-WebSocket-Key1"");; 13029 const char *key2 = mg_get_header(conn, ""Sec-WebSocket-Key2"");; 13030 char key3[8];; 13031 ; 13032 if ((key1 != NULL) && (key2 != NULL)) {; 13033 /* This version uses 8 byte body data in a GET request */; 13034 conn->content_len = 8;; 13035 if (8 == mg_read(conn, key3, 8)) {; 13036 /* This is the hixie version */; 13037 mg_send_http_error(conn,; 13038 426,; 13039 ""%s"",; 13040 ""Protocol upgrade to RFC 6455 required"");; 13041 return;; 13042 }; 13043 }; 13044 /* This is an unknown version */; 13045 mg_send_http_error(conn, 400, ""%s"", ""Malformed websocket request"");; 13046 return;; 13047 }; 13048 ; 13049 /* Step 1.2: Check websocket protocol version. */; 13050 /* The RFC version (https://tools.ietf.org/html/rfc6455) is 13. */; 13051 if ((version == NULL) || (strcmp(version, ""13"") != 0)) {; 13052 /* Reject wrong versions */; 13053 mg_send_http_error(conn, 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:380775,Integrability,protocol,protocols,380775," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:380918,Integrability,protocol,protocols,380918," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381235,Integrability,protocol,protocol,381235," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381246,Integrability,protocol,protocols,381246," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381302,Integrability,protocol,protocol,381302," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381342,Integrability,protocol,protocol,381342," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381393,Integrability,protocol,protocol,381393," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381434,Integrability,protocol,protocol,381434," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:381544,Integrability,protocol,protocol,381544," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382257,Integrability,protocol,protocol,382257,"; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if define",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382268,Integrability,protocol,protocols,382268,"; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if define",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382304,Integrability,protocol,protocol,382304,"; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if define",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382517,Integrability,protocol,protocol,382517,"7 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C call",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382583,Integrability,protocol,protocol,382583,"7 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C call",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382666,Integrability,protocol,protocol,382666," len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 1314",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382711,Integrability,protocol,protocols,382711," len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 1314",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382822,Integrability,protocol,protocols,382822," == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 1315",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382885,Integrability,protocol,protocols,382885,"while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 13151 else {; 13152 /* Step 3.1: Check if Lua is responsible. */; 13153 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13154",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:382940,Integrability,protocol,protocol,382940,"while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 13151 else {; 13152 /* Step 3.1: Check if Lua is responsible. */; 13153 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13154",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386375,Integrability,protocol,protocol,386375,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:386556,Integrability,protocol,protocoll,386556,"13206 }; 13207 ; 13208#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13209 /* Step 8: Close the deflate & inflate buffers */; 13210 if (conn->websocket_deflate_initialized) {; 13211 deflateEnd(&conn->websocket_deflate_state);; 13212 inflateEnd(&conn->websocket_inflate_state);; 13213 }; 13214#endif; 13215 ; 13216 /* Step 9: Call the close handler */; 13217 if (ws_close_handler) {; 13218 ws_close_handler(conn, cbData);; 13219 }; 13220}; 13221#endif /* !USE_WEBSOCKET */; 13222 ; 13223 ; 13224/* Is upgrade request:; 13225 * 0 = regular HTTP/1.0 or HTTP/1.1 request; 13226 * 1 = upgrade to websocket; 13227 * 2 = upgrade to HTTP/2; 13228 * -1 = upgrade to unknown protocol; 13229 */; 13230static int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:387385,Integrability,protocol,protocol,387385,"tic int; 13231should_switch_to_protocol(const struct mg_connection *conn); 13232{; 13233 const char *upgrade, *connection;; 13234 ; 13235 /* A websocket protocoll has the following HTTP headers:; 13236 *; 13237 * Connection: Upgrade; 13238 * Upgrade: Websocket; 13239 */; 13240 ; 13241 connection = mg_get_header(conn, ""Connection"");; 13242 if (connection == NULL) {; 13243 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; /* Websocket */; 13267 }; 13268 ; 13269 /* Upgrade to another protocol */; 13270 return -1;; 13271}; 13272 ; 13273 ; 13274static int; 13275parse_match_net(const struct vec *vec, const union usa *sa, int no_strict); 13276{; 13277 int n;; 13278 unsigned int a, b, c, d, slash;; 13279 ; 13280 if (sscanf(vec->ptr, ""%u.%u.%u.%u/%u%n"", &a, &b, &c, &d, &slash, &n); 13281 != 5) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to an; 13282 // integer value, but function will not report conversion; 13283 // errors; consider using 'strtol' instead; 13284 slash = 32;; 13285 if (sscanf(vec->ptr, ""%u.%u.%u.%u%n"", &a, &b, &c, &d, &n); 13286 != 4) { // NOLINT(cert-err34-c) 'sscanf' used to convert a stri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:387758,Integrability,protocol,protocol,387758,"43 return PROTOCOL_TYPE_HTTP1;; 13244 }; 13245 if (!mg_strcasestr(connection, ""upgrade"")) {; 13246 return PROTOCOL_TYPE_HTTP1;; 13247 }; 13248 ; 13249 upgrade = mg_get_header(conn, ""Upgrade"");; 13250 if (upgrade == NULL) {; 13251 /* ""Connection: Upgrade"" without ""Upgrade"" Header --> Error */; 13252 return -1;; 13253 }; 13254 ; 13255 /* Upgrade to ... */; 13256 if (0 != mg_strcasestr(upgrade, ""websocket"")) {; 13257 /* The headers ""Host"", ""Sec-WebSocket-Key"", ""Sec-WebSocket-Protocol"" and; 13258 * ""Sec-WebSocket-Version"" are also required.; 13259 * Don't check them here, since even an unsupported websocket protocol; 13260 * request still IS a websocket request (in contrast to a standard HTTP; 13261 * request). It will fail later in handle_websocket_request.; 13262 */; 13263 return PROTOCOL_TYPE_WEBSOCKET; /* Websocket */; 13264 }; 13265 if (0 != mg_strcasestr(upgrade, ""h2"")) {; 13266 return PROTOCOL_TYPE_HTTP2; /* Websocket */; 13267 }; 13268 ; 13269 /* Upgrade to another protocol */; 13270 return -1;; 13271}; 13272 ; 13273 ; 13274static int; 13275parse_match_net(const struct vec *vec, const union usa *sa, int no_strict); 13276{; 13277 int n;; 13278 unsigned int a, b, c, d, slash;; 13279 ; 13280 if (sscanf(vec->ptr, ""%u.%u.%u.%u/%u%n"", &a, &b, &c, &d, &slash, &n); 13281 != 5) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to an; 13282 // integer value, but function will not report conversion; 13283 // errors; consider using 'strtol' instead; 13284 slash = 32;; 13285 if (sscanf(vec->ptr, ""%u.%u.%u.%u%n"", &a, &b, &c, &d, &n); 13286 != 4) { // NOLINT(cert-err34-c) 'sscanf' used to convert a string to; 13287 // an integer value, but function will not report conversion; 13288 // errors; consider using 'strtol' instead; 13289 n = 0;; 13290 }; 13291 }; 13292 ; 13293 if ((n > 0) && ((size_t)n == vec->len)) {; 13294 if ((a < 256) && (b < 256) && (c < 256) && (d < 256) && (slash < 33)) {; 13295 /* IPv4 format */; 13296 if (sa->sa.sa_family == AF_INET) {; 13297 uint32",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:417754,Integrability,protocol,protocol,417754,"conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14215#else; 14216 handler_type = REQUEST_HANDLER;; 14217#endif /* defined(USE_WEBSOCKET) */; 14218 ; 14219 if (is_websocket_request) {; 14220 HTTP1_only;; 14221 }; 14222 ; 14223 /* 5.2. check if the request will be handled by a callback */; 14224 if (get_request_handler(conn,; 14225 handler_type,; 14226 &callback_handler,; 14227 &subprotocols,; 14228 &ws_connect_handler,; 14229 &ws_ready_handler,; 14230 &ws_data_handler,; 14231 &ws_close_handler,; 14232 NULL,; 14233 &callback_data,; 14234 &handler_info)) {; 14235 /* 5.2.1. A callback will handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:417799,Integrability,protocol,protocol,417799,"conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14215#else; 14216 handler_type = REQUEST_HANDLER;; 14217#endif /* defined(USE_WEBSOCKET) */; 14218 ; 14219 if (is_websocket_request) {; 14220 HTTP1_only;; 14221 }; 14222 ; 14223 /* 5.2. check if the request will be handled by a callback */; 14224 if (get_request_handler(conn,; 14225 handler_type,; 14226 &callback_handler,; 14227 &subprotocols,; 14228 &ws_connect_handler,; 14229 &ws_ready_handler,; 14230 &ws_data_handler,; 14231 &ws_close_handler,; 14232 NULL,; 14233 &callback_data,; 14234 &handler_info)) {; 14235 /* 5.2.1. A callback will handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:440840,Integrability,interface,interface,440840,"; 14862 if (vec->len < sizeof(so->lsa.sun.sun_path)) {; 14863 len = vec->len;; 14864 so->lsa.sun.sun_family = AF_UNIX;; 14865 memset(so->lsa.sun.sun_path, 0, sizeof(so->lsa.sun.sun_path));; 14866 memcpy(so->lsa.sun.sun_path, (char *)vec->ptr + 1, vec->len - 1);; 14867 port = 0;; 14868 *ip_version = 99;; 14869 } else {; 14870 /* String too long */; 14871 len = 0;; 14872 }; 14873#endif; 14874 ; 14875 } else {; 14876 /* Parsing failure. */; 14877 len = 0;; 14878 }; 14879 ; 14880 /* sscanf and the option splitting code ensure the following condition; 14881 * Make sure the port is valid and vector ends with the port, 's' or 'r' */; 14882 if ((len > 0) && is_valid_port(port); 14883 && (((size_t)len == vec->len) || (((size_t)len + 1) == vec->len))) {; 14884 /* Next character after the port number */; 14885 ch = ((size_t)len < vec->len) ? vec->ptr[len] : '\0';; 14886 so->is_ssl = (ch == 's');; 14887 so->ssl_redir = (ch == 'r');; 14888 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14889 return 1;; 14890 }; 14891 }; 14892 ; 14893 /* Reset ip_version to 0 if there is an error */; 14894 *ip_version = 0;; 14895 return 0;; 14896}; 14897 ; 14898 ; 14899/* Is there any SSL port in use? */; 14900static int; 14901is_ssl_port_used(const char *ports); 14902{; 14903 if (ports) {; 14904 /* There are several different allowed syntax variants:; 14905 * - ""80"" for a single port using every network interface; 14906 * - ""localhost:80"" for a single port using only localhost; 14907 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14908 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14909 * to IPv4 localhost, one to IPv6 localhost; 14910 * - ""+80"" use port 80 for IPv4 and IPv6; 14911 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14912 * for both: IPv4 and IPv4; 14913 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14914 * additionally port 8080 bound to localhost connections; 14915 *; 14916 * If we just look for 's' anywhe",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:441318,Integrability,interface,interface,441318,"en < vec->len) ? vec->ptr[len] : '\0';; 14886 so->is_ssl = (ch == 's');; 14887 so->ssl_redir = (ch == 'r');; 14888 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14889 return 1;; 14890 }; 14891 }; 14892 ; 14893 /* Reset ip_version to 0 if there is an error */; 14894 *ip_version = 0;; 14895 return 0;; 14896}; 14897 ; 14898 ; 14899/* Is there any SSL port in use? */; 14900static int; 14901is_ssl_port_used(const char *ports); 14902{; 14903 if (ports) {; 14904 /* There are several different allowed syntax variants:; 14905 * - ""80"" for a single port using every network interface; 14906 * - ""localhost:80"" for a single port using only localhost; 14907 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14908 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14909 * to IPv4 localhost, one to IPv6 localhost; 14910 * - ""+80"" use port 80 for IPv4 and IPv6; 14911 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14912 * for both: IPv4 and IPv4; 14913 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14914 * additionally port 8080 bound to localhost connections; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hos",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:442217,Integrability,interface,interface,442217,"d IPv4; 14913 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14914 * additionally port 8080 bound to localhost connections; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hostnames, so in most cases the only name will be ""localhost"".; 14934 *; 14935 * So, for now, we use this simple algorithm, that may still return; 14936 * a false positive in bizarre cases.; 14937 */; 14938 int i;; 14939 int portslen = (int)strlen(ports);; 14940 char prevIsNumber = 0;; 14941 ; 14942 for (i = 0; i < portslen; i++) {; 14943 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14944 return 1;; 14945 }; 14946 if (ports[i] >= '0' && ports[i] <= '9') {; 14947 prevIsNumber = 1;; 14948 } else {; 14949 prevIsNumber = 0;; 14950 }; 14951 }; 14952 }; 14953 return 0;; 14954}; 14955 ; 14956 ; 14957static int; 14958set_ports_option(struct mg_context *phys_ctx); 14959{; 14960 const char *list;; 14961 int on = 1;; 14962#if defined(USE_IPV6); 14963 int off = 0;; 14964#endif; 14965 struct vec vec;; 14966 struct socket so, *ptr;; 14967 ; 14968 struct mg_pollfd *pfd;; 14969 union usa usa;; 14970 socklen_t len;; 14971 int ip_version;; 14972 ; 14973 int portsTotal = 0;; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:444241,Integrability,protocol,protocol,444241,"Total = 0;; 14974 int portsOk = 0;; 14975 ; 14976 const char *opt_txt;; 14977 long opt_listen_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;; 14981 }; 14982 ; 14983 memset(&so, 0, sizeof(so));; 14984 memset(&usa, 0, sizeof(usa));; 14985 len = sizeof(usa);; 14986 list = phys_ctx->dd.config[LISTENING_PORTS];; 14987 ; 14988 while ((list = next_option(list, &vec, NULL)) != NULL) {; 14989 ; 14990 portsTotal++;; 14991 ; 14992 if (!parse_port_string(&vec, &so, &ip_version)) {; 14993 mg_cry_ctx_internal(; 14994 phys_ctx,; 14995 ""%.*s: invalid port spec (entry %i). Expecting list of: %s"",; 14996 (int)vec.len,; 14997 vec.ptr,; 14998 portsTotal,; 14999 ""[IP_ADDRESS:]PORT[s|r]"");; 15000 continue;; 15001 }; 15002 ; 15003#if !defined(NO_SSL); 15004 if (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {; 15005 ; 15006 mg_cry_ctx_internal(phys_ctx,; 15007 ""Cannot add SSL socket (entry %i)"",; 15008 portsTotal);; 15009 continue;; 15010 }; 15011#endif; 15012 /* Create socket. */; 15013 /* For a list of protocol numbers (e.g., TCP==6) see:; 15014 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15015 */; 15016 if ((so.sock =; 15017 socket(so.lsa.sa.sa_family,; 15018 SOCK_STREAM,; 15019 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15020 == INVALID_SOCKET) {; 15021 ; 15022 mg_cry_ctx_internal(phys_ctx,; 15023 ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 siz",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:444320,Integrability,protocol,protocol-numbers,444320,"n_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;; 14981 }; 14982 ; 14983 memset(&so, 0, sizeof(so));; 14984 memset(&usa, 0, sizeof(usa));; 14985 len = sizeof(usa);; 14986 list = phys_ctx->dd.config[LISTENING_PORTS];; 14987 ; 14988 while ((list = next_option(list, &vec, NULL)) != NULL) {; 14989 ; 14990 portsTotal++;; 14991 ; 14992 if (!parse_port_string(&vec, &so, &ip_version)) {; 14993 mg_cry_ctx_internal(; 14994 phys_ctx,; 14995 ""%.*s: invalid port spec (entry %i). Expecting list of: %s"",; 14996 (int)vec.len,; 14997 vec.ptr,; 14998 portsTotal,; 14999 ""[IP_ADDRESS:]PORT[s|r]"");; 15000 continue;; 15001 }; 15002 ; 15003#if !defined(NO_SSL); 15004 if (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {; 15005 ; 15006 mg_cry_ctx_internal(phys_ctx,; 15007 ""Cannot add SSL socket (entry %i)"",; 15008 portsTotal);; 15009 continue;; 15010 }; 15011#endif; 15012 /* Create socket. */; 15013 /* For a list of protocol numbers (e.g., TCP==6) see:; 15014 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15015 */; 15016 if ((so.sock =; 15017 socket(so.lsa.sa.sa_family,; 15018 SOCK_STREAM,; 15019 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15020 == INVALID_SOCKET) {; 15021 ; 15022 mg_cry_ctx_internal(phys_ctx,; 15023 ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:444337,Integrability,protocol,protocol-numbers,444337,"n_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;; 14981 }; 14982 ; 14983 memset(&so, 0, sizeof(so));; 14984 memset(&usa, 0, sizeof(usa));; 14985 len = sizeof(usa);; 14986 list = phys_ctx->dd.config[LISTENING_PORTS];; 14987 ; 14988 while ((list = next_option(list, &vec, NULL)) != NULL) {; 14989 ; 14990 portsTotal++;; 14991 ; 14992 if (!parse_port_string(&vec, &so, &ip_version)) {; 14993 mg_cry_ctx_internal(; 14994 phys_ctx,; 14995 ""%.*s: invalid port spec (entry %i). Expecting list of: %s"",; 14996 (int)vec.len,; 14997 vec.ptr,; 14998 portsTotal,; 14999 ""[IP_ADDRESS:]PORT[s|r]"");; 15000 continue;; 15001 }; 15002 ; 15003#if !defined(NO_SSL); 15004 if (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {; 15005 ; 15006 mg_cry_ctx_internal(phys_ctx,; 15007 ""Cannot add SSL socket (entry %i)"",; 15008 portsTotal);; 15009 continue;; 15010 }; 15011#endif; 15012 /* Create socket. */; 15013 /* For a list of protocol numbers (e.g., TCP==6) see:; 15014 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15015 */; 15016 if ((so.sock =; 15017 socket(so.lsa.sa.sa_family,; 15018 SOCK_STREAM,; 15019 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15020 == INVALID_SOCKET) {; 15021 ; 15022 mg_cry_ctx_internal(phys_ctx,; 15023 ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452138,Integrability,message,message,452138,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:454227,Integrability,message,message,454227,"log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?""",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455417,Integrability,message,message,455417,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:466871,Integrability,message,message,466871,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:472236,Integrability,message,message,472236,"k for ebuf */; 15947 ebuf,; 15948 ebuf_len,; 15949 ""%s: cannot load %s"",; 15950 __func__,; 15951 dll_name);; 15952 return NULL;; 15953 }; 15954 ; 15955 ok = 1;; 15956 for (fp = sw; fp->name != NULL; fp++) {; 15957#if defined(_WIN32); 15958 /* GetProcAddress() returns pointer to function */; 15959 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15960#else; 15961 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15962 * pointers to function pointers. We need to use a union to make a; 15963 * cast. */; 15964 u.p = dlsym(dll_handle, fp->name);; 15965#endif /* _WIN32 */; 15966 ; 15967 /* Set pointer (might be NULL) */; 15968 fp->ptr = u.fp;; 15969 ; 15970 if (u.fp == NULL) {; 15971 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15972 if (feature_missing) {; 15973 feature_missing[fp->required]++;; 15974 }; 15975 if (fp->required == TLS_Mandatory) {; 15976 /* Mandatory function is missing */; 15977 if (ok) {; 15978 /* This is the first missing function.; 15979 * Create a new error message. */; 15980 mg_snprintf(NULL,; 15981 &truncated,; 15982 ebuf,; 15983 ebuf_len,; 15984 ""%s: %s: cannot find %s"",; 15985 __func__,; 15986 dll_name,; 15987 fp->name);; 15988 ok = 0;; 15989 } else {; 15990 /* This is yet anothermissing function.; 15991 * Append existing error message. */; 15992 size_t cur_len = strlen(ebuf);; 15993 if (!truncated && ((ebuf_len - cur_len) > 3)) {; 15994 mg_snprintf(NULL,; 15995 &truncated,; 15996 ebuf + cur_len,; 15997 ebuf_len - cur_len - 3,; 15998 "", %s"",; 15999 fp->name);; 16000 if (truncated) {; 16001 /* If truncated, add ""..."" */; 16002 strcat(ebuf, ""..."");; 16003 }; 16004 }; 16005 }; 16006 }; 16007 }; 16008 }; 16009 ; 16010 if (!ok) {; 16011 (void)dlclose(dll_handle);; 16012 return NULL;; 16013 }; 16014 ; 16015 return dll_handle;; 16016}; 16017 ; 16018 ; 16019static void *ssllib_dll_handle; /* Store the ssl library handle. */; 16020static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16021 ; 16022#endif /* NO_SSL",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:472516,Integrability,message,message,472516,"function */; 15959 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15960#else; 15961 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15962 * pointers to function pointers. We need to use a union to make a; 15963 * cast. */; 15964 u.p = dlsym(dll_handle, fp->name);; 15965#endif /* _WIN32 */; 15966 ; 15967 /* Set pointer (might be NULL) */; 15968 fp->ptr = u.fp;; 15969 ; 15970 if (u.fp == NULL) {; 15971 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15972 if (feature_missing) {; 15973 feature_missing[fp->required]++;; 15974 }; 15975 if (fp->required == TLS_Mandatory) {; 15976 /* Mandatory function is missing */; 15977 if (ok) {; 15978 /* This is the first missing function.; 15979 * Create a new error message. */; 15980 mg_snprintf(NULL,; 15981 &truncated,; 15982 ebuf,; 15983 ebuf_len,; 15984 ""%s: %s: cannot find %s"",; 15985 __func__,; 15986 dll_name,; 15987 fp->name);; 15988 ok = 0;; 15989 } else {; 15990 /* This is yet anothermissing function.; 15991 * Append existing error message. */; 15992 size_t cur_len = strlen(ebuf);; 15993 if (!truncated && ((ebuf_len - cur_len) > 3)) {; 15994 mg_snprintf(NULL,; 15995 &truncated,; 15996 ebuf + cur_len,; 15997 ebuf_len - cur_len - 3,; 15998 "", %s"",; 15999 fp->name);; 16000 if (truncated) {; 16001 /* If truncated, add ""..."" */; 16002 strcat(ebuf, ""..."");; 16003 }; 16004 }; 16005 }; 16006 }; 16007 }; 16008 }; 16009 ; 16010 if (!ok) {; 16011 (void)dlclose(dll_handle);; 16012 return NULL;; 16013 }; 16014 ; 16015 return dll_handle;; 16016}; 16017 ; 16018 ; 16019static void *ssllib_dll_handle; /* Store the ssl library handle. */; 16020static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16021 ; 16022#endif /* NO_SSL_DL */; 16023 ; 16024 ; 16025#if defined(SSL_ALREADY_INITIALIZED); 16026static volatile ptrdiff_t cryptolib_users =; 16027 1; /* Reference counter for crypto library. */; 16028#else; 16029static volatile ptrdiff_t cryptolib_users =; 16030 0; /* Reference counter for crypto libr",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:484281,Integrability,protocol,protocol,484281,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:484730,Integrability,protocol,protocols,484730,"360alpn_select_cb(SSL *ssl,; 16361 const unsigned char **out,; 16362 unsigned char *outlen,; 16363 const unsigned char *in,; 16364 unsigned int inlen,; 16365 void *arg); 16366{; 16367 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16368 unsigned int i, j, enable_http2 = 0;; 16369 const char **alpn_proto_order = alpn_proto_order_http1;; 16370 ; 16371 struct mg_workerTLS *tls =; 16372 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16373 ; 16374 (void)ssl;; 16375 ; 16376 if (tls == NULL) {; 16377 /* Need to store protocol in Thread Local Storage */; 16378 /* If there is no Thread Local Storage, don't use ALPN */; 16379 return SSL_TLSEXT_ERR_NOACK;; 16380 }; 16381 ; 16382#if defined(USE_HTTP2); 16383 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16384 if (enable_http2) {; 16385 alpn_proto_order = alpn_proto_order_http2;; 16386 }; 16387#endif; 16388 ; 16389 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16390 /* check all accepted protocols in this order */; 16391 const char *alpn_proto = alpn_proto_order[j];; 16392 /* search input for matching protocol */; 16393 for (i = 0; i < inlen; i++) {; 16394 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16395 *out = in + i + 1;; 16396 *outlen = in[i];; 16397 tls->alpn_proto = alpn_proto;; 16398 return SSL_TLSEXT_ERR_OK;; 16399 }; 16400 }; 16401 }; 16402 ; 16403 /* Nothing found */; 16404 return SSL_TLSEXT_ERR_NOACK;; 16405}; 16406 ; 16407 ; 16408static int; 16409next_protos_advertised_cb(SSL *ssl,; 16410 const unsigned char **data,; 16411 unsigned int *len,; 16412 void *arg); 16413{; 16414 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16415 *data = (const unsigned char *)alpn_proto_list;; 16416 *len = (unsigned int)strlen((const char *)data);; 16417 ; 16418 (void)ssl;; 16419 (void)dom_ctx;; 16420 ; 16421 return SSL_TLSEXT_ERR_OK;; 16422}; 16423 ; 16424 ; 16425static int; 16426init_alpn(struct mg_context *phys_ctx, struct mg_domain_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:484846,Integrability,protocol,protocol,484846,"har *in,; 16364 unsigned int inlen,; 16365 void *arg); 16366{; 16367 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16368 unsigned int i, j, enable_http2 = 0;; 16369 const char **alpn_proto_order = alpn_proto_order_http1;; 16370 ; 16371 struct mg_workerTLS *tls =; 16372 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16373 ; 16374 (void)ssl;; 16375 ; 16376 if (tls == NULL) {; 16377 /* Need to store protocol in Thread Local Storage */; 16378 /* If there is no Thread Local Storage, don't use ALPN */; 16379 return SSL_TLSEXT_ERR_NOACK;; 16380 }; 16381 ; 16382#if defined(USE_HTTP2); 16383 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16384 if (enable_http2) {; 16385 alpn_proto_order = alpn_proto_order_http2;; 16386 }; 16387#endif; 16388 ; 16389 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16390 /* check all accepted protocols in this order */; 16391 const char *alpn_proto = alpn_proto_order[j];; 16392 /* search input for matching protocol */; 16393 for (i = 0; i < inlen; i++) {; 16394 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16395 *out = in + i + 1;; 16396 *outlen = in[i];; 16397 tls->alpn_proto = alpn_proto;; 16398 return SSL_TLSEXT_ERR_OK;; 16399 }; 16400 }; 16401 }; 16402 ; 16403 /* Nothing found */; 16404 return SSL_TLSEXT_ERR_NOACK;; 16405}; 16406 ; 16407 ; 16408static int; 16409next_protos_advertised_cb(SSL *ssl,; 16410 const unsigned char **data,; 16411 unsigned int *len,; 16412 void *arg); 16413{; 16414 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16415 *data = (const unsigned char *)alpn_proto_list;; 16416 *len = (unsigned int)strlen((const char *)data);; 16417 ; 16418 (void)ssl;; 16419 (void)dom_ctx;; 16420 ; 16421 return SSL_TLSEXT_ERR_OK;; 16422}; 16423 ; 16424 ; 16425static int; 16426init_alpn(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16427{; 16428 unsigned int alpn_len = (unsigned int)strlen((char *)alpn_proto_list);; 16429 int re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:506035,Integrability,message,message,506035," GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:518148,Integrability,protocol,protocol,518148,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:518567,Integrability,protocol,protocol,518567,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:518900,Integrability,protocol,protocolls,518900,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:518940,Integrability,protocol,protocol,518940,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519031,Integrability,protocol,protocol,519031,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519156,Integrability,protocol,protocol,519156,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519245,Integrability,protocol,protocol,519245,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519571,Integrability,protocol,protocol,519571,"s, 0, sizeof(opts));; 17434 opts.host = host;; 17435 opts.port = port;; 17436 return mg_connect_client_impl(&opts,; 17437 use_ssl,; 17438 error_buffer,; 17439 error_buffer_size);; 17440}; 17441 ; 17442 ; 17443#if defined(MG_EXPERIMENTAL_INTERFACES); 17444struct mg_connection *; 17445mg_connect_client2(const char *host,; 17446 const char *protocol,; 17447 int port,; 17448 const char *path,; 17449 struct mg_init_data *init,; 17450 struct mg_error_data *error); 17451{; 17452 int is_ssl, is_ws;; 17453 /* void *user_data = (init != NULL) ? init->user_data : NULL; -- TODO */; 17454 ; 17455 if (error != NULL) {; 17456 error->code = 0;; 17457 if (error->text_buffer_size > 0) {; 17458 *error->text = 0;; 17459 }; 17460 }; 17461 ; 17462 if ((host == NULL) || (protocol == NULL)) {; 17463 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17464 mg_snprintf(NULL,; 17465 NULL, /* No truncation check for error buffers */; 17466 error->text,; 17467 error->text_buffer_size,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interf",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519803,Integrability,interface,interfaces,519803,"e,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interfaces. */; 17504#if defined(USE_WEBSOCKET); 17505 if (is_ws) {; 17506 /* TODO: implement all options */; 17507 return mg_connect_websocket_client(; 17508 host,; 17509 port,; 17510 is_ssl,; 17511 ((error != NULL) ? error->text : NULL),; 17512 ((error != NULL) ? error->text_buffer_size : 0),; 17513 (path ? path : """"),; 17514 NULL /* TODO: origin */,; 17515 experimental_websocket_client_data_wrapper,; 17516 experimental_websocket_client_close_wrapper,; 17517 (void *)init->callbacks);; 17518 }; 17519#endif; 17520 ; 17521 /* TODO: all additional options */; 17522 struct mg_client_options opts;; 17523 memset(&opts, 0, sizeof(opts));; 17524 opts.host = host;; 17525 opts.port = port;; 17526 return mg_connect_client_impl(&opts,; 17527 is_ssl,; 17528 ((error != NULL) ? error->text : NULL),; 17529 ((error != NULL) ? error->text_buffer_size; 17530 : 0));; 17531}; 17532#endif; 17533 ; 17534 ; 17535static const struct {; 17536 const char *proto;; 17537 size_t proto_len;; 175",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:521609,Integrability,protocol,protocol,521609,"rror != NULL) ? error->text : NULL),; 17529 ((error != NULL) ? error->text_buffer_size; 17530 : 0));; 17531}; 17532#endif; 17533 ; 17534 ; 17535static const struct {; 17536 const char *proto;; 17537 size_t proto_len;; 17538 unsigned default_port;; 17539} abs_uri_protocols[] = {{""http://"", 7, 80},; 17540 {""https://"", 8, 443},; 17541 {""ws://"", 5, 80},; 17542 {""wss://"", 6, 443},; 17543 {NULL, 0, 0}};; 17544 ; 17545 ; 17546/* Check if the uri is valid.; 17547 * return 0 for invalid uri,; 17548 * return 1 for *,; 17549 * return 2 for relative uri,; 17550 * return 3 for absolute uri without port,; 17551 * return 4 for absolute uri with port */; 17552static int; 17553get_uri_type(const char *uri); 17554{; 17555 int i;; 17556 const char *hostend, *portbegin;; 17557 char *portend;; 17558 unsigned long port;; 17559 ; 17560 /* According to the HTTP standard; 17561 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2; 17562 * URI can be an asterisk (*) or should start with slash (relative uri),; 17563 * or it should start with the protocol (absolute uri). */; 17564 if ((uri[0] == '*') && (uri[1] == '\0')) {; 17565 /* asterisk */; 17566 return 1;; 17567 }; 17568 ; 17569 /* Valid URIs according to RFC 3986; 17570 * (https://www.ietf.org/rfc/rfc3986.txt); 17571 * must only contain reserved characters :/?#[]@!$&'()*+,;=; 17572 * and unreserved characters A-Z a-z 0-9 and -._~; 17573 * and % encoded symbols.; 17574 */; 17575 for (i = 0; uri[i] != 0; i++) {; 17576 if (uri[i] < 33) {; 17577 /* control characters and spaces are invalid */; 17578 return 0;; 17579 }; 17580 /* Allow everything else here (See #894) */; 17581 }; 17582 ; 17583 /* A relative uri starts with a / character */; 17584 if (uri[0] == '/') {; 17585 /* relative uri */; 17586 return 2;; 17587 }; 17588 ; 17589 /* It could be an absolute uri: */; 17590 /* This function only checks if the uri is valid, not if it is; 17591 * addressing the current server. So civetweb can also be used; 17592 * as a proxy server.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:524748,Integrability,protocol,protocol,524748,"egin;; 17633 char *portend;; 17634 ; 17635 auth_domain_check_enabled =; 17636 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17637 ; 17638 /* DNS is case insensitive, so use case insensitive string compare here; 17639 */; 17640 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17641 if (mg_strncasecmp(uri,; 17642 abs_uri_protocols[i].proto,; 17643 abs_uri_protocols[i].proto_len); 17644 == 0) {; 17645 ; 17646 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17647 hostend = strchr(hostbegin, '/');; 17648 if (!hostend) {; 17649 return 0;; 17650 }; 17651 portbegin = strchr(hostbegin, ':');; 17652 if ((!portbegin) || (portbegin > hostend)) {; 17653 port = abs_uri_protocols[i].default_port;; 17654 request_domain_len = (size_t)(hostend - hostbegin);; 17655 } else {; 17656 port = strtoul(portbegin + 1, &portend, 10);; 17657 if ((portend != hostend) || (port <= 0); 17658 || !is_valid_port(port)) {; 17659 return 0;; 17660 }; 17661 request_domain_len = (size_t)(portbegin - hostbegin);; 17662 }; 17663 /* protocol found, port set */; 17664 break;; 17665 }; 17666 }; 17667 ; 17668 if (!port) {; 17669 /* port remains 0 if the protocol is not found */; 17670 return 0;; 17671 }; 17672 ; 17673 /* Check if the request is directed to a different server. */; 17674 /* First check if the port is the same. */; 17675 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17676 /* Request is directed to a different port */; 17677 return 0;; 17678 }; 17679 ; 17680 /* Finally check if the server corresponds to the authentication; 17681 * domain of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:524868,Integrability,protocol,protocol,524868,"egin;; 17633 char *portend;; 17634 ; 17635 auth_domain_check_enabled =; 17636 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17637 ; 17638 /* DNS is case insensitive, so use case insensitive string compare here; 17639 */; 17640 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17641 if (mg_strncasecmp(uri,; 17642 abs_uri_protocols[i].proto,; 17643 abs_uri_protocols[i].proto_len); 17644 == 0) {; 17645 ; 17646 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17647 hostend = strchr(hostbegin, '/');; 17648 if (!hostend) {; 17649 return 0;; 17650 }; 17651 portbegin = strchr(hostbegin, ':');; 17652 if ((!portbegin) || (portbegin > hostend)) {; 17653 port = abs_uri_protocols[i].default_port;; 17654 request_domain_len = (size_t)(hostend - hostbegin);; 17655 } else {; 17656 port = strtoul(portbegin + 1, &portend, 10);; 17657 if ((portend != hostend) || (port <= 0); 17658 || !is_valid_port(port)) {; 17659 return 0;; 17660 }; 17661 request_domain_len = (size_t)(portbegin - hostbegin);; 17662 }; 17663 /* protocol found, port set */; 17664 break;; 17665 }; 17666 }; 17667 ; 17668 if (!port) {; 17669 /* port remains 0 if the protocol is not found */; 17670 return 0;; 17671 }; 17672 ; 17673 /* Check if the request is directed to a different server. */; 17674 /* First check if the port is the same. */; 17675 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17676 /* Request is directed to a different port */; 17677 return 0;; 17678 }; 17679 ; 17680 /* Finally check if the server corresponds to the authentication; 17681 * domain of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:527920,Integrability,message,message,527920,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:528468,Integrability,message,message,528468,"time(CLOCK_MONOTONIC, &(conn->req_time));; 17750 ; 17751 conn->request_len =; 17752 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17753 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17754 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17755 mg_snprintf(conn,; 17756 NULL, /* No truncation check for ebuf */; 17757 ebuf,; 17758 ebuf_len,; 17759 ""%s"",; 17760 ""Invalid message size"");; 17761 *err = 500;; 17762 return 0;; 17763 }; 17764 ; 17765 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17766 mg_snprintf(conn,; 17767 NULL, /* No truncation check for ebuf */; 17768 ebuf,; 17769 ebuf_len,; 17770 ""%s"",; 17771 ""Message too large"");; 17772 *err = 413;; 17773 return 0;; 17774 }; 17775 ; 17776 if (conn->request_len <= 0) {; 17777 if (conn->data_len > 0) {; 17778 mg_snprintf(conn,; 17779 NULL, /* No truncation check for ebuf */; 17780 ebuf,; 17781 ebuf_len,; 17782 ""%s"",; 17783 ""Malformed message"");; 17784 *err = 400;; 17785 } else {; 17786 /* Server did not recv anything -> just close the connection */; 17787 conn->must_close = 1;; 17788 mg_snprintf(conn,; 17789 NULL, /* No truncation check for ebuf */; 17790 ebuf,; 17791 ebuf_len,; 17792 ""%s"",; 17793 ""No data received"");; 17794 *err = 0;; 17795 }; 17796 return 0;; 17797 }; 17798 return 1;; 17799}; 17800 ; 17801 ; 17802static int; 17803get_request(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17804{; 17805 const char *cl;; 17806 ; 17807 conn->connection_type =; 17808 CONNECTION_TYPE_REQUEST; /* request (valid of not) */; 17809 ; 17810 if (!get_message(conn, ebuf, ebuf_len, err)) {; 17811 return 0;; 17812 }; 17813 ; 17814 if (parse_http_request(conn->buf, conn->buf_size, &conn->request_info); 17815 <= 0) {; 17816 mg_snprintf(conn,; 17817 NULL, /* No truncation check for ebuf */; 17818 ebuf,; 17819 ebuf_len,; 17820 ""%s"",; 17821 ""Bad request"");; 17822 *err = 400;; 17823 return 0;; 17824 }; 17825 ; 17826 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:539942,Integrability,message,message,539942," *user_data); 18165{; 18166 struct mg_connection *conn = NULL;; 18167 ; 18168#if defined(USE_WEBSOCKET); 18169 struct websocket_client_thread_data *thread_data;; 18170 static const char *magic = ""x3JJHMbDL1EzLkh9GBhXDw=="";; 18171 ; 18172 const char *host = client_options->host;; 18173 int i;; 18174 ; 18175#if defined(__clang__); 18176#pragma clang diagnostic push; 18177#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 18178#endif; 18179 ; 18180 /* Establish the client connection and request upgrade */; 18181 conn = mg_connect_client_impl(client_options,; 18182 use_ssl,; 18183 error_buffer,; 18184 error_buffer_size);; 18185 ; 18186 /* Connection object will be null if something goes wrong */; 18187 if (conn == NULL) {; 18188 /* error_buffer should be already filled ... */; 18189 if (!error_buffer[0]) {; 18190 /* ... if not add an error message */; 18191 mg_snprintf(conn,; 18192 NULL, /* No truncation check for ebuf */; 18193 error_buffer,; 18194 error_buffer_size,; 18195 ""Unexpected error"");; 18196 }; 18197 return NULL;; 18198 }; 18199 ; 18200 if (origin != NULL) {; 18201 if (extensions != NULL) {; 18202 i = mg_printf(conn,; 18203 ""GET %s HTTP/1.1\r\n""; 18204 ""Host: %s\r\n""; 18205 ""Upgrade: websocket\r\n""; 18206 ""Connection: Upgrade\r\n""; 18207 ""Sec-WebSocket-Key: %s\r\n""; 18208 ""Sec-WebSocket-Version: 13\r\n""; 18209 ""Sec-WebSocket-Extensions: %s\r\n""; 18210 ""Origin: %s\r\n""; 18211 ""\r\n"",; 18212 path,; 18213 host,; 18214 magic,; 18215 extensions,; 18216 origin);; 18217 } else {; 18218 i = mg_printf(conn,; 18219 ""GET %s HTTP/1.1\r\n""; 18220 ""Host: %s\r\n""; 18221 ""Upgrade: websocket\r\n""; 18222 ""Connection: Upgrade\r\n""; 18223 ""Sec-WebSocket-Key: %s\r\n""; 18224 ""Sec-WebSocket-Version: 13\r\n""; 18225 ""Origin: %s\r\n""; 18226 ""\r\n"",; 18227 path,; 18228 host,; 18229 magic,; 18230 origin);; 18231 }; 18232 } else {; 18233 ; 18234 if (extensions != NULL) {; 18235 i = mg_printf(conn,; 18236 ""GET %s HTTP/1.1\r\n""; 18237 ""Host: %s\r\n""; 18238 ""Upgrade: websocket\r\n""; 182",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:542401,Integrability,protocol,protocol,542401,"Upgrade: websocket\r\n""; 18253 ""Connection: Upgrade\r\n""; 18254 ""Sec-WebSocket-Key: %s\r\n""; 18255 ""Sec-WebSocket-Version: 13\r\n""; 18256 ""\r\n"",; 18257 path,; 18258 host,; 18259 magic);; 18260 }; 18261 }; 18262 if (i <= 0) {; 18263 mg_snprintf(conn,; 18264 NULL, /* No truncation check for ebuf */; 18265 error_buffer,; 18266 error_buffer_size,; 18267 ""%s"",; 18268 ""Error sending request"");; 18269 mg_close_connection(conn);; 18270 return NULL;; 18271 }; 18272 ; 18273 conn->data_len = 0;; 18274 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18275 mg_close_connection(conn);; 18276 return NULL;; 18277 }; 18278 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18279 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18280 ; 18281#if defined(__clang__); 18282#pragma clang diagnostic pop; 18283#endif; 18284 ; 18285 if (conn->response_info.status_code != 101) {; 18286 /* We sent an ""upgrade"" request. For a correct websocket; 18287 * protocol handshake, we expect a ""101 Continue"" response.; 18288 * Otherwise it is a protocol violation. Maybe the HTTP; 18289 * Server does not know websockets. */; 18290 if (!*error_buffer) {; 18291 /* set an error, if not yet set */; 18292 mg_snprintf(conn,; 18293 NULL, /* No truncation check for ebuf */; 18294 error_buffer,; 18295 error_buffer_size,; 18296 ""Unexpected server reply"");; 18297 }; 18298 ; 18299 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18300 mg_close_connection(conn);; 18301 return NULL;; 18302 }; 18303 ; 18304 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18305 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18306 if (!thread_data) {; 18307 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18308 mg_close_connection(conn);; 18309 return NULL;; 18310 }; 18311 ; 18312 thread_data->conn = conn;; 18313 thread_data->data_handler = data_func;; 18314 thread_data->close_handler = close_func;; 18315 thread_data->callback_data = us",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:542485,Integrability,protocol,protocol,542485,"-WebSocket-Key: %s\r\n""; 18255 ""Sec-WebSocket-Version: 13\r\n""; 18256 ""\r\n"",; 18257 path,; 18258 host,; 18259 magic);; 18260 }; 18261 }; 18262 if (i <= 0) {; 18263 mg_snprintf(conn,; 18264 NULL, /* No truncation check for ebuf */; 18265 error_buffer,; 18266 error_buffer_size,; 18267 ""%s"",; 18268 ""Error sending request"");; 18269 mg_close_connection(conn);; 18270 return NULL;; 18271 }; 18272 ; 18273 conn->data_len = 0;; 18274 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18275 mg_close_connection(conn);; 18276 return NULL;; 18277 }; 18278 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18279 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18280 ; 18281#if defined(__clang__); 18282#pragma clang diagnostic pop; 18283#endif; 18284 ; 18285 if (conn->response_info.status_code != 101) {; 18286 /* We sent an ""upgrade"" request. For a correct websocket; 18287 * protocol handshake, we expect a ""101 Continue"" response.; 18288 * Otherwise it is a protocol violation. Maybe the HTTP; 18289 * Server does not know websockets. */; 18290 if (!*error_buffer) {; 18291 /* set an error, if not yet set */; 18292 mg_snprintf(conn,; 18293 NULL, /* No truncation check for ebuf */; 18294 error_buffer,; 18295 error_buffer_size,; 18296 ""Unexpected server reply"");; 18297 }; 18298 ; 18299 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18300 mg_close_connection(conn);; 18301 return NULL;; 18302 }; 18303 ; 18304 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18305 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18306 if (!thread_data) {; 18307 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18308 mg_close_connection(conn);; 18309 return NULL;; 18310 }; 18311 ; 18312 thread_data->conn = conn;; 18313 thread_data->data_handler = data_func;; 18314 thread_data->close_handler = close_func;; 18315 thread_data->callback_data = user_data;; 18316 ; 18317 conn->phys_ctx->worker_threadids =; 18318 (pt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:550358,Integrability,message,message,550358," char ebuf[100];; 18522 const char *hostend;; 18523 int reqerr, uri_type;; 18524 ; 18525#if defined(USE_SERVER_STATS); 18526 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18527 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18528 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18529#endif; 18530 ; 18531 DEBUG_TRACE(""Start processing connection from %s"",; 18532 conn->request_info.remote_addr);; 18533 ; 18534 /* Loop over multiple requests sent using the same connection; 18535 * (while ""keep alive""). */; 18536 do {; 18537 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18538 conn->handled_requests + 1);; 18539 ; 18540#if defined(USE_SERVER_STATS); 18541 conn->conn_state = 3; /* ready */; 18542#endif; 18543 ; 18544 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18545 /* The request sent by the client could not be understood by; 18546 * the server, or it was incomplete or a timeout. Send an; 18547 * error message and close the connection. */; 18548 if (reqerr > 0) {; 18549 DEBUG_ASSERT(ebuf[0] != '\0');; 18550 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18551 }; 18552 ; 18553 } else if (strcmp(ri->http_version, ""1.0""); 18554 && strcmp(ri->http_version, ""1.1"")) {; 18555 /* HTTP/2 is not allowed here */; 18556 mg_snprintf(conn,; 18557 NULL, /* No truncation check for ebuf */; 18558 ebuf,; 18559 sizeof(ebuf),; 18560 ""Bad HTTP version: [%s]"",; 18561 ri->http_version);; 18562 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18563 }; 18564 ; 18565 if (ebuf[0] == '\0') {; 18566 uri_type = get_uri_type(conn->request_info.request_uri);; 18567 switch (uri_type) {; 18568 case 1:; 18569 /* Asterisk */; 18570 conn->request_info.local_uri_raw = 0;; 18571 /* TODO: Deal with '*'. */; 18572 break;; 18573 case 2:; 18574 /* relative uri */; 18575 conn->request_info.local_uri_raw =; 18576 conn->request_info.request_uri;; 18577 break;; 18578 case 3:; 18579 case 4:; 18580 /* absolute uri (with/without port) */; 185",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:552095,Integrability,protocol,protocol,552095,"eal with '*'. */; 18572 break;; 18573 case 2:; 18574 /* relative uri */; 18575 conn->request_info.local_uri_raw =; 18576 conn->request_info.request_uri;; 18577 break;; 18578 case 3:; 18579 case 4:; 18580 /* absolute uri (with/without port) */; 18581 hostend = get_rel_url_at_current_server(; 18582 conn->request_info.request_uri, conn);; 18583 if (hostend) {; 18584 conn->request_info.local_uri_raw = hostend;; 18585 } else {; 18586 conn->request_info.local_uri_raw = NULL;; 18587 }; 18588 break;; 18589 default:; 18590 mg_snprintf(conn,; 18591 NULL, /* No truncation check for ebuf */; 18592 ebuf,; 18593 sizeof(ebuf),; 18594 ""Invalid URI"");; 18595 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18596 conn->request_info.local_uri_raw = NULL;; 18597 break;; 18598 }; 18599 conn->request_info.local_uri =; 18600 (char *)conn->request_info.local_uri_raw;; 18601 }; 18602 ; 18603 if (ebuf[0] != '\0') {; 18604 conn->protocol_type = -1;; 18605 ; 18606 } else {; 18607 /* HTTP/1 allows protocol upgrade */; 18608 conn->protocol_type = should_switch_to_protocol(conn);; 18609 ; 18610 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18611 /* This will occur, if a HTTP/1.1 request should be upgraded; 18612 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18613 * Since most (all?) major browsers only support HTTP/2 using; 18614 * ALPN, this is hard to test and very low priority.; 18615 * Deactivate it (at least for now).; 18616 */; 18617 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18618 }; 18619 }; 18620 ; 18621 DEBUG_TRACE(""http: %s, error: %s"",; 18622 (ri->http_version ? ri->http_version : ""none""),; 18623 (ebuf[0] ? ebuf : ""none""));; 18624 ; 18625 if (ebuf[0] == '\0') {; 18626 if (conn->request_info.local_uri) {; 18627 ; 18628 /* handle request to local server */; 18629 handle_request_stat_log(conn);; 18630 ; 18631 } else {; 18632 /* TODO: handle non-local request (PROXY) */; 18633 conn->must_close = 1;; 18634 }; 18635 } else {; 18636 conn->must_close = 1;; 18637 }; 18638 ; 18639 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:563059,Integrability,protocol,protocol,563059,"ation that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, thread_index)) {; 18925 ; 18926 /* New connections must start with new protocol negotiation */; 18927 tls.alpn_proto = NULL;; 18928 ; 18929#if defined(USE_SERVER_STATS); 18930 conn->conn_close_time = 0;; 18931#endif; 18932 conn->conn_birth_time = time(NULL);; 18933 ; 18934 /* Fill in IP, port info early so even if SSL setup below fails,; 18935 * error handler would have the corresponding info.; 18936 * Thanks to Johannes Winkelmann for the patch.; 18937 */; 18938 conn->request_info.remote_port =; 18939 ntohs(USA_IN_PORT_UNSAFE(&conn->client.rsa));; 18940 ; 18941 conn->request_info.server_port =; 18942 ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18943 ; 18944 sockaddr_to_string(conn->request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:586332,Integrability,synchroniz,synchronization,586332,"9640 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19641 mg_snprintf(NULL,; 19642 NULL, /* No truncation check for error buffers */; 19643 error->text,; 19644 error->text_buffer_size,; 19645 ""%s"",; 19646 ""Library uninitialized"");; 19647 }; 19648 return NULL;; 19649 }; 19650 ; 19651 /* Allocate context and initialize reasonable general case defaults. */; 19652 if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {; 19653 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19654 mg_snprintf(NULL,; 19655 NULL, /* No truncation check for error buffers */; 19656 error->text,; 19657 error->text_buffer_size,; 19658 ""%s"",; 19659 ""Out of memory"");; 19660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization obje",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587306,Integrability,synchroniz,synchronization,587306,"9660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callba",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596534,Integrability,depend,depending,596534,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:632799,Integrability,protocol,protocol,632799,"= &(conn->request_info);; 21173 ; 21174#if defined(USE_SERVER_STATS); 21175 state = conn->conn_state;; 21176 ; 21177 /* State as string */; 21178 switch (state) {; 21179 case 0:; 21180 state_str = ""undefined"";; 21181 break;; 21182 case 1:; 21183 state_str = ""not used"";; 21184 break;; 21185 case 2:; 21186 state_str = ""init"";; 21187 break;; 21188 case 3:; 21189 state_str = ""ready"";; 21190 break;; 21191 case 4:; 21192 state_str = ""processing"";; 21193 break;; 21194 case 5:; 21195 state_str = ""processed"";; 21196 break;; 21197 case 6:; 21198 state_str = ""to close"";; 21199 break;; 21200 case 7:; 21201 state_str = ""closing"";; 21202 break;; 21203 case 8:; 21204 state_str = ""closed"";; 21205 break;; 21206 case 9:; 21207 state_str = ""done"";; 21208 break;; 21209 }; 21210#endif; 21211 ; 21212 /* Connection info */; 21213 if ((state >= 3) && (state < 9)) {; 21214 mg_snprintf(NULL,; 21215 NULL,; 21216 block,; 21217 sizeof(block),; 21218 ""%s\""connection\"" : {%s""; 21219 ""\""remote\"" : {%s""; 21220 ""\""protocol\"" : \""%s\"",%s""; 21221 ""\""addr\"" : \""%s\"",%s""; 21222 ""\""port\"" : %u%s""; 21223 ""},%s""; 21224 ""\""handled_requests\"" : %u%s""; 21225 ""}"",; 21226 eol,; 21227 eol,; 21228 eol,; 21229 get_proto_name(conn),; 21230 eol,; 21231 ri->remote_addr,; 21232 eol,; 21233 ri->remote_port,; 21234 eol,; 21235 eol,; 21236 conn->handled_requests,; 21237 eol);; 21238 connection_info_length += mg_str_append(&buffer, end, block);; 21239 }; 21240 ; 21241 /* Request info */; 21242 if ((state >= 4) && (state < 6)) {; 21243 mg_snprintf(NULL,; 21244 NULL,; 21245 block,; 21246 sizeof(block),; 21247 ""%s%s\""request_info\"" : {%s""; 21248 ""\""method\"" : \""%s\"",%s""; 21249 ""\""uri\"" : \""%s\"",%s""; 21250 ""\""query\"" : %s%s%s%s""; 21251 ""}"",; 21252 (connection_info_length > 1 ? "","" : """"),; 21253 eol,; 21254 eol,; 21255 ri->request_method,; 21256 eol,; 21257 ri->request_uri,; 21258 eol,; 21259 ri->query_string ? ""\"""" : """",; 21260 ri->query_string ? ri->query_string : ""null"",; 21261 ri->query_string ? ""\"""" : """",; 21262 eol);; 212",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:700581,Integrability,message,message,700581,"sedsize_t bufusedDefinition civetweb.c:10961; cgi_environment::varusedsize_t varusedDefinition civetweb.c:10965; cgi_environment::connstruct mg_connection * connDefinition civetweb.c:10957; cgi_environment::buflensize_t buflenDefinition civetweb.c:10960; cgi_environment::varlensize_t varlenDefinition civetweb.c:10964; deDefinition civetweb.c:2541; de::file_namechar * file_nameDefinition civetweb.c:2543; de::connstruct mg_connection * connDefinition civetweb.c:2542; de::filestruct mg_file_stat fileDefinition civetweb.c:2544; dir_scan_dataDefinition civetweb.c:9577; dir_scan_data::num_entriessize_t num_entriesDefinition civetweb.c:9579; dir_scan_data::entriesstruct de * entriesDefinition civetweb.c:9578; dir_scan_data::arr_sizesize_t arr_sizeDefinition civetweb.c:9580; md5_state_sDefinition md5.inl:54; mg_callbacksDefinition civetweb.h:218; mg_callbacks::init_sslint(* init_ssl)(void *ssl_ctx, void *user_data)Definition civetweb.h:254; mg_callbacks::log_messageint(* log_message)(const struct mg_connection *, const char *message)Definition civetweb.h:240; mg_callbacks::init_threadvoid *(* init_thread)(const struct mg_context *ctx, int thread_type)Definition civetweb.h:393; mg_callbacks::end_requestvoid(* end_request)(const struct mg_connection *, int reply_status_code)Definition civetweb.h:236; mg_callbacks::init_connectionint(* init_connection)(const struct mg_connection *conn, void **conn_data)Definition civetweb.h:417; mg_callbacks::connection_closevoid(* connection_close)(const struct mg_connection *)Definition civetweb.h:320; mg_callbacks::http_errorint(* http_error)(struct mg_connection *conn, int status, const char *errmsg)Definition civetweb.h:359; mg_callbacks::exit_contextvoid(* exit_context)(const struct mg_context *ctx)Definition civetweb.h:372; mg_callbacks::init_ssl_domainint(* init_ssl_domain)(const char *server_domain, void *ssl_ctx, void *user_data)Definition civetweb.h:265; mg_callbacks::external_ssl_ctxint(* external_ssl_ctx)(void **ssl_ctx, void *user",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:701904,Integrability,message,message,701904,"::init_connectionint(* init_connection)(const struct mg_connection *conn, void **conn_data)Definition civetweb.h:417; mg_callbacks::connection_closevoid(* connection_close)(const struct mg_connection *)Definition civetweb.h:320; mg_callbacks::http_errorint(* http_error)(struct mg_connection *conn, int status, const char *errmsg)Definition civetweb.h:359; mg_callbacks::exit_contextvoid(* exit_context)(const struct mg_context *ctx)Definition civetweb.h:372; mg_callbacks::init_ssl_domainint(* init_ssl_domain)(const char *server_domain, void *ssl_ctx, void *user_data)Definition civetweb.h:265; mg_callbacks::external_ssl_ctxint(* external_ssl_ctx)(void **ssl_ctx, void *user_data)Definition civetweb.h:278; mg_callbacks::exit_threadvoid(* exit_thread)(const struct mg_context *ctx, int thread_type, void *thread_pointer)Definition civetweb.h:400; mg_callbacks::begin_requestint(* begin_request)(struct mg_connection *)Definition civetweb.h:233; mg_callbacks::log_accessint(* log_access)(const struct mg_connection *, const char *message)Definition civetweb.h:244; mg_callbacks::init_contextvoid(* init_context)(const struct mg_context *ctx)Definition civetweb.h:367; mg_callbacks::connection_closedvoid(* connection_closed)(const struct mg_connection *)Definition civetweb.h:330; mg_callbacks::external_ssl_ctx_domainint(* external_ssl_ctx_domain)(const char *server_domain, void **ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:713200,Integrability,protocol,protocolint,713200,tion civetweb.h:152; mg_request_info::acceptedWebSocketSubprotocolconst char * acceptedWebSocketSubprotocolDefinition civetweb.h:184; mg_request_info::remote_userconst char * remote_userDefinition civetweb.h:164; mg_request_info::remote_portint remote_portDefinition civetweb.h:170; mg_request_info::is_sslint is_sslDefinition civetweb.h:173; mg_request_info::num_headersint num_headersDefinition civetweb.h:178; mg_response_infoDefinition civetweb.h:191; mg_response_info::http_headersstruct mg_header http_headers[(64)]Definition civetweb.h:200; mg_response_info::content_lengthlong long content_lengthDefinition civetweb.h:196; mg_response_info::http_versionconst char * http_versionDefinition civetweb.h:194; mg_response_info::num_headersint num_headersDefinition civetweb.h:199; mg_response_info::status_codeint status_codeDefinition civetweb.h:192; mg_response_info::status_textconst char * status_textDefinition civetweb.h:193; mg_server_portDefinition civetweb.h:712; mg_server_port::protocolint protocolDefinition civetweb.h:713; mg_server_port::is_redirectint is_redirectDefinition civetweb.h:716; mg_server_port::portint portDefinition civetweb.h:714; mg_server_port::is_sslint is_sslDefinition civetweb.h:715; mg_websocket_subprotocolsDefinition civetweb.h:562; mg_websocket_subprotocols::subprotocolsconst char ** subprotocolsDefinition civetweb.h:564; mg_websocket_subprotocols::nb_subprotocolsint nb_subprotocolsDefinition civetweb.h:563; mg_workerTLSDefinition civetweb.c:1579; mg_workerTLS::user_ptrvoid * user_ptrDefinition civetweb.c:1582; mg_workerTLS::alpn_protoconst char * alpn_protoDefinition civetweb.c:1587; mg_workerTLS::is_masterint is_masterDefinition civetweb.c:1580; mg_workerTLS::thread_idxunsigned long thread_idxDefinition civetweb.c:1581; passwdDefinition TWinNTSystem.h:38; passwd::pw_gidint pw_gidDefinition TWinNTSystem.h:42; passwd::pw_uidint pw_uidDefinition TWinNTSystem.h:41; process_control_dataDefinition civetweb.c:11238; process_control_data::referencespt,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:713212,Integrability,protocol,protocolDefinition,713212,tion civetweb.h:152; mg_request_info::acceptedWebSocketSubprotocolconst char * acceptedWebSocketSubprotocolDefinition civetweb.h:184; mg_request_info::remote_userconst char * remote_userDefinition civetweb.h:164; mg_request_info::remote_portint remote_portDefinition civetweb.h:170; mg_request_info::is_sslint is_sslDefinition civetweb.h:173; mg_request_info::num_headersint num_headersDefinition civetweb.h:178; mg_response_infoDefinition civetweb.h:191; mg_response_info::http_headersstruct mg_header http_headers[(64)]Definition civetweb.h:200; mg_response_info::content_lengthlong long content_lengthDefinition civetweb.h:196; mg_response_info::http_versionconst char * http_versionDefinition civetweb.h:194; mg_response_info::num_headersint num_headersDefinition civetweb.h:199; mg_response_info::status_codeint status_codeDefinition civetweb.h:192; mg_response_info::status_textconst char * status_textDefinition civetweb.h:193; mg_server_portDefinition civetweb.h:712; mg_server_port::protocolint protocolDefinition civetweb.h:713; mg_server_port::is_redirectint is_redirectDefinition civetweb.h:716; mg_server_port::portint portDefinition civetweb.h:714; mg_server_port::is_sslint is_sslDefinition civetweb.h:715; mg_websocket_subprotocolsDefinition civetweb.h:562; mg_websocket_subprotocols::subprotocolsconst char ** subprotocolsDefinition civetweb.h:564; mg_websocket_subprotocols::nb_subprotocolsint nb_subprotocolsDefinition civetweb.h:563; mg_workerTLSDefinition civetweb.c:1579; mg_workerTLS::user_ptrvoid * user_ptrDefinition civetweb.c:1582; mg_workerTLS::alpn_protoconst char * alpn_protoDefinition civetweb.c:1587; mg_workerTLS::is_masterint is_masterDefinition civetweb.c:1580; mg_workerTLS::thread_idxunsigned long thread_idxDefinition civetweb.c:1581; passwdDefinition TWinNTSystem.h:38; passwd::pw_gidint pw_gidDefinition TWinNTSystem.h:42; passwd::pw_uidint pw_uidDefinition TWinNTSystem.h:41; process_control_dataDefinition civetweb.c:11238; process_control_data::referencespt,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5691,Modifiability,config,configuration,5691,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:12088,Modifiability,config,configuration,12088,"with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang diagnostic ignored ""-Wno-error=date-time""; 346 * #pragma clang diagnostic ignored ""-Wdate-time""; 347 * So we just have to disable ALL warnings for some lines; 348 * of code.; 349 * This seems to be a known GCC bug, not resolved since 2012:; 350 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431; 351 */; 352#endif; 353 ; 354 ; 355#if defined(__MACH__) /* Apple OSX section */; 356 ; 357#if defi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:14418,Modifiability,variab,variable,14418,"-macro""; 362#endif; 363#endif; 364 ; 365#ifndef CLOCK_MONOTONIC; 366#define CLOCK_MONOTONIC (1); 367#endif; 368#ifndef CLOCK_REALTIME; 369#define CLOCK_REALTIME (2); 370#endif; 371 ; 372#include <mach/clock.h>; 373#include <mach/mach.h>; 374#include <mach/mach_time.h>; 375#include <sys/errno.h>; 376#include <sys/time.h>; 377 ; 378/* clock_gettime is not implemented on OSX prior to 10.12 */; 379static int; 380_civet_clock_gettime(int clk_id, struct timespec *t); 381{; 382 memset(t, 0, sizeof(*t));; 383 if (clk_id == CLOCK_REALTIME) {; 384 struct timeval now;; 385 int rv = gettimeofday(&now, NULL);; 386 if (rv) {; 387 return rv;; 388 }; 389 t->tv_sec = now.tv_sec;; 390 t->tv_nsec = now.tv_usec * 1000;; 391 return 0;; 392 ; 393 } else if (clk_id == CLOCK_MONOTONIC) {; 394 static uint64_t clock_start_time = 0;; 395 static mach_timebase_info_data_t timebase_ifo = {0, 0};; 396 ; 397 uint64_t now = mach_absolute_time();; 398 ; 399 if (clock_start_time == 0) {; 400 kern_return_t mach_status = mach_timebase_info(&timebase_ifo);; 401 DEBUG_ASSERT(mach_status == KERN_SUCCESS);; 402 ; 403 /* appease ""unused variable"" warning for release builds */; 404 (void)mach_status;; 405 ; 406 clock_start_time = now;; 407 }; 408 ; 409 now = (uint64_t)((double)(now - clock_start_time); 410 * (double)timebase_ifo.numer; 411 / (double)timebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16026,Modifiability,config,configuration,16026,"L at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16177,Modifiability,config,configured,16177,"L at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16271,Modifiability,config,configuration,16271," 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16542,Modifiability,config,configuration,16542,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:17166,Modifiability,variab,variables,17166," 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:17398,Modifiability,variab,variables,17398,"; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_static_assert(MAX_WORKER_THREADS >= 1,; 519 ""worker threads must be a positive number"");; 520 ; 521mg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,; 522 ""size_t data type size check"");",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:17492,Modifiability,variab,variables,17492,"oll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 495#if !defined(MG_BUF_LEN) /* in bytes */; 496#define MG_BUF_LEN (1024 * 8); 497#endif; 498 ; 499 ; 500/********************************************************************/; 501 ; 502/* Helper makros */; 503#if !defined(ARRAY_SIZE); 504#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0])); 505#endif; 506 ; 507#include <stdint.h>; 508 ; 509/* Standard defines */; 510#if !defined(INT64_MAX); 511#define INT64_MAX (9223372036854775807); 512#endif; 513 ; 514#define SHUTDOWN_RD (0); 515#define SHUTDOWN_WR (1); 516#define SHUTDOWN_BOTH (2); 517 ; 518mg_static_assert(MAX_WORKER_THREADS >= 1,; 519 ""worker threads must be a positive number"");; 520 ; 521mg_static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8,; 522 ""size_t data type size check"");; 523 ; 524 ; 525#if defined(_WIN32) /* WINDOWS include block */; 526#include <malloc.h> /* *alloc( */; 527#include <stdlib.h> /* *alloc( */; 528#include <time.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:61420,Modifiability,config,config,61420,"defined(USE_TIMERS); 1964 CGI2_TIMEOUT,; 1965#endif; 1966 ; 1967#if defined(USE_4_CGI); 1968 CGI3_EXTENSIONS,; 1969 CGI3_ENVIRONMENT,; 1970 CGI3_INTERPRETER,; 1971 CGI3_INTERPRETER_ARGS,; 1972#if defined(USE_TIMERS); 1973 CGI3_TIMEOUT,; 1974#endif; 1975 ; 1976 CGI4_EXTENSIONS,; 1977 CGI4_ENVIRONMENT,; 1978 CGI4_INTERPRETER,; 1979 CGI4_INTERPRETER_ARGS,; 1980#if defined(USE_TIMERS); 1981 CGI4_TIMEOUT,; 1982#endif; 1983#endif; 1984 ; 1985 PUT_DELETE_PASSWORDS_FILE, /* must follow CGI_* */; 1986 PROTECT_URI,; 1987 AUTHENTICATION_DOMAIN,; 1988 ENABLE_AUTH_DOMAIN_CHECK,; 1989 SSI_EXTENSIONS,; 1990 ENABLE_DIRECTORY_LISTING,; 1991 GLOBAL_PASSWORDS_FILE,; 1992 INDEX_FILES,; 1993 ACCESS_CONTROL_LIST,; 1994 EXTRA_MIME_TYPES,; 1995 SSL_CERTIFICATE,; 1996 SSL_CERTIFICATE_CHAIN,; 1997 URL_REWRITE_PATTERN,; 1998 HIDE_FILES,; 1999 SSL_DO_VERIFY_PEER,; 2000 SSL_CACHE_TIMEOUT,; 2001 SSL_CA_PATH,; 2002 SSL_CA_FILE,; 2003 SSL_VERIFY_DEPTH,; 2004 SSL_DEFAULT_VERIFY_PATHS,; 2005 SSL_CIPHER_LIST,; 2006 SSL_PROTOCOL_VERSION,; 2007 SSL_SHORT_TRUST,; 2008 ; 2009#if defined(USE_LUA); 2010 LUA_PRELOAD_FILE,; 2011 LUA_SCRIPT_EXTENSIONS,; 2012 LUA_SERVER_PAGE_EXTENSIONS,; 2013#if defined(MG_EXPERIMENTAL_INTERFACES); 2014 LUA_DEBUG_PARAMS,; 2015#endif; 2016#endif; 2017#if defined(USE_DUKTAPE); 2018 DUKTAPE_SCRIPT_EXTENSIONS,; 2019#endif; 2020 ; 2021#if defined(USE_WEBSOCKET); 2022 WEBSOCKET_ROOT,; 2023#endif; 2024#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2025 LUA_WEBSOCKET_EXTENSIONS,; 2026#endif; 2027 ; 2028 ACCESS_CONTROL_ALLOW_ORIGIN,; 2029 ACCESS_CONTROL_ALLOW_METHODS,; 2030 ACCESS_CONTROL_ALLOW_HEADERS,; 2031 ACCESS_CONTROL_ALLOW_CREDENTIALS,; 2032 ERROR_PAGES,; 2033#if !defined(NO_CACHING); 2034 STATIC_FILE_MAX_AGE,; 2035 STATIC_FILE_CACHE_CONTROL,; 2036#endif; 2037#if !defined(NO_SSL); 2038 STRICT_HTTPS_MAX_AGE,; 2039#endif; 2040 ADDITIONAL_HEADER,; 2041 ALLOW_INDEX_SCRIPT_SUB_RES,; 2042 ; 2043 NUM_OPTIONS; 2044};; 2045 ; 2046 ; 2047/* Config option name, config types, default value.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:66940,Modifiability,config,config,66940,"2150 ; 2151 {""ssl_ca_path"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2152 {""ssl_ca_file"", MG_CONFIG_TYPE_FILE, NULL},; 2153 {""ssl_verify_depth"", MG_CONFIG_TYPE_NUMBER, ""9""},; 2154 {""ssl_default_verify_paths"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2155 {""ssl_cipher_list"", MG_CONFIG_TYPE_STRING, NULL},; 2156 ; 2157 /* HTTP2 requires ALPN, and anyway TLS1.2 should be considered; 2158 * as a minimum in 2020 */; 2159 {""ssl_protocol_version"", MG_CONFIG_TYPE_NUMBER, ""4""},; 2160 ; 2161 {""ssl_short_trust"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2162 ; 2163#if defined(USE_LUA); 2164 {""lua_preload_file"", MG_CONFIG_TYPE_FILE, NULL},; 2165 {""lua_script_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lua$""},; 2166 {""lua_server_page_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lp$|**.lsp$""},; 2167#if defined(MG_EXPERIMENTAL_INTERFACES); 2168 {""lua_debug"", MG_CONFIG_TYPE_STRING, NULL},; 2169#endif; 2170#endif; 2171#if defined(USE_DUKTAPE); 2172 /* The support for duktape is still in alpha version state.; 2173 * The name of this config option might change. */; 2174 {""duktape_script_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.ssjs$""},; 2175#endif; 2176 ; 2177#if defined(USE_WEBSOCKET); 2178 {""websocket_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2179#endif; 2180#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2181 {""lua_websocket_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.lua$""},; 2182#endif; 2183 {""access_control_allow_origin"", MG_CONFIG_TYPE_STRING, ""*""},; 2184 {""access_control_allow_methods"", MG_CONFIG_TYPE_STRING, ""*""},; 2185 {""access_control_allow_headers"", MG_CONFIG_TYPE_STRING, ""*""},; 2186 {""access_control_allow_credentials"", MG_CONFIG_TYPE_STRING, """"},; 2187 {""error_pages"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2188#if !defined(NO_CACHING); 2189 {""static_file_max_age"", MG_CONFIG_TYPE_NUMBER, ""3600""},; 2190 {""static_file_cache_control"", MG_CONFIG_TYPE_STRING, NULL},; 2191#endif; 2192#if !defined(NO_SSL); 2193 {""strict_transport_security_max_age"", MG_CONFIG_TYPE_NUMBER, NULL},; 2194#endif; 2195 {""additional_header"", ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:69645,Modifiability,config,config,69645,"equests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:69678,Modifiability,config,configuration,69678,"equests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:72509,Modifiability,config,configured,72509,"2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdiff_t active_connections;; 2332 volatile ptrdiff_t max_active_connections;; 2333 volatile ptrdiff_t total_connections;; 2334 volatile ptrdiff_t total_requests;; 2335 volatile int64_t total_data_read;; 2336 volatile int64_t total_data_written;; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:94320,Modifiability,config,config,94320,"runcating vsnprintf buffer: [%.*s]"",; 3099 (int)((buflen > 200) ? 200 : (buflen - 1)),; 3100 buf);; 3101 n = (int)buflen - 1;; 3102 }; 3103 buf[n] = '\0';; 3104}; 3105 ; 3106 ; 3107static void; 3108mg_snprintf(const struct mg_connection *conn,; 3109 int *truncated,; 3110 char *buf,; 3111 size_t buflen,; 3112 const char *fmt,; 3113 ...); 3114{; 3115 va_list ap;; 3116 ; 3117 va_start(ap, fmt);; 3118 mg_vsnprintf(conn, truncated, buf, buflen, fmt, ap);; 3119 va_end(ap);; 3120}; 3121 ; 3122 ; 3123static int; 3124get_option_index(const char *name); 3125{; 3126 int i;; 3127 ; 3128 for (i = 0; config_options[i].name != NULL; i++) {; 3129 if (strcmp(config_options[i].name, name) == 0) {; 3130 return i;; 3131 }; 3132 }; 3133 return -1;; 3134}; 3135 ; 3136 ; 3137const char *; 3138mg_get_option(const struct mg_context *ctx, const char *name); 3139{; 3140 int i;; 3141 if ((i = get_option_index(name)) == -1) {; 3142 return NULL;; 3143 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3144 return """";; 3145 } else {; 3146 return ctx->dd.config[i];; 3147 }; 3148}; 3149 ; 3150#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3151 ; 3152struct mg_context *; 3153mg_get_context(const struct mg_connection *conn); 3154{; 3155 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3156}; 3157 ; 3158 ; 3159void *; 3160mg_get_user_data(const struct mg_context *ctx); 3161{; 3162 return (ctx == NULL) ? NULL : ctx->user_data;; 3163}; 3164 ; 3165 ; 3166void *; 3167mg_get_user_context_data(const struct mg_connection *conn); 3168{; 3169 return mg_get_user_data(mg_get_context(conn));; 3170}; 3171 ; 3172 ; 3173void *; 3174mg_get_thread_pointer(const struct mg_connection *conn); 3175{; 3176 /* both methods should return the same pointer */; 3177 if (conn) {; 3178 /* quick access, in case conn is known */; 3179 return conn->tls_user_ptr;; 3180 } else {; 3181 /* otherwise get pointer from thread local storage (TLS) */; 3182 struct mg_workerTLS *tls =; 3183 (str",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:94394,Modifiability,config,config,94394,"urn i;; 3131 }; 3132 }; 3133 return -1;; 3134}; 3135 ; 3136 ; 3137const char *; 3138mg_get_option(const struct mg_context *ctx, const char *name); 3139{; 3140 int i;; 3141 if ((i = get_option_index(name)) == -1) {; 3142 return NULL;; 3143 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3144 return """";; 3145 } else {; 3146 return ctx->dd.config[i];; 3147 }; 3148}; 3149 ; 3150#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3151 ; 3152struct mg_context *; 3153mg_get_context(const struct mg_connection *conn); 3154{; 3155 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3156}; 3157 ; 3158 ; 3159void *; 3160mg_get_user_data(const struct mg_context *ctx); 3161{; 3162 return (ctx == NULL) ? NULL : ctx->user_data;; 3163}; 3164 ; 3165 ; 3166void *; 3167mg_get_user_context_data(const struct mg_connection *conn); 3168{; 3169 return mg_get_user_data(mg_get_context(conn));; 3170}; 3171 ; 3172 ; 3173void *; 3174mg_get_thread_pointer(const struct mg_connection *conn); 3175{; 3176 /* both methods should return the same pointer */; 3177 if (conn) {; 3178 /* quick access, in case conn is known */; 3179 return conn->tls_user_ptr;; 3180 } else {; 3181 /* otherwise get pointer from thread local storage (TLS) */; 3182 struct mg_workerTLS *tls =; 3183 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3184 return tls->user_ptr;; 3185 }; 3186}; 3187 ; 3188 ; 3189void; 3190mg_set_user_connection_data(const struct mg_connection *const_conn, void *data); 3191{; 3192 if (const_conn != NULL) {; 3193 /* Const cast, since ""const struct mg_connection *"" does not mean; 3194 * the connection object is not modified. Here ""const"" is used,; 3195 * to indicate mg_read/mg_write/mg_send/.. must not be called. */; 3196 struct mg_connection *conn = (struct mg_connection *)const_conn;; 3197 conn->request_info.conn_data = data;; 3198 }; 3199}; 3200 ; 3201 ; 3202void *; 3203mg_get_user_connection_data(const struct mg_connection *conn); 3204{; 3205 if (conn !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:100925,Modifiability,config,config,100925,"mg_file fi;; 3357 time_t timestamp;; 3358 ; 3359 /* Unused, in the RELEASE build */; 3360 (void)func;; 3361 (void)line;; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101005,Modifiability,config,config,101005,"mg_file fi;; 3357 time_t timestamp;; 3358 ; 3359 /* Unused, in the RELEASE build */; 3360 (void)func;; 3361 (void)line;; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:108262,Modifiability,config,config,108262,"printf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3631 {; 3632#if defined(USE_IPV6); 3633 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3634#endif; 3635 int auth_domain_check_enabled =; 3636 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3637 && (!mg_strcasecmp(; 3638 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3639 ; 3640 const char *server_domain =; 3641 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3642 ; 3643 char portstr[16];; 3644 char server_ip[48];; 3645 ; 3646 if (port != default_port) {; 3647 sprintf(portstr, "":%u"", (unsigned)port);; 3648 } else {; 3649 portstr[0] = 0;; 3650 }; 3651 ; 3652 if (!auth_domain_check_enabled || !server_domain) {; 3653 ; 3654 sockaddr_to_string(server_ip,; 3655 sizeof(server_ip),; 3656 &conn->client.lsa);; 3657 ; 3658 server_domain = server_ip;; 3659 }; 3660 ; 3661 mg_snprintf(conn,; 3662 &truncated,; 3663 buf,; 3664 buflen,; 3665#if defined(USE_IPV6); 3666 ""%s://%s%s%s%s%s"",; 3667 proto,; 3668 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3669 server_domain,; 3670 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3671#else; 3672 ""%s://%s%s%s"",; 3673 proto,; 3674 server_domain,; 3675#endif; 3676 portstr,; 3677 ri->local_uri);; 3678 ; 3679 if (truncated) {; 3680 return -1;; 3681 }; 3682 return 0;; 3683 }; 3684 }; 3685}; 3686 ; 3687 ; 3688int; 3689mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3690{; 3691 return mg",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:108342,Modifiability,config,config,108342,"printf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3631 {; 3632#if defined(USE_IPV6); 3633 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3634#endif; 3635 int auth_domain_check_enabled =; 3636 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3637 && (!mg_strcasecmp(; 3638 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3639 ; 3640 const char *server_domain =; 3641 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3642 ; 3643 char portstr[16];; 3644 char server_ip[48];; 3645 ; 3646 if (port != default_port) {; 3647 sprintf(portstr, "":%u"", (unsigned)port);; 3648 } else {; 3649 portstr[0] = 0;; 3650 }; 3651 ; 3652 if (!auth_domain_check_enabled || !server_domain) {; 3653 ; 3654 sockaddr_to_string(server_ip,; 3655 sizeof(server_ip),; 3656 &conn->client.lsa);; 3657 ; 3658 server_domain = server_ip;; 3659 }; 3660 ; 3661 mg_snprintf(conn,; 3662 &truncated,; 3663 buf,; 3664 buflen,; 3665#if defined(USE_IPV6); 3666 ""%s://%s%s%s%s%s"",; 3667 proto,; 3668 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3669 server_domain,; 3670 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3671#else; 3672 ""%s://%s%s%s"",; 3673 proto,; 3674 server_domain,; 3675#endif; 3676 portstr,; 3677 ri->local_uri);; 3678 ; 3679 if (truncated) {; 3680 return -1;; 3681 }; 3682 return 0;; 3683 }; 3684 }; 3685}; 3686 ; 3687 ; 3688int; 3689mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3690{; 3691 return mg",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:108447,Modifiability,config,config,108447,"printf(conn,; 3607 &truncated,; 3608 buf,; 3609 buflen,; 3610 ""%s.unix://%s%s"",; 3611 proto,; 3612 server_name,; 3613 ri->local_uri);; 3614 default_port = 0;; 3615 return 0;; 3616 }; 3617#endif; 3618 ; 3619 if (define_proto) {; 3620 /* If we got a protocol name, use the default port accordingly. */; 3621 if ((0 == strcmp(define_proto, ""https"")); 3622 || (0 == strcmp(define_proto, ""wss""))) {; 3623 default_port = 443;; 3624 }; 3625 } else if (ri->is_ssl) {; 3626 /* If we did not get a protocol name, use TLS as default if it is; 3627 * already used. */; 3628 default_port = 443;; 3629 }; 3630 ; 3631 {; 3632#if defined(USE_IPV6); 3633 int is_ipv6 = (conn->client.lsa.sa.sa_family == AF_INET6);; 3634#endif; 3635 int auth_domain_check_enabled =; 3636 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK]; 3637 && (!mg_strcasecmp(; 3638 conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes""));; 3639 ; 3640 const char *server_domain =; 3641 conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 3642 ; 3643 char portstr[16];; 3644 char server_ip[48];; 3645 ; 3646 if (port != default_port) {; 3647 sprintf(portstr, "":%u"", (unsigned)port);; 3648 } else {; 3649 portstr[0] = 0;; 3650 }; 3651 ; 3652 if (!auth_domain_check_enabled || !server_domain) {; 3653 ; 3654 sockaddr_to_string(server_ip,; 3655 sizeof(server_ip),; 3656 &conn->client.lsa);; 3657 ; 3658 server_domain = server_ip;; 3659 }; 3660 ; 3661 mg_snprintf(conn,; 3662 &truncated,; 3663 buf,; 3664 buflen,; 3665#if defined(USE_IPV6); 3666 ""%s://%s%s%s%s%s"",; 3667 proto,; 3668 (is_ipv6 && (server_domain == server_ip)) ? ""["" : """",; 3669 server_domain,; 3670 (is_ipv6 && (server_domain == server_ip)) ? ""]"" : """",; 3671#else; 3672 ""%s://%s%s%s"",; 3673 proto,; 3674 server_domain,; 3675#endif; 3676 portstr,; 3677 ri->local_uri);; 3678 ; 3679 if (truncated) {; 3680 return -1;; 3681 }; 3682 return 0;; 3683 }; 3684 }; 3685}; 3686 ; 3687 ; 3688int; 3689mg_get_request_link(const struct mg_connection *conn, char *buf, size_t buflen); 3690{; 3691 return mg",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:118210,Modifiability,config,config,118210,"tern[i]) != lowercase(&str[j])) {; 3959 return -1;; 3960 }; 3961 }; 3962 return (ptrdiff_t)j;; 3963}; 3964 ; 3965 ; 3966static ptrdiff_t; 3967match_prefix_strlen(const char *pattern, const char *str); 3968{; 3969 if (pattern == NULL) {; 3970 return -1;; 3971 }; 3972 return match_prefix(pattern, strlen(pattern), str);; 3973}; 3974 ; 3975 ; 3976/* HTTP 1.1 assumes keep alive if ""Connection:"" header is not set; 3977 * This function must tolerate situations when connection info is not; 3978 * set up, for example if request parsing failed. */; 3979static int; 3980should_keep_alive(const struct mg_connection *conn); 3981{; 3982 const char *http_version;; 3983 const char *header;; 3984 ; 3985 /* First satisfy needs of the server */; 3986 if ((conn == NULL) || conn->must_close) {; 3987 /* Close, if civetweb framework needs to close */; 3988 return 0;; 3989 }; 3990 ; 3991 if (mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"") != 0) {; 3992 /* Close, if keep alive is not enabled */; 3993 return 0;; 3994 }; 3995 ; 3996 /* Check explicit wish of the client */; 3997 header = mg_get_header(conn, ""Connection"");; 3998 if (header) {; 3999 /* If there is a connection header from the client, obey */; 4000 if (header_has_option(header, ""keep-alive"")) {; 4001 return 1;; 4002 }; 4003 return 0;; 4004 }; 4005 ; 4006 /* Use default of the standard */; 4007 http_version = get_http_version(conn);; 4008 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4009 /* HTTP 1.1 default is keep alive */; 4010 return 1;; 4011 }; 4012 ; 4013 /* HTTP 1.0 (and earlier) default is to close the connection */; 4014 return 0;; 4015}; 4016 ; 4017 ; 4018static int; 4019should_decode_url(const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:119142,Modifiability,config,config,119142,", if keep alive is not enabled */; 3993 return 0;; 3994 }; 3995 ; 3996 /* Check explicit wish of the client */; 3997 header = mg_get_header(conn, ""Connection"");; 3998 if (header) {; 3999 /* If there is a connection header from the client, obey */; 4000 if (header_has_option(header, ""keep-alive"")) {; 4001 return 1;; 4002 }; 4003 return 0;; 4004 }; 4005 ; 4006 /* Use default of the standard */; 4007 http_version = get_http_version(conn);; 4008 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4009 /* HTTP 1.1 default is keep alive */; 4010 return 1;; 4011 }; 4012 ; 4013 /* HTTP 1.0 (and earlier) default is to close the connection */; 4014 return 0;; 4015}; 4016 ; 4017 ; 4018static int; 4019should_decode_url(const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:119397,Modifiability,config,config,119397,", if keep alive is not enabled */; 3993 return 0;; 3994 }; 3995 ; 3996 /* Check explicit wish of the client */; 3997 header = mg_get_header(conn, ""Connection"");; 3998 if (header) {; 3999 /* If there is a connection header from the client, obey */; 4000 if (header_has_option(header, ""keep-alive"")) {; 4001 return 1;; 4002 }; 4003 return 0;; 4004 }; 4005 ; 4006 /* Use default of the standard */; 4007 http_version = get_http_version(conn);; 4008 if (http_version && (0 == strcmp(http_version, ""1.1""))) {; 4009 /* HTTP 1.1 default is keep alive */; 4010 return 1;; 4011 }; 4012 ; 4013 /* HTTP 1.0 (and earlier) default is to close the connection */; 4014 return 0;; 4015}; 4016 ; 4017 ; 4018static int; 4019should_decode_url(const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120456,Modifiability,config,config,120456,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120547,Modifiability,config,configured,120547,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120731,Modifiability,config,config,120731,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120790,Modifiability,config,configuration,120790,"d obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120858,Modifiability,config,config,120858,"he-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""C",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:121661,Modifiability,config,configured,121661,";; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(struct mg_connection *conn); 4119{; 4120 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4121 ; 4122#if !defined(NO_SSL); 4123 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4124 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4125 if (max_age >= 0) {; 4126 char val[64];; 4127 mg_snprintf(conn,; 4128 NULL,; 4129 val,; 4130 sizeof(val),; 4131 ""max-age=%lu"",; 4132 (unsigned long)max_age);; 4133 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4134 }; 4135 }; 4136#endif; 4137 ; 4138 if (header && header[0]) {; 4139 mg_response_header_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:122156,Modifiability,config,config,122156,"RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(struct mg_connection *conn); 4119{; 4120 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4121 ; 4122#if !defined(NO_SSL); 4123 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4124 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4125 if (max_age >= 0) {; 4126 char val[64];; 4127 mg_snprintf(conn,; 4128 NULL,; 4129 val,; 4130 sizeof(val),; 4131 ""max-age=%lu"",; 4132 (unsigned long)max_age);; 4133 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4134 }; 4135 }; 4136#endif; 4137 ; 4138 if (header && header[0]) {; 4139 mg_response_header_add_lines(conn, header);; 4140 }; 4141}; 4142 ; 4143 ; 4144#if !defined(NO_FILESYSTEMS); 4145static void handle_file_based_request(struct mg_connection *conn,; 4146 const char *path,; 4147 struct mg_file *filep);; 4148#endif /* NO_FILESYSTEMS */; 4149 ; 4150 ; 4151const char *; 4152mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4153{; 4154 /* See IANA HTTP status code assignment:; 4155 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4156 */; 4157 ; 4158 switch (response_code) {; 4159 /* RFC2616 Section 10.1 - Informational 1xx */; 4160 case 100:; 4161 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4162 case 101:; 4163 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:122241,Modifiability,config,config,122241,"RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(struct mg_connection *conn); 4119{; 4120 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4121 ; 4122#if !defined(NO_SSL); 4123 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4124 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4125 if (max_age >= 0) {; 4126 char val[64];; 4127 mg_snprintf(conn,; 4128 NULL,; 4129 val,; 4130 sizeof(val),; 4131 ""max-age=%lu"",; 4132 (unsigned long)max_age);; 4133 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4134 }; 4135 }; 4136#endif; 4137 ; 4138 if (header && header[0]) {; 4139 mg_response_header_add_lines(conn, header);; 4140 }; 4141}; 4142 ; 4143 ; 4144#if !defined(NO_FILESYSTEMS); 4145static void handle_file_based_request(struct mg_connection *conn,; 4146 const char *path,; 4147 struct mg_file *filep);; 4148#endif /* NO_FILESYSTEMS */; 4149 ; 4150 ; 4151const char *; 4152mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4153{; 4154 /* See IANA HTTP status code assignment:; 4155 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4156 */; 4157 ; 4158 switch (response_code) {; 4159 /* RFC2616 Section 10.1 - Informational 1xx */; 4160 case 100:; 4161 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4162 case 101:; 4163 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:122314,Modifiability,config,config,122314,"RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(struct mg_connection *conn); 4119{; 4120 const char *header = conn->dom_ctx->config[ADDITIONAL_HEADER];; 4121 ; 4122#if !defined(NO_SSL); 4123 if (conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]) {; 4124 long max_age = atol(conn->dom_ctx->config[STRICT_HTTPS_MAX_AGE]);; 4125 if (max_age >= 0) {; 4126 char val[64];; 4127 mg_snprintf(conn,; 4128 NULL,; 4129 val,; 4130 sizeof(val),; 4131 ""max-age=%lu"",; 4132 (unsigned long)max_age);; 4133 mg_response_header_add(conn, ""Strict-Transport-Security"", val, -1);; 4134 }; 4135 }; 4136#endif; 4137 ; 4138 if (header && header[0]) {; 4139 mg_response_header_add_lines(conn, header);; 4140 }; 4141}; 4142 ; 4143 ; 4144#if !defined(NO_FILESYSTEMS); 4145static void handle_file_based_request(struct mg_connection *conn,; 4146 const char *path,; 4147 struct mg_file *filep);; 4148#endif /* NO_FILESYSTEMS */; 4149 ; 4150 ; 4151const char *; 4152mg_get_response_code_text(const struct mg_connection *conn, int response_code); 4153{; 4154 /* See IANA HTTP status code assignment:; 4155 * http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml; 4156 */; 4157 ; 4158 switch (response_code) {; 4159 /* RFC2616 Section 10.1 - Informational 1xx */; 4160 case 100:; 4161 return ""Continue""; /* RFC2616 Section 10.1.1 */; 4162 case 101:; 4163 return ""Switching Protocols""; /* RFC2616 Section 10.1.2 */; 416",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:132019,Modifiability,config,config,132019," args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 444",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:132083,Modifiability,config,config,132083," args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 444",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:133091,Modifiability,config,config,133091,"ig[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1]",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:133542,Modifiability,config,configuration,133542,"ror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; 4484 path_buf);; 4485 page_handler_found = 1;; 4486 break;; 4487 }; 4488 DEBUG_TRACE(""Check error page %s - not found"",; 4489 path_buf);; 4490 ; 4491 /* Continue with the next file extenstion from the; 4492 * configurat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:134420,Modifiability,config,configuration,134420," 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; 4484 path_buf);; 4485 page_handler_found = 1;; 4486 break;; 4487 }; 4488 DEBUG_TRACE(""Check error page %s - not found"",; 4489 path_buf);; 4490 ; 4491 /* Continue with the next file extenstion from the; 4492 * configuration (if there is a next one). */; 4493 tstr = strchr(tstr + i, '.');; 4494 }; 4495 }; 4496 }; 4497 ; 4498 if (page_handler_found) {; 4499 conn->in_error_handler = 1;; 4500 handle_file_based_request(conn, path_buf, &error_page_file);; 4501 conn->in_error_handler = 0;; 4502 return 0;; 4503 }; 4504#endif /* NO_FILESYSTEMS */; 4505 }; 4506 ; 4507 /* No custom error page. Send default error page. */; 4508 conn->must_close = 1;; 4509 mg_response_header_start(conn, status);; 4510 send_no_cache_header(conn);; 4511 send_additional_header(conn);; 4512 if (has_body) {; 4513 mg_response_header_add(conn,; 4514 ""Content-Type"",; 4515 ""text/plain; charset=utf-8"",; 4516 -1);; 4517 }; 4518 mg_response_header_send(conn);; 4519 ; 4520 /* HTTP responses 1xx, 204 and 304 MUST NOT send a body */; 4521 if (has_body) {; 4522 /* For other errors, send a generic error message. */; 4523 cons",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:148521,Modifiability,config,configuration,148521,"4964 ; 4965 /* Convert to Unicode and back. If doubly-converted string does not; 4966 * match the original, something is fishy, reject. */; 4967 memset(wbuf, 0, wbuf_len * sizeof(wchar_t));; 4968 MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);; 4969 WideCharToMultiByte(; 4970 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4971 if (strcmp(buf, buf2) != 0) {; 4972 wbuf[0] = L'\0';; 4973 }; 4974 ; 4975 /* Windows file systems are not case sensitive, but you can still use; 4976 * uppercase and lowercase letters (on all modern file systems).; 4977 * The server can check if the URI uses the same upper/lowercase; 4978 * letters an the file system, effectively making Windows servers; 4979 * case sensitive (like Linux servers are). It is still not possible; 4980 * to use two files with the same name in different cases on Windows; 4981 * (like /a and /A) - this would be possible in Linux.; 4982 * As a default, Windows is not case sensitive, but the case sensitive; 4983 * file name check can be activated by an additional configuration. */; 4984 if (conn) {; 4985 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4986 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4987 ""yes"")) {; 4988 /* Use case sensitive compare function */; 4989 fcompare = wcscmp;; 4990 }; 4991 }; 4992 (void)conn; /* conn is currently unused */; 4993 ; 4994 /* Only accept a full file path, not a Windows short (8.3) path. */; 4995 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4996 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4997 if (long_len == 0) {; 4998 err = GetLastError();; 4999 if (err == ERROR_FILE_NOT_FOUND) {; 5000 /* File does not exist. This is not always a problem here. */; 5001 return;; 5002 }; 5003 }; 5004 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5005 /* Short name is used. */; 5006 wbuf[0] = L'\0';; 5007 }; 5008}; 5009 ; 5010 ; 5011#if !defined(NO_FILESYSTEMS); 5012/* Get file informat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:148582,Modifiability,config,config,148582," 4969 WideCharToMultiByte(; 4970 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4971 if (strcmp(buf, buf2) != 0) {; 4972 wbuf[0] = L'\0';; 4973 }; 4974 ; 4975 /* Windows file systems are not case sensitive, but you can still use; 4976 * uppercase and lowercase letters (on all modern file systems).; 4977 * The server can check if the URI uses the same upper/lowercase; 4978 * letters an the file system, effectively making Windows servers; 4979 * case sensitive (like Linux servers are). It is still not possible; 4980 * to use two files with the same name in different cases on Windows; 4981 * (like /a and /A) - this would be possible in Linux.; 4982 * As a default, Windows is not case sensitive, but the case sensitive; 4983 * file name check can be activated by an additional configuration. */; 4984 if (conn) {; 4985 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4986 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4987 ""yes"")) {; 4988 /* Use case sensitive compare function */; 4989 fcompare = wcscmp;; 4990 }; 4991 }; 4992 (void)conn; /* conn is currently unused */; 4993 ; 4994 /* Only accept a full file path, not a Windows short (8.3) path. */; 4995 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4996 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4997 if (long_len == 0) {; 4998 err = GetLastError();; 4999 if (err == ERROR_FILE_NOT_FOUND) {; 5000 /* File does not exist. This is not always a problem here. */; 5001 return;; 5002 }; 5003 }; 5004 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5005 /* Short name is used. */; 5006 wbuf[0] = L'\0';; 5007 }; 5008}; 5009 ; 5010 ; 5011#if !defined(NO_FILESYSTEMS); 5012/* Get file information, return 1 if file exists, 0 if not */; 5013static int; 5014mg_stat(const struct mg_connection *conn,; 5015 const char *path,; 5016 struct mg_file_stat *filep); 5017{; 5018 wchar_t wbuf[UTF16_PATH_MAX];; 5019 WIN32_FILE_ATTRIBUTE_DATA info;; 5020 time_t c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:148650,Modifiability,config,config,148650," 4969 WideCharToMultiByte(; 4970 CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2), NULL, NULL);; 4971 if (strcmp(buf, buf2) != 0) {; 4972 wbuf[0] = L'\0';; 4973 }; 4974 ; 4975 /* Windows file systems are not case sensitive, but you can still use; 4976 * uppercase and lowercase letters (on all modern file systems).; 4977 * The server can check if the URI uses the same upper/lowercase; 4978 * letters an the file system, effectively making Windows servers; 4979 * case sensitive (like Linux servers are). It is still not possible; 4980 * to use two files with the same name in different cases on Windows; 4981 * (like /a and /A) - this would be possible in Linux.; 4982 * As a default, Windows is not case sensitive, but the case sensitive; 4983 * file name check can be activated by an additional configuration. */; 4984 if (conn) {; 4985 if (conn->dom_ctx->config[CASE_SENSITIVE_FILES]; 4986 && !mg_strcasecmp(conn->dom_ctx->config[CASE_SENSITIVE_FILES],; 4987 ""yes"")) {; 4988 /* Use case sensitive compare function */; 4989 fcompare = wcscmp;; 4990 }; 4991 }; 4992 (void)conn; /* conn is currently unused */; 4993 ; 4994 /* Only accept a full file path, not a Windows short (8.3) path. */; 4995 memset(wbuf2, 0, ARRAY_SIZE(wbuf2) * sizeof(wchar_t));; 4996 long_len = GetLongPathNameW(wbuf, wbuf2, ARRAY_SIZE(wbuf2) - 1);; 4997 if (long_len == 0) {; 4998 err = GetLastError();; 4999 if (err == ERROR_FILE_NOT_FOUND) {; 5000 /* File does not exist. This is not always a problem here. */; 5001 return;; 5002 }; 5003 }; 5004 if ((long_len >= ARRAY_SIZE(wbuf2)) || (fcompare(wbuf, wbuf2) != 0)) {; 5005 /* Short name is used. */; 5006 wbuf[0] = L'\0';; 5007 }; 5008}; 5009 ; 5010 ; 5011#if !defined(NO_FILESYSTEMS); 5012/* Get file information, return 1 if file exists, 0 if not */; 5013static int; 5014mg_stat(const struct mg_connection *conn,; 5015 const char *path,; 5016 struct mg_file_stat *filep); 5017{; 5018 wchar_t wbuf[UTF16_PATH_MAX];; 5019 WIN32_FILE_ATTRIBUTE_DATA info;; 5020 time_t c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:161563,Modifiability,inherit,inherited,161563,"r,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5441 int truncated;; 5442 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5443 STARTUPINFOA si;; 5444 PROCESS_INFORMATION pi = {0};; 5445 ; 5446 (void)envp;; 5447 ; 5448 memset(&si, 0, sizeof(si));; 5449 si.cb = sizeof(si);; 5450 ; 5451 si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;; 5452 si.wShowWindow = SW_HIDE;; 5453 ; 5454 me = GetCurrentProcess();; 5455 DuplicateHandle(me,; 5456 (HANDLE)_get_osfhandle(fdin[0]),; 5457 me,; 5458 &si.hStdInput,; 5459 0,; 5460 TRUE,; 5461 DUPLICATE_SAME_ACCESS);; 5462 DuplicateHandle(me,; 5463 (HANDLE)_get_osfhandle(fdout[1]),; 5464 me,; 5465 &si.hStdOutput,; 5466 0,; 5467 TRUE,; 5468 DUPLICATE_SAME_ACCESS);; 5469 DuplicateHandle(me,; 5470 (HANDLE)_get_osfhandle(fderr[1]),; 5471 me,; 5472 &si.hStdError,; 5473 0,; 5474 TRUE,; 5475 DUPLICATE_SAME_ACCESS);; 5476 ; 5477 /* Mark handles that should not be inherited. See; 5478 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5479 */; 5480 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5481 HANDLE_FLAG_INHERIT,; 5482 0);; 5483 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5484 HANDLE_FLAG_INHERIT,; 5485 0);; 5486 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5487 HANDLE_FLAG_INHERIT,; 5488 0);; 5489 ; 5490 /* First check, if there is a CGI interpreter configured for all CGI; 5491 * scripts. */; 5492 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5493 if (interp != NULL) {; 5494 /* If there is a configured interpreter, check for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:162031,Modifiability,config,configured,162031," ; 5448 memset(&si, 0, sizeof(si));; 5449 si.cb = sizeof(si);; 5450 ; 5451 si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;; 5452 si.wShowWindow = SW_HIDE;; 5453 ; 5454 me = GetCurrentProcess();; 5455 DuplicateHandle(me,; 5456 (HANDLE)_get_osfhandle(fdin[0]),; 5457 me,; 5458 &si.hStdInput,; 5459 0,; 5460 TRUE,; 5461 DUPLICATE_SAME_ACCESS);; 5462 DuplicateHandle(me,; 5463 (HANDLE)_get_osfhandle(fdout[1]),; 5464 me,; 5465 &si.hStdOutput,; 5466 0,; 5467 TRUE,; 5468 DUPLICATE_SAME_ACCESS);; 5469 DuplicateHandle(me,; 5470 (HANDLE)_get_osfhandle(fderr[1]),; 5471 me,; 5472 &si.hStdError,; 5473 0,; 5474 TRUE,; 5475 DUPLICATE_SAME_ACCESS);; 5476 ; 5477 /* Mark handles that should not be inherited. See; 5478 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5479 */; 5480 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5481 HANDLE_FLAG_INHERIT,; 5482 0);; 5483 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5484 HANDLE_FLAG_INHERIT,; 5485 0);; 5486 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5487 HANDLE_FLAG_INHERIT,; 5488 0);; 5489 ; 5490 /* First check, if there is a CGI interpreter configured for all CGI; 5491 * scripts. */; 5492 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5493 if (interp != NULL) {; 5494 /* If there is a configured interpreter, check for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_REA",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:162104,Modifiability,config,config,162104,"]),; 5464 me,; 5465 &si.hStdOutput,; 5466 0,; 5467 TRUE,; 5468 DUPLICATE_SAME_ACCESS);; 5469 DuplicateHandle(me,; 5470 (HANDLE)_get_osfhandle(fderr[1]),; 5471 me,; 5472 &si.hStdError,; 5473 0,; 5474 TRUE,; 5475 DUPLICATE_SAME_ACCESS);; 5476 ; 5477 /* Mark handles that should not be inherited. See; 5478 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5479 */; 5480 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5481 HANDLE_FLAG_INHERIT,; 5482 0);; 5483 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5484 HANDLE_FLAG_INHERIT,; 5485 0);; 5486 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5487 HANDLE_FLAG_INHERIT,; 5488 0);; 5489 ; 5490 /* First check, if there is a CGI interpreter configured for all CGI; 5491 * scripts. */; 5492 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5493 if (interp != NULL) {; 5494 /* If there is a configured interpreter, check for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:162197,Modifiability,config,configured,162197,"]),; 5464 me,; 5465 &si.hStdOutput,; 5466 0,; 5467 TRUE,; 5468 DUPLICATE_SAME_ACCESS);; 5469 DuplicateHandle(me,; 5470 (HANDLE)_get_osfhandle(fderr[1]),; 5471 me,; 5472 &si.hStdError,; 5473 0,; 5474 TRUE,; 5475 DUPLICATE_SAME_ACCESS);; 5476 ; 5477 /* Mark handles that should not be inherited. See; 5478 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5479 */; 5480 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5481 HANDLE_FLAG_INHERIT,; 5482 0);; 5483 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5484 HANDLE_FLAG_INHERIT,; 5485 0);; 5486 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5487 HANDLE_FLAG_INHERIT,; 5488 0);; 5489 ; 5490 /* First check, if there is a CGI interpreter configured for all CGI; 5491 * scripts. */; 5492 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5493 if (interp != NULL) {; 5494 /* If there is a configured interpreter, check for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:162301,Modifiability,config,config,162301,"]),; 5464 me,; 5465 &si.hStdOutput,; 5466 0,; 5467 TRUE,; 5468 DUPLICATE_SAME_ACCESS);; 5469 DuplicateHandle(me,; 5470 (HANDLE)_get_osfhandle(fderr[1]),; 5471 me,; 5472 &si.hStdError,; 5473 0,; 5474 TRUE,; 5475 DUPLICATE_SAME_ACCESS);; 5476 ; 5477 /* Mark handles that should not be inherited. See; 5478 * https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499%28v=vs.85%29.aspx; 5479 */; 5480 SetHandleInformation((HANDLE)_get_osfhandle(fdin[1]),; 5481 HANDLE_FLAG_INHERIT,; 5482 0);; 5483 SetHandleInformation((HANDLE)_get_osfhandle(fdout[0]),; 5484 HANDLE_FLAG_INHERIT,; 5485 0);; 5486 SetHandleInformation((HANDLE)_get_osfhandle(fderr[0]),; 5487 HANDLE_FLAG_INHERIT,; 5488 0);; 5489 ; 5490 /* First check, if there is a CGI interpreter configured for all CGI; 5491 * scripts. */; 5492 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5493 if (interp != NULL) {; 5494 /* If there is a configured interpreter, check for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:170798,Modifiability,config,config,170798,"SIGCHLD's handler; 5804 * will leave unchanged after exec if it was set to be ignored.; 5805 * Restore it to default action. */; 5806 memset(&sa, 0, sizeof(sa));; 5807 sa.sa_handler = SIG_DFL;; 5808 sigaction(SIGCHLD, &sa, NULL);; 5809 ; 5810 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5811 if (interp == NULL) {; 5812 /* no interpreter configured, call the programm directly */; 5813 (void)execle(prog, prog, NULL, envp);; 5814 mg_cry_internal(conn,; 5815 ""%s: execle(%s): %s"",; 5816 __func__,; 5817 prog,; 5818 strerror(ERRNO));; 5819 } else {; 5820 /* call the configured interpreter */; 5821 const char *interp_args =; 5822 conn->dom_ctx; 5823 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5824 ; 5825 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5826 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5827 } else {; 5828 (void)execle(interp, interp, prog, NULL, envp);; 5829 }; 5830 mg_cry_internal(conn,; 5831 ""%s: execle(%s %s): %s"",; 5832 __func__,; 5833 interp,; 5834 prog,; 5835 strerror(ERRNO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:170892,Modifiability,config,configured,170892,"SIGCHLD's handler; 5804 * will leave unchanged after exec if it was set to be ignored.; 5805 * Restore it to default action. */; 5806 memset(&sa, 0, sizeof(sa));; 5807 sa.sa_handler = SIG_DFL;; 5808 sigaction(SIGCHLD, &sa, NULL);; 5809 ; 5810 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5811 if (interp == NULL) {; 5812 /* no interpreter configured, call the programm directly */; 5813 (void)execle(prog, prog, NULL, envp);; 5814 mg_cry_internal(conn,; 5815 ""%s: execle(%s): %s"",; 5816 __func__,; 5817 prog,; 5818 strerror(ERRNO));; 5819 } else {; 5820 /* call the configured interpreter */; 5821 const char *interp_args =; 5822 conn->dom_ctx; 5823 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5824 ; 5825 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5826 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5827 } else {; 5828 (void)execle(interp, interp, prog, NULL, envp);; 5829 }; 5830 mg_cry_internal(conn,; 5831 ""%s: execle(%s %s): %s"",; 5832 __func__,; 5833 interp,; 5834 prog,; 5835 strerror(ERRNO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:171119,Modifiability,config,configured,171119,"SIGCHLD's handler; 5804 * will leave unchanged after exec if it was set to be ignored.; 5805 * Restore it to default action. */; 5806 memset(&sa, 0, sizeof(sa));; 5807 sa.sa_handler = SIG_DFL;; 5808 sigaction(SIGCHLD, &sa, NULL);; 5809 ; 5810 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5811 if (interp == NULL) {; 5812 /* no interpreter configured, call the programm directly */; 5813 (void)execle(prog, prog, NULL, envp);; 5814 mg_cry_internal(conn,; 5815 ""%s: execle(%s): %s"",; 5816 __func__,; 5817 prog,; 5818 strerror(ERRNO));; 5819 } else {; 5820 /* call the configured interpreter */; 5821 const char *interp_args =; 5822 conn->dom_ctx; 5823 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5824 ; 5825 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5826 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5827 } else {; 5828 (void)execle(interp, interp, prog, NULL, envp);; 5829 }; 5830 mg_cry_internal(conn,; 5831 ""%s: execle(%s %s): %s"",; 5832 __func__,; 5833 interp,; 5834 prog,; 5835 strerror(ERRNO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:171205,Modifiability,config,config,171205,"SIGCHLD's handler; 5804 * will leave unchanged after exec if it was set to be ignored.; 5805 * Restore it to default action. */; 5806 memset(&sa, 0, sizeof(sa));; 5807 sa.sa_handler = SIG_DFL;; 5808 sigaction(SIGCHLD, &sa, NULL);; 5809 ; 5810 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5811 if (interp == NULL) {; 5812 /* no interpreter configured, call the programm directly */; 5813 (void)execle(prog, prog, NULL, envp);; 5814 mg_cry_internal(conn,; 5815 ""%s: execle(%s): %s"",; 5816 __func__,; 5817 prog,; 5818 strerror(ERRNO));; 5819 } else {; 5820 /* call the configured interpreter */; 5821 const char *interp_args =; 5822 conn->dom_ctx; 5823 ->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5824 ; 5825 if ((interp_args != NULL) && (interp_args[0] != 0)) {; 5826 (void)execle(interp, interp, interp_args, prog, NULL, envp);; 5827 } else {; 5828 (void)execle(interp, interp, prog, NULL, envp);; 5829 }; 5830 mg_cry_internal(conn,; 5831 ""%s: execle(%s %s): %s"",; 5832 __func__,; 5833 interp,; 5834 prog,; 5835 strerror(ERRNO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Line",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179445,Modifiability,config,config,179445," {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179501,Modifiability,config,config,179501," using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187027,Modifiability,config,config,187027,"e have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187090,Modifiability,config,config,187090,"e have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:202789,Modifiability,variab,variable,202789,"97 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6998}; 6999 ; 7000 ; 7001int; 7002mg_get_var2(const char *data,; 7003 size_t data_len,; 7004 const char *name,; 7005 char *dst,; 7006 size_t dst_len,; 7007 size_t occurrence); 7008{; 7009 const char *p, *e, *s;; 7010 size_t name_len;; 7011 int len;; 7012 ; 7013 if ((dst == NULL) || (dst_len == 0)) {; 7014 len = -2;; 7015 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7016 len = -1;; 7017 dst[0] = '\0';; 7018 } else {; 7019 name_len = strlen(name);; 7020 e = data + data_len;; 7021 len = -1;; 7022 dst[0] = '\0';; 7023 ; 7024 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7025 for (p = data; p + name_len < e; p++) {; 7026 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7027 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7028 /* Point p to variable value */; 7029 p += name_len + 1;; 7030 ; 7031 /* Point s to the end of the value */; 7032 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7033 if (s == NULL) {; 7034 s = e;; 7035 }; 7036 DEBUG_ASSERT(s >= p);; 7037 if (s < p) {; 7038 return -3;; 7039 }; 7040 ; 7041 /* Decode variable into destination buffer */; 7042 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7043 ; 7044 /* Redirect error code from -1 to -2 (destination buffer too; 7045 * small). */; 7046 if (len == -1) {; 7047 len = -2;; 7048 }; 7049 break;; 7050 }; 7051 }; 7052 }; 7053 ; 7054 return len;; 7055}; 7056 ; 7057 ; 7058/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7059int; 7060mg_split_form_urlencoded(char *data,; 7061 struct mg_header *form_fields,; 7062 unsigned num_form_fields); 7063{; 7064 char *b;; 7065 int i;; 7066 int num = 0;; 7067 ; 7068 if (data == NULL) {; 7069 /* parameter error */; 7070 return -1;; 7071 }; 7072 ; 7073 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7074 /* determine the number of expected fields */; 7075 if (data[0] == 0) {; 7076 return 0;; 7077 }; 7078 /* count ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:203007,Modifiability,variab,variable,203007,"97 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6998}; 6999 ; 7000 ; 7001int; 7002mg_get_var2(const char *data,; 7003 size_t data_len,; 7004 const char *name,; 7005 char *dst,; 7006 size_t dst_len,; 7007 size_t occurrence); 7008{; 7009 const char *p, *e, *s;; 7010 size_t name_len;; 7011 int len;; 7012 ; 7013 if ((dst == NULL) || (dst_len == 0)) {; 7014 len = -2;; 7015 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7016 len = -1;; 7017 dst[0] = '\0';; 7018 } else {; 7019 name_len = strlen(name);; 7020 e = data + data_len;; 7021 len = -1;; 7022 dst[0] = '\0';; 7023 ; 7024 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7025 for (p = data; p + name_len < e; p++) {; 7026 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7027 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7028 /* Point p to variable value */; 7029 p += name_len + 1;; 7030 ; 7031 /* Point s to the end of the value */; 7032 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7033 if (s == NULL) {; 7034 s = e;; 7035 }; 7036 DEBUG_ASSERT(s >= p);; 7037 if (s < p) {; 7038 return -3;; 7039 }; 7040 ; 7041 /* Decode variable into destination buffer */; 7042 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7043 ; 7044 /* Redirect error code from -1 to -2 (destination buffer too; 7045 * small). */; 7046 if (len == -1) {; 7047 len = -2;; 7048 }; 7049 break;; 7050 }; 7051 }; 7052 }; 7053 ; 7054 return len;; 7055}; 7056 ; 7057 ; 7058/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7059int; 7060mg_split_form_urlencoded(char *data,; 7061 struct mg_header *form_fields,; 7062 unsigned num_form_fields); 7063{; 7064 char *b;; 7065 int i;; 7066 int num = 0;; 7067 ; 7068 if (data == NULL) {; 7069 /* parameter error */; 7070 return -1;; 7071 }; 7072 ; 7073 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7074 /* determine the number of expected fields */; 7075 if (data[0] == 0) {; 7076 return 0;; 7077 }; 7078 /* count ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:203297,Modifiability,variab,variable,203297,"97 return mg_get_var2(data, data_len, name, dst, dst_len, 0);; 6998}; 6999 ; 7000 ; 7001int; 7002mg_get_var2(const char *data,; 7003 size_t data_len,; 7004 const char *name,; 7005 char *dst,; 7006 size_t dst_len,; 7007 size_t occurrence); 7008{; 7009 const char *p, *e, *s;; 7010 size_t name_len;; 7011 int len;; 7012 ; 7013 if ((dst == NULL) || (dst_len == 0)) {; 7014 len = -2;; 7015 } else if ((data == NULL) || (name == NULL) || (data_len == 0)) {; 7016 len = -1;; 7017 dst[0] = '\0';; 7018 } else {; 7019 name_len = strlen(name);; 7020 e = data + data_len;; 7021 len = -1;; 7022 dst[0] = '\0';; 7023 ; 7024 /* data is ""var1=val1&var2=val2..."". Find variable first */; 7025 for (p = data; p + name_len < e; p++) {; 7026 if (((p == data) || (p[-1] == '&')) && (p[name_len] == '='); 7027 && !mg_strncasecmp(name, p, name_len) && 0 == occurrence--) {; 7028 /* Point p to variable value */; 7029 p += name_len + 1;; 7030 ; 7031 /* Point s to the end of the value */; 7032 s = (const char *)memchr(p, '&', (size_t)(e - p));; 7033 if (s == NULL) {; 7034 s = e;; 7035 }; 7036 DEBUG_ASSERT(s >= p);; 7037 if (s < p) {; 7038 return -3;; 7039 }; 7040 ; 7041 /* Decode variable into destination buffer */; 7042 len = mg_url_decode(p, (int)(s - p), dst, (int)dst_len, 1);; 7043 ; 7044 /* Redirect error code from -1 to -2 (destination buffer too; 7045 * small). */; 7046 if (len == -1) {; 7047 len = -2;; 7048 }; 7049 break;; 7050 }; 7051 }; 7052 }; 7053 ; 7054 return len;; 7055}; 7056 ; 7057 ; 7058/* split a string ""key1=val1&key2=val2"" into key/value pairs */; 7059int; 7060mg_split_form_urlencoded(char *data,; 7061 struct mg_header *form_fields,; 7062 unsigned num_form_fields); 7063{; 7064 char *b;; 7065 int i;; 7066 int num = 0;; 7067 ; 7068 if (data == NULL) {; 7069 /* parameter error */; 7070 return -1;; 7071 }; 7072 ; 7073 if ((form_fields == NULL) && (num_form_fields == 0)) {; 7074 /* determine the number of expected fields */; 7075 if (data[0] == 0) {; 7076 return 0;; 7077 }; 7078 /* count ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:210159,Modifiability,config,config,210159,"+ (c >> 2);; 7295 if (d != 255) {; 7296 dst[(*dst_len)++] = (c << 6) + d;; 7297 }; 7298 }; 7299 }; 7300 return -1;; 7301}; 7302#endif; 7303 ; 7304 ; 7305static int; 7306is_put_or_delete_method(const struct mg_connection *conn); 7307{; 7308 if (conn) {; 7309 const char *s = conn->request_info.request_method;; 7310 return (s != NULL); 7311 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7312 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7313 }; 7314 return 0;; 7315}; 7316 ; 7317 ; 7318#if !defined(NO_FILES); 7319static int; 7320extention_matches_script(; 7321 struct mg_connection *conn, /* in: request (must be valid) */; 7322 const char *filename /* in: filename (must be valid) */; 7323); 7324{; 7325#if !defined(NO_CGI); 7326 unsigned char cgi_config_idx, inc, max;; 7327#endif; 7328 ; 7329#if defined(USE_LUA); 7330 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7331 filename); 7332 > 0) {; 7333 return 1;; 7334 }; 7335#endif; 7336#if defined(USE_DUKTAPE); 7337 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:210330,Modifiability,config,config,210330,"+ (c >> 2);; 7295 if (d != 255) {; 7296 dst[(*dst_len)++] = (c << 6) + d;; 7297 }; 7298 }; 7299 }; 7300 return -1;; 7301}; 7302#endif; 7303 ; 7304 ; 7305static int; 7306is_put_or_delete_method(const struct mg_connection *conn); 7307{; 7308 if (conn) {; 7309 const char *s = conn->request_info.request_method;; 7310 return (s != NULL); 7311 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7312 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7313 }; 7314 return 0;; 7315}; 7316 ; 7317 ; 7318#if !defined(NO_FILES); 7319static int; 7320extention_matches_script(; 7321 struct mg_connection *conn, /* in: request (must be valid) */; 7322 const char *filename /* in: filename (must be valid) */; 7323); 7324{; 7325#if !defined(NO_CGI); 7326 unsigned char cgi_config_idx, inc, max;; 7327#endif; 7328 ; 7329#if defined(USE_LUA); 7330 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7331 filename); 7332 > 0) {; 7333 return 1;; 7334 }; 7335#endif; 7336#if defined(USE_DUKTAPE); 7337 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:210662,Modifiability,config,config,210662,"+ (c >> 2);; 7295 if (d != 255) {; 7296 dst[(*dst_len)++] = (c << 6) + d;; 7297 }; 7298 }; 7299 }; 7300 return -1;; 7301}; 7302#endif; 7303 ; 7304 ; 7305static int; 7306is_put_or_delete_method(const struct mg_connection *conn); 7307{; 7308 if (conn) {; 7309 const char *s = conn->request_info.request_method;; 7310 return (s != NULL); 7311 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7312 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7313 }; 7314 return 0;; 7315}; 7316 ; 7317 ; 7318#if !defined(NO_FILES); 7319static int; 7320extention_matches_script(; 7321 struct mg_connection *conn, /* in: request (must be valid) */; 7322 const char *filename /* in: filename (must be valid) */; 7323); 7324{; 7325#if !defined(NO_CGI); 7326 unsigned char cgi_config_idx, inc, max;; 7327#endif; 7328 ; 7329#if defined(USE_LUA); 7330 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7331 filename); 7332 > 0) {; 7333 return 1;; 7334 }; 7335#endif; 7336#if defined(USE_DUKTAPE); 7337 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:210763,Modifiability,config,config,210763,"+ (c >> 2);; 7295 if (d != 255) {; 7296 dst[(*dst_len)++] = (c << 6) + d;; 7297 }; 7298 }; 7299 }; 7300 return -1;; 7301}; 7302#endif; 7303 ; 7304 ; 7305static int; 7306is_put_or_delete_method(const struct mg_connection *conn); 7307{; 7308 if (conn) {; 7309 const char *s = conn->request_info.request_method;; 7310 return (s != NULL); 7311 && (!strcmp(s, ""PUT"") || !strcmp(s, ""DELETE""); 7312 || !strcmp(s, ""MKCOL"") || !strcmp(s, ""PATCH""));; 7313 }; 7314 return 0;; 7315}; 7316 ; 7317 ; 7318#if !defined(NO_FILES); 7319static int; 7320extention_matches_script(; 7321 struct mg_connection *conn, /* in: request (must be valid) */; 7322 const char *filename /* in: filename (must be valid) */; 7323); 7324{; 7325#if !defined(NO_CGI); 7326 unsigned char cgi_config_idx, inc, max;; 7327#endif; 7328 ; 7329#if defined(USE_LUA); 7330 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS],; 7331 filename); 7332 > 0) {; 7333 return 1;; 7334 }; 7335#endif; 7336#if defined(USE_DUKTAPE); 7337 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:211357,Modifiability,config,config,211357,"KTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#if defined(USE_LUA); 7372 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7373 filename); 7374 > 0) {; 7375 return 1;; 7376 }; 7377#endif; 7378 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7379 > 0) {; 7380 return 1;; 7381 }; 7382 return 0;; 7383}; 7384 ; 7385 ; 7386/* For given directory path, substitute it to valid index file.; 7387 * Return 1 if index file has been found, 0 if not found.; 7388 * If the file is found, it's stats is returned in stp. */; 7389static int; 7390substitute_index_file(struct mg_connection *conn,; 7391 char *path,; 7392 size_t path_len,; 7393 struct mg_file_stat *filestat); 7394{; 7395 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7396 struct vec filename_vec;; 7397 size_t n = strlen(path);; 7398 int found = 0;; 7399 ; 7400 /* The 'path' given to us points to the directory. Remove all trailing; 7401 * directory separator characters from the end of the path, and; 7402 * then append single directory separator character. */; 7403 while ((n > 0",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:211503,Modifiability,config,config,211503,"KTAPE_SCRIPT_EXTENSIONS],; 7338 filename); 7339 > 0) {; 7340 return 1;; 7341 }; 7342#endif; 7343#if !defined(NO_CGI); 7344 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 7345 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 7346 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 7347 if ((conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL); 7348 && (match_prefix_strlen(; 7349 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 7350 filename); 7351 > 0)) {; 7352 return 1;; 7353 }; 7354 }; 7355#endif; 7356 /* filename and conn could be unused, if all preocessor conditions; 7357 * are false (no script language supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#if defined(USE_LUA); 7372 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7373 filename); 7374 > 0) {; 7375 return 1;; 7376 }; 7377#endif; 7378 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7379 > 0) {; 7380 return 1;; 7381 }; 7382 return 0;; 7383}; 7384 ; 7385 ; 7386/* For given directory path, substitute it to valid index file.; 7387 * Return 1 if index file has been found, 0 if not found.; 7388 * If the file is found, it's stats is returned in stp. */; 7389static int; 7390substitute_index_file(struct mg_connection *conn,; 7391 char *path,; 7392 size_t path_len,; 7393 struct mg_file_stat *filestat); 7394{; 7395 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7396 struct vec filename_vec;; 7397 size_t n = strlen(path);; 7398 int found = 0;; 7399 ; 7400 /* The 'path' given to us points to the directory. Remove all trailing; 7401 * directory separator characters from the end of the path, and; 7402 * then append single directory separator character. */; 7403 while ((n > 0",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:212003,Modifiability,config,config,212003,"ge supported). */; 7358 (void)filename;; 7359 (void)conn;; 7360 ; 7361 return 0;; 7362}; 7363 ; 7364 ; 7365static int; 7366extention_matches_template_text(; 7367 struct mg_connection *conn, /* in: request (must be valid) */; 7368 const char *filename /* in: filename (must be valid) */; 7369); 7370{; 7371#if defined(USE_LUA); 7372 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 7373 filename); 7374 > 0) {; 7375 return 1;; 7376 }; 7377#endif; 7378 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], filename); 7379 > 0) {; 7380 return 1;; 7381 }; 7382 return 0;; 7383}; 7384 ; 7385 ; 7386/* For given directory path, substitute it to valid index file.; 7387 * Return 1 if index file has been found, 0 if not found.; 7388 * If the file is found, it's stats is returned in stp. */; 7389static int; 7390substitute_index_file(struct mg_connection *conn,; 7391 char *path,; 7392 size_t path_len,; 7393 struct mg_file_stat *filestat); 7394{; 7395 const char *list = conn->dom_ctx->config[INDEX_FILES];; 7396 struct vec filename_vec;; 7397 size_t n = strlen(path);; 7398 int found = 0;; 7399 ; 7400 /* The 'path' given to us points to the directory. Remove all trailing; 7401 * directory separator characters from the end of the path, and; 7402 * then append single directory separator character. */; 7403 while ((n > 0) && (path[n - 1] == '/')) {; 7404 n--;; 7405 }; 7406 path[n] = '/';; 7407 ; 7408 /* Traverse index files list. For each entry, append it to the given; 7409 * path and see if the file exists. If it exists, break the loop */; 7410 while ((list = next_option(list, &filename_vec, NULL)) != NULL) {; 7411 /* Ignore too long entries that may overflow path buffer */; 7412 if ((filename_vec.len + 1) > (path_len - (n + 1))) {; 7413 continue;; 7414 }; 7415 ; 7416 /* Prepare full path to the index file */; 7417 mg_strlcpy(path + n + 1, filename_vec.ptr, filename_vec.len + 1);; 7418 ; 7419 /* Does it exist? */; 7420 if (mg_stat(conn, path, filestat)) ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:214019,Modifiability,config,config,214019," */; 7447); 7448{; 7449 char const *accept_encoding;; 7450 ; 7451#if !defined(NO_FILES); 7452 const char *uri = conn->request_info.local_uri;; 7453 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7454 const char *rewrite;; 7455 struct vec a, b;; 7456 ptrdiff_t match_len;; 7457 char gz_path[UTF8_PATH_MAX];; 7458 int truncated;; 7459#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7460 char *tmp_str;; 7461 size_t tmp_str_len, sep_pos;; 7462 int allow_substitute_script_subresources;; 7463#endif; 7464#else; 7465 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7466#endif; 7467 ; 7468 /* Step 1: Set all initially unknown outputs to zero */; 7469 memset(filestat, 0, sizeof(*filestat));; 7470 *filename = 0;; 7471 *is_found = 0;; 7472 *is_script_resource = 0;; 7473 *is_template_text = 0;; 7474 ; 7475 /* Step 2: Check if the request attempts to modify the file system */; 7476 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7477 ; 7478 /* Step 3: Check if it is a websocket request, and modify the document; 7479 * root if required */; 7480#if defined(USE_WEBSOCKET); 7481 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7482#if !defined(NO_FILES); 7483 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7484 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7485 }; 7486#endif /* !NO_FILES */; 7487#else /* USE_WEBSOCKET */; 7488 *is_websocket_request = 0;; 7489#endif /* USE_WEBSOCKET */; 7490 ; 7491 /* Step 4: Check if gzip encoded response is allowed */; 7492 conn->accept_gzip = 0;; 7493 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:214060,Modifiability,rewrite,rewrite,214060," */; 7447); 7448{; 7449 char const *accept_encoding;; 7450 ; 7451#if !defined(NO_FILES); 7452 const char *uri = conn->request_info.local_uri;; 7453 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7454 const char *rewrite;; 7455 struct vec a, b;; 7456 ptrdiff_t match_len;; 7457 char gz_path[UTF8_PATH_MAX];; 7458 int truncated;; 7459#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7460 char *tmp_str;; 7461 size_t tmp_str_len, sep_pos;; 7462 int allow_substitute_script_subresources;; 7463#endif; 7464#else; 7465 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7466#endif; 7467 ; 7468 /* Step 1: Set all initially unknown outputs to zero */; 7469 memset(filestat, 0, sizeof(*filestat));; 7470 *filename = 0;; 7471 *is_found = 0;; 7472 *is_script_resource = 0;; 7473 *is_template_text = 0;; 7474 ; 7475 /* Step 2: Check if the request attempts to modify the file system */; 7476 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7477 ; 7478 /* Step 3: Check if it is a websocket request, and modify the document; 7479 * root if required */; 7480#if defined(USE_WEBSOCKET); 7481 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7482#if !defined(NO_FILES); 7483 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7484 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7485 }; 7486#endif /* !NO_FILES */; 7487#else /* USE_WEBSOCKET */; 7488 *is_websocket_request = 0;; 7489#endif /* USE_WEBSOCKET */; 7490 ; 7491 /* Step 4: Check if gzip encoded response is allowed */; 7492 conn->accept_gzip = 0;; 7493 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:215117,Modifiability,config,config,215117," */; 7447); 7448{; 7449 char const *accept_encoding;; 7450 ; 7451#if !defined(NO_FILES); 7452 const char *uri = conn->request_info.local_uri;; 7453 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7454 const char *rewrite;; 7455 struct vec a, b;; 7456 ptrdiff_t match_len;; 7457 char gz_path[UTF8_PATH_MAX];; 7458 int truncated;; 7459#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7460 char *tmp_str;; 7461 size_t tmp_str_len, sep_pos;; 7462 int allow_substitute_script_subresources;; 7463#endif; 7464#else; 7465 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7466#endif; 7467 ; 7468 /* Step 1: Set all initially unknown outputs to zero */; 7469 memset(filestat, 0, sizeof(*filestat));; 7470 *filename = 0;; 7471 *is_found = 0;; 7472 *is_script_resource = 0;; 7473 *is_template_text = 0;; 7474 ; 7475 /* Step 2: Check if the request attempts to modify the file system */; 7476 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7477 ; 7478 /* Step 3: Check if it is a websocket request, and modify the document; 7479 * root if required */; 7480#if defined(USE_WEBSOCKET); 7481 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7482#if !defined(NO_FILES); 7483 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7484 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7485 }; 7486#endif /* !NO_FILES */; 7487#else /* USE_WEBSOCKET */; 7488 *is_websocket_request = 0;; 7489#endif /* USE_WEBSOCKET */; 7490 ; 7491 /* Step 4: Check if gzip encoded response is allowed */; 7492 conn->accept_gzip = 0;; 7493 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:215171,Modifiability,config,config,215171," */; 7447); 7448{; 7449 char const *accept_encoding;; 7450 ; 7451#if !defined(NO_FILES); 7452 const char *uri = conn->request_info.local_uri;; 7453 const char *root = conn->dom_ctx->config[DOCUMENT_ROOT];; 7454 const char *rewrite;; 7455 struct vec a, b;; 7456 ptrdiff_t match_len;; 7457 char gz_path[UTF8_PATH_MAX];; 7458 int truncated;; 7459#if !defined(NO_CGI) || defined(USE_LUA) || defined(USE_DUKTAPE); 7460 char *tmp_str;; 7461 size_t tmp_str_len, sep_pos;; 7462 int allow_substitute_script_subresources;; 7463#endif; 7464#else; 7465 (void)filename_buf_len; /* unused if NO_FILES is defined */; 7466#endif; 7467 ; 7468 /* Step 1: Set all initially unknown outputs to zero */; 7469 memset(filestat, 0, sizeof(*filestat));; 7470 *filename = 0;; 7471 *is_found = 0;; 7472 *is_script_resource = 0;; 7473 *is_template_text = 0;; 7474 ; 7475 /* Step 2: Check if the request attempts to modify the file system */; 7476 *is_put_or_delete_request = is_put_or_delete_method(conn);; 7477 ; 7478 /* Step 3: Check if it is a websocket request, and modify the document; 7479 * root if required */; 7480#if defined(USE_WEBSOCKET); 7481 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7482#if !defined(NO_FILES); 7483 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7484 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7485 }; 7486#endif /* !NO_FILES */; 7487#else /* USE_WEBSOCKET */; 7488 *is_websocket_request = 0;; 7489#endif /* USE_WEBSOCKET */; 7490 ; 7491 /* Step 4: Check if gzip encoded response is allowed */; 7492 conn->accept_gzip = 0;; 7493 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:215864,Modifiability,config,config,215864,"/* Step 3: Check if it is a websocket request, and modify the document; 7479 * root if required */; 7480#if defined(USE_WEBSOCKET); 7481 *is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 7482#if !defined(NO_FILES); 7483 if (*is_websocket_request && conn->dom_ctx->config[WEBSOCKET_ROOT]) {; 7484 root = conn->dom_ctx->config[WEBSOCKET_ROOT];; 7485 }; 7486#endif /* !NO_FILES */; 7487#else /* USE_WEBSOCKET */; 7488 *is_websocket_request = 0;; 7489#endif /* USE_WEBSOCKET */; 7490 ; 7491 /* Step 4: Check if gzip encoded response is allowed */; 7492 conn->accept_gzip = 0;; 7493 if ((accept_encoding = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7503 * config is not required. */; 7504 if (root == NULL) {; 7505 /* all file related outputs have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 75",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:216487,Modifiability,rewrite,rewrite,216487,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7503 * config is not required. */; 7504 if (root == NULL) {; 7505 /* all file related outputs have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 7534 break;; 7535 }; 7536 }; 7537 ; 7538 if (truncated) {; 7539 goto interpret_cleanup;; 7540 }; 7541 ; 7542 /* Step 8: Check if the file exists at the server */; 7543 /* Local file path and name, corresponding to requested URI; 7544 * is now stored in ""filename"" variable. */; 7545 if (mg_stat(conn, filename, filestat)) {; 7546 int uri_len = (int)strlen(uri);; 7547 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7548 ; 7549 /* 8.1: File exists. */; 7550 *is_found = 1;; 7551 ; 7552 /* 8.2: Check if it is a script type. */; 7553 if (extention_matches_script(conn, filename)) {; 7554 /* The request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:216512,Modifiability,config,config,216512,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7503 * config is not required. */; 7504 if (root == NULL) {; 7505 /* all file related outputs have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 7534 break;; 7535 }; 7536 }; 7537 ; 7538 if (truncated) {; 7539 goto interpret_cleanup;; 7540 }; 7541 ; 7542 /* Step 8: Check if the file exists at the server */; 7543 /* Local file path and name, corresponding to requested URI; 7544 * is now stored in ""filename"" variable. */; 7545 if (mg_stat(conn, filename, filestat)) {; 7546 int uri_len = (int)strlen(uri);; 7547 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7548 ; 7549 /* 8.1: File exists. */; 7550 *is_found = 1;; 7551 ; 7552 /* 8.2: Check if it is a script type. */; 7553 if (extention_matches_script(conn, filename)) {; 7554 /* The request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:216555,Modifiability,rewrite,rewrite,216555,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7503 * config is not required. */; 7504 if (root == NULL) {; 7505 /* all file related outputs have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 7534 break;; 7535 }; 7536 }; 7537 ; 7538 if (truncated) {; 7539 goto interpret_cleanup;; 7540 }; 7541 ; 7542 /* Step 8: Check if the file exists at the server */; 7543 /* Local file path and name, corresponding to requested URI; 7544 * is now stored in ""filename"" variable. */; 7545 if (mg_stat(conn, filename, filestat)) {; 7546 int uri_len = (int)strlen(uri);; 7547 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7548 ; 7549 /* 8.1: File exists. */; 7550 *is_found = 1;; 7551 ; 7552 /* 8.2: Check if it is a script type. */; 7553 if (extention_matches_script(conn, filename)) {; 7554 /* The request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:216577,Modifiability,rewrite,rewrite,216577,"ing = mg_get_header(conn, ""Accept-Encoding"")) != NULL) {; 7494 if (strstr(accept_encoding, ""gzip"") != NULL) {; 7495 conn->accept_gzip = 1;; 7496 }; 7497 }; 7498 ; 7499#if !defined(NO_FILES); 7500 /* Step 5: If there is no root directory, don't look for files. */; 7501 /* Note that root == NULL is a regular use case here. This occurs,; 7502 * if all requests are handled by callbacks, so the WEBSOCKET_ROOT; 7503 * config is not required. */; 7504 if (root == NULL) {; 7505 /* all file related outputs have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 7534 break;; 7535 }; 7536 }; 7537 ; 7538 if (truncated) {; 7539 goto interpret_cleanup;; 7540 }; 7541 ; 7542 /* Step 8: Check if the file exists at the server */; 7543 /* Local file path and name, corresponding to requested URI; 7544 * is now stored in ""filename"" variable. */; 7545 if (mg_stat(conn, filename, filestat)) {; 7546 int uri_len = (int)strlen(uri);; 7547 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7548 ; 7549 /* 8.1: File exists. */; 7550 *is_found = 1;; 7551 ; 7552 /* 8.2: Check if it is a script type. */; 7553 if (extention_matches_script(conn, filename)) {; 7554 /* The request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:217091,Modifiability,variab,variable,217091,"ts have already been set to 0, just return; 7506 */; 7507 return;; 7508 }; 7509 ; 7510 /* Step 6: Determine the local file path from the root path and the; 7511 * request uri. */; 7512 /* Using filename_buf_len - 1 because memmove() for PATH_INFO may shift; 7513 * part of the path one byte on the right. */; 7514 truncated = 0;; 7515 mg_snprintf(; 7516 conn, &truncated, filename, filename_buf_len - 1, ""%s%s"", root, uri);; 7517 ; 7518 if (truncated) {; 7519 goto interpret_cleanup;; 7520 }; 7521 ; 7522 /* Step 7: URI rewriting */; 7523 rewrite = conn->dom_ctx->config[URL_REWRITE_PATTERN];; 7524 while ((rewrite = next_option(rewrite, &a, &b)) != NULL) {; 7525 if ((match_len = match_prefix(a.ptr, a.len, uri)) > 0) {; 7526 mg_snprintf(conn,; 7527 &truncated,; 7528 filename,; 7529 filename_buf_len - 1,; 7530 ""%.*s%s"",; 7531 (int)b.len,; 7532 b.ptr,; 7533 uri + match_len);; 7534 break;; 7535 }; 7536 }; 7537 ; 7538 if (truncated) {; 7539 goto interpret_cleanup;; 7540 }; 7541 ; 7542 /* Step 8: Check if the file exists at the server */; 7543 /* Local file path and name, corresponding to requested URI; 7544 * is now stored in ""filename"" variable. */; 7545 if (mg_stat(conn, filename, filestat)) {; 7546 int uri_len = (int)strlen(uri);; 7547 int is_uri_end_slash = (uri_len > 0) && (uri[uri_len - 1] == '/');; 7548 ; 7549 /* 8.1: File exists. */; 7550 *is_found = 1;; 7551 ; 7552 /* 8.2: Check if it is a script type. */; 7553 if (extention_matches_script(conn, filename)) {; 7554 /* The request addresses a CGI resource, Lua script or; 7555 * server-side javascript.; 7556 * The URI corresponds to the script itself (like; 7557 * /path/script.cgi), and there is no additional resource; 7558 * path (like /path/script.cgi/something).; 7559 * Requests that modify (replace or delete) a resource, like; 7560 * PUT and DELETE requests, should replace/delete the script; 7561 * file.; 7562 * Requests that read or write from/to a resource, like GET and; 7563 * POST requests, should call the script a",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:221040,Modifiability,config,config,221040,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:221172,Modifiability,config,config,221172,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:236111,Modifiability,config,config,236111,"(path_len - builtin_mime_types[i].ext_len);; 8145 if ((path_len > builtin_mime_types[i].ext_len); 8146 && (mg_strcasecmp(ext, builtin_mime_types[i].extension) == 0)) {; 8147 return builtin_mime_types[i].mime_type;; 8148 }; 8149 }; 8150 ; 8151 return ""text/plain"";; 8152}; 8153 ; 8154 ; 8155/* Look at the ""path"" extension and figure what mime type it has.; 8156 * Store mime type in the vector. */; 8157static void; 8158get_mime_type(struct mg_connection *conn, const char *path, struct vec *vec); 8159{; 8160 struct vec ext_vec, mime_vec;; 8161 const char *list, *ext;; 8162 size_t path_len;; 8163 ; 8164 path_len = strlen(path);; 8165 ; 8166 if ((conn == NULL) || (vec == NULL)) {; 8167 if (vec != NULL) {; 8168 memset(vec, '\0', sizeof(struct vec));; 8169 }; 8170 return;; 8171 }; 8172 ; 8173 /* Scan user-defined mime types first, in case user wants to; 8174 * override default mime types. */; 8175 list = conn->dom_ctx->config[EXTRA_MIME_TYPES];; 8176 while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {; 8177 /* ext now points to the path suffix */; 8178 ext = path + path_len - ext_vec.len;; 8179 if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {; 8180 *vec = mime_vec;; 8181 return;; 8182 }; 8183 }; 8184 ; 8185 vec->ptr = mg_get_builtin_mime_type(path);; 8186 vec->len = strlen(vec->ptr);; 8187}; 8188 ; 8189 ; 8190/* Stringify binary data. Output buffer must be twice as big as input,; 8191 * because each byte takes 2 bytes in string representation */; 8192static void; 8193bin2str(char *to, const unsigned char *p, size_t len); 8194{; 8195 static const char *hex = ""0123456789abcdef"";; 8196 ; 8197 for (; len--; p++) {; 8198 *to++ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:238925,Modifiability,config,config,238925,"| (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char name[UTF8_PATH_MAX];; 8282 const char *p, *e,; 8283 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8284 int truncated;; 8285 ; 8286 if (gpass != NULL) {; 8287 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:239200,Modifiability,config,configured,239200,"| (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char name[UTF8_PATH_MAX];; 8282 const char *p, *e,; 8283 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8284 int truncated;; 8285 ; 8286 if (gpass != NULL) {; 8287 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:249030,Modifiability,config,config,249030,"07 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250239,Modifiability,config,config,250239,"uth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:251540,Modifiability,config,config,251540," }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,; 8752 buf,; 8753 sizeof(buf),; 8754 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8755 ""nonce=\""%"" UINT64_FMT ""\"""",; 8756 realm,; 8757 nonce);; 8758 ; 8759 if (!trunc) {; 8760 /* !trunc should always be true */; 8761 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8762 }; 8763 ; 8764 /* Send all headers */; 8765 mg_response_header_send(conn);; 8766}; 8767 ; 8768 ; 8769/* Interface function. Parameters are provided by the user, so do; 8770 * at least some basic checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:253108,Modifiability,config,config,253108,"conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,; 8752 buf,; 8753 sizeof(buf),; 8754 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8755 ""nonce=\""%"" UINT64_FMT ""\"""",; 8756 realm,; 8757 nonce);; 8758 ; 8759 if (!trunc) {; 8760 /* !trunc should always be true */; 8761 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8762 }; 8763 ; 8764 /* Send all headers */; 8765 mg_response_header_send(conn);; 8766}; 8767 ; 8768 ; 8769/* Interface function. Parameters are provided by the user, so do; 8770 * at least some basic checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:270821,Modifiability,config,config,270821,"se if (!a->file.is_directory && b->file.is_directory) {; 9414 return 1; /* Always put directories on top */; 9415 } else if (*query_string == 'n') {; 9416 cmp_result = strcmp(a->file_name, b->file_name);; 9417 } else if (*query_string == 's') {; 9418 cmp_result = (a->file.size == b->file.size); 9419 ? 0; 9420 : ((a->file.size > b->file.size) ? 1 : -1);; 9421 } else if (*query_string == 'd') {; 9422 cmp_result =; 9423 (a->file.last_modified == b->file.last_modified); 9424 ? 0; 9425 : ((a->file.last_modified > b->file.last_modified) ? 1; 9426 : -1);; 9427 }; 9428 ; 9429 return (query_string[1] == 'd') ? -cmp_result : cmp_result;; 9430 }; 9431 return 0;; 9432}; 9433 ; 9434 ; 9435static int; 9436must_hide_file(struct mg_connection *conn, const char *path); 9437{; 9438 if (conn && conn->dom_ctx) {; 9439 const char *pw_pattern = ""**"" PASSWORDS_FILE_NAME ""$"";; 9440 const char *pattern = conn->dom_ctx->config[HIDE_FILES];; 9441 return (match_prefix_strlen(pw_pattern, path) > 0); 9442 || (match_prefix_strlen(pattern, path) > 0);; 9443 }; 9444 return 0;; 9445}; 9446 ; 9447 ; 9448#if !defined(NO_FILESYSTEMS); 9449static int; 9450scan_directory(struct mg_connection *conn,; 9451 const char *dir,; 9452 void *data,; 9453 int (*cb)(struct de *, void *)); 9454{; 9455 char path[UTF8_PATH_MAX];; 9456 struct dirent *dp;; 9457 DIR *dirp;; 9458 struct de de;; 9459 int truncated;; 9460 ; 9461 if ((dirp = mg_opendir(conn, dir)) == NULL) {; 9462 return 0;; 9463 } else {; 9464 de.conn = conn;; 9465 ; 9466 while ((dp = mg_readdir(dirp)) != NULL) {; 9467 /* Do not show current dir and hidden files */; 9468 if (!strcmp(dp->d_name, ""."") || !strcmp(dp->d_name, ""..""); 9469 || must_hide_file(conn, dp->d_name)) {; 9470 continue;; 9471 }; 9472 ; 9473 mg_snprintf(; 9474 conn, &truncated, path, sizeof(path), ""%s/%s"", dir, dp->d_name);; 9475 ; 9476 /* If we don't memset stat structure to zero, mtime will have; 9477 * garbage and strftime() will segfault later on in; 9478 * print_dir_entry(). memset is re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:279300,Modifiability,config,config,279300,"ntries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:284626,Modifiability,rewrite,rewrite,284626,"too small or a; 9906 * ""range"" request was made, on the fly compression is not possible. */; 9907 int allow_on_the_fly_compression = 1;; 9908#endif; 9909 ; 9910 if ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {; 9911 return;; 9912 }; 9913 ; 9914 is_head_request = !strcmp(conn->request_info.request_method, ""HEAD"");; 9915 ; 9916 if (mime_type == NULL) {; 9917 get_mime_type(conn, path, &mime_vec);; 9918 } else {; 9919 mime_vec.ptr = mime_type;; 9920 mime_vec.len = strlen(mime_type);; 9921 }; 9922 if (filep->stat.size > INT64_MAX) {; 9923 mg_send_http_error(conn,; 9924 500,; 9925 ""Error: File size is too large to send\n%"" INT64_FMT,; 9926 filep->stat.size);; 9927 return;; 9928 }; 9929 cl = (int64_t)filep->stat.size;; 9930 conn->status_code = 200;; 9931 range[0] = '\0';; 9932 ; 9933#if defined(USE_ZLIB); 9934 /* if this file is in fact a pre-gzipped file, rewrite its filename; 9935 * it's important to rewrite the filename after resolving; 9936 * the mime type from it, to preserve the actual file's type */; 9937 if (!conn->accept_gzip) {; 9938 allow_on_the_fly_compression = 0;; 9939 }; 9940#endif; 9941 ; 9942 /* Check if there is a range header */; 9943 range_hdr = mg_get_header(conn, ""Range"");; 9944 ; 9945 /* For gzipped files, add *.gz */; 9946 if (filep->stat.is_gzipped) {; 9947 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9948 ; 9949 if (truncated) {; 9950 mg_send_http_error(conn,; 9951 500,; 9952 ""Error: Path of zipped file too long (%s)"",; 9953 path);; 9954 return;; 9955 }; 9956 ; 9957 path = gz_path;; 9958 encoding = ""gzip"";; 9959 ; 9960#if defined(USE_ZLIB); 9961 /* File is already compressed. No ""on the fly"" compression. */; 9962 allow_on_the_fly_compression = 0;; 9963#endif; 9964 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9965 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9966 struct mg_file_stat file_stat;; 9967 ; 9968 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:284673,Modifiability,rewrite,rewrite,284673,"too small or a; 9906 * ""range"" request was made, on the fly compression is not possible. */; 9907 int allow_on_the_fly_compression = 1;; 9908#endif; 9909 ; 9910 if ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {; 9911 return;; 9912 }; 9913 ; 9914 is_head_request = !strcmp(conn->request_info.request_method, ""HEAD"");; 9915 ; 9916 if (mime_type == NULL) {; 9917 get_mime_type(conn, path, &mime_vec);; 9918 } else {; 9919 mime_vec.ptr = mime_type;; 9920 mime_vec.len = strlen(mime_type);; 9921 }; 9922 if (filep->stat.size > INT64_MAX) {; 9923 mg_send_http_error(conn,; 9924 500,; 9925 ""Error: File size is too large to send\n%"" INT64_FMT,; 9926 filep->stat.size);; 9927 return;; 9928 }; 9929 cl = (int64_t)filep->stat.size;; 9930 conn->status_code = 200;; 9931 range[0] = '\0';; 9932 ; 9933#if defined(USE_ZLIB); 9934 /* if this file is in fact a pre-gzipped file, rewrite its filename; 9935 * it's important to rewrite the filename after resolving; 9936 * the mime type from it, to preserve the actual file's type */; 9937 if (!conn->accept_gzip) {; 9938 allow_on_the_fly_compression = 0;; 9939 }; 9940#endif; 9941 ; 9942 /* Check if there is a range header */; 9943 range_hdr = mg_get_header(conn, ""Range"");; 9944 ; 9945 /* For gzipped files, add *.gz */; 9946 if (filep->stat.is_gzipped) {; 9947 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9948 ; 9949 if (truncated) {; 9950 mg_send_http_error(conn,; 9951 500,; 9952 ""Error: Path of zipped file too long (%s)"",; 9953 path);; 9954 return;; 9955 }; 9956 ; 9957 path = gz_path;; 9958 encoding = ""gzip"";; 9959 ; 9960#if defined(USE_ZLIB); 9961 /* File is already compressed. No ""on the fly"" compression. */; 9962 allow_on_the_fly_compression = 0;; 9963#endif; 9964 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9965 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9966 struct mg_file_stat file_stat;; 9967 ; 9968 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:288035,Modifiability,config,config,288035,"ep->access); /* ignore error on read only file */; 10012 return;; 10013 }; 10014 conn->status_code = 206;; 10015 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10016 mg_snprintf(conn,; 10017 NULL, /* range buffer is big enough */; 10018 range,; 10019 sizeof(range),; 10020 ""bytes ""; 10021 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10022 r1,; 10023 r1 + cl - 1,; 10024 filep->stat.size);; 10025 ; 10026#if defined(USE_ZLIB); 10027 /* Do not compress ranges. */; 10028 allow_on_the_fly_compression = 0;; 10029#endif; 10030 }; 10031 ; 10032 /* Do not compress small files. Small files do not benefit from file; 10033 * compression, but there is still some overhead. */; 10034#if defined(USE_ZLIB); 10035 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10036 /* File is below the size limit. */; 10037 allow_on_the_fly_compression = 0;; 10038 }; 10039#endif; 10040 ; 10041 /* Standard CORS header */; 10042 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10043 origin_hdr = mg_get_header(conn, ""Origin"");; 10044 if (cors_orig_cfg && *cors_orig_cfg && origin_hdr) {; 10045 /* Cross-origin resource sharing (CORS), see; 10046 * http://www.html5rocks.com/en/tutorials/cors/,; 10047 * http://www.html5rocks.com/static/images/cors_server_flowchart.png; 10048 * -; 10049 * preflight is not supported for files. */; 10050 cors1 = ""Access-Control-Allow-Origin"";; 10051 cors2 = cors_orig_cfg;; 10052 } else {; 10053 cors1 = cors2 = """";; 10054 }; 10055 ; 10056 /* Credentials CORS header */; 10057 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 10058 if (cors_cred_cfg && *cors_cred_cfg && origin_hdr) {; 10059 cors3 = ""Access-Control-Allow-Credentials"";; 10060 cors4 = cors_cred_cfg;; 10061 } else {; 10062 cors3 = cors4 = """";; 10063 }; 10064 ; 10065 /* Prepare Etag, and Last-Modified headers. */; 10066 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10067 construct_etag(etag, sizeof(etag), &filep->stat);; 10068 ; 1006",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:288637,Modifiability,config,config,288637,"not benefit from file; 10033 * compression, but there is still some overhead. */; 10034#if defined(USE_ZLIB); 10035 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10036 /* File is below the size limit. */; 10037 allow_on_the_fly_compression = 0;; 10038 }; 10039#endif; 10040 ; 10041 /* Standard CORS header */; 10042 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10043 origin_hdr = mg_get_header(conn, ""Origin"");; 10044 if (cors_orig_cfg && *cors_orig_cfg && origin_hdr) {; 10045 /* Cross-origin resource sharing (CORS), see; 10046 * http://www.html5rocks.com/en/tutorials/cors/,; 10047 * http://www.html5rocks.com/static/images/cors_server_flowchart.png; 10048 * -; 10049 * preflight is not supported for files. */; 10050 cors1 = ""Access-Control-Allow-Origin"";; 10051 cors2 = cors_orig_cfg;; 10052 } else {; 10053 cors1 = cors2 = """";; 10054 }; 10055 ; 10056 /* Credentials CORS header */; 10057 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 10058 if (cors_cred_cfg && *cors_cred_cfg && origin_hdr) {; 10059 cors3 = ""Access-Control-Allow-Credentials"";; 10060 cors4 = cors_cred_cfg;; 10061 } else {; 10062 cors3 = cors4 = """";; 10063 }; 10064 ; 10065 /* Prepare Etag, and Last-Modified headers. */; 10066 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10067 construct_etag(etag, sizeof(etag), &filep->stat);; 10068 ; 10069 /* Create 2xx (200, 206) response */; 10070 mg_response_header_start(conn, conn->status_code);; 10071 send_static_cache_header(conn);; 10072 send_additional_header(conn);; 10073 mg_response_header_add(conn,; 10074 ""Content-Type"",; 10075 mime_vec.ptr,; 10076 (int)mime_vec.len);; 10077 if (cors1[0] != 0) {; 10078 mg_response_header_add(conn, cors1, cors2, -1);; 10079 }; 10080 if (cors3[0] != 0) {; 10081 mg_response_header_add(conn, cors3, cors4, -1);; 10082 }; 10083 mg_response_header_add(conn, ""Last-Modified"", lm, -1);; 10084 mg_response_header_add(conn, ""Etag"", etag, -1);; 10085 ; 10086#if defin",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:294628,Modifiability,config,config,294628,"16{; 10217 mg_send_mime_file2(conn, path, mime_type, NULL);; 10218}; 10219 ; 10220 ; 10221void; 10222mg_send_mime_file2(struct mg_connection *conn,; 10223 const char *path,; 10224 const char *mime_type,; 10225 const char *additional_headers); 10226{; 10227 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10228 ; 10229 if (!conn) {; 10230 /* No conn */; 10231 return;; 10232 }; 10233 ; 10234 if (mg_stat(conn, path, &file.stat)) {; 10235#if !defined(NO_CACHING); 10236 if (is_not_modified(conn, &file.stat)) {; 10237 /* Send 304 ""Not Modified"" - this must not send any body data */; 10238 handle_not_modified_static_file_request(conn, &file);; 10239 } else; 10240#endif /* NO_CACHING */; 10241 if (file.stat.is_directory) {; 10242 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 10243 ""yes"")) {; 10244 handle_directory_request(conn, path);; 10245 } else {; 10246 mg_send_http_error(conn,; 10247 403,; 10248 ""%s"",; 10249 ""Error: Directory listing denied"");; 10250 }; 10251 } else {; 10252 handle_static_file_request(; 10253 conn, path, &file, mime_type, additional_headers);; 10254 }; 10255 } else {; 10256 mg_send_http_error(conn, 404, ""%s"", ""Error: File not found"");; 10257 }; 10258}; 10259 ; 10260 ; 10261/* For a given PUT path, create all intermediate subdirectories.; 10262 * Return 0 if the path itself is a directory.; 10263 * Return 1 if the path leads to a file.; 10264 * Return -1 for if the path is too long.; 10265 * Return -2 if path can not be created.; 10266 */; 10267static int; 10268put_dir(struct mg_connection *conn, const char *path); 10269{; 10270 char buf[UTF8_PATH_MAX];; 10271 const char *s, *p;; 10272 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10273 size_t len;; 10274 int res = 1;; 10275 ; 10276 for (s = p = path + 2; (p = strchr(s, '/')) != NULL; s = ++p) {; 10277 len = (size_t)(p - path);; 10278 if (len >= sizeof(buf)) {; 10279 /* path too long */; 10280 res = -1;; 10281 break;; 10282 }; 10283 memcpy(buf, path, len);; 10284 buf[len] = '\0';",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:311158,Modifiability,config,config,311158,"har)*buf));; 10780 ; 10781 ; 10782 /* Parse all HTTP headers */; 10783 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10784 if (ri->num_headers < 0) {; 10785 /* Error while parsing headers */; 10786 return -1;; 10787 }; 10788 ; 10789 return response_length + init_skip;; 10790}; 10791 ; 10792 ; 10793/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10794 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10795 * buffer (which marks the end of HTTP request). Buffer buf may already; 10796 * have some data. The length of the data is stored in nread.; 10797 * Upon every read operation, increase nread by the number of bytes read. */; 10798static int; 10799read_message(FILE *fp,; 10800 struct mg_connection *conn,; 10801 char *buf,; 10802 int bufsiz,; 10803 int *nread); 10804{; 10805 int request_len, n = 0;; 10806 struct timespec last_action_time;; 10807 double request_timeout;; 10808 ; 10809 if (!conn) {; 10810 return 0;; 10811 }; 10812 ; 10813 memset(&last_action_time, 0, sizeof(last_action_time));; 10814 ; 10815 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10816 /* value of request_timeout is in seconds, config in milliseconds */; 10817 request_timeout =; 10818 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10819 } else {; 10820 request_timeout =; 10821 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10822 / 1000.0;; 10823 }; 10824 if (conn->handled_requests > 0) {; 10825 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10826 request_timeout =; 10827 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10828 / 1000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:311235,Modifiability,config,config,311235,"har)*buf));; 10780 ; 10781 ; 10782 /* Parse all HTTP headers */; 10783 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10784 if (ri->num_headers < 0) {; 10785 /* Error while parsing headers */; 10786 return -1;; 10787 }; 10788 ; 10789 return response_length + init_skip;; 10790}; 10791 ; 10792 ; 10793/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10794 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10795 * buffer (which marks the end of HTTP request). Buffer buf may already; 10796 * have some data. The length of the data is stored in nread.; 10797 * Upon every read operation, increase nread by the number of bytes read. */; 10798static int; 10799read_message(FILE *fp,; 10800 struct mg_connection *conn,; 10801 char *buf,; 10802 int bufsiz,; 10803 int *nread); 10804{; 10805 int request_len, n = 0;; 10806 struct timespec last_action_time;; 10807 double request_timeout;; 10808 ; 10809 if (!conn) {; 10810 return 0;; 10811 }; 10812 ; 10813 memset(&last_action_time, 0, sizeof(last_action_time));; 10814 ; 10815 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10816 /* value of request_timeout is in seconds, config in milliseconds */; 10817 request_timeout =; 10818 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10819 } else {; 10820 request_timeout =; 10821 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10822 / 1000.0;; 10823 }; 10824 if (conn->handled_requests > 0) {; 10825 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10826 request_timeout =; 10827 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10828 / 1000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:311315,Modifiability,config,config,311315,"har)*buf));; 10780 ; 10781 ; 10782 /* Parse all HTTP headers */; 10783 ri->num_headers = parse_http_headers(&buf, ri->http_headers);; 10784 if (ri->num_headers < 0) {; 10785 /* Error while parsing headers */; 10786 return -1;; 10787 }; 10788 ; 10789 return response_length + init_skip;; 10790}; 10791 ; 10792 ; 10793/* Keep reading the input (either opened file descriptor fd, or socket sock,; 10794 * or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the; 10795 * buffer (which marks the end of HTTP request). Buffer buf may already; 10796 * have some data. The length of the data is stored in nread.; 10797 * Upon every read operation, increase nread by the number of bytes read. */; 10798static int; 10799read_message(FILE *fp,; 10800 struct mg_connection *conn,; 10801 char *buf,; 10802 int bufsiz,; 10803 int *nread); 10804{; 10805 int request_len, n = 0;; 10806 struct timespec last_action_time;; 10807 double request_timeout;; 10808 ; 10809 if (!conn) {; 10810 return 0;; 10811 }; 10812 ; 10813 memset(&last_action_time, 0, sizeof(last_action_time));; 10814 ; 10815 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10816 /* value of request_timeout is in seconds, config in milliseconds */; 10817 request_timeout =; 10818 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10819 } else {; 10820 request_timeout =; 10821 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10822 / 1000.0;; 10823 }; 10824 if (conn->handled_requests > 0) {; 10825 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10826 request_timeout =; 10827 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10828 / 1000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:311557,Modifiability,config,config,311557," buf may already; 10796 * have some data. The length of the data is stored in nread.; 10797 * Upon every read operation, increase nread by the number of bytes read. */; 10798static int; 10799read_message(FILE *fp,; 10800 struct mg_connection *conn,; 10801 char *buf,; 10802 int bufsiz,; 10803 int *nread); 10804{; 10805 int request_len, n = 0;; 10806 struct timespec last_action_time;; 10807 double request_timeout;; 10808 ; 10809 if (!conn) {; 10810 return 0;; 10811 }; 10812 ; 10813 memset(&last_action_time, 0, sizeof(last_action_time));; 10814 ; 10815 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10816 /* value of request_timeout is in seconds, config in milliseconds */; 10817 request_timeout =; 10818 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10819 } else {; 10820 request_timeout =; 10821 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10822 / 1000.0;; 10823 }; 10824 if (conn->handled_requests > 0) {; 10825 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10826 request_timeout =; 10827 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10828 / 1000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_ac",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:311641,Modifiability,config,config,311641," buf may already; 10796 * have some data. The length of the data is stored in nread.; 10797 * Upon every read operation, increase nread by the number of bytes read. */; 10798static int; 10799read_message(FILE *fp,; 10800 struct mg_connection *conn,; 10801 char *buf,; 10802 int bufsiz,; 10803 int *nread); 10804{; 10805 int request_len, n = 0;; 10806 struct timespec last_action_time;; 10807 double request_timeout;; 10808 ; 10809 if (!conn) {; 10810 return 0;; 10811 }; 10812 ; 10813 memset(&last_action_time, 0, sizeof(last_action_time));; 10814 ; 10815 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 10816 /* value of request_timeout is in seconds, config in milliseconds */; 10817 request_timeout =; 10818 strtod(conn->dom_ctx->config[REQUEST_TIMEOUT], NULL) / 1000.0;; 10819 } else {; 10820 request_timeout =; 10821 strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 10822 / 1000.0;; 10823 }; 10824 if (conn->handled_requests > 0) {; 10825 if (conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT]) {; 10826 request_timeout =; 10827 strtod(conn->dom_ctx->config[KEEP_ALIVE_TIMEOUT], NULL); 10828 / 1000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_ac",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:315650,Modifiability,variab,variables,315650,"0936 ; 10937#if defined(USE_TIMERS); 10938 ; 10939#define TIMER_API static; 10940#include ""timer.inl""; 10941 ; 10942#endif /* USE_TIMERS */; 10943 ; 10944 ; 10945#if !defined(NO_CGI); 10946/* This structure helps to create an environment for the spawned CGI; 10947 * program.; 10948 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10949 * last element must be NULL.; 10950 * However, on Windows there is a requirement that all these; 10951 * VARIABLE=VALUE\0; 10952 * strings must reside in a contiguous buffer. The end of the buffer is; 10953 * marked by two '\0' characters.; 10954 * We satisfy both worlds: we create an envp array (which is vars), all; 10955 * entries are actually pointers inside buf. */; 10956struct cgi_environment {; 10957 struct mg_connection *conn;; 10958 /* Data block */; 10959 char *buf; /* Environment buffer */; 10960 size_t buflen; /* Space available in buf */; 10961 size_t bufused; /* Space taken in buf */; 10962 /* Index block */; 10963 char **var; /* char **envp */; 10964 size_t varlen; /* Number of variables available in var */; 10965 size_t varused; /* Number of variables stored in var */; 10966};; 10967 ; 10968 ; 10969static void addenv(struct cgi_environment *env,; 10970 PRINTF_FORMAT_STRING(const char *fmt),; 10971 ...) PRINTF_ARGS(2, 3);; 10972 ; 10973/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10974 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10975static void; 10976addenv(struct cgi_environment *env, const char *fmt, ...); 10977{; 10978 size_t i, n, space;; 10979 int truncated = 0;; 10980 char *added;; 10981 va_list ap;; 10982 ; 10983 if ((env->varlen - env->varused) < 2) {; 10984 mg_cry_internal(env->conn,; 10985 ""%s: Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:315716,Modifiability,variab,variables,315716,"0936 ; 10937#if defined(USE_TIMERS); 10938 ; 10939#define TIMER_API static; 10940#include ""timer.inl""; 10941 ; 10942#endif /* USE_TIMERS */; 10943 ; 10944 ; 10945#if !defined(NO_CGI); 10946/* This structure helps to create an environment for the spawned CGI; 10947 * program.; 10948 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10949 * last element must be NULL.; 10950 * However, on Windows there is a requirement that all these; 10951 * VARIABLE=VALUE\0; 10952 * strings must reside in a contiguous buffer. The end of the buffer is; 10953 * marked by two '\0' characters.; 10954 * We satisfy both worlds: we create an envp array (which is vars), all; 10955 * entries are actually pointers inside buf. */; 10956struct cgi_environment {; 10957 struct mg_connection *conn;; 10958 /* Data block */; 10959 char *buf; /* Environment buffer */; 10960 size_t buflen; /* Space available in buf */; 10961 size_t bufused; /* Space taken in buf */; 10962 /* Index block */; 10963 char **var; /* char **envp */; 10964 size_t varlen; /* Number of variables available in var */; 10965 size_t varused; /* Number of variables stored in var */; 10966};; 10967 ; 10968 ; 10969static void addenv(struct cgi_environment *env,; 10970 PRINTF_FORMAT_STRING(const char *fmt),; 10971 ...) PRINTF_ARGS(2, 3);; 10972 ; 10973/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10974 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10975static void; 10976addenv(struct cgi_environment *env, const char *fmt, ...); 10977{; 10978 size_t i, n, space;; 10979 int truncated = 0;; 10980 char *added;; 10981 va_list ap;; 10982 ; 10983 if ((env->varlen - env->varused) < 2) {; 10984 mg_cry_internal(env->conn,; 10985 ""%s: Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:316364,Modifiability,variab,variable,316364,"ion *conn;; 10958 /* Data block */; 10959 char *buf; /* Environment buffer */; 10960 size_t buflen; /* Space available in buf */; 10961 size_t bufused; /* Space taken in buf */; 10962 /* Index block */; 10963 char **var; /* char **envp */; 10964 size_t varlen; /* Number of variables available in var */; 10965 size_t varused; /* Number of variables stored in var */; 10966};; 10967 ; 10968 ; 10969static void addenv(struct cgi_environment *env,; 10970 PRINTF_FORMAT_STRING(const char *fmt),; 10971 ...) PRINTF_ARGS(2, 3);; 10972 ; 10973/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10974 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10975static void; 10976addenv(struct cgi_environment *env, const char *fmt, ...); 10977{; 10978 size_t i, n, space;; 10979 int truncated = 0;; 10980 char *added;; 10981 va_list ap;; 10982 ; 10983 if ((env->varlen - env->varused) < 2) {; 10984 mg_cry_internal(env->conn,; 10985 ""%s: Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is always needed. */; 10996 if (space <= 2) {; 10997 /* Allocate new buffer */; 10998 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10999 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 11000 if (!added) {; 11001 /* Out of memory */; 11002 mg_cry_internal(; 11003 env->conn,; 11004 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11005 __func__,; 11006 fmt);; 11007 return;; 11008 }; 11009 /* Retarget pointers */; 11010 env->buf = added;; 11011 env->buflen = n;; 11012 for (i = 0, n = 0; i < env->varused; i++) {; 11013 env->var[i] = added + n;; 11014 n += strlen(added + n) + 1;; 11015 }; 11016 space = (env->buflen - env->bufused);; 11017 }; 11018 ; 11019 /* Make a pointer to the free space int the buffer */; 11020 added = env->buf + env->bufused;; 11021 ; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:316926,Modifiability,variab,variable,316926,"Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is always needed. */; 10996 if (space <= 2) {; 10997 /* Allocate new buffer */; 10998 n = env->buflen + CGI_ENVIRONMENT_SIZE;; 10999 added = (char *)mg_realloc_ctx(env->buf, n, env->conn->phys_ctx);; 11000 if (!added) {; 11001 /* Out of memory */; 11002 mg_cry_internal(; 11003 env->conn,; 11004 ""%s: Cannot allocate memory for CGI variable [%s]"",; 11005 __func__,; 11006 fmt);; 11007 return;; 11008 }; 11009 /* Retarget pointers */; 11010 env->buf = added;; 11011 env->buflen = n;; 11012 for (i = 0, n = 0; i < env->varused; i++) {; 11013 env->var[i] = added + n;; 11014 n += strlen(added + n) + 1;; 11015 }; 11016 space = (env->buflen - env->bufused);; 11017 }; 11018 ; 11019 /* Make a pointer to the free space int the buffer */; 11020 added = env->buf + env->bufused;; 11021 ; 11022 /* Copy VARIABLE=VALUE\0 string into the free space */; 11023 va_start(ap, fmt);; 11024 mg_vsnprintf(env->conn, &truncated, added, space - 1, fmt, ap);; 11025 va_end(ap);; 11026 ; 11027 /* Do not add truncated strings to the environment */; 11028 if (truncated) {; 11029 /* Reallocate the buffer */; 11030 space = 0;; 11031 }; 11032 } while (truncated);; 11033 ; 11034 /* Calculate number of bytes added to the environment */; 11035 n = strlen(added) + 1;; 11036 env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:319117,Modifiability,variab,variables,319117,"env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11054 int i, truncated, uri_len;; 11055 ; 11056 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11057 return -1;; 11058 }; 11059 ; 11060 env->conn = conn;; 11061 env->buflen = CGI_ENVIRONMENT_SIZE;; 11062 env->bufused = 0;; 11063 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11064 if (env->buf == NULL) {; 11065 mg_cry_internal(conn,; 11066 ""%s: Not enough memory for environmental buffer"",; 11067 __func__);; 11068 return -1;; 11069 }; 11070 env->varlen = MAX_CGI_ENVIR_VARS;; 11071 env->varused = 0;; 11072 env->var =; 11073 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11074 if (env->var == NULL) {; 11075 mg_cry_internal(conn,; 11076 ""%s: Not enough memory for environmental variables"",; 11077 __func__);; 11078 mg_free(env->buf);; 11079 return -1;; 11080 }; 11081 ; 11082 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11083 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11085 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11086 ; 11087 /* Prepare the environment block */; 11088 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11089 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11090 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11091 ; 11092 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11093 ; 11094 sockaddr_to_string",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:319260,Modifiability,config,config,319260,"env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11054 int i, truncated, uri_len;; 11055 ; 11056 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11057 return -1;; 11058 }; 11059 ; 11060 env->conn = conn;; 11061 env->buflen = CGI_ENVIRONMENT_SIZE;; 11062 env->bufused = 0;; 11063 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11064 if (env->buf == NULL) {; 11065 mg_cry_internal(conn,; 11066 ""%s: Not enough memory for environmental buffer"",; 11067 __func__);; 11068 return -1;; 11069 }; 11070 env->varlen = MAX_CGI_ENVIR_VARS;; 11071 env->varused = 0;; 11072 env->var =; 11073 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11074 if (env->var == NULL) {; 11075 mg_cry_internal(conn,; 11076 ""%s: Not enough memory for environmental variables"",; 11077 __func__);; 11078 mg_free(env->buf);; 11079 return -1;; 11080 }; 11081 ; 11082 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11083 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11085 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11086 ; 11087 /* Prepare the environment block */; 11088 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11089 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11090 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11091 ; 11092 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11093 ; 11094 sockaddr_to_string",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:319344,Modifiability,config,config,319344,"env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11054 int i, truncated, uri_len;; 11055 ; 11056 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11057 return -1;; 11058 }; 11059 ; 11060 env->conn = conn;; 11061 env->buflen = CGI_ENVIRONMENT_SIZE;; 11062 env->bufused = 0;; 11063 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11064 if (env->buf == NULL) {; 11065 mg_cry_internal(conn,; 11066 ""%s: Not enough memory for environmental buffer"",; 11067 __func__);; 11068 return -1;; 11069 }; 11070 env->varlen = MAX_CGI_ENVIR_VARS;; 11071 env->varused = 0;; 11072 env->var =; 11073 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11074 if (env->var == NULL) {; 11075 mg_cry_internal(conn,; 11076 ""%s: Not enough memory for environmental variables"",; 11077 __func__);; 11078 mg_free(env->buf);; 11079 return -1;; 11080 }; 11081 ; 11082 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11083 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11085 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11086 ; 11087 /* Prepare the environment block */; 11088 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11089 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11090 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11091 ; 11092 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11093 ; 11094 sockaddr_to_string",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:319422,Modifiability,config,config,319422,"env->bufused += n;; 11037 ; 11038 /* Append a pointer to the added string into the envp array */; 11039 env->var[env->varused] = added;; 11040 env->varused++;; 11041}; 11042 ; 11043/* Return 0 on success, non-zero if an error occurs. */; 11044 ; 11045static int; 11046prepare_cgi_environment(struct mg_connection *conn,; 11047 const char *prog,; 11048 struct cgi_environment *env,; 11049 unsigned char cgi_config_idx); 11050{; 11051 const char *s;; 11052 struct vec var_vec;; 11053 char *p, src_addr[IP_ADDR_STR_LEN], http_var_name[128];; 11054 int i, truncated, uri_len;; 11055 ; 11056 if ((conn == NULL) || (prog == NULL) || (env == NULL)) {; 11057 return -1;; 11058 }; 11059 ; 11060 env->conn = conn;; 11061 env->buflen = CGI_ENVIRONMENT_SIZE;; 11062 env->bufused = 0;; 11063 env->buf = (char *)mg_malloc_ctx(env->buflen, conn->phys_ctx);; 11064 if (env->buf == NULL) {; 11065 mg_cry_internal(conn,; 11066 ""%s: Not enough memory for environmental buffer"",; 11067 __func__);; 11068 return -1;; 11069 }; 11070 env->varlen = MAX_CGI_ENVIR_VARS;; 11071 env->varused = 0;; 11072 env->var =; 11073 (char **)mg_malloc_ctx(env->varlen * sizeof(char *), conn->phys_ctx);; 11074 if (env->var == NULL) {; 11075 mg_cry_internal(conn,; 11076 ""%s: Not enough memory for environmental variables"",; 11077 __func__);; 11078 mg_free(env->buf);; 11079 return -1;; 11080 }; 11081 ; 11082 addenv(env, ""SERVER_NAME=%s"", conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 11083 addenv(env, ""SERVER_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11084 addenv(env, ""DOCUMENT_ROOT=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11085 addenv(env, ""SERVER_SOFTWARE=CivetWeb/%s"", mg_version());; 11086 ; 11087 /* Prepare the environment block */; 11088 addenv(env, ""%s"", ""GATEWAY_INTERFACE=CGI/1.1"");; 11089 addenv(env, ""%s"", ""SERVER_PROTOCOL=HTTP/1.1"");; 11090 addenv(env, ""%s"", ""REDIRECT_STATUS=200""); /* For PHP */; 11091 ; 11092 addenv(env, ""SERVER_PORT=%d"", conn->request_info.server_port);; 11093 ; 11094 sockaddr_to_string",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:321255,Modifiability,config,config,321255,")strlen(conn->request_info.local_uri);; 11106 if (conn->path_info == NULL) {; 11107 if (conn->request_info.local_uri[uri_len - 1] != '/') {; 11108 /* URI: /path_to_script/script.cgi */; 11109 addenv(env, ""SCRIPT_NAME=%s"", conn->request_info.local_uri);; 11110 } else {; 11111 /* URI: /path_to_script/ ... using index.cgi */; 11112 const char *index_file = strrchr(prog, '/');; 11113 if (index_file) {; 11114 addenv(env,; 11115 ""SCRIPT_NAME=%s%s"",; 11116 conn->request_info.local_uri,; 11117 index_file + 1);; 11118 }; 11119 }; 11120 } else {; 11121 /* URI: /path_to_script/script.cgi/path_info */; 11122 addenv(env,; 11123 ""SCRIPT_NAME=%.*s"",; 11124 uri_len - (int)strlen(conn->path_info),; 11125 conn->request_info.local_uri);; 11126 }; 11127 ; 11128 addenv(env, ""SCRIPT_FILENAME=%s"", prog);; 11129 if (conn->path_info == NULL) {; 11130 addenv(env, ""PATH_TRANSLATED=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11131 } else {; 11132 addenv(env,; 11133 ""PATH_TRANSLATED=%s%s"",; 11134 conn->dom_ctx->config[DOCUMENT_ROOT],; 11135 conn->path_info);; 11136 }; 11137 ; 11138 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11139 ; 11140 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11141 addenv(env, ""CONTENT_TYPE=%s"", s);; 11142 }; 11143 if (conn->request_info.query_string != NULL) {; 11144 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11145 }; 11146 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11147 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11148 }; 11149 if ((s = getenv(""PATH"")) != NULL) {; 11150 addenv(env, ""PATH=%s"", s);; 11151 }; 11152 if (conn->path_info != NULL) {; 11153 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11154 }; 11155 ; 11156 if (conn->status_code > 0) {; 11157 /* CGI error handler should show the status code */; 11158 addenv(env, ""STATUS=%d"", conn->status_code);; 11159 }; 11160 ; 11161#if defined(_WIN32); 11162 if ((s = getenv(""COMSPEC"")) != NULL) {; 11163 addenv(env, ""COMSPEC=%s"", s);; 11164 }; 11165 if ((s = ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:321367,Modifiability,config,config,321367,")strlen(conn->request_info.local_uri);; 11106 if (conn->path_info == NULL) {; 11107 if (conn->request_info.local_uri[uri_len - 1] != '/') {; 11108 /* URI: /path_to_script/script.cgi */; 11109 addenv(env, ""SCRIPT_NAME=%s"", conn->request_info.local_uri);; 11110 } else {; 11111 /* URI: /path_to_script/ ... using index.cgi */; 11112 const char *index_file = strrchr(prog, '/');; 11113 if (index_file) {; 11114 addenv(env,; 11115 ""SCRIPT_NAME=%s%s"",; 11116 conn->request_info.local_uri,; 11117 index_file + 1);; 11118 }; 11119 }; 11120 } else {; 11121 /* URI: /path_to_script/script.cgi/path_info */; 11122 addenv(env,; 11123 ""SCRIPT_NAME=%.*s"",; 11124 uri_len - (int)strlen(conn->path_info),; 11125 conn->request_info.local_uri);; 11126 }; 11127 ; 11128 addenv(env, ""SCRIPT_FILENAME=%s"", prog);; 11129 if (conn->path_info == NULL) {; 11130 addenv(env, ""PATH_TRANSLATED=%s"", conn->dom_ctx->config[DOCUMENT_ROOT]);; 11131 } else {; 11132 addenv(env,; 11133 ""PATH_TRANSLATED=%s%s"",; 11134 conn->dom_ctx->config[DOCUMENT_ROOT],; 11135 conn->path_info);; 11136 }; 11137 ; 11138 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11139 ; 11140 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11141 addenv(env, ""CONTENT_TYPE=%s"", s);; 11142 }; 11143 if (conn->request_info.query_string != NULL) {; 11144 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11145 }; 11146 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11147 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11148 }; 11149 if ((s = getenv(""PATH"")) != NULL) {; 11150 addenv(env, ""PATH=%s"", s);; 11151 }; 11152 if (conn->path_info != NULL) {; 11153 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11154 }; 11155 ; 11156 if (conn->status_code > 0) {; 11157 /* CGI error handler should show the status code */; 11158 addenv(env, ""STATUS=%d"", conn->status_code);; 11159 }; 11160 ; 11161#if defined(_WIN32); 11162 if ((s = getenv(""COMSPEC"")) != NULL) {; 11163 addenv(env, ""COMSPEC=%s"", s);; 11164 }; 11165 if ((s = ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:323241,Modifiability,variab,variables,323241,"ode);; 11159 }; 11160 ; 11161#if defined(_WIN32); 11162 if ((s = getenv(""COMSPEC"")) != NULL) {; 11163 addenv(env, ""COMSPEC=%s"", s);; 11164 }; 11165 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11166 addenv(env, ""SYSTEMROOT=%s"", s);; 11167 }; 11168 if ((s = getenv(""SystemDrive"")) != NULL) {; 11169 addenv(env, ""SystemDrive=%s"", s);; 11170 }; 11171 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11172 addenv(env, ""ProgramFiles=%s"", s);; 11173 }; 11174 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11175 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11176 }; 11177#else; 11178 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11179 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11180 }; 11181#endif /* _WIN32 */; 11182 ; 11183 if ((s = getenv(""PERLLIB"")) != NULL) {; 11184 addenv(env, ""PERLLIB=%s"", s);; 11185 }; 11186 ; 11187 if (conn->request_info.remote_user != NULL) {; 11188 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_name,; 11198 sizeof(http_var_name),; 11199 ""HTTP_%s"",; 11200 conn->request_info.http_headers[i].name);; 11201 ; 11202 if (truncated) {; 11203 mg_cry_internal(conn,; 11204 ""%s: HTTP header variable too long [%s]"",; 11205 __func__,; 11206 conn->request_info.http_headers[i].name);; 11207 continue;; 11208 }; 11209 ; 11210 /* Convert variable name into uppercase, and change - to _ */; 11211 for (p = http_var_name; *p != '\0'; p++) {; 11212 if (*p == '-') {; 11213 *p = '_';; 11214 }; 11215 *p = (char)toupper((unsigned char)*p);; 11216 }; 11217 ; 11218 addenv(env,; 11219 ""%s=%s"",; 11220 http_var_name,; 11221 conn->request_info.http_headers[i].value);; 11222 }; 11223 ; 11224 /* Add user-specified variables */; 11225 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11226 while ((s = next_option(s, &var_vec,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:323578,Modifiability,variab,variable,323578," getenv(""ProgramFiles"")) != NULL) {; 11172 addenv(env, ""ProgramFiles=%s"", s);; 11173 }; 11174 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11175 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11176 }; 11177#else; 11178 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11179 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11180 }; 11181#endif /* _WIN32 */; 11182 ; 11183 if ((s = getenv(""PERLLIB"")) != NULL) {; 11184 addenv(env, ""PERLLIB=%s"", s);; 11185 }; 11186 ; 11187 if (conn->request_info.remote_user != NULL) {; 11188 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_name,; 11198 sizeof(http_var_name),; 11199 ""HTTP_%s"",; 11200 conn->request_info.http_headers[i].name);; 11201 ; 11202 if (truncated) {; 11203 mg_cry_internal(conn,; 11204 ""%s: HTTP header variable too long [%s]"",; 11205 __func__,; 11206 conn->request_info.http_headers[i].name);; 11207 continue;; 11208 }; 11209 ; 11210 /* Convert variable name into uppercase, and change - to _ */; 11211 for (p = http_var_name; *p != '\0'; p++) {; 11212 if (*p == '-') {; 11213 *p = '_';; 11214 }; 11215 *p = (char)toupper((unsigned char)*p);; 11216 }; 11217 ; 11218 addenv(env,; 11219 ""%s=%s"",; 11220 http_var_name,; 11221 conn->request_info.http_headers[i].value);; 11222 }; 11223 ; 11224 /* Add user-specified variables */; 11225 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11226 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11227 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11228 }; 11229 ; 11230 env->var[env->varused] = NULL;; 11231 env->buf[env->bufused] = '\0';; 11232 ; 11233 return 0;; 11234}; 11235 ; 11236 ; 11237/* Data for CGI process control: PID and number of references */; 11238struct process_control_data {; 11239 pid_t pid;; 11240 pt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:323721,Modifiability,variab,variable,323721,"denv(env, ""LD_LIBRARY_PATH=%s"", s);; 11180 }; 11181#endif /* _WIN32 */; 11182 ; 11183 if ((s = getenv(""PERLLIB"")) != NULL) {; 11184 addenv(env, ""PERLLIB=%s"", s);; 11185 }; 11186 ; 11187 if (conn->request_info.remote_user != NULL) {; 11188 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_name,; 11198 sizeof(http_var_name),; 11199 ""HTTP_%s"",; 11200 conn->request_info.http_headers[i].name);; 11201 ; 11202 if (truncated) {; 11203 mg_cry_internal(conn,; 11204 ""%s: HTTP header variable too long [%s]"",; 11205 __func__,; 11206 conn->request_info.http_headers[i].name);; 11207 continue;; 11208 }; 11209 ; 11210 /* Convert variable name into uppercase, and change - to _ */; 11211 for (p = http_var_name; *p != '\0'; p++) {; 11212 if (*p == '-') {; 11213 *p = '_';; 11214 }; 11215 *p = (char)toupper((unsigned char)*p);; 11216 }; 11217 ; 11218 addenv(env,; 11219 ""%s=%s"",; 11220 http_var_name,; 11221 conn->request_info.http_headers[i].value);; 11222 }; 11223 ; 11224 /* Add user-specified variables */; 11225 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11226 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11227 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11228 }; 11229 ; 11230 env->var[env->varused] = NULL;; 11231 env->buf[env->bufused] = '\0';; 11232 ; 11233 return 0;; 11234}; 11235 ; 11236 ; 11237/* Data for CGI process control: PID and number of references */; 11238struct process_control_data {; 11239 pid_t pid;; 11240 ptrdiff_t references;; 11241};; 11242 ; 11243static int; 11244abort_cgi_process(void *data); 11245{; 11246 /* Waitpid checks for child status and won't work for a pid that does; 11247 * not identify a child of the current process. Thus, if the pid is; 11248 * reused, we will ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:324088,Modifiability,variab,variables,324088,"11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_name,; 11198 sizeof(http_var_name),; 11199 ""HTTP_%s"",; 11200 conn->request_info.http_headers[i].name);; 11201 ; 11202 if (truncated) {; 11203 mg_cry_internal(conn,; 11204 ""%s: HTTP header variable too long [%s]"",; 11205 __func__,; 11206 conn->request_info.http_headers[i].name);; 11207 continue;; 11208 }; 11209 ; 11210 /* Convert variable name into uppercase, and change - to _ */; 11211 for (p = http_var_name; *p != '\0'; p++) {; 11212 if (*p == '-') {; 11213 *p = '_';; 11214 }; 11215 *p = (char)toupper((unsigned char)*p);; 11216 }; 11217 ; 11218 addenv(env,; 11219 ""%s=%s"",; 11220 http_var_name,; 11221 conn->request_info.http_headers[i].value);; 11222 }; 11223 ; 11224 /* Add user-specified variables */; 11225 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11226 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11227 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11228 }; 11229 ; 11230 env->var[env->varused] = NULL;; 11231 env->buf[env->bufused] = '\0';; 11232 ; 11233 return 0;; 11234}; 11235 ; 11236 ; 11237/* Data for CGI process control: PID and number of references */; 11238struct process_control_data {; 11239 pid_t pid;; 11240 ptrdiff_t references;; 11241};; 11242 ; 11243static int; 11244abort_cgi_process(void *data); 11245{; 11246 /* Waitpid checks for child status and won't work for a pid that does; 11247 * not identify a child of the current process. Thus, if the pid is; 11248 * reused, we will not affect a different process. */; 11249 struct process_control_data *proc = (struct process_control_data *)data;; 11250 int status = 0;; 11251 ptrdiff_t refs;; 11252 pid_t ret_pid;; 11253 ; 11254 ret_pid = waitpid(proc->pid, &status, WNOHANG);; 11255 if ((ret_pid != (pid_t)-1) && (status == 0)) {; 112",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:324127,Modifiability,config,config,324127,"11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_name,; 11198 sizeof(http_var_name),; 11199 ""HTTP_%s"",; 11200 conn->request_info.http_headers[i].name);; 11201 ; 11202 if (truncated) {; 11203 mg_cry_internal(conn,; 11204 ""%s: HTTP header variable too long [%s]"",; 11205 __func__,; 11206 conn->request_info.http_headers[i].name);; 11207 continue;; 11208 }; 11209 ; 11210 /* Convert variable name into uppercase, and change - to _ */; 11211 for (p = http_var_name; *p != '\0'; p++) {; 11212 if (*p == '-') {; 11213 *p = '_';; 11214 }; 11215 *p = (char)toupper((unsigned char)*p);; 11216 }; 11217 ; 11218 addenv(env,; 11219 ""%s=%s"",; 11220 http_var_name,; 11221 conn->request_info.http_headers[i].value);; 11222 }; 11223 ; 11224 /* Add user-specified variables */; 11225 s = conn->dom_ctx->config[CGI_ENVIRONMENT + cgi_config_idx];; 11226 while ((s = next_option(s, &var_vec, NULL)) != NULL) {; 11227 addenv(env, ""%.*s"", (int)var_vec.len, var_vec.ptr);; 11228 }; 11229 ; 11230 env->var[env->varused] = NULL;; 11231 env->buf[env->bufused] = '\0';; 11232 ; 11233 return 0;; 11234}; 11235 ; 11236 ; 11237/* Data for CGI process control: PID and number of references */; 11238struct process_control_data {; 11239 pid_t pid;; 11240 ptrdiff_t references;; 11241};; 11242 ; 11243static int; 11244abort_cgi_process(void *data); 11245{; 11246 /* Waitpid checks for child status and won't work for a pid that does; 11247 * not identify a child of the current process. Thus, if the pid is; 11248 * reused, we will not affect a different process. */; 11249 struct process_control_data *proc = (struct process_control_data *)data;; 11250 int status = 0;; 11251 ptrdiff_t refs;; 11252 pid_t ret_pid;; 11253 ; 11254 ret_pid = waitpid(proc->pid, &status, WNOHANG);; 11255 if ((ret_pid != (pid_t)-1) && (status == 0)) {; 112",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:326581,Modifiability,config,config,326581," /* Wait until process is terminated (don't leave zombies) */; 11261 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11262 ;; 11263 } else {; 11264 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11265 }; 11266 /* Dec reference counter */; 11267 refs = mg_atomic_dec(&proc->references);; 11268 if (refs == 0) {; 11269 /* no more references - free data */; 11270 mg_free(data);; 11271 }; 11272 ; 11273 return 0;; 11274}; 11275 ; 11276 ; 11277/* Local (static) function assumes all arguments are valid. */; 11278static void; 11279handle_cgi_request(struct mg_connection *conn,; 11280 const char *prog,; 11281 unsigned char cgi_config_idx); 11282{; 11283 char *buf;; 11284 size_t buflen;; 11285 int headers_len, data_len, i, truncated;; 11286 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11287 const char *status, *status_text, *connection_state;; 11288 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11289 struct mg_request_info ri;; 11290 struct cgi_environment blk;; 11291 FILE *in = NULL, *out = NULL, *err = NULL;; 11292 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11293 pid_t pid = (pid_t)-1;; 11294 struct process_control_data *proc = NULL;; 11295 ; 11296#if defined(USE_TIMERS); 11297 double cgi_timeout;; 11298 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11299 /* Get timeout in seconds */; 11300 cgi_timeout =; 11301 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11302 } else {; 11303 cgi_timeout =; 11304 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11305 }; 11306 ; 11307#endif; 11308 ; 11309 buf = NULL;; 11310 buflen = conn->phys_ctx->max_request_size;; 11311 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11312 if (i != 0) {; 11313 blk.buf = NULL;; 11314 blk.var = NULL;; 11315 goto done;; 11316 }; 11317 ; 11318 /* CGI must be executed in its own directory. 'dir' must point to the; 11319 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:326705,Modifiability,config,config,326705," /* Wait until process is terminated (don't leave zombies) */; 11261 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11262 ;; 11263 } else {; 11264 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11265 }; 11266 /* Dec reference counter */; 11267 refs = mg_atomic_dec(&proc->references);; 11268 if (refs == 0) {; 11269 /* no more references - free data */; 11270 mg_free(data);; 11271 }; 11272 ; 11273 return 0;; 11274}; 11275 ; 11276 ; 11277/* Local (static) function assumes all arguments are valid. */; 11278static void; 11279handle_cgi_request(struct mg_connection *conn,; 11280 const char *prog,; 11281 unsigned char cgi_config_idx); 11282{; 11283 char *buf;; 11284 size_t buflen;; 11285 int headers_len, data_len, i, truncated;; 11286 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11287 const char *status, *status_text, *connection_state;; 11288 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11289 struct mg_request_info ri;; 11290 struct cgi_environment blk;; 11291 FILE *in = NULL, *out = NULL, *err = NULL;; 11292 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11293 pid_t pid = (pid_t)-1;; 11294 struct process_control_data *proc = NULL;; 11295 ; 11296#if defined(USE_TIMERS); 11297 double cgi_timeout;; 11298 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11299 /* Get timeout in seconds */; 11300 cgi_timeout =; 11301 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11302 } else {; 11303 cgi_timeout =; 11304 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11305 }; 11306 ; 11307#endif; 11308 ; 11309 buf = NULL;; 11310 buflen = conn->phys_ctx->max_request_size;; 11311 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11312 if (i != 0) {; 11313 blk.buf = NULL;; 11314 blk.var = NULL;; 11315 goto done;; 11316 }; 11317 ; 11318 /* CGI must be executed in its own directory. 'dir' must point to the; 11319 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:344149,Modifiability,config,config,344149,"sscanf() is safe here, since send_ssi_file() also uses buffer; 11876 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11877 * always < MG_BUF_LEN. */; 11878 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11879 /* File name is relative to the webserver root */; 11880 file_name[511] = 0;; 11881 (void)mg_snprintf(conn,; 11882 &truncated,; 11883 path,; 11884 sizeof(path),; 11885 ""%s/%s"",; 11886 conn->dom_ctx->config[DOCUMENT_ROOT],; 11887 file_name);; 11888 ; 11889 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11890 /* File name is relative to the webserver working directory; 11891 * or it is absolute system path */; 11892 file_name[511] = 0;; 11893 (void); 11894 mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", file_name);; 11895 ; 11896 } else if ((sscanf(tag, "" file=\""%511[^\""]\"""", file_name) == 1); 11897 || (sscanf(tag, "" \""%511[^\""]\"""", file_name) == 1)) {; 11898 /* File name is relative to the currect document */; 11899 file_name[511] = 0;; 11900 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11901 ; 11902 if (!truncated) {; 11903 if ((p = strrchr(path, '/')) != NULL) {; 11904 p[1] = '\0';; 11905 }; 11906 len = strlen(path);; 11907 (void)mg_snprintf(conn,; 11908 &truncated,; 11909 path + len,; 11910 sizeof(path) - len,; 11911 ""%s"",; 11912 file_name);; 11913 }; 11914 ; 11915 } else {; 11916 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11917 return;; 11918 }; 11919 ; 11920 if (truncated) {; 11921 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:345627,Modifiability,config,config,345627,"1899 file_name[511] = 0;; 11900 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11901 ; 11902 if (!truncated) {; 11903 if ((p = strrchr(path, '/')) != NULL) {; 11904 p[1] = '\0';; 11905 }; 11906 len = strlen(path);; 11907 (void)mg_snprintf(conn,; 11908 &truncated,; 11909 path + len,; 11910 sizeof(path) - len,; 11911 ""%s"",; 11912 file_name);; 11913 }; 11914 ; 11915 } else {; 11916 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11917 return;; 11918 }; 11919 ; 11920 if (truncated) {; 11921 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:349941,Modifiability,config,config,349941,"46 ; 12047 if ((len + 2) > (int)sizeof(buf)) {; 12048 /* Tag to long for buffer */; 12049 mg_cry_internal(conn, ""%s: tag is too large"", path);; 12050 return;; 12051 }; 12052 }; 12053 ; 12054 } else {; 12055 ; 12056 /* We are not in a tag yet. */; 12057 if (ch == '<') {; 12058 /* Tag is opening */; 12059 in_tag = 1;; 12060 ; 12061 if (len > 0) {; 12062 /* Flush current buffer.; 12063 * Buffer is filled with ""len"" bytes. */; 12064 (void)mg_write(conn, buf, (size_t)len);; 12065 }; 12066 /* Store the < */; 12067 len = 1;; 12068 buf[0] = '<';; 12069 ; 12070 } else {; 12071 /* No Tag */; 12072 /* Add data to buffer */; 12073 buf[len++] = (char)(ch & 0xff);; 12074 /* Flush if buffer is full */; 12075 if (len == (int)sizeof(buf)) {; 12076 mg_write(conn, buf, (size_t)len);; 12077 len = 0;; 12078 }; 12079 }; 12080 }; 12081 }; 12082 ; 12083 /* Send the rest of buffered data */; 12084 if (len > 0) {; 12085 mg_write(conn, buf, (size_t)len);; 12086 }; 12087}; 12088 ; 12089 ; 12090static void; 12091handle_ssi_file_request(struct mg_connection *conn,; 12092 const char *path,; 12093 struct mg_file *filep); 12094{; 12095 char date[64];; 12096 time_t curtime = time(NULL);; 12097 const char *cors_orig_cfg, *cors_cred_cfg;; 12098 const char *cors1, *cors2, *cors3, *cors4;; 12099 ; 12100 if ((conn == NULL) || (path == NULL) || (filep == NULL)) {; 12101 return;; 12102 }; 12103 ; 12104 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 12105 if (cors_orig_cfg && *cors_orig_cfg && mg_get_header(conn, ""Origin"")) {; 12106 /* Cross-origin resource sharing (CORS). */; 12107 cors1 = ""Access-Control-Allow-Origin"";; 12108 cors2 = cors_orig_cfg;; 12109 } else {; 12110 cors1 = cors2 = """";; 12111 }; 12112 ; 12113 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 12114 if (cors_cred_cfg && *cors_cred_cfg && mg_get_header(conn, ""Origin"")) {; 12115 /* Credentials CORS header */; 12116 cors3 = ""Access-Control-Allow-Credentials"";; 12117 cors4 = cors_cred_cfg;; 1211",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:350282,Modifiability,config,config,350282,"2085 mg_write(conn, buf, (size_t)len);; 12086 }; 12087}; 12088 ; 12089 ; 12090static void; 12091handle_ssi_file_request(struct mg_connection *conn,; 12092 const char *path,; 12093 struct mg_file *filep); 12094{; 12095 char date[64];; 12096 time_t curtime = time(NULL);; 12097 const char *cors_orig_cfg, *cors_cred_cfg;; 12098 const char *cors1, *cors2, *cors3, *cors4;; 12099 ; 12100 if ((conn == NULL) || (path == NULL) || (filep == NULL)) {; 12101 return;; 12102 }; 12103 ; 12104 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 12105 if (cors_orig_cfg && *cors_orig_cfg && mg_get_header(conn, ""Origin"")) {; 12106 /* Cross-origin resource sharing (CORS). */; 12107 cors1 = ""Access-Control-Allow-Origin"";; 12108 cors2 = cors_orig_cfg;; 12109 } else {; 12110 cors1 = cors2 = """";; 12111 }; 12112 ; 12113 cors_cred_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 12114 if (cors_cred_cfg && *cors_cred_cfg && mg_get_header(conn, ""Origin"")) {; 12115 /* Credentials CORS header */; 12116 cors3 = ""Access-Control-Allow-Credentials"";; 12117 cors4 = cors_cred_cfg;; 12118 } else {; 12119 cors3 = cors4 = """";; 12120 }; 12121 ; 12122 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12123 /* File exists (precondition for calling this function),; 12124 * but can not be opened by the server. */; 12125 mg_send_http_error(conn,; 12126 500,; 12127 ""Error: Cannot read file\nfopen(%s): %s"",; 12128 path,; 12129 strerror(ERRNO));; 12130 } else {; 12131 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12132 * content length */; 12133 conn->must_close = 1;; 12134 gmt_time_string(date, sizeof(date), &curtime);; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:356006,Modifiability,config,config,356006,"ponse_header_add(conn, ""Content-Type"", ""text/xml; charset=utf-8"", -1);; 12283 mg_response_header_send(conn);; 12284 ; 12285 /* Content */; 12286 mg_printf(conn,; 12287 ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>""; 12288 ""<d:multistatus xmlns:d='DAV:'>\n"");; 12289 ; 12290 /* Print properties for the requested resource itself */; 12291 print_props(conn, conn->request_info.local_uri, """", filep);; 12292 ; 12293 /* If it is a directory, print directory entries too if Depth is not 0; 12294 */; 12295 if (filep->is_directory; 12296 && !mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 12297 ""yes""); 12298 && ((depth == NULL) || (strcmp(depth, ""0"") != 0))) {; 12299 scan_directory(conn, path, conn, &print_dav_dir_entry);; 12300 }; 12301 ; 12302 mg_printf(conn, ""%s\n"", ""</d:multistatus>"");; 12303}; 12304#endif; 12305 ; 12306void; 12307mg_lock_connection(struct mg_connection *conn); 12308{; 12309 if (conn) {; 12310 (void)pthread_mutex_lock(&conn->mutex);; 12311 }; 12312}; 12313 ; 12314void; 12315mg_unlock_connection(struct mg_connection *conn); 12316{; 12317 if (conn) {; 12318 (void)pthread_mutex_unlock(&conn->mutex);; 12319 }; 12320}; 12321 ; 12322void; 12323mg_lock_context(struct mg_context *ctx); 12324{; 12325 if (ctx && (ctx->context_type == CONTEXT_SERVER)) {; 12326 (void)pthread_mutex_lock(&ctx->nonce_mutex);; 12327 }; 12328}; 12329 ; 12330void; 12331mg_unlock_context(struct mg_context *ctx); 12332{; 12333 if (ctx && (ctx->context_type == CONTEXT_SERVER)) {; 12334 (void)pthread_mutex_unlock(&ctx->nonce_mutex);; 12335 }; 12336}; 12337 ; 12338 ; 12339#if defined(USE_LUA); 12340#include ""mod_lua.inl""; 12341#endif /* USE_LUA */; 12342 ; 12343#if defined(USE_DUKTAPE); 12344#include ""mod_duktape.inl""; 12345#endif /* USE_DUKTAPE */; 12346 ; 12347#if defined(USE_WEBSOCKET); 12348 ; 12349#if !defined(NO_SSL_DL); 12350#if !defined(OPENSSL_API_3_0); 12351#define SHA_API static; 12352#include ""sha1.inl""; 12353#endif; 12354#endif; 12355 ; 12356static int; 12357send_websoc",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361109,Modifiability,config,config,361109,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361210,Modifiability,config,config,361210,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361304,Modifiability,config,config,361304,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361370,Modifiability,config,config,361370,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361463,Modifiability,config,config,361463,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361528,Modifiability,config,config,361528,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:383875,Modifiability,config,config,383875," the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 13151 else {; 13152 /* Step 3.1: Check if Lua is responsible. */; 13153 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13154 lua_websock = match_prefix_strlen(; 13155 conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS], path);; 13156 }; 13157 ; 13158 if (lua_websock) {; 13159 /* Step 3.2: Lua is responsible: call it. */; 13160 conn->lua_websocket_state = lua_websocket_new(path, conn);; 13161 if (!conn->lua_websocket_state) {; 13162 /* Lua rejected the new client */; 13163 return;; 13164 }; 13165 }; 13166 }; 13167#endif; 13168 ; 13169 /* Step 4: Check if there is a responsible websocket handler. */; 13170 if (!is_callback_resource && !lua_websock) {; 13171 /* There is no callback, and Lua is not responsible either. */; 13172 /* Reply with a 404 Not Found. We are still at a standard; 13173 * HTTP request here, before the websocket handshake, so; 13174 * we can still send standard HTTP error replies. */; 13175 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 13176 return;; 13177 }; 13178 ; 13179 /* Step 5: The websocket connection has been accepted */; 13180 if (!send_websocket_handshake(conn, websock_key)) {; 13181 mg_send_http_error(conn, 500, ""%s"", ""We",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:383975,Modifiability,config,config,383975," the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 13151 else {; 13152 /* Step 3.1: Check if Lua is responsible. */; 13153 if (conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS]) {; 13154 lua_websock = match_prefix_strlen(; 13155 conn->dom_ctx->config[LUA_WEBSOCKET_EXTENSIONS], path);; 13156 }; 13157 ; 13158 if (lua_websock) {; 13159 /* Step 3.2: Lua is responsible: call it. */; 13160 conn->lua_websocket_state = lua_websocket_new(path, conn);; 13161 if (!conn->lua_websocket_state) {; 13162 /* Lua rejected the new client */; 13163 return;; 13164 }; 13165 }; 13166 }; 13167#endif; 13168 ; 13169 /* Step 4: Check if there is a responsible websocket handler. */; 13170 if (!is_callback_resource && !lua_websock) {; 13171 /* There is no callback, and Lua is not responsible either. */; 13172 /* Reply with a 404 Not Found. We are still at a standard; 13173 * HTTP request here, before the websocket handshake, so; 13174 * we can still send standard HTTP error replies. */; 13175 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 13176 return;; 13177 }; 13178 ; 13179 /* Step 5: The websocket connection has been accepted */; 13180 if (!send_websocket_handshake(conn, websock_key)) {; 13181 mg_send_http_error(conn, 500, ""%s"", ""We",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:394343,Modifiability,config,config,394343,"3462 DEBUG_TRACE(""%s"", ""Host name format error '[' without ']'"");; 13463 return;; 13464 }; 13465 /* terminate after ']' */; 13466 host->ptr = host_header;; 13467 host->len = (size_t)(pos + 1 - host_header);; 13468 } else {; 13469 /* Otherwise, a ':' separates hostname and port number */; 13470 pos = strchr(host_header, ':');; 13471 if (pos != NULL) {; 13472 host->len = (size_t)(pos - host_header);; 13473 } else {; 13474 host->len = strlen(host_header);; 13475 }; 13476 host->ptr = host_header;; 13477 }; 13478 }; 13479}; 13480 ; 13481 ; 13482static int; 13483switch_domain_context(struct mg_connection *conn); 13484{; 13485 struct vec host;; 13486 ; 13487 get_host_from_request_info(&host, &conn->request_info);; 13488 ; 13489 if (host.ptr) {; 13490 if (conn->ssl) {; 13491 /* This is a HTTPS connection, maybe we have a hostname; 13492 * from SNI (set in ssl_servername_callback). */; 13493 const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13494 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13495 /* We are not using the default domain */; 13496 if ((strlen(sslhost) != host.len); 13497 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13498 /* Mismatch between SNI domain and HTTP domain */; 13499 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13500 sslhost,; 13501 (int)host.len,; 13502 host.ptr);; 13503 return 0;; 13504 }; 13505 }; 13506 ; 13507 } else {; 13508 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13509 while (dom) {; 13510 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13511 size_t domNameLen = strlen(domName);; 13512 if ((domNameLen == host.len); 13513 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13514 ; 13515 /* Found matching domain */; 13516 DEBUG_TRACE(""HTTP domain %s found"",; 13517 dom->config[AUTHENTICATION_DOMAIN]);; 13518 ; 13519 /* TODO: Check if this is a HTTP or HTTPS domain */; 13520 conn->dom_ctx = dom;; 13521 break;; 13522 }; 13523 mg_lock_context(conn->phys_ctx);; 13524 dom = dom->n",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:394934,Modifiability,config,config,394934,"ost_header;; 13477 }; 13478 }; 13479}; 13480 ; 13481 ; 13482static int; 13483switch_domain_context(struct mg_connection *conn); 13484{; 13485 struct vec host;; 13486 ; 13487 get_host_from_request_info(&host, &conn->request_info);; 13488 ; 13489 if (host.ptr) {; 13490 if (conn->ssl) {; 13491 /* This is a HTTPS connection, maybe we have a hostname; 13492 * from SNI (set in ssl_servername_callback). */; 13493 const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13494 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13495 /* We are not using the default domain */; 13496 if ((strlen(sslhost) != host.len); 13497 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13498 /* Mismatch between SNI domain and HTTP domain */; 13499 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13500 sslhost,; 13501 (int)host.len,; 13502 host.ptr);; 13503 return 0;; 13504 }; 13505 }; 13506 ; 13507 } else {; 13508 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13509 while (dom) {; 13510 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13511 size_t domNameLen = strlen(domName);; 13512 if ((domNameLen == host.len); 13513 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13514 ; 13515 /* Found matching domain */; 13516 DEBUG_TRACE(""HTTP domain %s found"",; 13517 dom->config[AUTHENTICATION_DOMAIN]);; 13518 ; 13519 /* TODO: Check if this is a HTTP or HTTPS domain */; 13520 conn->dom_ctx = dom;; 13521 break;; 13522 }; 13523 mg_lock_context(conn->phys_ctx);; 13524 dom = dom->next;; 13525 mg_unlock_context(conn->phys_ctx);; 13526 }; 13527 }; 13528 ; 13529 DEBUG_TRACE(""HTTP%s Host: %.*s"",; 13530 conn->ssl ? ""S"" : """",; 13531 (int)host.len,; 13532 host.ptr);; 13533 ; 13534 } else {; 13535 DEBUG_TRACE(""HTTP%s Host is not set"", conn->ssl ? ""S"" : """");; 13536 return 1;; 13537 }; 13538 ; 13539 return 1;; 13540}; 13541 ; 13542 ; 13543static void; 13544redirect_to_https_port(struct mg_connection *conn, int port); 13545{; 13546 char target_url[MG_BUF_LEN];; 13547 i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:395201,Modifiability,config,config,395201,"const char *sslhost = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 13494 if (sslhost && (conn->dom_ctx != &(conn->phys_ctx->dd))) {; 13495 /* We are not using the default domain */; 13496 if ((strlen(sslhost) != host.len); 13497 || mg_strncasecmp(host.ptr, sslhost, host.len)) {; 13498 /* Mismatch between SNI domain and HTTP domain */; 13499 DEBUG_TRACE(""Host mismatch: SNI: %s, HTTPS: %.*s"",; 13500 sslhost,; 13501 (int)host.len,; 13502 host.ptr);; 13503 return 0;; 13504 }; 13505 }; 13506 ; 13507 } else {; 13508 struct mg_domain_context *dom = &(conn->phys_ctx->dd);; 13509 while (dom) {; 13510 const char *domName = dom->config[AUTHENTICATION_DOMAIN];; 13511 size_t domNameLen = strlen(domName);; 13512 if ((domNameLen == host.len); 13513 && !mg_strncasecmp(host.ptr, domName, host.len)) {; 13514 ; 13515 /* Found matching domain */; 13516 DEBUG_TRACE(""HTTP domain %s found"",; 13517 dom->config[AUTHENTICATION_DOMAIN]);; 13518 ; 13519 /* TODO: Check if this is a HTTP or HTTPS domain */; 13520 conn->dom_ctx = dom;; 13521 break;; 13522 }; 13523 mg_lock_context(conn->phys_ctx);; 13524 dom = dom->next;; 13525 mg_unlock_context(conn->phys_ctx);; 13526 }; 13527 }; 13528 ; 13529 DEBUG_TRACE(""HTTP%s Host: %.*s"",; 13530 conn->ssl ? ""S"" : """",; 13531 (int)host.len,; 13532 host.ptr);; 13533 ; 13534 } else {; 13535 DEBUG_TRACE(""HTTP%s Host is not set"", conn->ssl ? ""S"" : """");; 13536 return 1;; 13537 }; 13538 ; 13539 return 1;; 13540}; 13541 ; 13542 ; 13543static void; 13544redirect_to_https_port(struct mg_connection *conn, int port); 13545{; 13546 char target_url[MG_BUF_LEN];; 13547 int truncated = 0;; 13548 const char *expect_proto =; 13549 (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET) ? ""wss"" : ""https"";; 13550 ; 13551 /* Use ""308 Permanent Redirect"" */; 13552 int redirect_code = 308;; 13553 ; 13554 /* In any case, close the current connection */; 13555 conn->must_close = 1;; 13556 ; 13557 /* Send host, port, uri and (if it exists) ?query_string */; 13558 if (mg_construct_local_link(",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:408371,Modifiability,config,config,408371,"ata_handler;; 13922 *close_handler = tmp_rh->close_handler;; 13923 } else if (handler_type == REQUEST_HANDLER) {; 13924 if (tmp_rh->removing) {; 13925 /* Treat as none found */; 13926 step = 2;; 13927 break;; 13928 }; 13929 *handler = tmp_rh->handler;; 13930 /* Acquire handler and give it back */; 13931 tmp_rh->refcount++;; 13932 *handler_info = tmp_rh;; 13933 } else { /* AUTH_HANDLER */; 13934 *auth_handler = tmp_rh->auth_handler;; 13935 }; 13936 *cbdata = tmp_rh->cbdata;; 13937 mg_unlock_context(conn->phys_ctx);; 13938 return 1;; 13939 }; 13940 }; 13941 }; 13942 ; 13943 mg_unlock_context(conn->phys_ctx);; 13944 }; 13945 return 0; /* none found */; 13946}; 13947 ; 13948 ; 13949/* Check if the script file is in a path, allowed for script files.; 13950 * This can be used if uploading files is possible not only for the server; 13951 * admin, and the upload mechanism does not check the file extension.; 13952 */; 13953static int; 13954is_in_script_path(const struct mg_connection *conn, const char *path); 13955{; 13956 /* TODO (Feature): Add config value for allowed script path.; 13957 * Default: All allowed. */; 13958 (void)conn;; 13959 (void)path;; 13960 return 1;; 13961}; 13962 ; 13963 ; 13964#if defined(USE_WEBSOCKET) && defined(MG_EXPERIMENTAL_INTERFACES); 13965static int; 13966experimental_websocket_client_data_wrapper(struct mg_connection *conn,; 13967 int bits,; 13968 char *data,; 13969 size_t len,; 13970 void *cbdata); 13971{; 13972 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13973 if (pcallbacks->websocket_data) {; 13974 return pcallbacks->websocket_data(conn, bits, data, len);; 13975 }; 13976 /* No handler set - assume ""OK"" */; 13977 return 1;; 13978}; 13979 ; 13980 ; 13981static void; 13982experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13983 void *cbdata); 13984{; 13985 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13986 if (pcallbacks->connection_close) {; 13987 pcallbacks->connection_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:412147,Modifiability,config,configured,412147,"internal state (required for HTTP/2 proxy) */; 14041 conn->request_state = 0;; 14042 ; 14043 /* 1. get the request url */; 14044 /* 1.1. split into url and query string */; 14045 if ((conn->request_info.query_string = strchr(ri->request_uri, '?')); 14046 != NULL) {; 14047 *((char *)conn->request_info.query_string++) = '\0';; 14048 }; 14049 ; 14050 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14051 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14052 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14053 if (ssl_index >= 0) {; 14054 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14055 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14056 redirect_to_https_port(conn, port);; 14057 } else {; 14058 /* A http to https forward port has been specified,; 14059 * but no https port to forward to. */; 14060 mg_send_http_error(conn,; 14061 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:412386,Modifiability,config,config,412386,"_string++) = '\0';; 14048 }; 14049 ; 14050 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14051 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14052 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14053 if (ssl_index >= 0) {; 14054 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14055 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14056 redirect_to_https_port(conn, port);; 14057 } else {; 14058 /* A http to https forward port has been specified,; 14059 * but no https port to forward to. */; 14060 mg_send_http_error(conn,; 14061 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:412620,Modifiability,config,configuration,412620,"_string++) = '\0';; 14048 }; 14049 ; 14050 /* 1.2. do a https redirect, if required. Do not decode URIs yet. */; 14051 if (!conn->client.is_ssl && conn->client.ssl_redir) {; 14052 ssl_index = get_first_ssl_listener_index(conn->phys_ctx);; 14053 if (ssl_index >= 0) {; 14054 int port = (int)ntohs(USA_IN_PORT_UNSAFE(; 14055 &(conn->phys_ctx->listening_sockets[ssl_index].lsa)));; 14056 redirect_to_https_port(conn, port);; 14057 } else {; 14058 /* A http to https forward port has been specified,; 14059 * but no https port to forward to. */; 14060 mg_send_http_error(conn,; 14061 503,; 14062 ""%s"",; 14063 ""Error: SSL forward not configured properly"");; 14064 mg_cry_internal(conn,; 14065 ""%s"",; 14066 ""Can not redirect to SSL, no SSL port available"");; 14067 }; 14068 return;; 14069 }; 14070 uri_len = (int)strlen(ri->local_uri);; 14071 ; 14072 /* 1.3. decode url (if config says so) */; 14073 if (should_decode_url(conn)) {; 14074 mg_url_decode(; 14075 ri->local_uri, uri_len, (char *)ri->local_uri, uri_len + 1, 0);; 14076 }; 14077 ; 14078 /* URL decode the query-string only if explicity set in the configuration */; 14079 if (conn->request_info.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:413701,Modifiability,config,config,413701,"fo.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:414797,Modifiability,config,configured,414797,"; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_orig_cfg =; 14142 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14143 const char *cors_cred_cfg =; 14144 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14145 const char *cors_origin =; 14146 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14147 const char *cors_acrm = get_header(ri->http_headers,; 14148 ri->num_headers,; 14149 ""Access-Control-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:415194,Modifiability,config,config,415194,"; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_orig_cfg =; 14142 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14143 const char *cors_cred_cfg =; 14144 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14145 const char *cors_origin =; 14146 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14147 const char *cors_acrm = get_header(ri->http_headers,; 14148 ri->num_headers,; 14149 ""Access-Control-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14155 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14156 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14157 /* This is a valid CORS preflight, and the server is configured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:415289,Modifiability,config,config,415289,"; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_orig_cfg =; 14142 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14143 const char *cors_cred_cfg =; 14144 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14145 const char *cors_origin =; 14146 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14147 const char *cors_acrm = get_header(ri->http_headers,; 14148 ri->num_headers,; 14149 ""Access-Control-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14155 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14156 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14157 /* This is a valid CORS preflight, and the server is configured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:415383,Modifiability,config,config,415383,"; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_orig_cfg =; 14142 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14143 const char *cors_cred_cfg =; 14144 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14145 const char *cors_origin =; 14146 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14147 const char *cors_acrm = get_header(ri->http_headers,; 14148 ri->num_headers,; 14149 ""Access-Control-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14155 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14156 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14157 /* This is a valid CORS preflight, and the server is configured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:416001,Modifiability,config,configured,416001,"14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_orig_cfg =; 14142 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 14143 const char *cors_cred_cfg =; 14144 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_CREDENTIALS];; 14145 const char *cors_origin =; 14146 get_header(ri->http_headers, ri->num_headers, ""Origin"");; 14147 const char *cors_acrm = get_header(ri->http_headers,; 14148 ri->num_headers,; 14149 ""Access-Control-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14155 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14156 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14157 /* This is a valid CORS preflight, and the server is configured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if ac",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:416767,Modifiability,config,config,416767,"-Request-Method"");; 14150 ; 14151 /* Todo: check if cors_origin is in cors_orig_cfg.; 14152 * Or, let the client check this. */; 14153 ; 14154 if ((cors_meth_cfg != NULL) && (*cors_meth_cfg != 0); 14155 && (cors_orig_cfg != NULL) && (*cors_orig_cfg != 0); 14156 && (cors_origin != NULL) && (cors_acrm != NULL)) {; 14157 /* This is a valid CORS preflight, and the server is configured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:416990,Modifiability,config,configuration,416990,"nfigured; 14158 * to handle it automatically. */; 14159 const char *cors_acrh =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:417059,Modifiability,config,configuration,417059," =; 14160 get_header(ri->http_headers,; 14161 ri->num_headers,; 14162 ""Access-Control-Request-Headers"");; 14163 ; 14164 gmt_time_string(date, sizeof(date), &curtime);; 14165 mg_printf(conn,; 14166 ""HTTP/1.1 200 OK\r\n""; 14167 ""Date: %s\r\n""; 14168 ""Access-Control-Allow-Origin: %s\r\n""; 14169 ""Access-Control-Allow-Methods: %s\r\n""; 14170 ""Content-Length: 0\r\n""; 14171 ""Connection: %s\r\n"",; 14172 date,; 14173 cors_orig_cfg,; 14174 ((cors_meth_cfg[0] == '*') ? cors_acrm : cors_meth_cfg),; 14175 suggest_connection_header(conn));; 14176 ; 14177 if (cors_acrh != NULL) {; 14178 /* CORS request is asking for additional headers */; 14179 const char *cors_hdr_cfg =; 14180 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14215#else; 14216 handler_type = REQUEST_HANDLER;; 1421",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:420167,Modifiability,config,config,420167,"cket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 releas",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:424979,Modifiability,config,config,424979,"(is_script_resource) {; 14405 ; 14406 if (is_in_script_path(conn, path)) {; 14407 /* Websocket Lua script */; 14408 handle_websocket_request(conn,; 14409 path,; 14410 0 /* Lua Script */,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 NULL,; 14416 conn->phys_ctx->user_data);; 14417 } else {; 14418 /* Script was in an illegal path */; 14419 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14420 }; 14421 } else {; 14422 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 14423 }; 14424 return;; 14425 } else; 14426#endif; 14427 ; 14428#if defined(NO_FILES); 14429 /* 9a. In case the server uses only callbacks, this uri is; 14430 * unknown.; 14431 * Then, all request handling ends here. */; 14432 mg_send_http_error(conn, 404, ""%s"", ""Not Found"");; 14433 ; 14434#else; 14435 /* 9b. This request is either for a static file or resource handled; 14436 * by a script file. Thus, a DOCUMENT_ROOT must exist. */; 14437 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14438 mg_send_http_error(conn, 404, ""%s"", ""Not Found"");; 14439 return;; 14440 }; 14441 ; 14442 /* 10. Request is handled by a script */; 14443 if (is_script_resource) {; 14444 HTTP1_only;; 14445 handle_file_based_request(conn, path, &file);; 14446 return;; 14447 }; 14448 ; 14449 /* 11. Handle put/delete/mkcol requests */; 14450 if (is_put_or_delete_request) {; 14451 HTTP1_only;; 14452 /* 11.1. PUT method */; 14453 if (!strcmp(ri->request_method, ""PUT"")) {; 14454 put_file(conn, path);; 14455 return;; 14456 }; 14457 /* 11.2. DELETE method */; 14458 if (!strcmp(ri->request_method, ""DELETE"")) {; 14459 delete_file(conn, path);; 14460 return;; 14461 }; 14462 /* 11.3. MKCOL method */; 14463 if (!strcmp(ri->request_method, ""MKCOL"")) {; 14464 mkcol(conn, path);; 14465 return;; 14466 }; 14467 /* 11.4. PATCH method; 14468 * This method is not supported for static resources,; 14469 * only for scripts (Lua, CGI) and callbacks. */; 14470 mg_send_http_error(conn,; 14471 405,; 14472 ""%s method not allowed"",; 14473 conn-",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:426140,Modifiability,config,configured,426140,"equest(conn, path, &file);; 14446 return;; 14447 }; 14448 ; 14449 /* 11. Handle put/delete/mkcol requests */; 14450 if (is_put_or_delete_request) {; 14451 HTTP1_only;; 14452 /* 11.1. PUT method */; 14453 if (!strcmp(ri->request_method, ""PUT"")) {; 14454 put_file(conn, path);; 14455 return;; 14456 }; 14457 /* 11.2. DELETE method */; 14458 if (!strcmp(ri->request_method, ""DELETE"")) {; 14459 delete_file(conn, path);; 14460 return;; 14461 }; 14462 /* 11.3. MKCOL method */; 14463 if (!strcmp(ri->request_method, ""MKCOL"")) {; 14464 mkcol(conn, path);; 14465 return;; 14466 }; 14467 /* 11.4. PATCH method; 14468 * This method is not supported for static resources,; 14469 * only for scripts (Lua, CGI) and callbacks. */; 14470 mg_send_http_error(conn,; 14471 405,; 14472 ""%s method not allowed"",; 14473 conn->request_info.request_method);; 14474 return;; 14475 }; 14476 ; 14477 /* 11. File does not exist, or it was configured that it should be; 14478 * hidden */; 14479 if (!is_found || (must_hide_file(conn, path))) {; 14480 mg_send_http_error(conn, 404, ""%s"", ""Not found"");; 14481 return;; 14482 }; 14483 ; 14484 /* 12. Directory uris should end with a slash */; 14485 if (file.stat.is_directory && (uri_len > 0); 14486 && (ri->local_uri[uri_len - 1] != '/')) {; 14487 ; 14488 size_t len = strlen(ri->request_uri);; 14489 size_t lenQS = ri->query_string ? strlen(ri->query_string) + 1 : 0;; 14490 char *new_path = (char *)mg_malloc_ctx(len + lenQS + 2, conn->phys_ctx);; 14491 if (!new_path) {; 14492 mg_send_http_error(conn, 500, ""out or memory"");; 14493 } else {; 14494 memcpy(new_path, ri->request_uri, len);; 14495 new_path[len] = '/';; 14496 new_path[len + 1] = 0;; 14497 if (ri->query_string) {; 14498 new_path[len + 1] = '?';; 14499 /* Copy query string including terminating zero */; 14500 memcpy(new_path + len + 2, ri->query_string, lenQS);; 14501 }; 14502 mg_send_http_redirect(conn, new_path, 301);; 14503 mg_free(new_path);; 14504 }; 14505 return;; 14506 }; 14507 ; 14508 /* 13. Handle o",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:428429,Modifiability,config,config,428429,"handler is only used for real files.; 14517 * Scripts should support the OPTIONS method themselves, to allow a; 14518 * maximum flexibility.; 14519 * Lua and CGI scripts may fully support CORS this way (including; 14520 * preflights). */; 14521 send_options(conn);; 14522 return;; 14523 }; 14524 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14525 if ((0 != strcmp(ri->request_method, ""GET"")); 14526 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14527 mg_send_http_error(conn,; 14528 405,; 14529 ""%s method not allowed"",; 14530 conn->request_info.request_method);; 14531 return;; 14532 }; 14533 ; 14534 /* 14. directories */; 14535 if (file.stat.is_directory) {; 14536 /* Substitute files have already been handled above. */; 14537 /* Here we can either generate and send a directory listing,; 14538 * or send an ""access denied"" error. */; 14539 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14540 ""yes"")) {; 14541 handle_directory_request(conn, path);; 14542 } else {; 14543 mg_send_http_error(conn,; 14544 403,; 14545 ""%s"",; 14546 ""Error: Directory listing denied"");; 14547 }; 14548 return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:429826,Modifiability,config,config,429826,"return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SSI like page containing mostly plain; 14594 * html code plus some tags with server generated contents. */; 14595 handle_lsp_request(conn, path, file, NULL);; 14596 } else {; 14597 /* Script was in an illegal path */; 14598 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14599 }; 14600 return;; 14601 }; 14602 ; 14603 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14604 > 0) {; 14605 if (is_in_script_path(conn, path)) {; 14606 /* Lua in-server module script: a CGI like script used to; 14607 * generate the entire reply. */; 14608 mg_exec_lua_script(conn, path, NULL);; 14609 } else {; 14610 /* Script was in an illegal path */; 14611 mg_send_http_error(conn",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:430324,Modifiability,config,config,430324,"tatic_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SSI like page containing mostly plain; 14594 * html code plus some tags with server generated contents. */; 14595 handle_lsp_request(conn, path, file, NULL);; 14596 } else {; 14597 /* Script was in an illegal path */; 14598 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14599 }; 14600 return;; 14601 }; 14602 ; 14603 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14604 > 0) {; 14605 if (is_in_script_path(conn, path)) {; 14606 /* Lua in-server module script: a CGI like script used to; 14607 * generate the entire reply. */; 14608 mg_exec_lua_script(conn, path, NULL);; 14609 } else {; 14610 /* Script was in an illegal path */; 14611 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14612 }; 14613 return;; 14614 }; 14615#endif; 14616 ; 14617#if defined(USE_DUKTAPE); 14618 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 14619 path); 14620 > 0) {; 14621 if (is_in_script_path(conn, path)) {; 14622 /* Call duktape to generate the page */; 14623 mg_exec_duktape_script(conn, path);; 14624 } else {; 14625 /* Script was in an illegal path */; 14626 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14627 }; 14628 return;; 14629 }; 14630#endif; 14631 ; 14632#if !defined(NO_CGI); 14633 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14634 max = PUT_DELETE_PASSWORDS_FILE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:430815,Modifiability,config,config,430815,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:431417,Modifiability,config,config,431417,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:431522,Modifiability,config,config,431522,"4608 mg_exec_lua_script(conn, path, NULL);; 14609 } else {; 14610 /* Script was in an illegal path */; 14611 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14612 }; 14613 return;; 14614 }; 14615#endif; 14616 ; 14617#if defined(USE_DUKTAPE); 14618 if (match_prefix_strlen(conn->dom_ctx->config[DUKTAPE_SCRIPT_EXTENSIONS],; 14619 path); 14620 > 0) {; 14621 if (is_in_script_path(conn, path)) {; 14622 /* Call duktape to generate the page */; 14623 mg_exec_duktape_script(conn, path);; 14624 } else {; 14625 /* Script was in an illegal path */; 14626 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14627 }; 14628 return;; 14629 }; 14630#endif; 14631 ; 14632#if !defined(NO_CGI); 14633 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14634 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 14635 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 14636 if (conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL) {; 14637 if (match_prefix_strlen(; 14638 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 14639 path); 14640 > 0) {; 14641 if (is_in_script_path(conn, path)) {; 14642 /* CGI scripts may support all HTTP methods */; 14643 handle_cgi_request(conn, path, 0);; 14644 } else {; 14645 /* Script was in an illegal path */; 14646 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14647 }; 14648 return;; 14649 }; 14650 }; 14651 }; 14652#endif /* !NO_CGI */; 14653 ; 14654 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path) > 0) {; 14655 if (is_in_script_path(conn, path)) {; 14656 handle_ssi_file_request(conn, path, file);; 14657 } else {; 14658 /* Script was in an illegal path */; 14659 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14660 }; 14661 return;; 14662 }; 14663 ; 14664#if !defined(NO_CACHING); 14665 if ((!conn->in_error_handler) && is_not_modified(conn, &file->stat)) {; 14666 /* Send 304 ""Not Modified"" - this must not send any body data */; 14667 handle_not_modified_static_file_request(conn, file);; 14668 return;; 146",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:431978,Modifiability,config,config,431978,"te the page */; 14623 mg_exec_duktape_script(conn, path);; 14624 } else {; 14625 /* Script was in an illegal path */; 14626 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14627 }; 14628 return;; 14629 }; 14630#endif; 14631 ; 14632#if !defined(NO_CGI); 14633 inc = CGI2_EXTENSIONS - CGI_EXTENSIONS;; 14634 max = PUT_DELETE_PASSWORDS_FILE - CGI_EXTENSIONS;; 14635 for (cgi_config_idx = 0; cgi_config_idx < max; cgi_config_idx += inc) {; 14636 if (conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx] != NULL) {; 14637 if (match_prefix_strlen(; 14638 conn->dom_ctx->config[CGI_EXTENSIONS + cgi_config_idx],; 14639 path); 14640 > 0) {; 14641 if (is_in_script_path(conn, path)) {; 14642 /* CGI scripts may support all HTTP methods */; 14643 handle_cgi_request(conn, path, 0);; 14644 } else {; 14645 /* Script was in an illegal path */; 14646 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14647 }; 14648 return;; 14649 }; 14650 }; 14651 }; 14652#endif /* !NO_CGI */; 14653 ; 14654 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path) > 0) {; 14655 if (is_in_script_path(conn, path)) {; 14656 handle_ssi_file_request(conn, path, file);; 14657 } else {; 14658 /* Script was in an illegal path */; 14659 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14660 }; 14661 return;; 14662 }; 14663 ; 14664#if !defined(NO_CACHING); 14665 if ((!conn->in_error_handler) && is_not_modified(conn, &file->stat)) {; 14666 /* Send 304 ""Not Modified"" - this must not send any body data */; 14667 handle_not_modified_static_file_request(conn, file);; 14668 return;; 14669 }; 14670#endif /* !NO_CACHING */; 14671 ; 14672 handle_static_file_request(conn, path, file, NULL, NULL);; 14673}; 14674#endif /* NO_FILESYSTEMS */; 14675 ; 14676 ; 14677static void; 14678close_all_listening_sockets(struct mg_context *ctx); 14679{; 14680 unsigned int i;; 14681 if (!ctx) {; 14682 return;; 14683 }; 14684 ; 14685 for (i = 0; i < ctx->num_listening_sockets; i++) {; 14686 closesocket(ctx->listening_sockets[i].",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:443531,Modifiability,config,config,443531," 'r')) {; 14944 return 1;; 14945 }; 14946 if (ports[i] >= '0' && ports[i] <= '9') {; 14947 prevIsNumber = 1;; 14948 } else {; 14949 prevIsNumber = 0;; 14950 }; 14951 }; 14952 }; 14953 return 0;; 14954}; 14955 ; 14956 ; 14957static int; 14958set_ports_option(struct mg_context *phys_ctx); 14959{; 14960 const char *list;; 14961 int on = 1;; 14962#if defined(USE_IPV6); 14963 int off = 0;; 14964#endif; 14965 struct vec vec;; 14966 struct socket so, *ptr;; 14967 ; 14968 struct mg_pollfd *pfd;; 14969 union usa usa;; 14970 socklen_t len;; 14971 int ip_version;; 14972 ; 14973 int portsTotal = 0;; 14974 int portsOk = 0;; 14975 ; 14976 const char *opt_txt;; 14977 long opt_listen_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;; 14981 }; 14982 ; 14983 memset(&so, 0, sizeof(so));; 14984 memset(&usa, 0, sizeof(usa));; 14985 len = sizeof(usa);; 14986 list = phys_ctx->dd.config[LISTENING_PORTS];; 14987 ; 14988 while ((list = next_option(list, &vec, NULL)) != NULL) {; 14989 ; 14990 portsTotal++;; 14991 ; 14992 if (!parse_port_string(&vec, &so, &ip_version)) {; 14993 mg_cry_ctx_internal(; 14994 phys_ctx,; 14995 ""%.*s: invalid port spec (entry %i). Expecting list of: %s"",; 14996 (int)vec.len,; 14997 vec.ptr,; 14998 portsTotal,; 14999 ""[IP_ADDRESS:]PORT[s|r]"");; 15000 continue;; 15001 }; 15002 ; 15003#if !defined(NO_SSL); 15004 if (so.is_ssl && phys_ctx->dd.ssl_ctx == NULL) {; 15005 ; 15006 mg_cry_ctx_internal(phys_ctx,; 15007 ""Cannot add SSL socket (entry %i)"",; 15008 portsTotal);; 15009 continue;; 15010 }; 15011#endif; 15012 /* Create socket. */; 15013 /* For a list of protocol numbers (e.g., TCP==6) see:; 15014 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15015 */; 15016 if ((so.sock =; 15017 socket(so.lsa.sa.sa_family,; 15018 SOCK_STREAM,; 15019 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15020 == INVALID_SOCKET) {; 15021 ; 15022 mg_cry_ctx_internal(phys_ctx,; 15023 ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:448625,Modifiability,config,config,448625,"39 (int)ERRNO,; 15140 strerror(errno));; 15141 closesocket(so.sock);; 15142 so.sock = INVALID_SOCKET;; 15143 continue;; 15144 }; 15145 }; 15146#endif; 15147#if defined(USE_X_DOM_SOCKET); 15148 else if (so.lsa.sa.sa_family == AF_UNIX) {; 15149 ; 15150 len = sizeof(so.lsa.sun);; 15151 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15152 mg_cry_ctx_internal(phys_ctx,; 15153 ""cannot bind to unix socket %s: %d (%s)"",; 15154 so.lsa.sun.sun_path,; 15155 (int)ERRNO,; 15156 strerror(errno));; 15157 closesocket(so.sock);; 15158 so.sock = INVALID_SOCKET;; 15159 continue;; 15160 }; 15161 }; 15162#endif; 15163 else {; 15164 mg_cry_ctx_internal(; 15165 phys_ctx,; 15166 ""cannot bind: address family not supported (entry %i)"",; 15167 portsTotal);; 15168 closesocket(so.sock);; 15169 so.sock = INVALID_SOCKET;; 15170 continue;; 15171 }; 15172 ; 15173 opt_txt = phys_ctx->dd.config[LISTEN_BACKLOG_SIZE];; 15174 opt_listen_backlog = strtol(opt_txt, NULL, 10);; 15175 if ((opt_listen_backlog > INT_MAX) || (opt_listen_backlog < 1)) {; 15176 mg_cry_ctx_internal(phys_ctx,; 15177 ""%s value \""%s\"" is invalid"",; 15178 config_options[LISTEN_BACKLOG_SIZE].name,; 15179 opt_txt);; 15180 closesocket(so.sock);; 15181 so.sock = INVALID_SOCKET;; 15182 continue;; 15183 }; 15184 ; 15185 if (listen(so.sock, (int)opt_listen_backlog) != 0) {; 15186 ; 15187 mg_cry_ctx_internal(phys_ctx,; 15188 ""cannot listen to %.*s: %d (%s)"",; 15189 (int)vec.len,; 15190 vec.ptr,; 15191 (int)ERRNO,; 15192 strerror(errno));; 15193 closesocket(so.sock);; 15194 so.sock = INVALID_SOCKET;; 15195 continue;; 15196 }; 15197 ; 15198 if ((getsockname(so.sock, &(usa.sa), &len) != 0); 15199 || (usa.sa.sa_family != so.lsa.sa.sa_family)) {; 15200 ; 15201 int err = (int)ERRNO;; 15202 mg_cry_ctx_internal(phys_ctx,; 15203 ""call to getsockname failed %.*s: %d (%s)"",; 15204 (int)vec.len,; 15205 vec.ptr,; 15206 err,; 15207 strerror(errno));; 15208 closesocket(so.sock);; 15209 so.sock = INVALID_SOCKET;; 15210 continue;; 15211 }; 15212 ; 15213 /* Updat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453669,Modifiability,config,config,453669,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453752,Modifiability,config,config,453752,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:456188,Modifiability,config,config,456188,": """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched = -1;; 15457 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15458 vec.ptr++;; 15459 vec.len--;; 15460 matched = parse_match_net(&vec, sa, 1);; 15461 }; 15462 if (matched < 0) {; 15463 mg_cry_ctx_internal(phys_ctx,; 15464 ""%s: su",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:456768,Modifiability,config,config,456768,", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched = -1;; 15457 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15458 vec.ptr++;; 15459 vec.len--;; 15460 matched = parse_match_net(&vec, sa, 1);; 15461 }; 15462 if (matched < 0) {; 15463 mg_cry_ctx_internal(phys_ctx,; 15464 ""%s: subnet must be [+|-]IP-addr[/x]"",; 15465 __func__);; 15466 return -1;; 15467 }; 15468 if (matched) {; 15469 allowed = flag;; 15470 }; 15471 }; 15472 ; 15473 return allowed == '+';; 15474 }; 15475 return -1;; 15476}; 15477 ; 15478 ; 15479#if !defined(_WIN32) && !defined(__ZEPHYR__); 15480static int; 15481set_uid_option(struct mg_context *phys_ctx); 15482{; 15483 int success = 0;; 15484 ; 15485 if (phys_ctx) {; 15486 /* We are currently running as curr_uid. */; 15487 const uid_t curr_uid = getuid();; 15488 /* If set, we want to run as run_as_user. */; 15489 const char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];; 15490 c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:457849,Modifiability,config,config,457849,"c, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched = -1;; 15457 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15458 vec.ptr++;; 15459 vec.len--;; 15460 matched = parse_match_net(&vec, sa, 1);; 15461 }; 15462 if (matched < 0) {; 15463 mg_cry_ctx_internal(phys_ctx,; 15464 ""%s: subnet must be [+|-]IP-addr[/x]"",; 15465 __func__);; 15466 return -1;; 15467 }; 15468 if (matched) {; 15469 allowed = flag;; 15470 }; 15471 }; 15472 ; 15473 return allowed == '+';; 15474 }; 15475 return -1;; 15476}; 15477 ; 15478 ; 15479#if !defined(_WIN32) && !defined(__ZEPHYR__); 15480static int; 15481set_uid_option(struct mg_context *phys_ctx); 15482{; 15483 int success = 0;; 15484 ; 15485 if (phys_ctx) {; 15486 /* We are currently running as curr_uid. */; 15487 const uid_t curr_uid = getuid();; 15488 /* If set, we want to run as run_as_user. */; 15489 const char *run_as_user = phys_ctx->dd.config[RUN_AS_USER];; 15490 const struct passwd *to_pw = NULL;; 15491 ; 15492 if ((run_as_user != NULL) && (to_pw = getpwnam(run_as_user)) == NULL) {; 15493 /* run_as_user does not exist on the system. We can't proceed; 15494 * further. */; 15495 mg_cry_ctx_internal(phys_ctx,; 15496 ""%s: unknown user [%s]"",; 15497 __func__,; 15498 run_as_user);; 15499 } else if ((run_as_user == NULL) || (curr_uid == to_pw->pw_uid)) {; 15500 /* There was either no request to change user, or we're already; 15501 * running as run_as_user. Nothing else to do.; 15502 */; 15503 success = 1;; 15504 } else {; 15505 /* Valid change request. */; 15506 if (setgid(to_pw->pw_gid) == -1) {; 15507 mg_cry_ctx_internal(phys_ctx,; 15508 ""%s: setgid(%s): %s"",; 15509 __func__,; 15510 run_as_user,; 15511 strerror(errno));; 15512 } else if (setgroups(0, NULL) == -1) {; 15513 mg_cry_ctx_internal(phys_ctx,; 15514 ""%s: setgroups(): %s"",; 15515 __func__,; 15516 strerror(errno));; 15517 } else if (setuid(to_pw->pw_uid) == -1) {; 15518 mg_cry_ctx_internal(phys_ctx,; 15519 ""%s: setuid(%s): %s"",; 15520 __func__,; 15521 run_as_user",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:459900,Modifiability,config,config,459900,"rror(errno));; 15517 } else if (setuid(to_pw->pw_uid) == -1) {; 15518 mg_cry_ctx_internal(phys_ctx,; 15519 ""%s: setuid(%s): %s"",; 15520 __func__,; 15521 run_as_user,; 15522 strerror(errno));; 15523 } else {; 15524 success = 1;; 15525 }; 15526 }; 15527 }; 15528 ; 15529 return success;; 15530}; 15531#endif /* !_WIN32 */; 15532 ; 15533 ; 15534static void; 15535tls_dtor(void *key); 15536{; 15537 struct mg_workerTLS *tls = (struct mg_workerTLS *)key;; 15538 /* key == pthread_getspecific(sTlsKey); */; 15539 ; 15540 if (tls) {; 15541 if (tls->is_master == 2) {; 15542 tls->is_master = -3; /* Mark memory as dead */; 15543 mg_free(tls);; 15544 }; 15545 }; 15546 pthread_setspecific(sTlsKey, NULL);; 15547}; 15548 ; 15549 ; 15550#if defined(USE_MBEDTLS); 15551/* Check if SSL is required.; 15552 * If so, set up ctx->ssl_ctx pointer. */; 15553static int; 15554mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15555{; 15556 if (!phys_ctx) {; 15557 return 0;; 15558 }; 15559 ; 15560 if (!dom_ctx) {; 15561 dom_ctx = &(phys_ctx->dd);; 15562 }; 15563 ; 15564 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15565 /* No SSL port is set. No need to setup SSL. */; 15566 return 1;; 15567 }; 15568 ; 15569 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15570 if (dom_ctx->ssl_ctx == NULL) {; 15571 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15572 return 0;; 15573 }; 15574 ; 15575 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15576 == 0; 15577 ? 1; 15578 : 0;; 15579}; 15580 ; 15581#elif !defined(NO_SSL); 15582 ; 15583static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15584 struct mg_domain_context *dom_ctx,; 15585 const char *pem,; 15586 const char *chain);; 15587static const char *ssl_error(void);; 15588 ; 15589 ; 15590static int; 15591refresh_trust(struct mg_connection *conn); 15592{; 15593 struct stat cert_buf;; 15594 int64_t t = 0;; 15595 const char *pem;; 15596 const char *chain;; 15597 in",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:460277,Modifiability,config,config,460277,"cific(sTlsKey, NULL);; 15547}; 15548 ; 15549 ; 15550#if defined(USE_MBEDTLS); 15551/* Check if SSL is required.; 15552 * If so, set up ctx->ssl_ctx pointer. */; 15553static int; 15554mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15555{; 15556 if (!phys_ctx) {; 15557 return 0;; 15558 }; 15559 ; 15560 if (!dom_ctx) {; 15561 dom_ctx = &(phys_ctx->dd);; 15562 }; 15563 ; 15564 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15565 /* No SSL port is set. No need to setup SSL. */; 15566 return 1;; 15567 }; 15568 ; 15569 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15570 if (dom_ctx->ssl_ctx == NULL) {; 15571 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15572 return 0;; 15573 }; 15574 ; 15575 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15576 == 0; 15577 ? 1; 15578 : 0;; 15579}; 15580 ; 15581#elif !defined(NO_SSL); 15582 ; 15583static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15584 struct mg_domain_context *dom_ctx,; 15585 const char *pem,; 15586 const char *chain);; 15587static const char *ssl_error(void);; 15588 ; 15589 ; 15590static int; 15591refresh_trust(struct mg_connection *conn); 15592{; 15593 struct stat cert_buf;; 15594 int64_t t = 0;; 15595 const char *pem;; 15596 const char *chain;; 15597 int should_verify_peer;; 15598 ; 15599 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:460850,Modifiability,config,config,460850,"cific(sTlsKey, NULL);; 15547}; 15548 ; 15549 ; 15550#if defined(USE_MBEDTLS); 15551/* Check if SSL is required.; 15552 * If so, set up ctx->ssl_ctx pointer. */; 15553static int; 15554mg_sslctx_init(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 15555{; 15556 if (!phys_ctx) {; 15557 return 0;; 15558 }; 15559 ; 15560 if (!dom_ctx) {; 15561 dom_ctx = &(phys_ctx->dd);; 15562 }; 15563 ; 15564 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 15565 /* No SSL port is set. No need to setup SSL. */; 15566 return 1;; 15567 }; 15568 ; 15569 dom_ctx->ssl_ctx = (SSL_CTX *)mg_calloc(1, sizeof(*dom_ctx->ssl_ctx));; 15570 if (dom_ctx->ssl_ctx == NULL) {; 15571 fprintf(stderr, ""ssl_ctx malloc failed\n"");; 15572 return 0;; 15573 }; 15574 ; 15575 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15576 == 0; 15577 ? 1; 15578 : 0;; 15579}; 15580 ; 15581#elif !defined(NO_SSL); 15582 ; 15583static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15584 struct mg_domain_context *dom_ctx,; 15585 const char *pem,; 15586 const char *chain);; 15587static const char *ssl_error(void);; 15588 ; 15589 ; 15590static int; 15591refresh_trust(struct mg_connection *conn); 15592{; 15593 struct stat cert_buf;; 15594 int64_t t = 0;; 15595 const char *pem;; 15596 const char *chain;; 15597 int should_verify_peer;; 15598 ; 15599 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:461060,Modifiability,config,config,461060,"ssl_ctx malloc failed\n"");; 15572 return 0;; 15573 }; 15574 ; 15575 return mbed_sslctx_init(dom_ctx->ssl_ctx, dom_ctx->config[SSL_CERTIFICATE]); 15576 == 0; 15577 ? 1; 15578 : 0;; 15579}; 15580 ; 15581#elif !defined(NO_SSL); 15582 ; 15583static int ssl_use_pem_file(struct mg_context *phys_ctx,; 15584 struct mg_domain_context *dom_ctx,; 15585 const char *pem,; 15586 const char *chain);; 15587static const char *ssl_error(void);; 15588 ; 15589 ; 15590static int; 15591refresh_trust(struct mg_connection *conn); 15592{; 15593 struct stat cert_buf;; 15594 int64_t t = 0;; 15595 const char *pem;; 15596 const char *chain;; 15597 int should_verify_peer;; 15598 ; 15599 if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:461563,Modifiability,config,config,461563,"x->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 mg_unlock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:461641,Modifiability,config,config,461641,"x->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 mg_unlock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:461769,Modifiability,config,config,461769,"x->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 mg_unlock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:461959,Modifiability,config,config,461959,"x->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 mg_unlock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:462018,Modifiability,config,config,462018,"x->config[SSL_CERTIFICATE]) == NULL) {; 15600 /* If pem is NULL and conn->phys_ctx->callbacks.init_ssl is not,; 15601 * refresh_trust still can not work. */; 15602 return 0;; 15603 }; 15604 chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 15605 if (chain == NULL) {; 15606 /* pem is not NULL here */; 15607 chain = pem;; 15608 }; 15609 if (*chain == 0) {; 15610 chain = NULL;; 15611 }; 15612 ; 15613 if (stat(pem, &cert_buf) != -1) {; 15614 t = (int64_t)cert_buf.st_mtime;; 15615 }; 15616 ; 15617 mg_lock_context(conn->phys_ctx);; 15618 if ((t != 0) && (conn->dom_ctx->ssl_cert_last_mtime != t)) {; 15619 conn->dom_ctx->ssl_cert_last_mtime = t;; 15620 ; 15621 should_verify_peer = 0;; 15622 if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 15623 if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes""); 15624 == 0) {; 15625 should_verify_peer = 1;; 15626 } else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],; 15627 ""optional""); 15628 == 0) {; 15629 should_verify_peer = 1;; 15630 }; 15631 }; 15632 ; 15633 if (should_verify_peer) {; 15634 char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];; 15635 char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];; 15636 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 15637 ca_file,; 15638 ca_path); 15639 != 1) {; 15640 mg_unlock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:463230,Modifiability,config,config,463230,"lock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endif /* OPENSSL_API_1_1 */; 15667 ; 15668static int; 15669sslize(struct mg_connection *conn,; 15670 int (*func)(SSL *),; 15671 const struct mg_client_options *client_options); 15672{; 15673 int ret, err;; 15674 int short_trust;; 15675 unsigned timeout = 1024;; 15676 unsigned i;; 15677 ; 15678 if (!conn) {; 15679 return 0;; 15680 }; 15681 ; 15682 short_trust =; 15683 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_opt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:463303,Modifiability,config,config,463303,"lock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endif /* OPENSSL_API_1_1 */; 15667 ; 15668static int; 15669sslize(struct mg_connection *conn,; 15670 int (*func)(SSL *),; 15671 const struct mg_client_options *client_options); 15672{; 15673 int ret, err;; 15674 int short_trust;; 15675 unsigned timeout = 1024;; 15676 unsigned i;; 15677 ; 15678 if (!conn) {; 15679 return 0;; 15680 }; 15681 ; 15682 short_trust =; 15683 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_opt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464383,Modifiability,config,config,464383,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464580,Modifiability,config,config,464580,"L) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:480262,Modifiability,layers,layers,480262,"6#endif; 16227 return ret;; 16228}; 16229#else; 16230static long; 16231ssl_get_protocol(int version_id); 16232{; 16233 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16234 if (version_id > 0); 16235 ret |= SSL_OP_NO_SSLv2;; 16236 if (version_id > 1); 16237 ret |= SSL_OP_NO_SSLv3;; 16238 if (version_id > 2); 16239 ret |= SSL_OP_NO_TLSv1;; 16240 if (version_id > 3); 16241 ret |= SSL_OP_NO_TLSv1_1;; 16242 if (version_id > 4); 16243 ret |= SSL_OP_NO_TLSv1_2;; 16244#if defined(SSL_OP_NO_TLSv1_3); 16245 if (version_id > 5); 16246 ret |= SSL_OP_NO_TLSv1_3;; 16247#endif; 16248 return (long)ret;; 16249}; 16250#endif /* OPENSSL_API_1_1 */; 16251 ; 16252 ; 16253/* SSL callback documentation:; 16254 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16255 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16256 * https://linux.die.net/man/3/ssl_set_info_callback */; 16257/* Note: There is no ""const"" for the first argument in the documentation; 16258 * examples, however some (maybe most, but not all) headers of OpenSSL; 16259 * versions / OpenSSL compatibility layers have it. Having a different; 16260 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16261 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16262 * but not other way around */; 16263static void; 16264ssl_info_callback(const SSL *ssl, int what, int ret); 16265{; 16266 (void)ret;; 16267 ; 16268 if (what & SSL_CB_HANDSHAKE_START) {; 16269 SSL_get_app_data(ssl);; 16270 }; 16271 if (what & SSL_CB_HANDSHAKE_DONE) {; 16272 /* TODO: check for openSSL 1.1 */; 16273 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16274 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16275 }; 16276}; 16277 ; 16278 ; 16279static int; 16280ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16281{; 16282#if defined(GCC_DIAGNOSTIC); 16283#pragma GCC diagnostic push; 16284#pragma GCC diagnostic ignored ""-Wcast-align""; 16285#endif /* defi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:482546,Modifiability,config,config,482546,"95 ; 16296 (void)ad;; 16297 (void)arg;; 16298 ; 16299 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16300 DEBUG_ASSERT(0);; 16301 return SSL_TLSEXT_ERR_NOACK;; 16302 }; 16303 conn->dom_ctx = &(conn->phys_ctx->dd);; 16304 ; 16305 /* Old clients (Win XP) will not support SNI. Then, there; 16306 * is no server name available in the request - we can; 16307 * only work with the default certificate.; 16308 * Multiple HTTPS hosts on one IP+port are only possible; 16309 * with a certificate containing all alternative names.; 16310 */; 16311 if ((servername == NULL) || (*servername == 0)) {; 16312 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16313 mg_lock_context(conn->phys_ctx);; 16314 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16315 mg_unlock_context(conn->phys_ctx);; 16316 return SSL_TLSEXT_ERR_NOACK;; 16317 }; 16318 ; 16319 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16320 ; 16321 while (conn->dom_ctx) {; 16322 if (!mg_strcasecmp(servername,; 16323 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16324 /* Found matching domain */; 16325 DEBUG_TRACE(""TLS domain %s found"",; 16326 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16327 break;; 16328 }; 16329 mg_lock_context(conn->phys_ctx);; 16330 conn->dom_ctx = conn->dom_ctx->next;; 16331 mg_unlock_context(conn->phys_ctx);; 16332 }; 16333 ; 16334 if (conn->dom_ctx == NULL) {; 16335 /* Default domain */; 16336 DEBUG_TRACE(""TLS default domain %s used"",; 16337 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16338 conn->dom_ctx = &(conn->phys_ctx->dd);; 16339 }; 16340 mg_lock_context(conn->phys_ctx);; 16341 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16342 mg_unlock_context(conn->phys_ctx);; 16343 return SSL_TLSEXT_ERR_OK;; 16344}; 16345 ; 16346 ; 16347#if defined(USE_ALPN); 16348static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16349static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16350 alpn_proto_list + 3 + 8,; 16351 NULL};; 16352#if defined(USE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:482679,Modifiability,config,config,482679,"95 ; 16296 (void)ad;; 16297 (void)arg;; 16298 ; 16299 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16300 DEBUG_ASSERT(0);; 16301 return SSL_TLSEXT_ERR_NOACK;; 16302 }; 16303 conn->dom_ctx = &(conn->phys_ctx->dd);; 16304 ; 16305 /* Old clients (Win XP) will not support SNI. Then, there; 16306 * is no server name available in the request - we can; 16307 * only work with the default certificate.; 16308 * Multiple HTTPS hosts on one IP+port are only possible; 16309 * with a certificate containing all alternative names.; 16310 */; 16311 if ((servername == NULL) || (*servername == 0)) {; 16312 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16313 mg_lock_context(conn->phys_ctx);; 16314 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16315 mg_unlock_context(conn->phys_ctx);; 16316 return SSL_TLSEXT_ERR_NOACK;; 16317 }; 16318 ; 16319 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16320 ; 16321 while (conn->dom_ctx) {; 16322 if (!mg_strcasecmp(servername,; 16323 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16324 /* Found matching domain */; 16325 DEBUG_TRACE(""TLS domain %s found"",; 16326 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16327 break;; 16328 }; 16329 mg_lock_context(conn->phys_ctx);; 16330 conn->dom_ctx = conn->dom_ctx->next;; 16331 mg_unlock_context(conn->phys_ctx);; 16332 }; 16333 ; 16334 if (conn->dom_ctx == NULL) {; 16335 /* Default domain */; 16336 DEBUG_TRACE(""TLS default domain %s used"",; 16337 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16338 conn->dom_ctx = &(conn->phys_ctx->dd);; 16339 }; 16340 mg_lock_context(conn->phys_ctx);; 16341 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16342 mg_unlock_context(conn->phys_ctx);; 16343 return SSL_TLSEXT_ERR_OK;; 16344}; 16345 ; 16346 ; 16347#if defined(USE_ALPN); 16348static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16349static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16350 alpn_proto_list + 3 + 8,; 16351 NULL};; 16352#if defined(USE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:483016,Modifiability,config,config,483016,"6313 mg_lock_context(conn->phys_ctx);; 16314 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16315 mg_unlock_context(conn->phys_ctx);; 16316 return SSL_TLSEXT_ERR_NOACK;; 16317 }; 16318 ; 16319 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16320 ; 16321 while (conn->dom_ctx) {; 16322 if (!mg_strcasecmp(servername,; 16323 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16324 /* Found matching domain */; 16325 DEBUG_TRACE(""TLS domain %s found"",; 16326 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16327 break;; 16328 }; 16329 mg_lock_context(conn->phys_ctx);; 16330 conn->dom_ctx = conn->dom_ctx->next;; 16331 mg_unlock_context(conn->phys_ctx);; 16332 }; 16333 ; 16334 if (conn->dom_ctx == NULL) {; 16335 /* Default domain */; 16336 DEBUG_TRACE(""TLS default domain %s used"",; 16337 conn->phys_ctx->dd.config[AUTHENTICATION_DOMAIN]);; 16338 conn->dom_ctx = &(conn->phys_ctx->dd);; 16339 }; 16340 mg_lock_context(conn->phys_ctx);; 16341 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16342 mg_unlock_context(conn->phys_ctx);; 16343 return SSL_TLSEXT_ERR_OK;; 16344}; 16345 ; 16346 ; 16347#if defined(USE_ALPN); 16348static const char alpn_proto_list[] = ""\x02h2\x08http/1.1\x08http/1.0"";; 16349static const char *alpn_proto_order_http1[] = {alpn_proto_list + 3,; 16350 alpn_proto_list + 3 + 8,; 16351 NULL};; 16352#if defined(USE_HTTP2); 16353static const char *alpn_proto_order_http2[] = {alpn_proto_list,; 16354 alpn_proto_list + 3,; 16355 alpn_proto_list + 3 + 8,; 16356 NULL};; 16357#endif; 16358 ; 16359static int; 16360alpn_select_cb(SSL *ssl,; 16361 const unsigned char **out,; 16362 unsigned char *outlen,; 16363 const unsigned char *in,; 16364 unsigned int inlen,; 16365 void *arg); 16366{; 16367 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16368 unsigned int i, j, enable_http2 = 0;; 16369 const char **alpn_proto_order = alpn_proto_order_http1;; 16370 ; 16371 struct mg_workerTLS *tls =; 16372 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 163",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:484508,Modifiability,config,config,484508,"51 NULL};; 16352#if defined(USE_HTTP2); 16353static const char *alpn_proto_order_http2[] = {alpn_proto_list,; 16354 alpn_proto_list + 3,; 16355 alpn_proto_list + 3 + 8,; 16356 NULL};; 16357#endif; 16358 ; 16359static int; 16360alpn_select_cb(SSL *ssl,; 16361 const unsigned char **out,; 16362 unsigned char *outlen,; 16363 const unsigned char *in,; 16364 unsigned int inlen,; 16365 void *arg); 16366{; 16367 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16368 unsigned int i, j, enable_http2 = 0;; 16369 const char **alpn_proto_order = alpn_proto_order_http1;; 16370 ; 16371 struct mg_workerTLS *tls =; 16372 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 16373 ; 16374 (void)ssl;; 16375 ; 16376 if (tls == NULL) {; 16377 /* Need to store protocol in Thread Local Storage */; 16378 /* If there is no Thread Local Storage, don't use ALPN */; 16379 return SSL_TLSEXT_ERR_NOACK;; 16380 }; 16381 ; 16382#if defined(USE_HTTP2); 16383 enable_http2 = (0 == strcmp(dom_ctx->config[ENABLE_HTTP2], ""yes""));; 16384 if (enable_http2) {; 16385 alpn_proto_order = alpn_proto_order_http2;; 16386 }; 16387#endif; 16388 ; 16389 for (j = 0; alpn_proto_order[j] != NULL; j++) {; 16390 /* check all accepted protocols in this order */; 16391 const char *alpn_proto = alpn_proto_order[j];; 16392 /* search input for matching protocol */; 16393 for (i = 0; i < inlen; i++) {; 16394 if (!memcmp(in + i, alpn_proto, (unsigned char)alpn_proto[0])) {; 16395 *out = in + i + 1;; 16396 *outlen = in[i];; 16397 tls->alpn_proto = alpn_proto;; 16398 return SSL_TLSEXT_ERR_OK;; 16399 }; 16400 }; 16401 }; 16402 ; 16403 /* Nothing found */; 16404 return SSL_TLSEXT_ERR_NOACK;; 16405}; 16406 ; 16407 ; 16408static int; 16409next_protos_advertised_cb(SSL *ssl,; 16410 const unsigned char **data,; 16411 unsigned int *len,; 16412 void *arg); 16413{; 16414 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16415 *data = (const unsigned char *)alpn_proto_list;; 16416 *len = (unsigned in",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:488010,Modifiability,config,config,488010,"ruct timespec now_mt;; 16466 md5_byte_t ssl_context_id[16];; 16467 md5_state_t md5state;; 16468 int protocol_ver;; 16469 int ssl_cache_timeout;; 16470 ; 16471#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16472 && !defined(NO_SSL_DL); 16473 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16474 mg_cry_ctx_internal(phys_ctx,; 16475 ""SSL_CTX_new (server) error: %s"",; 16476 ssl_error());; 16477 return 0;; 16478 }; 16479#else; 16480 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16481 mg_cry_ctx_internal(phys_ctx,; 16482 ""SSL_CTX_new (server) error: %s"",; 16483 ssl_error());; 16484 return 0;; 16485 }; 16486#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16487 ; 16488#if defined(SSL_OP_NO_TLSv1_3); 16489 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16490 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16491 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16492 | SSL_OP_NO_TLSv1_3);; 16493#else; 16494 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16495 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16496 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16497#endif; 16498 ; 16499 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16503 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16504 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16505 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16506 ; 16507#if defined(SSL_OP_NO_RENEGOTIATION); 16508 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_RENEGOTIATION);; 16509#endif; 16510 ; 16511#if !defined(NO_SSL_DL); 16512 SSL_CTX_set_ecdh_auto(dom_ctx->ssl_ctx, 1);; 16513#endif /* NO_SSL_DL */; 16514 ; 16515 /* In SSL documentation examples callback defined without const; 16516 * specifier 'void (*)(SSL *, int, int)' See:; 16517 * https://www.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:490543,Modifiability,config,config,490543,"x,; 16531 ssl_servername_callback);; 16532 ; 16533 /* If a callback has been specified, call it. */; 16534 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16535 ? 0; 16536 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16537 phys_ctx->user_data));; 16538 ; 16539 /* If callback returns 0, civetweb sets up the SSL certificate.; 16540 * If it returns 1, civetweb assumes the calback already did this.; 16541 * If it returns -1, initializing ssl fails. */; 16542 if (callback_ret < 0) {; 16543 mg_cry_ctx_internal(phys_ctx,; 16544 ""SSL callback returned error: %i"",; 16545 callback_ret);; 16546 return 0;; 16547 }; 16548 if (callback_ret > 0) {; 16549 /* Callback did everything. */; 16550 return 1;; 16551 }; 16552 ; 16553 /* If a domain callback has been specified, call it. */; 16554 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16555 ? 0; 16556 : (phys_ctx->callbacks.init_ssl_domain(; 16557 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16558 dom_ctx->ssl_ctx,; 16559 phys_ctx->user_data));; 16560 ; 16561 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16562 * If it returns 1, civetweb assumes the calback already did this.; 16563 * If it returns -1, initializing ssl fails. */; 16564 if (callback_ret < 0) {; 16565 mg_cry_ctx_internal(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:491478,Modifiability,config,config,491478,"backs.init_ssl_domain(; 16557 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16558 dom_ctx->ssl_ctx,; 16559 phys_ctx->user_data));; 16560 ; 16561 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16562 * If it returns 1, civetweb assumes the calback already did this.; 16563 * If it returns -1, initializing ssl fails. */; 16564 if (callback_ret < 0) {; 16565 mg_cry_ctx_internal(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandato",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:491530,Modifiability,config,config,491530,"al(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:491622,Modifiability,config,config,491622,"al(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:491676,Modifiability,config,config,491676,"al(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492358,Modifiability,config,config,492358,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492430,Modifiability,config,config,492430,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492582,Modifiability,config,config,492582,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492826,Modifiability,config,config,492826,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492902,Modifiability,config,config,492902,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:493024,Modifiability,config,config,493024,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:493071,Modifiability,config,config,493071,"state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS], ""yes""); 16620 == 0);; 16621 ; 16622 if (should_verify_peer) {; 16623 ca_path = dom_ctx->config[SSL_CA_PATH];; 16624 ca_file = dom_ctx->config[SSL_CA_FILE];; 16625 if (SSL_CTX_load_verify_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_veri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494012,Modifiability,config,config,494012,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494076,Modifiability,config,config,494076,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494214,Modifiability,config,config,494214,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494318,Modifiability,config,config,494318,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494557,Modifiability,config,config,494557,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:494615,Modifiability,config,config,494615,"y_locations(dom_ctx->ssl_ctx, ca_file, ca_path); 16626 != 1) {; 16627 mg_cry_ctx_internal(phys_ctx,; 16628 ""SSL_CTX_load_verify_locations error: %s ""; 16629 ""ssl_verify_peer requires setting ""; 16630 ""either ssl_ca_path or ssl_ca_file. ""; 16631 ""Is any of them present in the ""; 16632 "".conf file?"",; 16633 ssl_error());; 16634 return 0;; 16635 }; 16636 ; 16637 if (peer_certificate_optional) {; 16638 SSL_CTX_set_verify(dom_ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);; 16639 } else {; 16640 SSL_CTX_set_verify(dom_ctx->ssl_ctx,; 16641 SSL_VERIFY_PEER; 16642 | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,; 16643 NULL);; 16644 }; 16645 ; 16646 if (use_default_verify_paths; 16647 && (SSL_CTX_set_default_verify_paths(dom_ctx->ssl_ctx) != 1)) {; 16648 mg_cry_ctx_internal(phys_ctx,; 16649 ""SSL_CTX_set_default_verify_paths error: %s"",; 16650 ssl_error());; 16651 return 0;; 16652 }; 16653 ; 16654 if (dom_ctx->config[SSL_VERIFY_DEPTH]) {; 16655 verify_depth = atoi(dom_ctx->config[SSL_VERIFY_DEPTH]);; 16656 SSL_CTX_set_verify_depth(dom_ctx->ssl_ctx, verify_depth);; 16657 }; 16658 }; 16659 ; 16660 if (dom_ctx->config[SSL_CIPHER_LIST] != NULL) {; 16661 if (SSL_CTX_set_cipher_list(dom_ctx->ssl_ctx,; 16662 dom_ctx->config[SSL_CIPHER_LIST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[T",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:495796,Modifiability,config,config,495796,"nfig[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[TLS_ALPN]); 16685#endif; 16686 {; 16687 init_alpn(phys_ctx, dom_ctx);; 16688 }; 16689#endif; 16690 ; 16691 return 1;; 16692}; 16693 ; 16694 ; 16695/* Check if SSL is required.; 16696 * If so, dynamically load SSL library; 16697 * and set up ctx->ssl_ctx pointer. */; 16698static int; 16699init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16700{; 16701 void *ssl_ctx = 0;; 16702 int callback_ret;; 16703 const char *pem;; 16704 const char *chain;; 16705 char ebuf[128];; 16706 ; 16707 if (!phys_ctx) {; 16708 return 0;; 16709 }; 16710 ; 16711 if (!dom_ctx) {; 16712 dom_ctx = &(phys_ctx->dd);; 16713 }; 16714 ; 16715 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16716 /* No SSL port is set. No need to setup SSL. */; 16717 return 1;; 16718 }; 16719 ; 16720 /* Check for external SSL_CTX */; 16721 callback_ret =; 16722 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16723 ? 0; 16724 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16725 phys_ctx->user_data));; 16726 ; 16727 if (callback_ret < 0) {; 16728 /* Callback exists and returns <0: Initializing failed. */; 16729 mg_cry_ctx_internal(phys_ctx,; 16730 ""external_ssl_ctx callback returned error: %i"",; 16731 callback_ret);; 16732 return 0;; 16733 } else if (callback_ret > 0) {; 16734 /* Callback exists and returns >0: Initializing complete,; 16735 * civetweb should not modify the SSL context. */; 16736 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16737 if (!initialize_openssl(ebuf, sizeof(ebuf))",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:497086,Modifiability,config,config,497086,"27 if (callback_ret < 0) {; 16728 /* Callback exists and returns <0: Initializing failed. */; 16729 mg_cry_ctx_internal(phys_ctx,; 16730 ""external_ssl_ctx callback returned error: %i"",; 16731 callback_ret);; 16732 return 0;; 16733 } else if (callback_ret > 0) {; 16734 /* Callback exists and returns >0: Initializing complete,; 16735 * civetweb should not modify the SSL context. */; 16736 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16737 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16738 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16739 return 0;; 16740 }; 16741 return 1;; 16742 }; 16743 /* If the callback does not exist or return 0, civetweb must initialize; 16744 * the SSL context. Handle ""domain"" callback next. */; 16745 ; 16746 /* Check for external domain SSL_CTX callback. */; 16747 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16748 ? 0; 16749 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16750 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16751 &ssl_ctx,; 16752 phys_ctx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:497969,Modifiability,config,config,497969,"tx_domain == NULL); 16748 ? 0; 16749 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16750 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16751 &ssl_ctx,; 16752 phys_ctx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:498426,Modifiability,config,configured,498426,"6761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16813 ; 16814 /* Shutdown according to; 16815 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modul",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:498473,Modifiability,config,config,498473," 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16813 ; 16814 /* Shutdown according to; 16815 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modules_unload(1);; 16819#else; 16820 int i;; 16821 ; 16822 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16823 ; 16824 /* Shutdown according to; 16825 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:500658,Modifiability,config,config,500658,"15 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modules_unload(1);; 16819#else; 16820 int i;; 16821 ; 16822 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16823 ; 16824 /* Shutdown according to; 16825 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16826 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16827 */; 16828 CRYPTO_set_locking_callback(NULL);; 16829 CRYPTO_set_id_callback(NULL);; 16830 ENGINE_cleanup();; 16831 CONF_modules_unload(1);; 16832 ERR_free_strings();; 16833 EVP_cleanup();; 16834 CRYPTO_cleanup_all_ex_data();; 16835 OPENSSL_REMOVE_THREAD_STATE();; 16836 ; 16837 for (i = 0; i < CRYPTO_num_locks(); i++) {; 16838 pthread_mutex_destroy(&ssl_mutexes[i]);; 16839 }; 16840 mg_free(ssl_mutexes);; 16841 ssl_mutexes = NULL;; 16842#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16843 }; 16844}; 16845#endif /* !defined(NO_SSL) && !defined(USE_MBEDTLS) */; 16846 ; 16847 ; 16848#if !defined(NO_FILESYSTEMS); 16849static int; 16850set_gpass_option(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16851{; 16852 if (phys_ctx) {; 16853 struct mg_file file = STRUCT_FILE_INITIALIZER;; 16854 const char *path;; 16855 struct mg_connection fc;; 16856 if (!dom_ctx) {; 16857 dom_ctx = &(phys_ctx->dd);; 16858 }; 16859 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16860 if ((path != NULL); 16861 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16862 mg_cry_ctx_internal(phys_ctx,; 16863 ""Cannot open %s: %s"",; 16864 path,; 16865 strerror(ERRNO));; 16866 return 0;; 16867 }; 16868 return 1;; 16869 }; 16870 return 0;; 16871}; 16872#endif /* NO_FILESYSTEMS */; 16873 ; 16874 ; 16875static int; 16876set_acl_option(struct mg_context *phys_ctx); 16877{; 16878 union usa sa;; 16879 memset(&sa, 0, sizeof(sa));; 16880#if defined(USE_IPV6); 16881 sa.sin6.sin6_family = AF_I",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:504475,Modifiability,config,config,504475,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:504545,Modifiability,config,config,504545,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:504628,Modifiability,config,configuration,504628,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:505627,Modifiability,config,configure,505627,"according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 1706",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:523814,Modifiability,config,config,523814," it is; 17591 * addressing the current server. So civetweb can also be used; 17592 * as a proxy server. */; 17593 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17594 if (mg_strncasecmp(uri,; 17595 abs_uri_protocols[i].proto,; 17596 abs_uri_protocols[i].proto_len); 17597 == 0) {; 17598 ; 17599 hostend = strchr(uri + abs_uri_protocols[i].proto_len, '/');; 17600 if (!hostend) {; 17601 return 0;; 17602 }; 17603 portbegin = strchr(uri + abs_uri_protocols[i].proto_len, ':');; 17604 if (!portbegin) {; 17605 return 3;; 17606 }; 17607 ; 17608 port = strtoul(portbegin + 1, &portend, 10);; 17609 if ((portend != hostend) || (port <= 0) || !is_valid_port(port)) {; 17610 return 0;; 17611 }; 17612 ; 17613 return 4;; 17614 }; 17615 }; 17616 ; 17617 return 0;; 17618}; 17619 ; 17620 ; 17621/* Return NULL or the relative uri at the current server */; 17622static const char *; 17623get_rel_url_at_current_server(const char *uri, const struct mg_connection *conn); 17624{; 17625 const char *server_domain;; 17626 size_t server_domain_len;; 17627 size_t request_domain_len = 0;; 17628 unsigned long port = 0;; 17629 int i, auth_domain_check_enabled;; 17630 const char *hostbegin = NULL;; 17631 const char *hostend = NULL;; 17632 const char *portbegin;; 17633 char *portend;; 17634 ; 17635 auth_domain_check_enabled =; 17636 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_AUTH_DOMAIN_CHECK], ""yes"");; 17637 ; 17638 /* DNS is case insensitive, so use case insensitive string compare here; 17639 */; 17640 for (i = 0; abs_uri_protocols[i].proto != NULL; i++) {; 17641 if (mg_strncasecmp(uri,; 17642 abs_uri_protocols[i].proto,; 17643 abs_uri_protocols[i].proto_len); 17644 == 0) {; 17645 ; 17646 hostbegin = uri + abs_uri_protocols[i].proto_len;; 17647 hostend = strchr(hostbegin, '/');; 17648 if (!hostend) {; 17649 return 0;; 17650 }; 17651 portbegin = strchr(hostbegin, ':');; 17652 if ((!portbegin) || (portbegin > hostend)) {; 17653 port = abs_uri_protocols[i].default_port;; 17654 request_domain_len ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:525706,Modifiability,config,config,525706,"7669 /* port remains 0 if the protocol is not found */; 17670 return 0;; 17671 }; 17672 ; 17673 /* Check if the request is directed to a different server. */; 17674 /* First check if the port is the same. */; 17675 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17676 /* Request is directed to a different port */; 17677 return 0;; 17678 }; 17679 ; 17680 /* Finally check if the server corresponds to the authentication; 17681 * domain of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17690 server_domain_len = strlen(server_domain);; 17691 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17692 return 0;; 17693 }; 17694 if ((request_domain_len == server_domain_len); 17695 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17696 /* Request is directed to this server - full name match. */; 17697 } else {; 17698 if (request_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700 * is longer than the request name.; 17701 * Drop this case here to avoid overflows in the; 17702 * following checks. */; 17703 return 0;; 17704 }; 17705 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:534575,Modifiability,config,config,534575,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:534808,Modifiability,config,config,534808,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:534924,Modifiability,config,config,534924,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:548099,Modifiability,config,config,548099,"ar *extensions,; 18429 mg_websocket_data_handler data_func,; 18430 mg_websocket_close_handler close_func,; 18431 void *user_data); 18432{; 18433 struct mg_client_options client_options;; 18434 memset(&client_options, 0, sizeof(client_options));; 18435 client_options.host = host;; 18436 client_options.port = port;; 18437 ; 18438 return mg_connect_websocket_client_impl(&client_options,; 18439 use_ssl,; 18440 error_buffer,; 18441 error_buffer_size,; 18442 path,; 18443 origin,; 18444 extensions,; 18445 data_func,; 18446 close_func,; 18447 user_data);; 18448}; 18449 ; 18450struct mg_connection *; 18451mg_connect_websocket_client_secure_extensions(; 18452 const struct mg_client_options *client_options,; 18453 char *error_buffer,; 18454 size_t error_buffer_size,; 18455 const char *path,; 18456 const char *origin,; 18457 const char *extensions,; 18458 mg_websocket_data_handler data_func,; 18459 mg_websocket_close_handler close_func,; 18460 void *user_data); 18461{; 18462 if (!client_options) {; 18463 return NULL;; 18464 }; 18465 return mg_connect_websocket_client_impl(client_options,; 18466 1,; 18467 error_buffer,; 18468 error_buffer_size,; 18469 path,; 18470 origin,; 18471 extensions,; 18472 data_func,; 18473 close_func,; 18474 user_data);; 18475}; 18476 ; 18477/* Prepare connection data structure */; 18478static void; 18479init_connection(struct mg_connection *conn); 18480{; 18481 /* Is keep alive allowed by the server */; 18482 int keep_alive_enabled =; 18483 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"");; 18484 ; 18485 if (!keep_alive_enabled) {; 18486 conn->must_close = 1;; 18487 }; 18488 ; 18489 /* Important: on new connection, reset the receiving buffer. Credit; 18490 * goes to crule42. */; 18491 conn->data_len = 0;; 18492 conn->handled_requests = 0;; 18493 conn->connection_type = CONNECTION_TYPE_INVALID;; 18494 mg_set_user_connection_data(conn, NULL);; 18495 ; 18496#if defined(USE_SERVER_STATS); 18497 conn->conn_state = 2; /* init */; 18498#endif; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:571483,Modifiability,config,config,571483,"n forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 19194{; 19195 struct mg_workerTLS tls;; 19196 struct mg_pollfd *pfd;; 19197 unsigned int i;; 19198 unsigned int workerthreadcount;; 19199 ; 19200 if (!ctx) {; 19201 return;; 19202 }; 19203 ; 19204 mg_set_thread_name(""master"");; 19205 ; 19206 /* Increase priority of the master thread */; 19207#if defined(_WIN32); 19208 SetThreadPriority(GetCurrentThread(), ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:571546,Modifiability,config,config,571546,"; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 19194{; 19195 struct mg_workerTLS tls;; 19196 struct mg_pollfd *pfd;; 19197 unsigned int i;; 19198 unsigned int workerthreadcount;; 19199 ; 19200 if (!ctx) {; 19201 return;; 19202 }; 19203 ; 19204 mg_set_thread_name(""master"");; 19205 ; 19206 /* Increase priority of the master thread */; 19207#if defined(_WIN32); 19208 SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);; 19209#elif defined(USE_MASTER_THREAD_PRIORITY); 19210 int min_prio = sched_get_priority_min(SCHED_RR);; 19211 int max_prio = sched_get_priority_max(SCHED_RR);; 19212 if ((mi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:571860,Modifiability,inherit,inherited,571860,"; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 19194{; 19195 struct mg_workerTLS tls;; 19196 struct mg_pollfd *pfd;; 19197 unsigned int i;; 19198 unsigned int workerthreadcount;; 19199 ; 19200 if (!ctx) {; 19201 return;; 19202 }; 19203 ; 19204 mg_set_thread_name(""master"");; 19205 ; 19206 /* Increase priority of the master thread */; 19207#if defined(_WIN32); 19208 SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);; 19209#elif defined(USE_MASTER_THREAD_PRIORITY); 19210 int min_prio = sched_get_priority_min(SCHED_RR);; 19211 int max_prio = sched_get_priority_max(SCHED_RR);; 19212 if ((mi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:579776,Modifiability,config,config,579776,"SIGPIPE, &sa, NULL);; 19388#endif; 19389 ; 19390 master_thread_run((struct mg_context *)thread_func_param);; 19391 return NULL;; 19392}; 19393#endif /* _WIN32 */; 19394 ; 19395 ; 19396static void; 19397free_context(struct mg_context *ctx); 19398{; 19399 int i;; 19400 struct mg_handler_info *tmp_rh;; 19401 ; 19402 if (ctx == NULL) {; 19403 return;; 19404 }; 19405 ; 19406 /* Call user callback */; 19407 if (ctx->callbacks.exit_context) {; 19408 ctx->callbacks.exit_context(ctx);; 19409 }; 19410 ; 19411 /* All threads exited, no sync is needed. Destroy thread mutex and; 19412 * condvars; 19413 */; 19414 (void)pthread_mutex_destroy(&ctx->thread_mutex);; 19415 ; 19416#if defined(ALTERNATIVE_QUEUE); 19417 mg_free(ctx->client_socks);; 19418 if (ctx->client_wait_events != NULL) {; 19419 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19420 event_destroy(ctx->client_wait_events[i]);; 19421 }; 19422 mg_free(ctx->client_wait_events);; 19423 }; 19424#else; 19425 (void)pthread_cond_destroy(&ctx->sq_empty);; 19426 (void)pthread_cond_destroy(&ctx->sq_full);; 19427 mg_free(ctx->squeue);; 19428#endif; 19429 ; 19430 /* Destroy other context global data structures mutex */; 19431 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19432 ; 19433#if defined(USE_LUA); 19434 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19435#endif; 19436 ; 19437 /* Deallocate config parameters */; 19438 for (i = 0; i < NUM_OPTIONS; i++) {; 19439 if (ctx->dd.config[i] != NULL) {; 19440#if defined(_MSC_VER); 19441#pragma warning(suppress : 6001); 19442#endif; 19443 mg_free(ctx->dd.config[i]);; 19444 }; 19445 }; 19446 ; 19447 /* Deallocate request handlers */; 19448 while (ctx->dd.handlers) {; 19449 tmp_rh = ctx->dd.handlers;; 19450 ctx->dd.handlers = tmp_rh->next;; 19451 mg_free(tmp_rh->uri);; 19452 mg_free(tmp_rh);; 19453 }; 19454 ; 19455#if defined(USE_MBEDTLS); 19456 if (ctx->dd.ssl_ctx != NULL) {; 19457 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19458 mg_free(ctx->dd.ssl_ctx);; 19459 ctx->dd.ssl_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:579859,Modifiability,config,config,579859,"ads exited, no sync is needed. Destroy thread mutex and; 19412 * condvars; 19413 */; 19414 (void)pthread_mutex_destroy(&ctx->thread_mutex);; 19415 ; 19416#if defined(ALTERNATIVE_QUEUE); 19417 mg_free(ctx->client_socks);; 19418 if (ctx->client_wait_events != NULL) {; 19419 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19420 event_destroy(ctx->client_wait_events[i]);; 19421 }; 19422 mg_free(ctx->client_wait_events);; 19423 }; 19424#else; 19425 (void)pthread_cond_destroy(&ctx->sq_empty);; 19426 (void)pthread_cond_destroy(&ctx->sq_full);; 19427 mg_free(ctx->squeue);; 19428#endif; 19429 ; 19430 /* Destroy other context global data structures mutex */; 19431 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19432 ; 19433#if defined(USE_LUA); 19434 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19435#endif; 19436 ; 19437 /* Deallocate config parameters */; 19438 for (i = 0; i < NUM_OPTIONS; i++) {; 19439 if (ctx->dd.config[i] != NULL) {; 19440#if defined(_MSC_VER); 19441#pragma warning(suppress : 6001); 19442#endif; 19443 mg_free(ctx->dd.config[i]);; 19444 }; 19445 }; 19446 ; 19447 /* Deallocate request handlers */; 19448 while (ctx->dd.handlers) {; 19449 tmp_rh = ctx->dd.handlers;; 19450 ctx->dd.handlers = tmp_rh->next;; 19451 mg_free(tmp_rh->uri);; 19452 mg_free(tmp_rh);; 19453 }; 19454 ; 19455#if defined(USE_MBEDTLS); 19456 if (ctx->dd.ssl_ctx != NULL) {; 19457 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19458 mg_free(ctx->dd.ssl_ctx);; 19459 ctx->dd.ssl_ctx = NULL;; 19460 }; 19461 ; 19462#elif !defined(NO_SSL); 19463 /* Deallocate SSL context */; 19464 if (ctx->dd.ssl_ctx != NULL) {; 19465 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19466 int callback_ret =; 19467 (ctx->callbacks.external_ssl_ctx == NULL); 19468 ? 0; 19469 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19470 ; 19471 if (callback_ret == 0) {; 19472 SSL_CTX_free(ctx->dd.ssl_ctx);; 19473 }; 19474 /* else: ignore error and ommit SSL_CTX_free in case; 19475 * callback_ret is 1 */; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:579983,Modifiability,config,config,579983,"estroy(&ctx->thread_mutex);; 19415 ; 19416#if defined(ALTERNATIVE_QUEUE); 19417 mg_free(ctx->client_socks);; 19418 if (ctx->client_wait_events != NULL) {; 19419 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 19420 event_destroy(ctx->client_wait_events[i]);; 19421 }; 19422 mg_free(ctx->client_wait_events);; 19423 }; 19424#else; 19425 (void)pthread_cond_destroy(&ctx->sq_empty);; 19426 (void)pthread_cond_destroy(&ctx->sq_full);; 19427 mg_free(ctx->squeue);; 19428#endif; 19429 ; 19430 /* Destroy other context global data structures mutex */; 19431 (void)pthread_mutex_destroy(&ctx->nonce_mutex);; 19432 ; 19433#if defined(USE_LUA); 19434 (void)pthread_mutex_destroy(&ctx->lua_bg_mutex);; 19435#endif; 19436 ; 19437 /* Deallocate config parameters */; 19438 for (i = 0; i < NUM_OPTIONS; i++) {; 19439 if (ctx->dd.config[i] != NULL) {; 19440#if defined(_MSC_VER); 19441#pragma warning(suppress : 6001); 19442#endif; 19443 mg_free(ctx->dd.config[i]);; 19444 }; 19445 }; 19446 ; 19447 /* Deallocate request handlers */; 19448 while (ctx->dd.handlers) {; 19449 tmp_rh = ctx->dd.handlers;; 19450 ctx->dd.handlers = tmp_rh->next;; 19451 mg_free(tmp_rh->uri);; 19452 mg_free(tmp_rh);; 19453 }; 19454 ; 19455#if defined(USE_MBEDTLS); 19456 if (ctx->dd.ssl_ctx != NULL) {; 19457 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19458 mg_free(ctx->dd.ssl_ctx);; 19459 ctx->dd.ssl_ctx = NULL;; 19460 }; 19461 ; 19462#elif !defined(NO_SSL); 19463 /* Deallocate SSL context */; 19464 if (ctx->dd.ssl_ctx != NULL) {; 19465 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19466 int callback_ret =; 19467 (ctx->callbacks.external_ssl_ctx == NULL); 19468 ? 0; 19469 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19470 ; 19471 if (callback_ret == 0) {; 19472 SSL_CTX_free(ctx->dd.ssl_ctx);; 19473 }; 19474 /* else: ignore error and ommit SSL_CTX_free in case; 19475 * callback_ret is 1 */; 19476 }; 19477#endif /* !NO_SSL */; 19478 ; 19479 /* Deallocate worker thread ID array */; 19480 mg_free(ctx->worke",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:588918,Modifiability,config,configuration,588918,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589394,Modifiability,config,configuration,589394,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589567,Modifiability,config,config,589567,"e)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589612,Modifiability,config,configuration,589612,"e)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589794,Modifiability,config,config,589794,"runcation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_sets",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:589832,Modifiability,config,config,589832,"uration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 197",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590114,Modifiability,config,config,590114,"tion value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CO",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590178,Modifiability,config,config,590178," 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 m",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590311,Modifiability,config,config,590311,"""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invali",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:590679,Modifiability,config,configuration,590679,"licate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for (i = 0; config_options[i].name != NULL; i++) {; 19768 default_value = config_options[i].default_value;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591012,Modifiability,config,config,591012,"lue;; 19769 if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {; 19770 ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);; 19771 }; 19772 }; 19773 ; 19774 /* Request size option */; 19775 itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:591387,Modifiability,config,configuration,591387,"g[MAX_REQUEST_SIZE]);; 19776 if (itmp < 1024) {; 19777 mg_cry_ctx_internal(ctx,; 19778 ""%s too small"",; 19779 config_options[MAX_REQUEST_SIZE].name);; 19780 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19781 mg_snprintf(NULL,; 19782 NULL, /* No truncation check for error buffers */; 19783 error->text,; 19784 error->text_buffer_size,; 19785 ""Invalid configuration option value: %s"",; 19786 config_options[MAX_REQUEST_SIZE].name);; 19787 }; 19788 free_context(ctx);; 19789 pthread_setspecific(sTlsKey, NULL);; 19790 return NULL;; 19791 }; 19792 ctx->max_request_size = (unsigned)itmp;; 19793 ; 19794 /* Queue length */; 19795#if !defined(ALTERNATIVE_QUEUE); 19796 itmp = atoi(ctx->dd.config[CONNECTION_QUEUE_SIZE]);; 19797 if (itmp < 1) {; 19798 mg_cry_ctx_internal(ctx,; 19799 ""%s too small"",; 19800 config_options[CONNECTION_QUEUE_SIZE].name);; 19801 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19802 mg_snprintf(NULL,; 19803 NULL, /* No truncation check for error buffers */; 19804 error->text,; 19805 error->text_buffer_size,; 19806 ""Invalid configuration option value: %s"",; 19807 config_options[CONNECTION_QUEUE_SIZE].name);; 19808 }; 19809 free_context(ctx);; 19810 pthread_setspecific(sTlsKey, NULL);; 19811 return NULL;; 19812 }; 19813 ctx->squeue =; 19814 (struct socket *)mg_calloc((unsigned int)itmp, sizeof(struct socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread cou",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592369,Modifiability,config,config,592369," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:592898,Modifiability,config,configuration,592898," socket));; 19815 if (ctx->squeue == NULL) {; 19816 mg_cry_ctx_internal(ctx,; 19817 ""Out of memory: Cannot allocate %s"",; 19818 config_options[CONNECTION_QUEUE_SIZE].name);; 19819 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19820 mg_snprintf(NULL,; 19821 NULL, /* No truncation check for error buffers */; 19822 error->text,; 19823 error->text_buffer_size,; 19824 ""Out of memory: Cannot allocate %s"",; 19825 config_options[CONNECTION_QUEUE_SIZE].name);; 19826 }; 19827 free_context(ctx);; 19828 pthread_setspecific(sTlsKey, NULL);; 19829 return NULL;; 19830 }; 19831 ctx->sq_size = itmp;; 19832#endif; 19833 ; 19834 /* Worker thread count option */; 19835 workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 198",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593162,Modifiability,config,config,593162,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593480,Modifiability,config,configuration,593480,"atoi(ctx->dd.config[NUM_THREADS]);; 19836 ; 19837 if ((workerthreadcount > MAX_WORKER_THREADS) || (workerthreadcount <= 0)) {; 19838 if (workerthreadcount <= 0) {; 19839 mg_cry_ctx_internal(ctx, ""%s"", ""Invalid number of worker threads"");; 19840 } else {; 19841 mg_cry_ctx_internal(ctx, ""%s"", ""Too many worker threads"");; 19842 }; 19843 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593808,Modifiability,config,configured,593808,"43 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19844 mg_snprintf(NULL,; 19845 NULL, /* No truncation check for error buffers */; 19846 error->text,; 19847 error->text_buffer_size,; 19848 ""Invalid configuration option value: %s"",; 19849 config_options[NUM_THREADS].name);; 19850 }; 19851 free_context(ctx);; 19852 pthread_setspecific(sTlsKey, NULL);; 19853 return NULL;; 19854 }; 19855 ; 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:593890,Modifiability,config,config,593890," 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lu",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594286,Modifiability,config,config,594286,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595005,Modifiability,config,config,595005,"ate, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 199",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:595611,Modifiability,config,config,595611,");; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598986,Modifiability,config,configured,598986,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609380,Modifiability,config,config,609380,"k for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609567,Modifiability,config,config,609567,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609606,Modifiability,config,config,609606,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609834,Modifiability,config,config,609834,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610344,Modifiability,config,config,610344,"85 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610487,Modifiability,config,config,610487,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610519,Modifiability,config,config,610519,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:610584,Modifiability,config,config,610584,"xt_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 2046",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611608,Modifiability,config,config,611608,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611651,Modifiability,config,config,611651,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:611798,Modifiability,config,config,611798,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:612097,Modifiability,config,config,612097,"t64_t)get_random() << 31);; 20424 ; 20425#if defined(USE_LUA) && defined(USE_WEBSOCKET); 20426 new_dom->shared_lua_websockets = NULL;; 20427#endif; 20428 ; 20429#if !defined(NO_SSL) && !defined(USE_MBEDTLS); 20430 if (!init_ssl_ctx(ctx, new_dom)) {; 20431 /* Init SSL failed */; 20432 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20433 mg_snprintf(NULL,; 20434 NULL, /* No truncation check for error buffers */; 20435 error->text,; 20436 error->text_buffer_size,; 20437 ""%s"",; 20438 ""Initializing SSL context failed"");; 20439 }; 20440 mg_free(new_dom);; 20441 return -3;; 20442 }; 20443#endif; 20444 ; 20445 /* Add element to linked list. */; 20446 mg_lock_context(ctx);; 20447 ; 20448 idx = 0;; 20449 dom = &(ctx->dd);; 20450 for (;;) {; 20451 if (!mg_strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],; 20452 dom->config[AUTHENTICATION_DOMAIN])) {; 20453 /* Domain collision */; 20454 mg_cry_ctx_internal(ctx,; 20455 ""domain %s already in use"",; 20456 new_dom->config[AUTHENTICATION_DOMAIN]);; 20457 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20458 mg_snprintf(NULL,; 20459 NULL, /* No truncation check for error buffers */; 20460 error->text,; 20461 error->text_buffer_size,; 20462 ""Domain %s specified by %s is already in use"",; 20463 new_dom->config[AUTHENTICATION_DOMAIN],; 20464 config_options[AUTHENTICATION_DOMAIN].name);; 20465 }; 20466 mg_free(new_dom);; 20467 mg_unlock_context(ctx);; 20468 return -5;; 20469 }; 20470 ; 20471 /* Count number of domains */; 20472 idx++;; 20473 ; 20474 if (dom->next == NULL) {; 20475 dom->next = new_dom;; 20476 break;; 20477 }; 20478 dom = dom->next;; 20479 }; 20480 ; 20481 mg_unlock_context(ctx);; 20482 ; 20483 /* Return domain number */; 20484 return idx;; 20485}; 20486 ; 20487 ; 20488int; 20489mg_start_domain(struct mg_context *ctx, const char **options); 20490{; 20491 return mg_start_domain2(ctx, options, NULL);; 20492}; 20493 ; 20494 ; 20495/* Feature check API function */; 20496unsigned; 20497mg_check_feature(unsig",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:626293,Modifiability,variab,variables,626293,"0908/* Get context information. It can be printed or stored by the caller.; 20909 * Return the size of available information. */; 20910int; 20911mg_get_context_info(const struct mg_context *ctx, char *buffer, int buflen); 20912{; 20913#if defined(USE_SERVER_STATS); 20914 char *end, *append_eoobj = NULL, block[256];; 20915 size_t context_info_length = 0;; 20916 ; 20917#if defined(_WIN32); 20918 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 20919#else; 20920 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 20921#endif; 20922 struct mg_memory_stat *ms = get_memory_stat((struct mg_context *)ctx);; 20923 ; 20924 if ((buffer == NULL) || (buflen < 1)) {; 20925 buflen = 0;; 20926 end = buffer;; 20927 } else {; 20928 *buffer = 0;; 20929 end = buffer + buflen;; 20930 }; 20931 if (buflen > (int)(sizeof(eoobj) - 1)) {; 20932 /* has enough space to append eoobj */; 20933 append_eoobj = buffer;; 20934 end -= sizeof(eoobj) - 1;; 20935 }; 20936 ; 20937 context_info_length += mg_str_append(&buffer, end, ""{"");; 20938 ; 20939 if (ms) { /* <-- should be always true */; 20940 /* Memory information */; 20941 int blockCount = (int)ms->blockCount;; 20942 int64_t totalMemUsed = ms->totalMemUsed;; 20943 int64_t maxMemUsed = ms->maxMemUsed;; 20944 if (totalMemUsed > maxMemUsed) {; 20945 maxMemUsed = totalMemUsed;; 20946 }; 20947 ; 20948 mg_snprintf(NULL,; 20949 NULL,; 20950 block,; 20951 sizeof(block),; 20952 ""%s\""memory\"" : {%s""; 20953 ""\""blocks\"" : %i,%s""; 20954 ""\""used\"" : %"" INT64_FMT "",%s""; 20955 ""\""maxUsed\"" : %"" INT64_FMT ""%s""; 20956 ""}"",; 20957 eol,; 20958 eol,; 20959 blockCount,; 20960 eol,; 20961 totalMemUsed,; 20962 eol,; 20963 maxMemUsed,; 20964 eol);; 20965 context_info_length += mg_str_append(&buffer, end, block);; 20966 }; 20967 ; 20968 if (ctx) {; 20969 /* Declare all variables at begin of the block, to comply; 20970 * with old C standards. */; 20971 char start_time_str[64] = {0};; 20972 char now_str[64] = {0};; 20973 time_t start_time = ctx->start_time;; 20974 t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:631780,Modifiability,variab,variables,631780,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:707379,Modifiability,config,configchar,707379,hread_mutexpthread_mutex_t thread_mutexDefinition civetweb.c:2341; mg_context::callbacksstruct mg_callbacks callbacksDefinition civetweb.c:2396; mg_context::ddstruct mg_domain_context ddDefinition civetweb.c:2406; mg_context::listening_socket_fdsstruct pollfd * listening_socket_fdsDefinition civetweb.c:2324; mg_context::sq_fullpthread_cond_t sq_fullDefinition civetweb.c:2358; mg_context::sq_tailvolatile int sq_tailDefinition civetweb.c:2357; mg_context::num_listening_socketsunsigned int num_listening_socketsDefinition civetweb.c:2325; mg_context::sq_sizeint sq_sizeDefinition civetweb.c:2361; mg_context::max_request_sizeunsigned int max_request_sizeDefinition civetweb.c:2368; mg_context::cfg_worker_threadsunsigned int cfg_worker_threadsDefinition civetweb.c:2345; mg_context::nonce_mutexpthread_mutex_t nonce_mutexDefinition civetweb.c:2391; mg_context::sq_blockedvolatile int sq_blockedDefinition civetweb.c:2360; mg_domain_contextDefinition civetweb.c:2252; mg_domain_context::configchar * config[NUM_OPTIONS]Definition civetweb.c:2254; mg_domain_context::nonce_countunsigned long nonce_countDefinition civetweb.c:2260; mg_domain_context::ssl_cert_last_mtimeint64_t ssl_cert_last_mtimeDefinition civetweb.c:2256; mg_domain_context::auth_nonce_maskuint64_t auth_nonce_maskDefinition civetweb.c:2259; mg_domain_context::nextstruct mg_domain_context * nextDefinition civetweb.c:2268; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2253; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2255; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1872; mg_file_access::fpFILE * fpDefinition civetweb.c:1874; mg_file_statDefinition civetweb.c:1861; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1863; mg_file_sta,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:707392,Modifiability,config,config,707392,hread_mutexpthread_mutex_t thread_mutexDefinition civetweb.c:2341; mg_context::callbacksstruct mg_callbacks callbacksDefinition civetweb.c:2396; mg_context::ddstruct mg_domain_context ddDefinition civetweb.c:2406; mg_context::listening_socket_fdsstruct pollfd * listening_socket_fdsDefinition civetweb.c:2324; mg_context::sq_fullpthread_cond_t sq_fullDefinition civetweb.c:2358; mg_context::sq_tailvolatile int sq_tailDefinition civetweb.c:2357; mg_context::num_listening_socketsunsigned int num_listening_socketsDefinition civetweb.c:2325; mg_context::sq_sizeint sq_sizeDefinition civetweb.c:2361; mg_context::max_request_sizeunsigned int max_request_sizeDefinition civetweb.c:2368; mg_context::cfg_worker_threadsunsigned int cfg_worker_threadsDefinition civetweb.c:2345; mg_context::nonce_mutexpthread_mutex_t nonce_mutexDefinition civetweb.c:2391; mg_context::sq_blockedvolatile int sq_blockedDefinition civetweb.c:2360; mg_domain_contextDefinition civetweb.c:2252; mg_domain_context::configchar * config[NUM_OPTIONS]Definition civetweb.c:2254; mg_domain_context::nonce_countunsigned long nonce_countDefinition civetweb.c:2260; mg_domain_context::ssl_cert_last_mtimeint64_t ssl_cert_last_mtimeDefinition civetweb.c:2256; mg_domain_context::auth_nonce_maskuint64_t auth_nonce_maskDefinition civetweb.c:2259; mg_domain_context::nextstruct mg_domain_context * nextDefinition civetweb.c:2268; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2253; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2255; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1872; mg_file_access::fpFILE * fpDefinition civetweb.c:1874; mg_file_statDefinition civetweb.c:1861; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1863; mg_file_sta,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5486,Performance,queue,queue,5486,"ing C99 support */; 103#pragma warning(disable : 4204); 104/* padding added after data member */; 105#pragma warning(disable : 4820); 106/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */; 107#pragma warning(disable : 4668); 108/* no function prototype given: converting '()' to '(void)' */; 109#pragma warning(disable : 4255); 110/* function has been selected for automatic inline expansion */; 111#pragma warning(disable : 4711); 112#endif; 113 ; 114 ; 115/* This code uses static_assert to check some conditions.; 116 * Unfortunately some compilers still do not support it, so we have a; 117 * replacement function here. */; 118#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEU",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5623,Performance,queue,queue,5623,"ning(disable : 4711); 112#endif; 113 ; 114 ; 115/* This code uses static_assert to check some conditions.; 116 * Unfortunately some compilers still do not support it, so we have a; 117 * replacement function here. */; 118#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read acce",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5777,Performance,queue,queue,5777,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5816,Performance,queue,queue,5816,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:5906,Performance,queue,queue,5906,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:6040,Performance,queue,queues,6040,"rt; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callba",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:15702,Performance,optimiz,optimize,15702,"mebase_ifo.denom);; 412 ; 413 t->tv_sec = now / 1000000000;; 414 t->tv_nsec = now % 1000000000;; 415 return 0;; 416 }; 417 return -1; /* EINVAL - Clock ID is unknown */; 418}; 419 ; 420/* if clock_gettime is declared, then __CLOCK_AVAILABILITY will be defined */; 421#if defined(__CLOCK_AVAILABILITY); 422/* If we compiled with Mac OSX 10.12 or later, then clock_gettime will be; 423 * declared but it may be NULL at runtime. So we need to check before using; 424 * it. */; 425static int; 426_civet_safe_clock_gettime(int clk_id, struct timespec *t); 427{; 428 if (clock_gettime) {; 429 return clock_gettime(clk_id, t);; 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOU",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:34979,Performance,load,load,34979,"endif /* defined(GCC_DIAGNOSTIC) */; 1080#if defined(__clang__); 1081/* Show no warning in case system functions are not used. */; 1082#pragma clang diagnostic push; 1083#pragma clang diagnostic ignored ""-Wunused-function""; 1084#endif; 1085 ; 1086static pthread_mutex_t global_lock_mutex;; 1087 ; 1088 ; 1089FUNCTION_MAY_BE_UNUSED; 1090static void; 1091mg_global_lock(void); 1092{; 1093 (void)pthread_mutex_lock(&global_lock_mutex);; 1094}; 1095 ; 1096 ; 1097FUNCTION_MAY_BE_UNUSED; 1098static void; 1099mg_global_unlock(void); 1100{; 1101 (void)pthread_mutex_unlock(&global_lock_mutex);; 1102}; 1103 ; 1104 ; 1105#if defined(_WIN64); 1106mg_static_assert(SIZE_MAX == 0xFFFFFFFFFFFFFFFFu, ""Mismatch for atomic types"");; 1107#elif defined(_WIN32); 1108mg_static_assert(SIZE_MAX == 0xFFFFFFFFu, ""Mismatch for atomic types"");; 1109#endif; 1110 ; 1111 ; 1112/* Atomic functions working on ptrdiff_t (""signed size_t"").; 1113 * Operations: Increment, Decrement, Add, Maximum.; 1114 * Up to size_t, they do not an atomic ""load"" operation.; 1115 */; 1116FUNCTION_MAY_BE_UNUSED; 1117static ptrdiff_t; 1118mg_atomic_inc(volatile ptrdiff_t *addr); 1119{; 1120 ptrdiff_t ret;; 1121 ; 1122#if defined(_WIN64) && !defined(NO_ATOMICS); 1123 ret = InterlockedIncrement64(addr);; 1124#elif defined(_WIN32) && !defined(NO_ATOMICS); 1125 ret = InterlockedIncrement(addr);; 1126#elif defined(__GNUC__) \; 1127 && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 0))) \; 1128 && !defined(NO_ATOMICS); 1129 ret = __sync_add_and_fetch(addr, 1);; 1130#else; 1131 mg_global_lock();; 1132 ret = (++(*addr));; 1133 mg_global_unlock();; 1134#endif; 1135 return ret;; 1136}; 1137 ; 1138 ; 1139FUNCTION_MAY_BE_UNUSED; 1140static ptrdiff_t; 1141mg_atomic_dec(volatile ptrdiff_t *addr); 1142{; 1143 ptrdiff_t ret;; 1144 ; 1145#if defined(_WIN64) && !defined(NO_ATOMICS); 1146 ret = InterlockedDecrement64(addr);; 1147#elif defined(_WIN32) && !defined(NO_ATOMICS); 1148 ret = InterlockedDecrement(addr);; 1149#elif defined(__",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:53350,Performance,load,loading,53350,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/engine.h>; 1748#include <openssl/err.h>; 1749#include <openssl/opensslv.h>; 1750#include <openssl/pem.h>; 1751#include <openssl/ssl.h>; 1752#include <openssl/tls1.h>; 1753#include <openssl/x509.h>; 1754 ; 1755#if defined(WOLFSSL_VERSION); 1756/* Additional defines for WolfSSL, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:55138,Performance,load,loaded,55138,"L, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767 * the standard memory functions.; 1768 *; 1769 * #define OPENSSL_free free */; 1770#define free free; 1771// disable for boringssl; 1772#define CONF_modules_unload(a) ((void)0); 1773#define ENGINE_cleanup() ((void)0); 1774#endif; 1775 ; 1776/* If OpenSSL headers are included, automatically select the API version */; 1777#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1778#if !defined(OPENSSL_API_3_0); 1779#define OPENSSL_API_3_0; 1780#endif; 1781#define OPENSSL_REMOVE_THREAD_STATE(); 1782#else; 1783#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1784#if !defined(OPENSSL_API_1_1); 1785#define OPENSSL_API_1_1; 1786#endif; 1787#define OPENSSL_REMOVE_THREAD_STATE(); 1788#else; 1789#if !defined(OPENSSL_API_1_0); 1790#define OPENSSL_API_1_0; 1791#endif; 1792#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1793#endif; 1794#endif; 1795 ; 1796 ; 1797#else; 1798/* SSL loaded dynamically from DLL / shared object */; 1799/* Add all prototypes here, to be independent from OpenSSL source; 1800 * installation. */; 1801#include ""openssl_dl.inl""; 1802 ; 1803#endif /* Various SSL bindings */; 1804 ; 1805 ; 1806#if !defined(NO_CACHING); 1807static const char month_names[][4] = {""Jan"",; 1808 ""Feb"",; 1809 ""Mar"",; 1810 ""Apr"",; 1811 ""May"",; 1812 ""Jun"",; 1813 ""Jul"",; 1814 ""Aug"",; 1815 ""Sep"",; 1816 ""Oct"",; 1817 ""Nov"",; 1818 ""Dec""};; 1819#endif /* !NO_CACHING */; 1820 ; 1821 ; 1822/* Unified socket address. For IPv6 support, add IPv6 address structure in; 1823 * the union u. */; 1824union usa {; 1825 struct sockadd",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:57546,Performance,queue,queued,57546,"{; 1839 if (s->sa.sa_family == AF_INET); 1840 return s->sin.sin_port;; 1841#if defined(USE_IPV6); 1842 if (s->sa.sa_family == AF_INET6); 1843 return s->sin6.sin6_port;; 1844#endif; 1845 return 0;; 1846}; 1847#endif; 1848#if defined(USE_IPV6); 1849#define USA_IN_PORT_UNSAFE(s) \; 1850 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1851#else; 1852#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1853#endif; 1854 ; 1855/* Describes a string (chunk of memory). */; 1856struct vec {; 1857 const char *ptr;; 1858 size_t len;; 1859};; 1860 ; 1861struct mg_file_stat {; 1862 /* File properties filled by mg_stat: */; 1863 uint64_t size;; 1864 time_t last_modified;; 1865 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1866 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:62265,Performance,throttle,throttle,62265," name, config types, default value.; 2048 * Must be in the same order as the enum const above.; 2049 */; 2050static const struct mg_option config_options[] = {; 2051 ; 2052 /* Once for each server */; 2053 {""listening_ports"", MG_CONFIG_TYPE_STRING_LIST, ""8080""},; 2054 {""num_threads"", MG_CONFIG_TYPE_NUMBER, ""50""},; 2055 {""run_as_user"", MG_CONFIG_TYPE_STRING, NULL},; 2056 {""tcp_nodelay"", MG_CONFIG_TYPE_NUMBER, ""0""},; 2057 {""max_request_size"", MG_CONFIG_TYPE_NUMBER, ""16384""},; 2058 {""linger_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2059 {""connection_queue"", MG_CONFIG_TYPE_NUMBER, ""20""},; 2060 {""listen_backlog"", MG_CONFIG_TYPE_NUMBER, ""200""},; 2061#if defined(__linux__); 2062 {""allow_sendfile_call"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2063#endif; 2064#if defined(_WIN32); 2065 {""case_sensitive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2066#endif; 2067 {""throttle"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2068 {""enable_keep_alive"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2069 {""request_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""30000""},; 2070 {""keep_alive_timeout_ms"", MG_CONFIG_TYPE_NUMBER, ""500""},; 2071#if defined(USE_WEBSOCKET); 2072 {""websocket_timeout_ms"", MG_CONFIG_TYPE_NUMBER, NULL},; 2073 {""enable_websocket_ping_pong"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2074#endif; 2075 {""decode_url"", MG_CONFIG_TYPE_BOOLEAN, ""yes""},; 2076 {""decode_query_string"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2077#if defined(USE_LUA); 2078 {""lua_background_script"", MG_CONFIG_TYPE_FILE, NULL},; 2079 {""lua_background_script_params"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2080#endif; 2081#if defined(USE_HTTP2); 2082 {""enable_http2"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2083#endif; 2084 ; 2085 /* Once for each domain */; 2086 {""document_root"", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2087 ; 2088 {""access_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2089 {""error_log_file"", MG_CONFIG_TYPE_FILE, NULL},; 2090 ; 2091 {""cgi_pattern"", MG_CONFIG_TYPE_EXT_PATTERN, ""**.cgi$|**.pl$|**.php$""},; 2092 {""cgi_environment"", MG_CONFIG_TYPE_STRING_LIST, NULL},; 2093 {""cg",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:72372,Performance,queue,queue,72372,"2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdiff_t active_connections;; 2332 volatile ptrdiff_t max_active_connections;; 2333 volatile ptrdiff_t total_connections;; 2334 volatile ptrdiff_t total_requests;; 2335 volatile int64_t total_data_read;; 2336 volatile int64_t total_data_written;; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:72889,Performance,queue,queue,72889,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:73006,Performance,queue,queue,73006,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:73065,Performance,queue,queue,73065,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:73328,Performance,queue,queue,73328,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:79088,Performance,throttle,throttle,79088,"; 2503#if defined(USE_WEBSOCKET); 2504 int in_websocket_handling; /* 1 if in read_websocket */; 2505#endif; 2506#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2507 && defined(MG_EXPERIMENTAL_INTERFACES); 2508 /* Parameters for websocket data compression according to rfc7692 */; 2509 int websocket_deflate_server_max_windows_bits;; 2510 int websocket_deflate_client_max_windows_bits;; 2511 int websocket_deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARG",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:79146,Performance,throttle,throttle,79146,"deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2553 ; 2554static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2555 struct mg_context *ctx,; 2556 const char *func,; 2557 unsigned line,; 2558 const char *fmt,; 2559 ...) PRINTF_ARGS(5, 6);; 2560 ; 2561 ; 2562#if !defined(NO_THREAD_NAME); 2563#if defined(_WIN32) && defined(_MSC_VER); 2564/* Set the thread name for debugging purposes in Visual Studio; 2565 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:79211,Performance,throttle,throttled,79211,"deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2553 ; 2554static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2555 struct mg_context *ctx,; 2556 const char *func,; 2557 unsigned line,; 2558 const char *fmt,; 2559 ...) PRINTF_ARGS(5, 6);; 2560 ; 2561 ; 2562#if !defined(NO_THREAD_NAME); 2563#if defined(_WIN32) && defined(_MSC_VER); 2564/* Set the thread name for debugging purposes in Visual Studio; 2565 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:119808,Performance,cache,cache,119808,"rsion, ""1.1""))) {; 4009 /* HTTP 1.1 default is keep alive */; 4010 return 1;; 4011 }; 4012 ; 4013 /* HTTP 1.0 (and earlier) default is to close the connection */; 4014 return 0;; 4015}; 4016 ; 4017 ; 4018static int; 4019should_decode_url(const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how lo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:119905,Performance,cache,cache,119905,"const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120201,Performance,cache,cache,120201,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120526,Performance,cache,cache-control,120526,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120770,Performance,cache,cached,120770,"040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:120939,Performance,cache,cache,120939,"he-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""C",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:121061,Performance,cache,cached,121061,"L_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may be used differently in the future. */; 4091 /* If a file should not be cached, do not only send; 4092 * max-age=0, but also pragmas and Expires headers. */; 4093 send_no_cache_header(conn);; 4094 return;; 4095 }; 4096 ; 4097 /* Use ""Cache-Control: max-age"" instead of ""Expires"" header.; 4098 * Reason: see https://www.mnot.net/blog/2007/05/15/expires_max-age */; 4099 /* See also https://www.mnot.net/cache_docs/ */; 4100 /* According to RFC 2616, Section 14.21, caching times should not exceed; 4101 * one year. A year with 365 days corresponds to 31536000 seconds, a; 4102 * leap; 4103 * year to 31622400 seconds. For the moment, we just send whatever has; 4104 * been configured, still the behavior for >1 year should be considered; 4105 * as undefined. */; 4106 mg_snprintf(; 4107 conn, NULL, val, sizeof(val), ""max-age=%lu"", (unsigned long)max_age);; 4108 mg_response_header_add(conn, ""Cache-Control"", val, -1);; 4109 ; 4110#else /* NO_CACHING */; 4111 ; 4112 send_no_cache_header(conn);; 4113#endif /* !NO_CACHING */; 4114}; 4115 ; 4116 ; 4117static void; 4118send_additional_header(stru",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:154321,Performance,queue,queue,154321,"t;; 5139}; 5140 ; 5141 ; 5142FUNCTION_MAY_BE_UNUSED; 5143static struct dirent *; 5144mg_readdir(DIR *dir); 5145{; 5146 struct dirent *result = 0;; 5147 ; 5148 if (dir) {; 5149 if (dir->handle != INVALID_HANDLE_VALUE) {; 5150 result = &dir->result;; 5151 (void)WideCharToMultiByte(CP_UTF8,; 5152 0,; 5153 dir->info.cFileName,; 5154 -1,; 5155 result->d_name,; 5156 sizeof(result->d_name),; 5157 NULL,; 5158 NULL);; 5159 ; 5160 if (!FindNextFileW(dir->handle, &dir->info)) {; 5161 (void)FindClose(dir->handle);; 5162 dir->handle = INVALID_HANDLE_VALUE;; 5163 }; 5164 ; 5165 } else {; 5166 SetLastError(ERROR_FILE_NOT_FOUND);; 5167 }; 5168 } else {; 5169 SetLastError(ERROR_BAD_ARGUMENTS);; 5170 }; 5171 ; 5172 return result;; 5173}; 5174 ; 5175 ; 5176#if !defined(HAVE_POLL); 5177#undef POLLIN; 5178#undef POLLPRI; 5179#undef POLLOUT; 5180#undef POLLERR; 5181#define POLLIN (1) /* Data ready - read will not block. */; 5182#define POLLPRI (2) /* Priority data ready. */; 5183#define POLLOUT (4) /* Send queue not full - write will not block. */; 5184#define POLLERR (8) /* Error event */; 5185 ; 5186FUNCTION_MAY_BE_UNUSED; 5187static int; 5188poll(struct mg_pollfd *pfd, unsigned int n, int milliseconds); 5189{; 5190 struct timeval tv;; 5191 fd_set rset;; 5192 fd_set wset;; 5193 fd_set eset;; 5194 unsigned int i;; 5195 int result;; 5196 SOCKET maxfd = 0;; 5197 ; 5198 memset(&tv, 0, sizeof(tv));; 5199 tv.tv_sec = milliseconds / 1000;; 5200 tv.tv_usec = (milliseconds % 1000) * 1000;; 5201 FD_ZERO(&rset);; 5202 FD_ZERO(&wset);; 5203 FD_ZERO(&eset);; 5204 ; 5205 for (i = 0; i < n; i++) {; 5206 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5207 if (pfd[i].events & POLLIN) {; 5208 FD_SET(pfd[i].fd, &rset);; 5209 }; 5210 if (pfd[i].events & POLLOUT) {; 5211 FD_SET(pfd[i].fd, &wset);; 5212 }; 5213 /* Check for errors for any FD in the set */; 5214 FD_SET(pfd[i].fd, &eset);; 5215 }; 5216 pfd[i].revents = 0;; 5217 ; 5218 if (pfd[i].fd > maxfd) {; 5219 maxfd = pfd[i].fd;; 5220 }; 5221 }; 522",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:158241,Performance,load,loaded,158241,"read((void(__cdecl *)(void *))f, 0, p) == ((uintptr_t)(-1L))); 5281 ? -1; 5282 : 0);; 5283#endif /* defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1) */; 5284}; 5285 ; 5286 ; 5287/* Start a thread storing the thread context. */; 5288static int; 5289mg_start_thread_with_id(unsigned(__stdcall *f)(void *),; 5290 void *p,; 5291 pthread_t *threadidptr); 5292{; 5293 uintptr_t uip;; 5294 HANDLE threadhandle;; 5295 int result = -1;; 5296 ; 5297 uip = _beginthreadex(NULL, 0, f, p, 0, NULL);; 5298 threadhandle = (HANDLE)uip;; 5299 if ((uip != 0) && (threadidptr != NULL)) {; 5300 *threadidptr = threadhandle;; 5301 result = 0;; 5302 }; 5303 ; 5304 return result;; 5305}; 5306 ; 5307 ; 5308/* Wait for a thread to finish. */; 5309static int; 5310mg_join_thread(pthread_t threadid); 5311{; 5312 int result;; 5313 DWORD dwevent;; 5314 ; 5315 result = -1;; 5316 dwevent = WaitForSingleObject(threadid, (DWORD)INFINITE);; 5317 if (dwevent == WAIT_FAILED) {; 5318 DEBUG_TRACE(""WaitForSingleObject() failed, error %d"", ERRNO);; 5319 } else {; 5320 if (dwevent == WAIT_OBJECT_0) {; 5321 CloseHandle(threadid);; 5322 result = 0;; 5323 }; 5324 }; 5325 ; 5326 return result;; 5327}; 5328 ; 5329#if !defined(NO_SSL_DL) && !defined(NO_SSL); 5330/* If SSL is loaded dynamically, dlopen/dlclose is required. */; 5331/* Create substitutes for POSIX functions in Win32. */; 5332 ; 5333#if defined(GCC_DIAGNOSTIC); 5334/* Show no warning in case system functions are not used. */; 5335#pragma GCC diagnostic push; 5336#pragma GCC diagnostic ignored ""-Wunused-function""; 5337#endif; 5338 ; 5339 ; 5340FUNCTION_MAY_BE_UNUSED; 5341static HANDLE; 5342dlopen(const char *dll_name, int flags); 5343{; 5344 wchar_t wbuf[UTF16_PATH_MAX];; 5345 (void)flags;; 5346 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5347 return LoadLibraryW(wbuf);; 5348}; 5349 ; 5350 ; 5351FUNCTION_MAY_BE_UNUSED; 5352static int; 5353dlclose(void *handle); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:194871,Performance,throttle,throttle,194871,"8 }; 6649 if ((i > 0) && (lenbuf[i] == '\r'); 6650 && (lenbuf[i - 1] != '\r')) {; 6651 continue;; 6652 }; 6653 if ((i > 1) && (lenbuf[i] == '\n'); 6654 && (lenbuf[i - 1] == '\r')) {; 6655 lenbuf[i + 1] = 0;; 6656 chunkSize = strtoul(lenbuf, &end, 16);; 6657 if (chunkSize == 0) {; 6658 /* regular end of content */; 6659 conn->is_chunked = 3;; 6660 }; 6661 break;; 6662 }; 6663 if (!isxdigit((unsigned char)lenbuf[i])) {; 6664 /* illegal character for chunk length */; 6665 conn->is_chunked = 2;; 6666 return -1;; 6667 }; 6668 }; 6669 if ((end == NULL) || (*end != '\r')) {; 6670 /* chunksize not set correctly */; 6671 conn->is_chunked = 2;; 6672 return -1;; 6673 }; 6674 if (chunkSize == 0) {; 6675 /* try discarding trailer for keep-alive */; 6676 conn->content_len += 2;; 6677 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6678 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6679 conn->is_chunked = 4;; 6680 }; 6681 break;; 6682 }; 6683 ; 6684 /* append a new chunk */; 6685 conn->content_len += (int64_t)chunkSize;; 6686 }; 6687 }; 6688 ; 6689 return (int)all_read;; 6690 }; 6691 return mg_read_inner(conn, buf, len);; 6692}; 6693 ; 6694 ; 6695int; 6696mg_write(struct mg_connection *conn, const void *buf, size_t len); 6697{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:195052,Performance,throttle,throttle,195052,"8 }; 6649 if ((i > 0) && (lenbuf[i] == '\r'); 6650 && (lenbuf[i - 1] != '\r')) {; 6651 continue;; 6652 }; 6653 if ((i > 1) && (lenbuf[i] == '\n'); 6654 && (lenbuf[i - 1] == '\r')) {; 6655 lenbuf[i + 1] = 0;; 6656 chunkSize = strtoul(lenbuf, &end, 16);; 6657 if (chunkSize == 0) {; 6658 /* regular end of content */; 6659 conn->is_chunked = 3;; 6660 }; 6661 break;; 6662 }; 6663 if (!isxdigit((unsigned char)lenbuf[i])) {; 6664 /* illegal character for chunk length */; 6665 conn->is_chunked = 2;; 6666 return -1;; 6667 }; 6668 }; 6669 if ((end == NULL) || (*end != '\r')) {; 6670 /* chunksize not set correctly */; 6671 conn->is_chunked = 2;; 6672 return -1;; 6673 }; 6674 if (chunkSize == 0) {; 6675 /* try discarding trailer for keep-alive */; 6676 conn->content_len += 2;; 6677 if ((mg_read_inner(conn, lenbuf, 2) == 2); 6678 && (lenbuf[0] == '\r') && (lenbuf[1] == '\n')) {; 6679 conn->is_chunked = 4;; 6680 }; 6681 break;; 6682 }; 6683 ; 6684 /* append a new chunk */; 6685 conn->content_len += (int64_t)chunkSize;; 6686 }; 6687 }; 6688 ; 6689 return (int)all_read;; 6690 }; 6691 return mg_read_inner(conn, buf, len);; 6692}; 6693 ; 6694 ; 6695int; 6696mg_write(struct mg_connection *conn, const void *buf, size_t len); 6697{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:195535,Performance,throttle,throttle,195535,"7{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.sock,; 6729 conn->ssl,; 6730 (const char *)buf,; 6731 allowed);; 6732 ; 6733 if (total == allowed) {; 6734 ; 6735 buf = (const char *)buf + total;; 6736 conn->last_throttle_bytes += total;; 6737 while ((total < (int)len); 6738 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6739 allowed = (conn->throttle > ((int)len - total)); 6740 ? (int)len - total; 6741 : conn->throttle;; 6742 ; 6743 n = push_all(conn->phys_ctx,; 6744 NULL,; 6745 conn->client.sock,; 6746 conn->ssl,; 6747 (const char *)buf,; 6748 allowed);; 6749 ; 6750 if (n != allowed) {; 6751 break;; 6752 }; 6753 sleep(1);; 6754 conn->last_throttle_bytes = allowed;; 6755 conn->last_throttle_time = time(NULL);; 6756 buf = (const char *)buf + n;; 6757 total += n;; 6758 }; 6759 }; 6760 } else {; 6761 total = push_all(conn->phys_ctx,; 6762 NULL,; 6763 conn->client.sock,; 6764 conn->ssl,; 6765 (const char *)buf,; 6766 (int)len);; 6767 }; 6768 if (total > 0) {; 6769 conn->num_bytes_sent += total;; 6770 }; 6771 return total;; 6772}; 6773 ; 6774 ; 6775/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6776int; 6777mg_send_chunk(struct mg_connection *conn,; 6778 const char *chunk,; 6779 unsigned int chunk_len); 6780{; 6781 char lenbuf[16];; 6782 siz",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:195605,Performance,throttle,throttle,195605,"7{; 6698 time_t now;; 6699 int n, total, allowed;; 6700 ; 6701 if (conn == NULL) {; 6702 return 0;; 6703 }; 6704 if (len > INT_MAX) {; 6705 return -1;; 6706 }; 6707 ; 6708 /* Mark connection as ""data sent"" */; 6709 conn->request_state = 10;; 6710#if defined(USE_HTTP2); 6711 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 6712 http2_data_frame_head(conn, len, 0);; 6713 }; 6714#endif; 6715 ; 6716 if (conn->throttle > 0) {; 6717 if ((now = time(NULL)) != conn->last_throttle_time) {; 6718 conn->last_throttle_time = now;; 6719 conn->last_throttle_bytes = 0;; 6720 }; 6721 allowed = conn->throttle - conn->last_throttle_bytes;; 6722 if (allowed > (int)len) {; 6723 allowed = (int)len;; 6724 }; 6725 ; 6726 total = push_all(conn->phys_ctx,; 6727 NULL,; 6728 conn->client.sock,; 6729 conn->ssl,; 6730 (const char *)buf,; 6731 allowed);; 6732 ; 6733 if (total == allowed) {; 6734 ; 6735 buf = (const char *)buf + total;; 6736 conn->last_throttle_bytes += total;; 6737 while ((total < (int)len); 6738 && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6739 allowed = (conn->throttle > ((int)len - total)); 6740 ? (int)len - total; 6741 : conn->throttle;; 6742 ; 6743 n = push_all(conn->phys_ctx,; 6744 NULL,; 6745 conn->client.sock,; 6746 conn->ssl,; 6747 (const char *)buf,; 6748 allowed);; 6749 ; 6750 if (n != allowed) {; 6751 break;; 6752 }; 6753 sleep(1);; 6754 conn->last_throttle_bytes = allowed;; 6755 conn->last_throttle_time = time(NULL);; 6756 buf = (const char *)buf + n;; 6757 total += n;; 6758 }; 6759 }; 6760 } else {; 6761 total = push_all(conn->phys_ctx,; 6762 NULL,; 6763 conn->client.sock,; 6764 conn->ssl,; 6765 (const char *)buf,; 6766 (int)len);; 6767 }; 6768 if (total > 0) {; 6769 conn->num_bytes_sent += total;; 6770 }; 6771 return total;; 6772}; 6773 ; 6774 ; 6775/* Send a chunk, if ""Transfer-Encoding: chunked"" is used */; 6776int; 6777mg_send_chunk(struct mg_connection *conn,; 6778 const char *chunk,; 6779 unsigned int chunk_len); 6780{; 6781 char lenbuf[16];; 6782 siz",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:279245,Performance,throttle,throttle,279245,"ntries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302271,Performance,cache,cached,302271,"o {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302314,Performance,cache,cache,302314,"o {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:303013,Performance,cache,cached,303013,") */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10561 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10562 * to be useful for REST in case a ""GET request with body"" is; 10563 * required. */; 10564 ; 10565 {NULL, 0, 0, 0, 0, 0}; 10566 /* end of list */; 10567};; 10568 ; 10569 ; 10570static con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:359802,Performance,queue,queue,359802,"r\n"",; 12389 b64_sha);; 12390 ; 12391#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12392 // Send negotiated compression extension parameters; 12393 websocket_deflate_response(conn);; 12394#endif; 12395 ; 12396 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12397 mg_printf(conn,; 12398 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12399 conn->request_info.acceptedWebSocketSubprotocol);; 12400 } else {; 12401 mg_printf(conn, ""%s"", ""\r\n"");; 12402 }; 12403 ; 12404 return 1;; 12405}; 12406 ; 12407 ; 12408#if !defined(MG_MAX_UNANSWERED_PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to th",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:359882,Performance,queue,queue,359882," 12396 if (conn->request_info.acceptedWebSocketSubprotocol) {; 12397 mg_printf(conn,; 12398 ""Sec-WebSocket-Protocol: %s\r\n\r\n"",; 12399 conn->request_info.acceptedWebSocketSubprotocol);; 12400 } else {; 12401 mg_printf(conn, ""%s"", ""\r\n"");; 12402 }; 12403 ; 12404 return 1;; 12405}; 12406 ; 12407 ; 12408#if !defined(MG_MAX_UNANSWERED_PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360103,Performance,queue,queue,360103,"PING); 12409/* Configuration of the maximum number of websocket PINGs that might; 12410 * stay unanswered before the connection is considered broken.; 12411 * Note: The name of this define may still change (until it is; 12412 * defined as a compile parameter in a documentation).; 12413 */; 12414#define MG_MAX_UNANSWERED_PING (5); 12415#endif; 12416 ; 12417 ; 12418static void; 12419read_websocket(struct mg_connection *conn,; 12420 mg_websocket_data_handler ws_data_handler,; 12421 void *callback_data); 12422{; 12423 /* Pointer to the beginning of the portion of the incoming websocket; 12424 * message queue.; 12425 * The original websocket upgrade request is never removed, so the queue; 12426 * begins after it. */; 12427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:363901,Performance,queue,queue,363901,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:364146,Performance,queue,queue,364146,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:364187,Performance,queue,queue,364187,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:365336,Performance,queue,queue,365336,"t of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place. */; 12541 DEBUG_ASSERT(body_len >= header_len);; 12542 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12543 mop = buf[0]; /* current mask and opcode */; 12544 /* Overflow case */; 12545 len = body_len - header_len;; 12546 memcpy(data, buf + header_len, len);; 12547 error = 0;; 12548 while ((uint64_t)len < data_len) {; 12549 n = pull_inner(NULL,; 12550 conn,; 12551 (char *)(data + len),; 12552 (int)(data_len - len),; 12553 timeout);; 12554 if (n <= -2) {; 12555 error = 1;; 12556 break;; 12557 } else if (n > 0) {; 12558 len += (size_t)n;; 12559 } else {; 12560 /* Timeout: should retry */; 12561 /* TODO: retry condition */; 12562 }; 12563 }; 12564 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Ma",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:365688,Performance,queue,queue,365688,"4 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:365790,Performance,queue,queue,365790,"4 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:370487,Performance,queue,queue,370487,"llback = 1;; 12710 }; 12711 mg_free(inflated);; 12712 }; 12713 } else; 12714#endif; 12715 if (!ws_data_handler(conn,; 12716 mop,; 12717 (char *)data,; 12718 (size_t)data_len,; 12719 callback_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PIN",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:391199,Performance,throttle,throttle,391199,"nsupported, at least two colons are needed */; 13340 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13341 if (*(p++) == ':') {; 13342 c++;; 13343 }; 13344 }; 13345 if ((*p == '\0') && (c >= 2)) {; 13346 struct sockaddr_in6 sin6;; 13347 unsigned int i;; 13348 ; 13349 /* for strict validation, an actual IPv6 argument is needed */; 13350 if (sa->sa.sa_family != AF_INET6) {; 13351 return 0;; 13352 }; 13353 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13354 /* IPv6 format */; 13355 for (i = 0; i < 16; i++) {; 13356 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13357 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13358 uint8_t mask = 0;; 13359 ; 13360 if (8 * i + 8 < slash) {; 13361 mask = 0xFFu;; 13362 } else if (8 * i < slash) {; 13363 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13364 }; 13365 if ((ip & mask) != net) {; 13366 return 0;; 13367 }; 13368 }; 13369 return 1;; 13370 }; 13371 }; 13372 }; 13373 }; 13374#else; 13375 (void)no_strict;; 13376#endif; 13377 ; 13378 /* malformed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:391931,Performance,throttle,throttle,391931,"rmed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13436 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13437 }; 13438 }; 13439 return idx;; 13440}; 13441 ; 13442 ; 13443/* Return host (without port) */; 13444static void; 13445get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13446{; 13447 const char *host_header =; 13448 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13449 ; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:392105,Performance,throttle,throttle,392105,"rmed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13436 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13437 }; 13438 }; 13439 return idx;; 13440}; 13441 ; 13442 ; 13443/* Return host (without port) */; 13444static void; 13445get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13446{; 13447 const char *host_header =; 13448 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13449 ; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:392201,Performance,throttle,throttle,392201," 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13436 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13437 }; 13438 }; 13439 return idx;; 13440}; 13441 ; 13442 ; 13443/* Return host (without port) */; 13444static void; 13445get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13446{; 13447 const char *host_header =; 13448 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13449 ; 13450 host->ptr = NULL;; 13451 host->len = 0;; 13452 ; 13453 if (host_header != NULL) {; 13454 const char *pos;; 13455 ; 13456 /* If the ""Host"" is an IPv6 address, like [::1], parse until ]; 13457 * is found. */; 13458 if (*host_header == ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:392269,Performance,throttle,throttle,392269," 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13436 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13437 }; 13438 }; 13439 return idx;; 13440}; 13441 ; 13442 ; 13443/* Return host (without port) */; 13444static void; 13445get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13446{; 13447 const char *host_header =; 13448 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13449 ; 13450 host->ptr = NULL;; 13451 host->len = 0;; 13452 ; 13453 if (host_header != NULL) {; 13454 const char *pos;; 13455 ; 13456 /* If the ""Host"" is an IPv6 address, like [::1], parse until ]; 13457 * is found. */; 13458 if (*host_header == ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:413662,Performance,throttle,throttle,413662,"fo.query_string) {; 14080 if (should_decode_query_string(conn)) {; 14081 url_decode_in_place((char *)conn->request_info.query_string);; 14082 }; 14083 }; 14084 ; 14085 /* 1.4. clean URIs, so a path like allowed_dir/../forbidden_file is not; 14086 * possible. The fact that we cleaned the URI is stored in that the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:428921,Performance,cache,cached,428921,">request_method, ""HEAD""))) {; 14527 mg_send_http_error(conn,; 14528 405,; 14529 ""%s method not allowed"",; 14530 conn->request_info.request_method);; 14531 return;; 14532 }; 14533 ; 14534 /* 14. directories */; 14535 if (file.stat.is_directory) {; 14536 /* Substitute files have already been handled above. */; 14537 /* Here we can either generate and send a directory listing,; 14538 * or send an ""access denied"" error. */; 14539 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14540 ""yes"")) {; 14541 handle_directory_request(conn, path);; 14542 } else {; 14543 mg_send_http_error(conn,; 14544 403,; 14545 ""%s"",; 14546 ""Error: Directory listing denied"");; 14547 }; 14548 return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SS",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:429267,Performance,cache,cached,429267,"return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SSI like page containing mostly plain; 14594 * html code plus some tags with server generated contents. */; 14595 handle_lsp_request(conn, path, file, NULL);; 14596 } else {; 14597 /* Script was in an illegal path */; 14598 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14599 }; 14600 return;; 14601 }; 14602 ; 14603 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14604 > 0) {; 14605 if (is_in_script_path(conn, path)) {; 14606 /* Lua in-server module script: a CGI like script used to; 14607 * generate the entire reply. */; 14608 mg_exec_lua_script(conn, path, NULL);; 14609 } else {; 14610 /* Script was in an illegal path */; 14611 mg_send_http_error(conn",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:471288,Performance,load,load,471288,";; 15902 return 1;; 15903 }; 15904 return 0;; 15905}; 15906 ; 15907 ; 15908#if defined(OPENSSL_API_1_1); 15909#else; 15910static void; 15911ssl_locking_callback(int mode, int mutex_num, const char *file, int line); 15912{; 15913 (void)line;; 15914 (void)file;; 15915 ; 15916 if (mode & 1) {; 15917 /* 1 is CRYPTO_LOCK */; 15918 (void)pthread_mutex_lock(&ssl_mutexes[mutex_num]);; 15919 } else {; 15920 (void)pthread_mutex_unlock(&ssl_mutexes[mutex_num]);; 15921 }; 15922}; 15923#endif /* OPENSSL_API_1_1 */; 15924 ; 15925 ; 15926#if !defined(NO_SSL_DL); 15927/* Load a DLL/Shared Object with a TLS/SSL implementation. */; 15928static void *; 15929load_tls_dll(char *ebuf,; 15930 size_t ebuf_len,; 15931 const char *dll_name,; 15932 struct ssl_func *sw,; 15933 int *feature_missing); 15934{; 15935 union {; 15936 void *p;; 15937 void (*fp)(void);; 15938 } u;; 15939 void *dll_handle;; 15940 struct ssl_func *fp;; 15941 int ok;; 15942 int truncated = 0;; 15943 ; 15944 if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {; 15945 mg_snprintf(NULL,; 15946 NULL, /* No truncation check for ebuf */; 15947 ebuf,; 15948 ebuf_len,; 15949 ""%s: cannot load %s"",; 15950 __func__,; 15951 dll_name);; 15952 return NULL;; 15953 }; 15954 ; 15955 ok = 1;; 15956 for (fp = sw; fp->name != NULL; fp++) {; 15957#if defined(_WIN32); 15958 /* GetProcAddress() returns pointer to function */; 15959 u.fp = (void (*)(void))dlsym(dll_handle, fp->name);; 15960#else; 15961 /* dlsym() on UNIX returns void *. ISO C forbids casts of data; 15962 * pointers to function pointers. We need to use a union to make a; 15963 * cast. */; 15964 u.p = dlsym(dll_handle, fp->name);; 15965#endif /* _WIN32 */; 15966 ; 15967 /* Set pointer (might be NULL) */; 15968 fp->ptr = u.fp;; 15969 ; 15970 if (u.fp == NULL) {; 15971 DEBUG_TRACE(""Missing function: %s\n"", fp->name);; 15972 if (feature_missing) {; 15973 feature_missing[fp->required]++;; 15974 }; 15975 if (fp->required == TLS_Mandatory) {; 15976 /* Mandatory function is missing ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:474218,Performance,load,loading,474218,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16020static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16021 ; 16022#endif /* NO_SSL_DL */; 16023 ; 16024 ; 16025#if defined(SSL_ALREADY_INITIALIZED); 16026static volatile ptrdiff_t cryptolib_users =; 16027 1; /* Reference counter for crypto library. */; 16028#else; 16029static volatile ptrdiff_t cryptolib_users =; 16030 0; /* Reference counter for crypto library. */; 16031#endif; 16032 ; 16033 ; 16034static int; 16035initialize_openssl(char *ebuf, size_t ebuf_len); 16036{; 16037#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16038 int i, num_locks;; 16039 size_t size;; 16040#endif; 16041 ; 16042 if (ebuf_len > 0) {; 16043 ebuf[0] = 0;; 16044 }; 16045 ; 16046#if !defined(NO_SSL_DL); 16047 if (!cryptolib_dll_handle) {; 16048 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16049 cryptolib_dll_handle = load_tls_dll(; 16050 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16051 if (!cryptolib_dll_handle) {; 16052 mg_snprintf(NULL,; 16053 NULL, /* No truncation check for ebuf */; 16054 ebuf,; 16055 ebuf_len,; 16056 ""%s: error loading library %s"",; 16057 __func__,; 16058 CRYPTO_LIB);; 16059 DEBUG_TRACE(""%s"", ebuf);; 16060 return 0;; 16061 }; 16062 }; 16063#endif /* NO_SSL_DL */; 16064 ; 16065 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16066 return 1;; 16067 }; 16068 ; 16069#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16070 /* Initialize locking callbacks, needed for thread safety.; 16071 * http://www.openssl.org/support/faq.html#PROG1; 16072 */; 16073 num_locks = CRYPTO_num_locks();; 16074 if (num_locks < 0) {; 16075 num_locks = 0;; 16076 }; 16077 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16078 ; 16079 /* allocate mutex array, if required */; 16080 if (num_locks == 0) {; 16081 /* No mutex array required */; 16082 ssl_mutexes = NULL;; 16083 } else {; 16084 /* Mutex array required - allocate it */; 16085 ssl_mutexes",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:495324,Performance,load,load,495324,"ST]); 16663 != 1) {; 16664 mg_cry_ctx_internal(phys_ctx,; 16665 ""SSL_CTX_set_cipher_list error: %s"",; 16666 ssl_error());; 16667 }; 16668 }; 16669 ; 16670 /* SSL session caching */; 16671 ssl_cache_timeout = ((dom_ctx->config[SSL_CACHE_TIMEOUT] != NULL); 16672 ? atoi(dom_ctx->config[SSL_CACHE_TIMEOUT]); 16673 : 0);; 16674 if (ssl_cache_timeout > 0) {; 16675 SSL_CTX_set_session_cache_mode(dom_ctx->ssl_ctx, SSL_SESS_CACHE_BOTH);; 16676 /* SSL_CTX_sess_set_cache_size(dom_ctx->ssl_ctx, 10000); ... use; 16677 * default */; 16678 SSL_CTX_set_timeout(dom_ctx->ssl_ctx, (long)ssl_cache_timeout);; 16679 }; 16680 ; 16681#if defined(USE_ALPN); 16682 /* Initialize ALPN only of TLS library (OpenSSL version) supports ALPN */; 16683#if !defined(NO_SSL_DL); 16684 if (!tls_feature_missing[TLS_ALPN]); 16685#endif; 16686 {; 16687 init_alpn(phys_ctx, dom_ctx);; 16688 }; 16689#endif; 16690 ; 16691 return 1;; 16692}; 16693 ; 16694 ; 16695/* Check if SSL is required.; 16696 * If so, dynamically load SSL library; 16697 * and set up ctx->ssl_ctx pointer. */; 16698static int; 16699init_ssl_ctx(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16700{; 16701 void *ssl_ctx = 0;; 16702 int callback_ret;; 16703 const char *pem;; 16704 const char *chain;; 16705 char ebuf[128];; 16706 ; 16707 if (!phys_ctx) {; 16708 return 0;; 16709 }; 16710 ; 16711 if (!dom_ctx) {; 16712 dom_ctx = &(phys_ctx->dd);; 16713 }; 16714 ; 16715 if (!is_ssl_port_used(dom_ctx->config[LISTENING_PORTS])) {; 16716 /* No SSL port is set. No need to setup SSL. */; 16717 return 1;; 16718 }; 16719 ; 16720 /* Check for external SSL_CTX */; 16721 callback_ret =; 16722 (phys_ctx->callbacks.external_ssl_ctx == NULL); 16723 ? 0; 16724 : (phys_ctx->callbacks.external_ssl_ctx(&ssl_ctx,; 16725 phys_ctx->user_data));; 16726 ; 16727 if (callback_ret < 0) {; 16728 /* Callback exists and returns <0: Initializing failed. */; 16729 mg_cry_ctx_internal(phys_ctx,; 16730 ""external_ssl_ctx callback returned error: %i"",; 16731 callback",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:501780,Performance,throttle,throttle,501780," mg_connection fc;; 16856 if (!dom_ctx) {; 16857 dom_ctx = &(phys_ctx->dd);; 16858 }; 16859 path = dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 16860 if ((path != NULL); 16861 && !mg_stat(fake_connection(&fc, phys_ctx), path, &file.stat)) {; 16862 mg_cry_ctx_internal(phys_ctx,; 16863 ""Cannot open %s: %s"",; 16864 path,; 16865 strerror(ERRNO));; 16866 return 0;; 16867 }; 16868 return 1;; 16869 }; 16870 return 0;; 16871}; 16872#endif /* NO_FILESYSTEMS */; 16873 ; 16874 ; 16875static int; 16876set_acl_option(struct mg_context *phys_ctx); 16877{; 16878 union usa sa;; 16879 memset(&sa, 0, sizeof(sa));; 16880#if defined(USE_IPV6); 16881 sa.sin6.sin6_family = AF_INET6;; 16882#else; 16883 sa.sin.sin_family = AF_INET;; 16884#endif; 16885 return check_acl(phys_ctx, &sa) != -1;; 16886}; 16887 ; 16888 ; 16889static void; 16890reset_per_request_attributes(struct mg_connection *conn); 16891{; 16892 if (!conn) {; 16893 return;; 16894 }; 16895 ; 16896 conn->num_bytes_sent = conn->consumed_content = 0;; 16897 ; 16898 conn->path_info = NULL;; 16899 conn->status_code = -1;; 16900 conn->content_len = -1;; 16901 conn->is_chunked = 0;; 16902 conn->must_close = 0;; 16903 conn->request_len = 0;; 16904 conn->request_state = 0;; 16905 conn->throttle = 0;; 16906 conn->accept_gzip = 0;; 16907 ; 16908 conn->response_info.content_length = conn->request_info.content_length = -1;; 16909 conn->response_info.http_version = conn->request_info.http_version = NULL;; 16910 conn->response_info.num_headers = conn->request_info.num_headers = 0;; 16911 conn->response_info.status_text = NULL;; 16912 conn->response_info.status_code = 0;; 16913 ; 16914 conn->request_info.remote_user = NULL;; 16915 conn->request_info.request_method = NULL;; 16916 conn->request_info.request_uri = NULL;; 16917 ; 16918 /* Free cleaned local URI (if any) */; 16919 if (conn->request_info.local_uri != conn->request_info.local_uri_raw) {; 16920 mg_free((void *)conn->request_info.local_uri);; 16921 conn->request_info.local_uri = NULL;; 16922",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:556373,Performance,queue,queue,556373,">handled_requests);; 18701 mg_atomic_dec(&(conn->phys_ctx->active_connections));; 18702#endif; 18703}; 18704 ; 18705 ; 18706#if defined(ALTERNATIVE_QUEUE); 18707 ; 18708static void; 18709produce_socket(struct mg_context *ctx, const struct socket *sp); 18710{; 18711 unsigned int i;; 18712 ; 18713 while (!ctx->stop_flag) {; 18714 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 18715 /* find a free worker slot and signal it */; 18716 if (ctx->client_socks[i].in_use == 2) {; 18717 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18718 if ((ctx->client_socks[i].in_use == 2) && !ctx->stop_flag) {; 18719 ctx->client_socks[i] = *sp;; 18720 ctx->client_socks[i].in_use = 1;; 18721 /* socket has been moved to the consumer */; 18722 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18723 (void)event_signal(ctx->client_wait_events[i]);; 18724 return;; 18725 }; 18726 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18727 }; 18728 }; 18729 /* queue is full */; 18730 mg_sleep(1);; 18731 }; 18732 /* must consume */; 18733 set_blocking_mode(sp->sock);; 18734 closesocket(sp->sock);; 18735}; 18736 ; 18737 ; 18738static int; 18739consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18740{; 18741 DEBUG_TRACE(""%s"", ""going idle"");; 18742 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18743 ctx->client_socks[thread_index].in_use = 2;; 18744 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18745 ; 18746 event_wait(ctx->client_wait_events[thread_index]);; 18747 ; 18748 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18749 *sp = ctx->client_socks[thread_index];; 18750 if (ctx->stop_flag) {; 18751 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18752 if (sp->in_use == 1) {; 18753 /* must consume */; 18754 set_blocking_mode(sp->sock);; 18755 closesocket(sp->sock);; 18756 }; 18757 return 0;; 18758 }; 18759 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18760 if (sp->in_use == 1) {; 18761 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18762 return 1;; 18763 }; 1876",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:557617,Performance,queue,queue,557617,"ex);; 18727 }; 18728 }; 18729 /* queue is full */; 18730 mg_sleep(1);; 18731 }; 18732 /* must consume */; 18733 set_blocking_mode(sp->sock);; 18734 closesocket(sp->sock);; 18735}; 18736 ; 18737 ; 18738static int; 18739consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18740{; 18741 DEBUG_TRACE(""%s"", ""going idle"");; 18742 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18743 ctx->client_socks[thread_index].in_use = 2;; 18744 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18745 ; 18746 event_wait(ctx->client_wait_events[thread_index]);; 18747 ; 18748 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18749 *sp = ctx->client_socks[thread_index];; 18750 if (ctx->stop_flag) {; 18751 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18752 if (sp->in_use == 1) {; 18753 /* must consume */; 18754 set_blocking_mode(sp->sock);; 18755 closesocket(sp->sock);; 18756 }; 18757 return 0;; 18758 }; 18759 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18760 if (sp->in_use == 1) {; 18761 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18762 return 1;; 18763 }; 18764 /* must not reach here */; 18765 DEBUG_ASSERT(0);; 18766 return 0;; 18767}; 18768 ; 18769#else /* ALTERNATIVE_QUEUE */; 18770 ; 18771/* Worker threads take accepted socket from the queue */; 18772static int; 18773consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18774{; 18775 (void)thread_index;; 18776 ; 18777 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18778 DEBUG_TRACE(""%s"", ""going idle"");; 18779 ; 18780 /* If the queue is empty, wait. We're idle at this point. */; 18781 while ((ctx->sq_head == ctx->sq_tail); 18782 && (STOP_FLAG_IS_ZERO(&ctx->stop_flag))) {; 18783 pthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);; 18784 }; 18785 ; 18786 /* If we're stopping, sq_head may be equal to sq_tail. */; 18787 if (ctx->sq_head > ctx->sq_tail) {; 18788 /* Copy socket from the queue and increment tail */; 18789 *sp = ctx->squeue[ctx->sq_tail % ctx->sq_size];; 18790 ctx",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:557886,Performance,queue,queue,557886,"ex);; 18727 }; 18728 }; 18729 /* queue is full */; 18730 mg_sleep(1);; 18731 }; 18732 /* must consume */; 18733 set_blocking_mode(sp->sock);; 18734 closesocket(sp->sock);; 18735}; 18736 ; 18737 ; 18738static int; 18739consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18740{; 18741 DEBUG_TRACE(""%s"", ""going idle"");; 18742 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18743 ctx->client_socks[thread_index].in_use = 2;; 18744 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18745 ; 18746 event_wait(ctx->client_wait_events[thread_index]);; 18747 ; 18748 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18749 *sp = ctx->client_socks[thread_index];; 18750 if (ctx->stop_flag) {; 18751 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18752 if (sp->in_use == 1) {; 18753 /* must consume */; 18754 set_blocking_mode(sp->sock);; 18755 closesocket(sp->sock);; 18756 }; 18757 return 0;; 18758 }; 18759 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18760 if (sp->in_use == 1) {; 18761 DEBUG_TRACE(""grabbed socket %d, going busy"", sp->sock);; 18762 return 1;; 18763 }; 18764 /* must not reach here */; 18765 DEBUG_ASSERT(0);; 18766 return 0;; 18767}; 18768 ; 18769#else /* ALTERNATIVE_QUEUE */; 18770 ; 18771/* Worker threads take accepted socket from the queue */; 18772static int; 18773consume_socket(struct mg_context *ctx, struct socket *sp, int thread_index); 18774{; 18775 (void)thread_index;; 18776 ; 18777 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18778 DEBUG_TRACE(""%s"", ""going idle"");; 18779 ; 18780 /* If the queue is empty, wait. We're idle at this point. */; 18781 while ((ctx->sq_head == ctx->sq_tail); 18782 && (STOP_FLAG_IS_ZERO(&ctx->stop_flag))) {; 18783 pthread_cond_wait(&ctx->sq_full, &ctx->thread_mutex);; 18784 }; 18785 ; 18786 /* If we're stopping, sq_head may be equal to sq_tail. */; 18787 if (ctx->sq_head > ctx->sq_tail) {; 18788 /* Copy socket from the queue and increment tail */; 18789 *sp = ctx->squeue[ctx->sq_tail % ctx->sq_size];; 18790 ctx",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:558248,Performance,queue,queue,558248,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:558861,Performance,queue,queue,558861,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:559136,Performance,queue,queue,559136,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:559724,Performance,queue,queue,559724,") {; 18796 ctx->sq_tail -= ctx->sq_size;; 18797 ctx->sq_head -= ctx->sq_size;; 18798 }; 18799 }; 18800 ; 18801 (void)pthread_cond_signal(&ctx->sq_empty);; 18802 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18803 ; 18804 return STOP_FLAG_IS_ZERO(&ctx->stop_flag);; 18805}; 18806 ; 18807 ; 18808/* Master thread adds accepted socket to a queue */; 18809static void; 18810produce_socket(struct mg_context *ctx, const struct socket *sp); 18811{; 18812 int queue_filled;; 18813 ; 18814 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18815 ; 18816 queue_filled = ctx->sq_head - ctx->sq_tail;; 18817 ; 18818 /* If the queue is full, wait */; 18819 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 18820 && (queue_filled >= ctx->sq_size)) {; 18821 ctx->sq_blocked = 1; /* Status information: All threads busy */; 18822#if defined(USE_SERVER_STATS); 18823 if (queue_filled > ctx->sq_max_fill) {; 18824 ctx->sq_max_fill = queue_filled;; 18825 }; 18826#endif; 18827 (void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);; 18828 ctx->sq_blocked = 0; /* Not blocked now */; 18829 queue_filled = ctx->sq_head - ctx->sq_tail;; 18830 }; 18831 ; 18832 if (queue_filled < ctx->sq_size) {; 18833 /* Copy socket to the queue and increment head */; 18834 ctx->squeue[ctx->sq_head % ctx->sq_size] = *sp;; 18835 ctx->sq_head++;; 18836 DEBUG_TRACE(""queued socket %d"", sp ? sp->sock : -1);; 18837 }; 18838 ; 18839 queue_filled = ctx->sq_head - ctx->sq_tail;; 18840#if defined(USE_SERVER_STATS); 18841 if (queue_filled > ctx->sq_max_fill) {; 18842 ctx->sq_max_fill = queue_filled;; 18843 }; 18844#endif; 18845 ; 18846 (void)pthread_cond_signal(&ctx->sq_full);; 18847 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18848}; 18849#endif /* ALTERNATIVE_QUEUE */; 18850 ; 18851 ; 18852static void; 18853worker_thread_run(struct mg_connection *conn); 18854{; 18855 struct mg_context *ctx = conn->phys_ctx;; 18856 int thread_index;; 18857 struct mg_workerTLS tls;; 18858 ; 18859 mg_set_thread_name(""worker"");; 18860 ; 18861 tls.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:559850,Performance,queue,queued,559850,") {; 18796 ctx->sq_tail -= ctx->sq_size;; 18797 ctx->sq_head -= ctx->sq_size;; 18798 }; 18799 }; 18800 ; 18801 (void)pthread_cond_signal(&ctx->sq_empty);; 18802 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18803 ; 18804 return STOP_FLAG_IS_ZERO(&ctx->stop_flag);; 18805}; 18806 ; 18807 ; 18808/* Master thread adds accepted socket to a queue */; 18809static void; 18810produce_socket(struct mg_context *ctx, const struct socket *sp); 18811{; 18812 int queue_filled;; 18813 ; 18814 (void)pthread_mutex_lock(&ctx->thread_mutex);; 18815 ; 18816 queue_filled = ctx->sq_head - ctx->sq_tail;; 18817 ; 18818 /* If the queue is full, wait */; 18819 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 18820 && (queue_filled >= ctx->sq_size)) {; 18821 ctx->sq_blocked = 1; /* Status information: All threads busy */; 18822#if defined(USE_SERVER_STATS); 18823 if (queue_filled > ctx->sq_max_fill) {; 18824 ctx->sq_max_fill = queue_filled;; 18825 }; 18826#endif; 18827 (void)pthread_cond_wait(&ctx->sq_empty, &ctx->thread_mutex);; 18828 ctx->sq_blocked = 0; /* Not blocked now */; 18829 queue_filled = ctx->sq_head - ctx->sq_tail;; 18830 }; 18831 ; 18832 if (queue_filled < ctx->sq_size) {; 18833 /* Copy socket to the queue and increment head */; 18834 ctx->squeue[ctx->sq_head % ctx->sq_size] = *sp;; 18835 ctx->sq_head++;; 18836 DEBUG_TRACE(""queued socket %d"", sp ? sp->sock : -1);; 18837 }; 18838 ; 18839 queue_filled = ctx->sq_head - ctx->sq_tail;; 18840#if defined(USE_SERVER_STATS); 18841 if (queue_filled > ctx->sq_max_fill) {; 18842 ctx->sq_max_fill = queue_filled;; 18843 }; 18844#endif; 18845 ; 18846 (void)pthread_cond_signal(&ctx->sq_full);; 18847 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 18848}; 18849#endif /* ALTERNATIVE_QUEUE */; 18850 ; 18851 ; 18852static void; 18853worker_thread_run(struct mg_connection *conn); 18854{; 18855 struct mg_context *ctx = conn->phys_ctx;; 18856 int thread_index;; 18857 struct mg_workerTLS tls;; 18858 ; 18859 mg_set_thread_name(""worker"");; 18860 ; 18861 tls.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:569766,Performance,queue,queue,569766,"5#endif; 19096 ; 19097 worker_thread_run((struct mg_connection *)thread_func_param);; 19098 return NULL;; 19099}; 19100#endif /* _WIN32 */; 19101 ; 19102 ; 19103/* This is an internal function, thus all arguments are expected to be; 19104 * valid - a NULL check is not required. */; 19105static void; 19106accept_new_connection(const struct socket *listener, struct mg_context *ctx); 19107{; 19108 struct socket so;; 19109 char src_addr[IP_ADDR_STR_LEN];; 19110 socklen_t len = sizeof(so.rsa);; 19111#if !defined(__ZEPHYR__); 19112 int on = 1;; 19113#endif; 19114 memset(&so, 0, sizeof(so));; 19115 ; 19116 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19117 == INVALID_SOCKET) {; 19118 } else if (check_acl(ctx, &so.rsa) != 1) {; 19119 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19120 mg_cry_ctx_internal(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:571283,Performance,throughput,throughput,571283,"9141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if (set_tcp_nodelay(&so, 1) != 0) {; 19173 mg_cry_ctx_internal(; 19174 ctx,; 19175 ""%s: setsockopt(IPPROTO_TCP TCP_NODELAY) failed: %s"",; 19176 __func__,; 19177 strerror(ERRNO));; 19178 }; 19179 }; 19180 ; 19181 /* The ""non blocking"" property should already be; 19182 * inherited from the parent socket. Set it for; 19183 * non-compliant socket implementations. */; 19184 set_non_blocking_mode(so.sock);; 19185 ; 19186 so.in_use = 0;; 19187 produce_socket(ctx, &so);; 19188 }; 19189}; 19190 ; 19191 ; 19192static void; 19193master_thread_run(struct mg_context *ctx); 19194{; 19195 struct mg_workerTLS tls;; 19196 struct mg_pollfd *pfd;; 19197 unsigned int i;; 19198 unsigned int w",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594166,Performance,load,load,594166," 19856 /* Document root */; 19857#if defined(NO_FILES); 19858 if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {; 19859 mg_cry_ctx_internal(ctx, ""%s"", ""Document root must not be set"");; 19860 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19861 mg_snprintf(NULL,; 19862 NULL, /* No truncation check for error buffers */; 19863 error->text,; 19864 error->text_buffer_size,; 19865 ""Invalid configuration option value: %s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lu",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:594426,Performance,load,load,594426,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:627612,Performance,queue,queue,627612,"_connections;; 20977 int max_active_connections = (int)ctx->max_active_connections;; 20978 int total_connections = (int)ctx->total_connections;; 20979 if (active_connections > max_active_connections) {; 20980 max_active_connections = active_connections;; 20981 }; 20982 if (active_connections > total_connections) {; 20983 total_connections = active_connections;; 20984 }; 20985 ; 20986 /* Connections information */; 20987 mg_snprintf(NULL,; 20988 NULL,; 20989 block,; 20990 sizeof(block),; 20991 "",%s\""connections\"" : {%s""; 20992 ""\""active\"" : %i,%s""; 20993 ""\""maxActive\"" : %i,%s""; 20994 ""\""total\"" : %i%s""; 20995 ""}"",; 20996 eol,; 20997 eol,; 20998 active_connections,; 20999 eol,; 21000 max_active_connections,; 21001 eol,; 21002 total_connections,; 21003 eol);; 21004 context_info_length += mg_str_append(&buffer, end, block);; 21005 ; 21006 /* Queue information */; 21007#if !defined(ALTERNATIVE_QUEUE); 21008 mg_snprintf(NULL,; 21009 NULL,; 21010 block,; 21011 sizeof(block),; 21012 "",%s\""queue\"" : {%s""; 21013 ""\""length\"" : %i,%s""; 21014 ""\""filled\"" : %i,%s""; 21015 ""\""maxFilled\"" : %i,%s""; 21016 ""\""full\"" : %s%s""; 21017 ""}"",; 21018 eol,; 21019 eol,; 21020 ctx->sq_size,; 21021 eol,; 21022 ctx->sq_head - ctx->sq_tail,; 21023 eol,; 21024 ctx->sq_max_fill,; 21025 eol,; 21026 (ctx->sq_blocked ? ""true"" : ""false""),; 21027 eol);; 21028 context_info_length += mg_str_append(&buffer, end, block);; 21029#endif; 21030 ; 21031 /* Requests information */; 21032 mg_snprintf(NULL,; 21033 NULL,; 21034 block,; 21035 sizeof(block),; 21036 "",%s\""requests\"" : {%s""; 21037 ""\""total\"" : %lu%s""; 21038 ""}"",; 21039 eol,; 21040 eol,; 21041 (unsigned long)ctx->total_requests,; 21042 eol);; 21043 context_info_length += mg_str_append(&buffer, end, block);; 21044 ; 21045 /* Data information */; 21046 total_data_read =; 21047 mg_atomic_add64((volatile int64_t *)&ctx->total_data_read, 0);; 21048 total_data_written =; 21049 mg_atomic_add64((volatile int64_t *)&ctx->total_data_written, 0);; 21050 mg_snprintf(",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:703248,Performance,throttle,throttleint,703248,"*ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefinition civetweb.h:1436; mg_client_options::portint portDefinition civetweb.h:1435; mg_client_options::server_certconst char * server_certDefinition civetweb.h:1437; mg_client_options::hostconst char * hostDefinition civetweb.h:1434; mg_connectionDefinition civetweb.c:2449; mg_connection::last_throttle_timetime_t last_throttle_timeDefinition civetweb.c:2527; mg_connection::throttleint throttleDefinition civetweb.c:2524; mg_connection::request_stateint request_stateDefinition civetweb.c:2452; mg_connection::content_lenint64_t content_lenDefinition civetweb.c:2482; mg_connection::req_timestruct timespec req_timeDefinition civetweb.c:2479; mg_connection::consumed_contentint64_t consumed_contentDefinition civetweb.c:2488; mg_connection::request_lenint request_lenDefinition civetweb.c:2521; mg_connection::path_infochar * path_infoDefinition civetweb.c:2497; mg_connection::is_chunkedint is_chunkedDefinition civetweb.c:2489; mg_connection::num_bytes_sentint64_t num_bytes_sentDefinition civetweb.c:2481; mg_connection::connection_typeint connection_typeDefinition civetweb.c:2450; mg_connection::buf_sizeint buf_sizeDefinition civetweb.c:2520; mg_connection::mutexpthread_mutex_t mutexDefinition civetweb.c:2529; mg_connection::clientstruct socket clientDefinition civetweb.c:2471; mg_connection::protocol_typeint protocol_typeDefinition civetweb.c:2451; mg_connection::must_clo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:703260,Performance,throttle,throttleDefinition,703260,"*ssl_ctx, void *user_data)Definition civetweb.h:290; mg_client_certDefinition civetweb.h:206; mg_client_cert::issuerconst char * issuerDefinition civetweb.h:209; mg_client_cert::fingerconst char * fingerDefinition civetweb.h:211; mg_client_cert::peer_certvoid * peer_certDefinition civetweb.h:207; mg_client_cert::subjectconst char * subjectDefinition civetweb.h:208; mg_client_cert::serialconst char * serialDefinition civetweb.h:210; mg_client_optionsDefinition civetweb.h:1433; mg_client_options::host_nameconst char * host_nameDefinition civetweb.h:1438; mg_client_options::client_certconst char * client_certDefinition civetweb.h:1436; mg_client_options::portint portDefinition civetweb.h:1435; mg_client_options::server_certconst char * server_certDefinition civetweb.h:1437; mg_client_options::hostconst char * hostDefinition civetweb.h:1434; mg_connectionDefinition civetweb.c:2449; mg_connection::last_throttle_timetime_t last_throttle_timeDefinition civetweb.c:2527; mg_connection::throttleint throttleDefinition civetweb.c:2524; mg_connection::request_stateint request_stateDefinition civetweb.c:2452; mg_connection::content_lenint64_t content_lenDefinition civetweb.c:2482; mg_connection::req_timestruct timespec req_timeDefinition civetweb.c:2479; mg_connection::consumed_contentint64_t consumed_contentDefinition civetweb.c:2488; mg_connection::request_lenint request_lenDefinition civetweb.c:2521; mg_connection::path_infochar * path_infoDefinition civetweb.c:2497; mg_connection::is_chunkedint is_chunkedDefinition civetweb.c:2489; mg_connection::num_bytes_sentint64_t num_bytes_sentDefinition civetweb.c:2481; mg_connection::connection_typeint connection_typeDefinition civetweb.c:2450; mg_connection::buf_sizeint buf_sizeDefinition civetweb.c:2520; mg_connection::mutexpthread_mutex_t mutexDefinition civetweb.c:2529; mg_connection::clientstruct socket clientDefinition civetweb.c:2471; mg_connection::protocol_typeint protocol_typeDefinition civetweb.c:2451; mg_connection::must_clo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16508,Safety,timeout,timeouts,16508,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:16580,Safety,timeout,timeouts,16580,"Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#if !defined(CGI_ENVIRONMENT_SIZE); 486#define CGI_ENVIRONMENT_SIZE (4096) /* in bytes */; 487#endif; 488 ; 489/* Maximum number of environment variables. */; 490#if !defined(MAX_CGI_ENVIR_VARS); 491#define MAX_CGI_ENVIR_VARS (256) /* in variables (count) */; 492#endif; 493 ; 494/* General purpose buffer size. */; 49",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:58350,Safety,avoid,avoid,58350,"; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_options[]; 1907 * This is tested in the unit test (test/private.c); 1908 * ""Private Config Options""; 1909 */; 1910enum {; 1911 /* Once for each server */; 1912 LISTENING_PORTS,; 1913 NUM_THREADS,; 1914 RUN_AS_USER,; 1915 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1916 * socket option typedef TCP_NODELAY. */; 1917 MAX_REQUEST_SIZE,; 1918 LINGER_TIMEOUT,; 1919 CONNECTION_QUEUE_SIZE,; 1920 LISTEN_BACKLOG_SIZE,; 1921#if defined(__linux__); 1922 ALLOW_SENDFILE_CALL,; 1923#endif; 1924#if defined(_WIN32); 1925 CASE_SENSITIVE_FILES,; 1926#endif; 1927 THROTTLE,; 1928 ENABLE_KEEP_ALIVE,; 1929 REQUEST_TIMEOUT,; 1930 KEEP_ALIVE_TIMEOUT,; 1931#if defined(USE_WEBSOCKET); 1932 WEBSOCKET_TIMEOUT,; 1933 ENABLE_WEBSOCKET_PING_PONG,; 1934#endif; 1935 DECODE_URL,; 1936 DECODE_QUERY_STRING,; 1937#if defined(USE_LUA); 1938 LUA_BACKGROUND_SCRIPT,; 1939 LUA_BACKGROUND_SCRIPT_PARAMS,; 1940#endif; 1941#if defined(USE_HTTP2); 1942 ENABLE_HTTP2,; 1943#endif; 1944 ; 1945 /* Once for each domain */; 1946 DOCUMENT_ROOT,; 1947 ; 1948 ACCESS_LOG_FILE,; 1949 ERROR_LOG_FILE,; 1950 ; 1951 CGI_EXTENSIONS,; 1952 CGI_ENVIRONMENT,; 1953 CGI_INTERPRETER,; 1954 CGI_INTERPRETER_ARGS,; 1955#if def",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:71444,Safety,timeout,timeouts,71444," used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);; 2290 return (sf == 2);; 2291}; 2292 ; 2293static void; 2294STOP_FLAG_ASSIGN(stop_flag_t *f, stop_flag_t v); 2295{; 2296 stop_flag_t sf;; 2297 do {; 2298 sf = mg_atomic_compare_and_swap(f, *f, v);; 2299 } while (sf != v);; 2300}; 2301 ; 2302#else /* STOP_FLAG_NEEDS_LOCK */; 2303 ; 2304typedef int volatile stop_flag_t;; 2305#define STOP_FLAG_IS_ZERO(f) ((*(f)) == 0); 2306#define STOP_FLAG_IS_TWO(f) ((*(f)) == 2); 2307#define STOP_FLAG_ASSIGN(f, v) ((*(f)) = (v)); 2308 ; 2309#endif /* STOP_FLAG_NEEDS_LOCK */; 2310 ; 2311 ; 2312struct mg_context {; 2313 ; 2314 /* Part 1 - Physical context:; 2315 * This holds threads, ports, timeouts, ...; 2316 * set for the entire server, independent from the; 2317 * addressed hostname.; 2318 */; 2319 ; 2320 /* Connection related */; 2321 int context_type; /* See CONTEXT_* above */; 2322 ; 2323 struct socket *listening_sockets;; 2324 struct mg_pollfd *listening_socket_fds;; 2325 unsigned int num_listening_sockets;; 2326 ; 2327 struct mg_connection *worker_connections; /* The connection struct, pre-; 2328 * allocated for each worker */; 2329 ; 2330#if defined(USE_SERVER_STATS); 2331 volatile ptrdif",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:104132,Safety,safe,safe,104132,"0 va_list ap;; 3471 va_start(ap, fmt);; 3472 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap);; 3473 va_end(ap);; 3474}; 3475 ; 3476 ; 3477#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3478 ; 3479 ; 3480const char *; 3481mg_version(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:104256,Safety,safe,safe,104256," 3475 ; 3476 ; 3477#define mg_cry DO_NOT_USE_THIS_FUNCTION__USE_mg_cry_internal; 3478 ; 3479 ; 3480const char *; 3481mg_version(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma cla",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:104378,Safety,safe,safe,104378,"n(void); 3482{; 3483 return CIVETWEB_VERSION;; 3484}; 3485 ; 3486 ; 3487const struct mg_request_info *; 3488mg_get_request_info(const struct mg_connection *conn); 3489{; 3490 if (!conn) {; 3491 return NULL;; 3492 }; 3493#if defined(MG_ALLOW_USING_GET_REQUEST_INFO_FOR_RESPONSE); 3494 if (conn->connection_type == CONNECTION_TYPE_RESPONSE) {; 3495 char txt[16];; 3496 struct mg_workerTLS *tls =; 3497 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3498 ; 3499 sprintf(txt, ""%03i"", conn->response_info.status_code);; 3500 if (strlen(txt) == 3) {; 3501 memcpy(tls->txtbuf, txt, 4);; 3502 } else {; 3503 strcpy(tls->txtbuf, ""ERR"");; 3504 }; 3505 ; 3506 ((struct mg_connection *)conn)->request_info.local_uri =; 3507 tls->txtbuf; /* use thread safe buffer */; 3508 ((struct mg_connection *)conn)->request_info.local_uri_raw =; 3509 tls->txtbuf; /* use the same thread safe buffer */; 3510 ((struct mg_connection *)conn)->request_info.request_uri =; 3511 tls->txtbuf; /* use the same thread safe buffer */; 3512 ; 3513 ((struct mg_connection *)conn)->request_info.num_headers =; 3514 conn->response_info.num_headers;; 3515 memcpy(((struct mg_connection *)conn)->request_info.http_headers,; 3516 conn->response_info.http_headers,; 3517 sizeof(conn->response_info.http_headers));; 3518 } else; 3519#endif; 3520 if (conn->connection_type != CONNECTION_TYPE_REQUEST) {; 3521 return NULL;; 3522 }; 3523 return &conn->request_info;; 3524}; 3525 ; 3526 ; 3527const struct mg_response_info *; 3528mg_get_response_info(const struct mg_connection *conn); 3529{; 3530 if (!conn) {; 3531 return NULL;; 3532 }; 3533 if (conn->connection_type != CONNECTION_TYPE_RESPONSE) {; 3534 return NULL;; 3535 }; 3536 return &conn->response_info;; 3537}; 3538 ; 3539 ; 3540static const char *; 3541get_proto_name(const struct mg_connection *conn); 3542{; 3543#if defined(__clang__); 3544#pragma clang diagnostic push; 3545#pragma clang diagnostic ignored ""-Wunreachable-code""; 3546 /* Depending on USE_WEBSOCKET and NO_SSL, s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:131441,Safety,avoid,avoid,131441,"8 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serro",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:133182,Safety,redund,redundant,133182," && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:133207,Safety,avoid,avoid,133207," && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while (tstr) {; 4469 for (i = 1;; 4470 (i < 32) && (tstr[i] != 0) && (tstr[i] != ',');; 4471 i++) {; 4472 /* buffer overrun is not possible here, since; 4473 * (i < 32) && (len < sizeof(path_buf) - 32); 4474 * ==> (i + len) < sizeof(path_buf) */; 4475 path_buf[len + i - 1] = tstr[i];; 4476 }; 4477 /* buffer overrun is not possible here, since; 4478 * (i <= 32) && (len < sizeof(path_buf) - 32); 4479 * ==> (i + len) <= sizeof(path_buf) */; 4480 path_buf[len + i - 1] = 0;; 4481 ; 4482 if (mg_stat(conn, path_buf, &error_page_file.stat)) {; 4483 DEBUG_TRACE(""Check error page %s - found"",; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:155842,Safety,timeout,timeout,155842,"00;; 5200 tv.tv_usec = (milliseconds % 1000) * 1000;; 5201 FD_ZERO(&rset);; 5202 FD_ZERO(&wset);; 5203 FD_ZERO(&eset);; 5204 ; 5205 for (i = 0; i < n; i++) {; 5206 if (pfd[i].events & (POLLIN | POLLOUT | POLLERR)) {; 5207 if (pfd[i].events & POLLIN) {; 5208 FD_SET(pfd[i].fd, &rset);; 5209 }; 5210 if (pfd[i].events & POLLOUT) {; 5211 FD_SET(pfd[i].fd, &wset);; 5212 }; 5213 /* Check for errors for any FD in the set */; 5214 FD_SET(pfd[i].fd, &eset);; 5215 }; 5216 pfd[i].revents = 0;; 5217 ; 5218 if (pfd[i].fd > maxfd) {; 5219 maxfd = pfd[i].fd;; 5220 }; 5221 }; 5222 ; 5223 if ((result = select((int)maxfd + 1, &rset, &wset, &eset, &tv)) > 0) {; 5224 for (i = 0; i < n; i++) {; 5225 if (FD_ISSET(pfd[i].fd, &rset)) {; 5226 pfd[i].revents |= POLLIN;; 5227 }; 5228 if (FD_ISSET(pfd[i].fd, &wset)) {; 5229 pfd[i].revents |= POLLOUT;; 5230 }; 5231 if (FD_ISSET(pfd[i].fd, &eset)) {; 5232 pfd[i].revents |= POLLERR;; 5233 }; 5234 }; 5235 }; 5236 ; 5237 /* We should subtract the time used in select from remaining; 5238 * ""milliseconds"", in particular if called from mg_poll with a; 5239 * timeout quantum.; 5240 * Unfortunately, the remaining time is not stored in ""tv"" in all; 5241 * implementations, so the result in ""tv"" must be considered undefined.; 5242 * See http://man7.org/linux/man-pages/man2/select.2.html */; 5243 ; 5244 return result;; 5245}; 5246#endif /* HAVE_POLL */; 5247 ; 5248 ; 5249#if defined(GCC_DIAGNOSTIC); 5250/* Enable unused function warning again */; 5251#pragma GCC diagnostic pop; 5252#endif; 5253 ; 5254 ; 5255static void; 5256set_close_on_exec(SOCKET sock,; 5257 const struct mg_connection *conn /* may be null */,; 5258 struct mg_context *ctx /* may be null */); 5259{; 5260 (void)conn; /* Unused. */; 5261 (void)ctx;; 5262 ; 5263 (void)SetHandleInformation((HANDLE)(intptr_t)sock, HANDLE_FLAG_INHERIT, 0);; 5264}; 5265 ; 5266 ; 5267int; 5268mg_start_thread(mg_thread_func_t f, void *p); 5269{; 5270#if defined(USE_STACK_SIZE) && (USE_STACK_SIZE > 1); 5271 /* Compile",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:159679,Safety,timeout,timeout,159679,"_t wbuf[UTF16_PATH_MAX];; 5345 (void)flags;; 5346 path_to_unicode(NULL, dll_name, wbuf, ARRAY_SIZE(wbuf));; 5347 return LoadLibraryW(wbuf);; 5348}; 5349 ; 5350 ; 5351FUNCTION_MAY_BE_UNUSED; 5352static int; 5353dlclose(void *handle); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX],",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:159846,Safety,timeout,timeout,159846,"UNCTION_MAY_BE_UNUSED; 5352static int; 5353dlclose(void *handle); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5441 int truncated;; 5442 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5443 STARTUPINFOA si;; 5444 PROCESS_INFORMATION pi = {0};; 5445 ; 5446 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:159923,Safety,timeout,timeout,159923,"le); 5354{; 5355 int result;; 5356 ; 5357 if (FreeLibrary((HMODULE)handle) != 0) {; 5358 result = 0;; 5359 } else {; 5360 result = -1;; 5361 }; 5362 ; 5363 return result;; 5364}; 5365 ; 5366 ; 5367#if defined(GCC_DIAGNOSTIC); 5368/* Enable unused function warning again */; 5369#pragma GCC diagnostic pop; 5370#endif; 5371 ; 5372#endif; 5373 ; 5374 ; 5375#if !defined(NO_CGI); 5376#define SIGKILL (0); 5377 ; 5378 ; 5379static int; 5380kill(pid_t pid, int sig_num); 5381{; 5382 (void)TerminateProcess((HANDLE)pid, (UINT)sig_num);; 5383 (void)CloseHandle((HANDLE)pid);; 5384 return 0;; 5385}; 5386 ; 5387 ; 5388#if !defined(WNOHANG); 5389#define WNOHANG (1); 5390#endif; 5391 ; 5392 ; 5393static pid_t; 5394waitpid(pid_t pid, int *status, int flags); 5395{; 5396 DWORD timeout = INFINITE;; 5397 DWORD waitres;; 5398 ; 5399 (void)status; /* Currently not used by any client here */; 5400 ; 5401 if ((flags | WNOHANG) == WNOHANG) {; 5402 timeout = 0;; 5403 }; 5404 ; 5405 waitres = WaitForSingleObject((HANDLE)pid, timeout);; 5406 if (waitres == WAIT_OBJECT_0) {; 5407 return pid;; 5408 }; 5409 if (waitres == WAIT_TIMEOUT) {; 5410 return 0;; 5411 }; 5412 return (pid_t)-1;; 5413}; 5414 ; 5415 ; 5416static void; 5417trim_trailing_whitespaces(char *s); 5418{; 5419 char *e = s + strlen(s);; 5420 while ((e > s) && isspace((unsigned char)e[-1])) {; 5421 *(--e) = '\0';; 5422 }; 5423}; 5424 ; 5425 ; 5426static pid_t; 5427spawn_process(struct mg_connection *conn,; 5428 const char *prog,; 5429 char *envblk,; 5430 char *envp[],; 5431 int fdin[2],; 5432 int fdout[2],; 5433 int fderr[2],; 5434 const char *dir,; 5435 unsigned char cgi_config_idx); 5436{; 5437 HANDLE me;; 5438 char *interp;; 5439 char *interp_arg = 0;; 5440 char full_dir[UTF8_PATH_MAX], cmdline[UTF8_PATH_MAX], buf[UTF8_PATH_MAX];; 5441 int truncated;; 5442 struct mg_file file = STRUCT_FILE_INITIALIZER;; 5443 STARTUPINFOA si;; 5444 PROCESS_INFORMATION pi = {0};; 5445 ; 5446 (void)envp;; 5447 ; 5448 memset(&si, 0, sizeof(si));; 5449 si.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:173732,Safety,timeout,timeout,173732,"85 ; 5886 if (lfsr == 0) {; 5887 /* lfsr will be only 0 if has not been initialized,; 5888 * so this code is called only once. */; 5889 lfsr = mg_get_current_time_ns();; 5890 lcg = mg_get_current_time_ns();; 5891 } else {; 5892 /* Get the next step of both random number generators. */; 5893 lfsr = (lfsr >> 1); 5894 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5895 << 63);; 5896 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5897 }; 5898 ; 5899 /* Combining two pseudo-random number generators and a high resolution; 5900 * part; 5901 * of the current server time will make it hard (impossible?) to guess; 5902 * the; 5903 * next number. */; 5904 return (lfsr ^ lcg ^ now);; 5905}; 5906 ; 5907 ; 5908static int; 5909mg_poll(struct mg_pollfd *pfd,; 5910 unsigned int n,; 5911 int milliseconds,; 5912 const stop_flag_t *stop_flag); 5913{; 5914 /* Call poll, but only for a maximum time of a few seconds.; 5915 * This will allow to stop the server after some seconds, instead; 5916 * of having to wait for a long socket timeout. */; 5917 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5918 ; 5919 int check_pollerr = 0;; 5920 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:174703,Safety,timeout,timeout,174703,"seconds.; 5915 * This will allow to stop the server after some seconds, instead; 5916 * of having to wait for a long socket timeout. */; 5917 int ms_now = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5918 ; 5919 int check_pollerr = 0;; 5920 if ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:174844,Safety,timeout,timeout,174844,"f ((n == 1) && ((pfd[0].events & POLLERR) == 0)) {; 5921 /* If we wait for only one file descriptor, wait on error as well */; 5922 pfd[0].events |= POLLERR;; 5923 check_pollerr = 1;; 5924 }; 5925 ; 5926 do {; 5927 int result;; 5928 ; 5929 if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:175087,Safety,timeout,timeout,175087,"if (!STOP_FLAG_IS_ZERO(&*stop_flag)) {; 5930 /* Shut down signal */; 5931 return -2;; 5932 }; 5933 ; 5934 if ((milliseconds >= 0) && (milliseconds < ms_now)) {; 5935 ms_now = milliseconds;; 5936 }; 5937 ; 5938 result = poll(pfd, n, ms_now);; 5939 if (result != 0) {; 5940 /* Poll returned either success (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:175282,Safety,timeout,timeout,175282,"ccess (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6012 if (n <= 0) {; 6013 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6014 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6015 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6016 n = 0;; 6017 } else {; 6018 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6019 return -2;; 6020 }; 6021 } else {; 602",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:175567,Safety,timeout,timeout,175567,"ccess (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6012 if (n <= 0) {; 6013 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6014 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6015 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6016 n = 0;; 6017 } else {; 6018 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6019 return -2;; 6020 }; 6021 } else {; 602",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:175669,Safety,timeout,timeout,175669,"ccess (1) or error (-1).; 5941 * Forward both to the caller. */; 5942 if ((check_pollerr); 5943 && ((pfd[0].revents & (POLLIN | POLLOUT | POLLERR)); 5944 == POLLERR)) {; 5945 /* One and only file descriptor returned error */; 5946 return -1;; 5947 }; 5948 return result;; 5949 }; 5950 ; 5951 /* Poll returned timeout (0). */; 5952 if (milliseconds > 0) {; 5953 milliseconds -= ms_now;; 5954 }; 5955 ; 5956 } while (milliseconds > 0);; 5957 ; 5958 /* timeout: return 0 */; 5959 return 0;; 5960}; 5961 ; 5962 ; 5963/* Write data to the IO channel - opened file descriptor, socket or SSL; 5964 * descriptor.; 5965 * Return value:; 5966 * >=0 .. number of bytes successfully written; 5967 * -1 .. timeout; 5968 * -2 .. error; 5969 */; 5970static int; 5971push_inner(struct mg_context *ctx,; 5972 FILE *fp,; 5973 SOCKET sock,; 5974 SSL *ssl,; 5975 const char *buf,; 5976 int len,; 5977 double timeout); 5978{; 5979 uint64_t start = 0, now = 0, timeout_ns = 0;; 5980 int n, err;; 5981 unsigned ms_wait = SOCKET_TIMEOUT_QUANTUM; /* Sleep quantum in ms */; 5982 ; 5983#if defined(_WIN32); 5984 typedef int len_t;; 5985#else; 5986 typedef size_t len_t;; 5987#endif; 5988 ; 5989 if (timeout > 0) {; 5990 now = mg_get_current_time_ns();; 5991 start = now;; 5992 timeout_ns = (uint64_t)(timeout * 1.0E9);; 5993 }; 5994 ; 5995 if (ctx == NULL) {; 5996 return -2;; 5997 }; 5998 ; 5999#if defined(NO_SSL) && !defined(USE_MBEDTLS); 6000 if (ssl) {; 6001 return -2;; 6002 }; 6003#endif; 6004 ; 6005 /* Try to read until it succeeds, fails, times out, or the server; 6006 * shuts down. */; 6007 for (;;) {; 6008 ; 6009#if defined(USE_MBEDTLS); 6010 if (ssl != NULL) {; 6011 n = mbed_ssl_write(ssl, (const unsigned char *)buf, len);; 6012 if (n <= 0) {; 6013 if ((n == MBEDTLS_ERR_SSL_WANT_READ); 6014 || (n == MBEDTLS_ERR_SSL_WANT_WRITE); 6015 || n == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6016 n = 0;; 6017 } else {; 6018 fprintf(stderr, ""SSL write failed, error %d\n"", n);; 6019 return -2;; 6020 }; 6021 } else {; 602",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:178236,Safety,timeout,timeout,178236,"060 if (err == WSAEWOULDBLOCK) {; 6061 err = 0;; 6062 n = 0;; 6063 }; 6064#else; 6065 if (ERROR_TRY_AGAIN(err)) {; 6066 err = 0;; 6067 n = 0;; 6068 }; 6069#endif; 6070 if (n < 0) {; 6071 /* shutdown of the socket at client side */; 6072 return -2;; 6073 }; 6074 }; 6075 ; 6076 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6077 return -2;; 6078 }; 6079 ; 6080 if ((n > 0) || ((n == 0) && (len == 0))) {; 6081 /* some data has been read, or no data was requested */; 6082 return n;; 6083 }; 6084 if (n < 0) {; 6085 /* socket error - check errno */; 6086 DEBUG_TRACE(""send() failed, error %d"", err);; 6087 ; 6088 /* TODO (mid): error handling depending on the error code.; 6089 * These codes are different between Windows and Linux.; 6090 * Currently there is no problem with failing send calls,; 6091 * if there is a reproducible situation, it should be; 6092 * investigated in detail.; 6093 */; 6094 return -2;; 6095 }; 6096 ; 6097 /* Only in case n=0 (timeout), repeat calling the write function */; 6098 ; 6099 /* If send failed, wait before retry */; 6100 if (fp != NULL) {; 6101 /* For files, just wait a fixed time.; 6102 * Maybe it helps, maybe not. */; 6103 mg_sleep(5);; 6104 } else {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:178860,Safety,timeout,timeout,178860,"fferent between Windows and Linux.; 6090 * Currently there is no problem with failing send calls,; 6091 * if there is a reproducible situation, it should be; 6092 * investigated in detail.; 6093 */; 6094 return -2;; 6095 }; 6096 ; 6097 /* Only in case n=0 (timeout), repeat calling the write function */; 6098 ; 6099 /* If send failed, wait before retry */; 6100 if (fp != NULL) {; 6101 /* For files, just wait a fixed time.; 6102 * Maybe it helps, maybe not. */; 6103 mg_sleep(5);; 6104 } else {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179320,Safety,timeout,timeout,179320,"fferent between Windows and Linux.; 6090 * Currently there is no problem with failing send calls,; 6091 * if there is a reproducible situation, it should be; 6092 * investigated in detail.; 6093 */; 6094 return -2;; 6095 }; 6096 ; 6097 /* Only in case n=0 (timeout), repeat calling the write function */; 6098 ; 6099 /* If send failed, wait before retry */; 6100 if (fp != NULL) {; 6101 /* For files, just wait a fixed time.; 6102 * Maybe it helps, maybe not. */; 6103 mg_sleep(5);; 6104 } else {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179478,Safety,timeout,timeout,179478," {; 6105 /* For sockets, wait for the socket using poll */; 6106 struct mg_pollfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179554,Safety,timeout,timeout,179554,"llfd pfd[1];; 6107 int pollres;; 6108 ; 6109 pfd[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179578,Safety,timeout,timeout,179578,"d[0].fd = sock;; 6110 pfd[0].events = POLLOUT;; 6111 pollres = mg_poll(pfd, 1, (int)(ms_wait), &(ctx->stop_flag));; 6112 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6113 return -2;; 6114 }; 6115 if (pollres > 0) {; 6116 continue;; 6117 }; 6118 }; 6119 ; 6120 if (timeout > 0) {; 6121 now = mg_get_current_time_ns();; 6122 if ((now - start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:179805,Safety,timeout,timeout,179805," start) > timeout_ns) {; 6123 /* Timeout */; 6124 break;; 6125 }; 6126 }; 6127 }; 6128 ; 6129 (void)err; /* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 6130 used */; 6131 ; 6132 return -1;; 6133}; 6134 ; 6135 ; 6136static int; 6137push_all(struct mg_context *ctx,; 6138 FILE *fp,; 6139 SOCKET sock,; 6140 SSL *ssl,; 6141 const char *buf,; 6142 int len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:180283,Safety,timeout,timeout,180283,"nt len); 6143{; 6144 double timeout = -1.0;; 6145 int n, nwritten = 0;; 6146 ; 6147 if (ctx == NULL) {; 6148 return -1;; 6149 }; 6150 ; 6151 if (ctx->dd.config[REQUEST_TIMEOUT]) {; 6152 timeout = atoi(ctx->dd.config[REQUEST_TIMEOUT]) / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:180441,Safety,timeout,timeout,180441,") / 1000.0;; 6153 }; 6154 if (timeout <= 0.0) {; 6155 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6156 / 1000.0;; 6157 }; 6158 ; 6159 while ((len > 0) && STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 6160 n = push_inner(ctx, fp, sock, ssl, buf + nwritten, len, timeout);; 6161 if (n < 0) {; 6162 if (nwritten == 0) {; 6163 nwritten = -1; /* Propagate the error */; 6164 }; 6165 break;; 6166 } else if (n == 0) {; 6167 break; /* No more data to write */; 6168 } else {; 6169 nwritten += n;; 6170 len -= n;; 6171 }; 6172 }; 6173 ; 6174 return nwritten;; 6175}; 6176 ; 6177 ; 6178/* Read from IO channel - opened file descriptor, socket, or SSL descriptor.; 6179 * Return value:; 6180 * >=0 .. number of bytes successfully read; 6181 * -1 .. timeout; 6182 * -2 .. error; 6183 */; 6184static int; 6185pull_inner(FILE *fp,; 6186 struct mg_connection *conn,; 6187 char *buf,; 6188 int len,; 6189 double timeout); 6190{; 6191 int nread, err = 0;; 6192 ; 6193#if defined(_WIN32); 6194 typedef int len_t;; 6195#else; 6196 typedef size_t len_t;; 6197#endif; 6198 ; 6199 /* We need an additional wait loop around this, because in some cases; 6200 * with TLSwe may get data from the socket but not from SSL_read.; 6201 * In this case we need to repeat at least once.; 6202 */; 6203 ; 6204 if (fp != NULL) {; 6205 /* Use read() instead of fread(), because if we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:181933,Safety,timeout,timeout,181933," we're reading from the; 6206 * CGI pipe, fread() may block until IO buffer is filled up. We; 6207 * cannot afford to block and must pass all read bytes immediately; 6208 * to the client. */; 6209 nread = (int)read(fileno(fp), buf, (size_t)len);; 6210 ; 6211 err = (nread < 0) ? ERRNO : 0;; 6212 if ((nread == 0) && (len > 0)) {; 6213 /* Should get data, but got EOL */; 6214 return -2;; 6215 }; 6216 ; 6217#if defined(USE_MBEDTLS); 6218 } else if (conn->ssl != NULL) {; 6219 struct mg_pollfd pfd[1];; 6220 int to_read;; 6221 int pollres;; 6222 ; 6223 to_read = mbedtls_ssl_get_bytes_avail(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:182637,Safety,timeout,timeout,182637,"il(conn->ssl);; 6224 ; 6225 if (to_read > 0) {; 6226 /* We already know there is no more data buffered in conn->buf; 6227 * but there is more available in the SSL layer. So don't poll; 6228 * conn->client.sock yet. */; 6229 ; 6230 pollres = 1;; 6231 if (to_read > len); 6232 to_read = len;; 6233 } else {; 6234 pfd[0].fd = conn->client.sock;; 6235 pfd[0].events = POLLIN;; 6236 ; 6237 to_read = len;; 6238 ; 6239 pollres = mg_poll(pfd,; 6240 1,; 6241 (int)(timeout * 1000.0),; 6242 &(conn->phys_ctx->stop_flag));; 6243 ; 6244 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6245 return -2;; 6246 }; 6247 }; 6248 ; 6249 if (pollres > 0) {; 6250 nread = mbed_ssl_read(conn->ssl, (unsigned char *)buf, to_read);; 6251 if (nread <= 0) {; 6252 if ((nread == MBEDTLS_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nre",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:183268,Safety,timeout,timeout,183268,"S_ERR_SSL_WANT_READ); 6253 || (nread == MBEDTLS_ERR_SSL_WANT_WRITE); 6254 || nread == MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS) {; 6255 nread = 0;; 6256 } else {; 6257 fprintf(stderr, ""SSL read failed, error %d\n"", nread);; 6258 return -2;; 6259 }; 6260 } else {; 6261 err = 0;; 6262 }; 6263 ; 6264 } else if (pollres < 0) {; 6265 /* Error */; 6266 return -2;; 6267 } else {; 6268 /* pollres = 0 means timeout */; 6269 nread = 0;; 6270 }; 6271 ; 6272#elif !defined(NO_SSL); 6273 } else if (conn->ssl != NULL) {; 6274 int ssl_pending;; 6275 struct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:184134,Safety,timeout,timeout,184134,"uct mg_pollfd pfd[1];; 6276 int pollres;; 6277 ; 6278 if ((ssl_pending = SSL_pending(conn->ssl)) > 0) {; 6279 /* We already know there is no more data buffered in conn->buf; 6280 * but there is more available in the SSL layer. So don't poll; 6281 * conn->client.sock yet. */; 6282 if (ssl_pending > len) {; 6283 ssl_pending = len;; 6284 }; 6285 pollres = 1;; 6286 } else {; 6287 pfd[0].fd = conn->client.sock;; 6288 pfd[0].events = POLLIN;; 6289 pollres = mg_poll(pfd,; 6290 1,; 6291 (int)(timeout * 1000.0),; 6292 &(conn->phys_ctx->stop_flag));; 6293 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 63",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:184378,Safety,timeout,timeout,184378,"(&conn->phys_ctx->stop_flag)) {; 6294 return -2;; 6295 }; 6296 }; 6297 if (pollres > 0) {; 6298 ERR_clear_error();; 6299 nread =; 6300 SSL_read(conn->ssl, buf, (ssl_pending > 0) ? ssl_pending : len);; 6301 if (nread <= 0) {; 6302 err = SSL_get_error(conn->ssl, nread);; 6303 if ((err == SSL_ERROR_SYSCALL) && (nread == -1)) {; 6304 err = ERRNO;; 6305 } else if ((err == SSL_ERROR_WANT_READ); 6306 || (err == SSL_ERROR_WANT_WRITE)) {; 6307 nread = 0;; 6308 } else {; 6309 /* All errors should return -2 */; 6310 DEBUG_TRACE(""SSL_read() failed, error %d"", err);; 6311 ERR_clear_error();; 6312 return -2;; 6313 }; 6314 ERR_clear_error();; 6315 } else {; 6316 err = 0;; 6317 }; 6318 } else if (pollres < 0) {; 6319 /* Error */; 6320 return -2;; 6321 } else {; 6322 /* pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* st",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:184866,Safety,timeout,timeout,184866,"pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:185528,Safety,timeout,timeout,185528,"pollres = 0 means timeout */; 6323 nread = 0;; 6324 }; 6325#endif; 6326 ; 6327 } else {; 6328 struct mg_pollfd pfd[1];; 6329 int pollres;; 6330 ; 6331 pfd[0].fd = conn->client.sock;; 6332 pfd[0].events = POLLIN;; 6333 pollres = mg_poll(pfd,; 6334 1,; 6335 (int)(timeout * 1000.0),; 6336 &(conn->phys_ctx->stop_flag));; 6337 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6338 return -2;; 6339 }; 6340 if (pollres > 0) {; 6341 nread = (int)recv(conn->client.sock, buf, (len_t)len, 0);; 6342 err = (nread < 0) ? ERRNO : 0;; 6343 if (nread <= 0) {; 6344 /* shutdown of the socket at client side */; 6345 return -2;; 6346 }; 6347 } else if (pollres < 0) {; 6348 /* error callint poll */; 6349 return -2;; 6350 } else {; 6351 /* pollres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:185890,Safety,timeout,timeout,185890,"lres = 0 means timeout */; 6352 nread = 0;; 6353 }; 6354 }; 6355 ; 6356 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6357 return -2;; 6358 }; 6359 ; 6360 if ((nread > 0) || ((nread == 0) && (len == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:186052,Safety,timeout,timeout,186052,"n == 0))) {; 6361 /* some data has been read, or no data was requested */; 6362 return nread;; 6363 }; 6364 ; 6365 if (nread < 0) {; 6366 /* socket error - check errno */; 6367#if defined(_WIN32); 6368 if (err == WSAEWOULDBLOCK) {; 6369 /* TODO (low): check if this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:186315,Safety,timeout,timeout,186315,"f this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:186441,Safety,timeout,timeout,186441,"f this is still required */; 6370 /* standard case if called from close_socket_gracefully */; 6371 return -2;; 6372 } else if (err == WSAETIMEDOUT) {; 6373 /* TODO (low): check if this is still required */; 6374 /* timeout is handled by the while loop */; 6375 return 0;; 6376 } else if (err == WSAECONNABORTED) {; 6377 /* See https://www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 t",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:186923,Safety,timeout,timeout,186923,"IN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187060,Safety,timeout,timeout,187060,"e have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187143,Safety,timeout,timeout,187143," (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, bu",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187167,Safety,timeout,timeout,187167,"1 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 646",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187336,Safety,timeout,timeout,187336," */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187485,Safety,timeout,timeout,187485,"signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t content_len, n, buffered_len, nread;; 6472 int64_t len64 =; 6473 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6474 * int, we may not read more; 6475 * bytes */; 6476 const char *body;; 64",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187642,Safety,timeout,timeout,187642,"signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t content_len, n, buffered_len, nread;; 6472 int64_t len64 =; 6473 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6474 * int, we may not read more; 6475 * bytes */; 6476 const char *body;; 64",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:187663,Safety,timeout,timeout,187663,"signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeout */; 6439 if (timeout >= 0.0) {; 6440 now = mg_get_current_time_ns();; 6441 if ((now - start_time) <= timeout_ns) {; 6442 continue;; 6443 }; 6444 }; 6445 break;; 6446 } else if (n == 0) {; 6447 break; /* No more data to read */; 6448 } else {; 6449 nread += n;; 6450 len -= n;; 6451 }; 6452 }; 6453 ; 6454 return nread;; 6455}; 6456 ; 6457 ; 6458static void; 6459discard_unread_request_data(struct mg_connection *conn); 6460{; 6461 char buf[MG_BUF_LEN];; 6462 ; 6463 while (mg_read(conn, buf, sizeof(buf)) > 0); 6464 ;; 6465}; 6466 ; 6467 ; 6468static int; 6469mg_read_inner(struct mg_connection *conn, void *buf, size_t len); 6470{; 6471 int64_t content_len, n, buffered_len, nread;; 6472 int64_t len64 =; 6473 (int64_t)((len > INT_MAX) ? INT_MAX : len); /* since the return value is; 6474 * int, we may not read more; 6475 * bytes */; 6476 const char *body;; 64",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:224466,Safety,abort,abort,224466,"d(NO_FILES) */; 7736 return;; 7737 ; 7738#if !defined(NO_FILES); 7739/* Reset all outputs */; 7740interpret_cleanup:; 7741 memset(filestat, 0, sizeof(*filestat));; 7742 *filename = 0;; 7743 *is_found = 0;; 7744 *is_script_resource = 0;; 7745 *is_websocket_request = 0;; 7746 *is_put_or_delete_request = 0;; 7747#endif /* !defined(NO_FILES) */; 7748}; 7749 ; 7750 ; 7751/* Check whether full request is buffered. Return:; 7752 * -1 if request or response is malformed; 7753 * 0 if request or response is not yet fully buffered; 7754 * >0 actual request length, including last \r\n\r\n */; 7755static int; 7756get_http_header_len(const char *buf, int buflen); 7757{; 7758 int i;; 7759 for (i = 0; i < buflen; i++) {; 7760 /* Do an unsigned comparison in some conditions below */; 7761 const unsigned char c = (unsigned char)buf[i];; 7762 ; 7763 if ((c < 128) && ((char)c != '\r') && ((char)c != '\n'); 7764 && !isprint(c)) {; 7765 /* abort scan as soon as one malformed character is found */; 7766 return -1;; 7767 }; 7768 ; 7769 if (i < buflen - 1) {; 7770 if ((buf[i] == '\n') && (buf[i + 1] == '\n')) {; 7771 /* Two newline, no carriage return - not standard compliant,; 7772 * but it should be accepted */; 7773 return i + 2;; 7774 }; 7775 }; 7776 ; 7777 if (i < buflen - 3) {; 7778 if ((buf[i] == '\r') && (buf[i + 1] == '\n') && (buf[i + 2] == '\r'); 7779 && (buf[i + 3] == '\n')) {; 7780 /* Two \r\n - standard compliant */; 7781 return i + 4;; 7782 }; 7783 }; 7784 }; 7785 ; 7786 return 0;; 7787}; 7788 ; 7789 ; 7790#if !defined(NO_CACHING); 7791/* Convert month to the month number. Return -1 on error, or month number */; 7792static int; 7793get_month_index(const char *s); 7794{; 7795 size_t i;; 7796 ; 7797 for (i = 0; i < ARRAY_SIZE(month_names); i++) {; 7798 if (!strcmp(s, month_names[i])) {; 7799 return (int)i;; 7800 }; 7801 }; 7802 ; 7803 return -1;; 7804}; 7805 ; 7806 ; 7807/* Parse UTC date-time string, and return the corresponding time_t value. */; 7808static time_t; 7809parse_d",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:263972,Safety,timeout,timeout,263972,"uncation check for ebuf */; 9138 ebuf,; 9139 ebuf_len,; 9140 ""socket(): %s"",; 9141 strerror(ERRNO));; 9142 return 0;; 9143 }; 9144 ; 9145 if (0 != set_non_blocking_mode(*sock)) {; 9146 mg_snprintf(NULL,; 9147 NULL, /* No truncation check for ebuf */; 9148 ebuf,; 9149 ebuf_len,; 9150 ""Cannot set socket to non-blocking: %s"",; 9151 strerror(ERRNO));; 9152 closesocket(*sock);; 9153 *sock = INVALID_SOCKET;; 9154 return 0;; 9155 }; 9156 ; 9157 set_close_on_exec(*sock, NULL, ctx);; 9158 ; 9159 if (ip_ver == 4) {; 9160 /* connected with IPv4 */; 9161 conn_ret = connect(*sock,; 9162 (struct sockaddr *)((void *)&sa->sin),; 9163 sizeof(sa->sin));; 9164 }; 9165#if defined(USE_IPV6); 9166 else if (ip_ver == 6) {; 9167 /* connected with IPv6 */; 9168 conn_ret = connect(*sock,; 9169 (struct sockaddr *)((void *)&sa->sin6),; 9170 sizeof(sa->sin6));; 9171 }; 9172#endif; 9173#if defined(USE_X_DOM_SOCKET); 9174 else if (ip_ver == -99) {; 9175 /* connected to domain socket */; 9176 conn_ret = connect(*sock,; 9177 (struct sockaddr *)((void *)&sa->sun),; 9178 sizeof(sa->sun));; 9179 }; 9180#endif; 9181 ; 9182 if (conn_ret != 0) {; 9183 sockerr = ERRNO;; 9184 }; 9185 ; 9186#if defined(_WIN32); 9187 if ((conn_ret != 0) && (sockerr == WSAEWOULDBLOCK)) {; 9188#else; 9189 if ((conn_ret != 0) && (sockerr == EINPROGRESS)) {; 9190#endif; 9191 /* Data for getsockopt */; 9192 void *psockerr = &sockerr;; 9193 int ret;; 9194 ; 9195#if defined(_WIN32); 9196 int len = (int)sizeof(sockerr);; 9197#else; 9198 socklen_t len = (socklen_t)sizeof(sockerr);; 9199#endif; 9200 ; 9201 /* Data for poll */; 9202 struct mg_pollfd pfd[1];; 9203 int pollres;; 9204 int ms_wait = 10000; /* 10 second timeout */; 9205 stop_flag_t nonstop;; 9206 STOP_FLAG_ASSIGN(&nonstop, 0);; 9207 ; 9208 /* For a non-blocking socket, the connect sequence is:; 9209 * 1) call connect (will not block); 9210 * 2) wait until the socket is ready for writing (select or poll); 9211 * 3) check connection state with getsockopt; 9212 */; 9213 pfd[0].",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:264601,Safety,timeout,timeout,264601,"fd[1];; 9203 int pollres;; 9204 int ms_wait = 10000; /* 10 second timeout */; 9205 stop_flag_t nonstop;; 9206 STOP_FLAG_ASSIGN(&nonstop, 0);; 9207 ; 9208 /* For a non-blocking socket, the connect sequence is:; 9209 * 1) call connect (will not block); 9210 * 2) wait until the socket is ready for writing (select or poll); 9211 * 3) check connection state with getsockopt; 9212 */; 9213 pfd[0].fd = *sock;; 9214 pfd[0].events = POLLOUT;; 9215 pollres = mg_poll(pfd, 1, ms_wait, ctx ? &(ctx->stop_flag) : &nonstop);; 9216 ; 9217 if (pollres != 1) {; 9218 /* Not connected */; 9219 mg_snprintf(NULL,; 9220 NULL, /* No truncation check for ebuf */; 9221 ebuf,; 9222 ebuf_len,; 9223 ""connect(%s:%d): timeout"",; 9224 host,; 9225 port);; 9226 closesocket(*sock);; 9227 *sock = INVALID_SOCKET;; 9228 return 0;; 9229 }; 9230 ; 9231#if defined(_WIN32); 9232 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, (char *)psockerr, &len);; 9233#else; 9234 ret = getsockopt(*sock, SOL_SOCKET, SO_ERROR, psockerr, &len);; 9235#endif; 9236 ; 9237 if ((ret == 0) && (sockerr == 0)) {; 9238 conn_ret = 0;; 9239 }; 9240 }; 9241 ; 9242 if (conn_ret != 0) {; 9243 /* Not connected */; 9244 mg_snprintf(NULL,; 9245 NULL, /* No truncation check for ebuf */; 9246 ebuf,; 9247 ebuf_len,; 9248 ""connect(%s:%d): error %s"",; 9249 host,; 9250 port,; 9251 strerror(sockerr));; 9252 closesocket(*sock);; 9253 *sock = INVALID_SOCKET;; 9254 return 0;; 9255 }; 9256 ; 9257 return 1;; 9258}; 9259 ; 9260 ; 9261int; 9262mg_url_encode(const char *src, char *dst, size_t dst_len); 9263{; 9264 static const char *dont_escape = ""._-$,;~()"";; 9265 static const char *hex = ""0123456789abcdef"";; 9266 char *pos = dst;; 9267 const char *end = dst + dst_len - 1;; 9268 ; 9269 for (; ((*src != '\0') && (pos < end)); src++, pos++) {; 9270 if (isalnum((unsigned char)*src); 9271 || (strchr(dont_escape, *src) != NULL)) {; 9272 *pos = *src;; 9273 } else if (pos + 2 < end) {; 9274 pos[0] = '%';; 9275 pos[1] = hex[(unsigned char)*src >> 4];; 9276 pos[2] = ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302391,Safety,safe,safe,302391,"safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEA",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302921,Safety,safe,safe,302921,"s not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10561 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10562 * to be useful for REST in case a ""GET request with body"" is; 10563 * required. */; 10564 ; 10565 {NULL, 0",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:326635,Safety,timeout,timeout,326635," /* Wait until process is terminated (don't leave zombies) */; 11261 while (waitpid(proc->pid, &status, 0) != (pid_t)-1) /* nop */; 11262 ;; 11263 } else {; 11264 DEBUG_TRACE(""CGI timer: Child process %d already stopped\n"", proc->pid);; 11265 }; 11266 /* Dec reference counter */; 11267 refs = mg_atomic_dec(&proc->references);; 11268 if (refs == 0) {; 11269 /* no more references - free data */; 11270 mg_free(data);; 11271 }; 11272 ; 11273 return 0;; 11274}; 11275 ; 11276 ; 11277/* Local (static) function assumes all arguments are valid. */; 11278static void; 11279handle_cgi_request(struct mg_connection *conn,; 11280 const char *prog,; 11281 unsigned char cgi_config_idx); 11282{; 11283 char *buf;; 11284 size_t buflen;; 11285 int headers_len, data_len, i, truncated;; 11286 int fdin[2] = {-1, -1}, fdout[2] = {-1, -1}, fderr[2] = {-1, -1};; 11287 const char *status, *status_text, *connection_state;; 11288 char *pbuf, dir[UTF8_PATH_MAX], *p;; 11289 struct mg_request_info ri;; 11290 struct cgi_environment blk;; 11291 FILE *in = NULL, *out = NULL, *err = NULL;; 11292 struct mg_file fout = STRUCT_FILE_INITIALIZER;; 11293 pid_t pid = (pid_t)-1;; 11294 struct process_control_data *proc = NULL;; 11295 ; 11296#if defined(USE_TIMERS); 11297 double cgi_timeout;; 11298 if (conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) {; 11299 /* Get timeout in seconds */; 11300 cgi_timeout =; 11301 atof(conn->dom_ctx->config[CGI_TIMEOUT + cgi_config_idx]) * 0.001;; 11302 } else {; 11303 cgi_timeout =; 11304 atof(config_options[REQUEST_TIMEOUT].default_value) * 0.001;; 11305 }; 11306 ; 11307#endif; 11308 ; 11309 buf = NULL;; 11310 buflen = conn->phys_ctx->max_request_size;; 11311 i = prepare_cgi_environment(conn, prog, &blk, cgi_config_idx);; 11312 if (i != 0) {; 11313 blk.buf = NULL;; 11314 blk.var = NULL;; 11315 goto done;; 11316 }; 11317 ; 11318 /* CGI must be executed in its own directory. 'dir' must point to the; 11319 * directory containing executable program, 'p' must point to the; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:333044,Safety,abort,abort,333044,"n, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != NULL) {; 11518 conn->status_code = atoi(status);; 11519 status_text = status;; 11520 while (isdigit((unsigned char)*status_text) || *status_text == ' ') {; 11521 status_text++;; 11522 }; 11523 } else if (get_header(ri.http_headers, ri.num_headers, ""Location""); 11524 != NULL) {; 11525 conn->status_code = 307;; 11526 } else {; 11527 conn->status_code = 200;; 11528 }; 11529 connection_state =; 11530 get_header(ri.http_headers, ri.num_headers, ""Connection"");; 11531 if (!header_has_option(connection_state, ""keep-alive"")) {; 11532 conn->must_close = 1;; 11533 }; 11534 ; 11535 DEBUG_TRACE(""CGI: response %u %s"", conn->status_code, status_text);; 11536 ; 11537 (v",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:343730,Safety,safe,safe,343730,"; 11826 mg_send_http_error(; 11827 conn,; 11828 403,; 11829 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11830 path);; 11831 return;; 11832 }; 11833 ; 11834 /* Try to delete it. */; 11835 if (mg_remove(conn, path) == 0) {; 11836 /* Delete was successful: Return 204 without content. */; 11837 mg_response_header_start(conn, 204);; 11838 send_no_cache_header(conn);; 11839 send_additional_header(conn);; 11840 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11841 mg_response_header_send(conn);; 11842 ; 11843 } else {; 11844 /* Delete not successful (file locked). */; 11845 mg_send_http_error(conn,; 11846 423,; 11847 ""Error: Cannot delete file\nremove(%s): %s"",; 11848 path,; 11849 strerror(ERRNO));; 11850 }; 11851}; 11852#endif /* !NO_FILES */; 11853 ; 11854 ; 11855#if !defined(NO_FILESYSTEMS); 11856static void; 11857send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11858 ; 11859 ; 11860static void; 11861do_ssi_include(struct mg_connection *conn,; 11862 const char *ssi,; 11863 char *tag,; 11864 int include_level); 11865{; 11866 char file_name[MG_BUF_LEN], path[512], *p;; 11867 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11868 size_t len;; 11869 int truncated = 0;; 11870 ; 11871 if (conn == NULL) {; 11872 return;; 11873 }; 11874 ; 11875 /* sscanf() is safe here, since send_ssi_file() also uses buffer; 11876 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 11877 * always < MG_BUF_LEN. */; 11878 if (sscanf(tag, "" virtual=\""%511[^\""]\"""", file_name) == 1) {; 11879 /* File name is relative to the webserver root */; 11880 file_name[511] = 0;; 11881 (void)mg_snprintf(conn,; 11882 &truncated,; 11883 path,; 11884 sizeof(path),; 11885 ""%s/%s"",; 11886 conn->dom_ctx->config[DOCUMENT_ROOT],; 11887 file_name);; 11888 ; 11889 } else if (sscanf(tag, "" abspath=\""%511[^\""]\"""", file_name) == 1) {; 11890 /* File name is relative to the webserver working directory; 11891 * or it is absolute system path */; 11892 file_name[511] = 0;; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:360999,Safety,timeout,timeout,360999,"2427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_h",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361340,Safety,timeout,timeout,361340,"urrent message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361428,Safety,timeout,timeout,361428,"ing key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1]",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361498,Safety,timeout,timeout,361498,"ls.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361583,Safety,timeout,timeout,361583,"12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:361608,Safety,timeout,timeout,361608,"data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_handling = 1;; 12476 mg_set_thread_name(""wsock"");; 12477 ; 12478 /* Loop continuously, reading messages from the socket, invoking the; 12479 * callback, and waiting repeatedly until an error occurs. */; 12480 while (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12481 && (!conn->must_close)) {; 12482 header_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (bod",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:364664,Safety,timeout,timeout,364664,"t of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place. */; 12541 DEBUG_ASSERT(body_len >= header_len);; 12542 if (data_len + (uint64_t)header_len > (uint64_t)body_len) {; 12543 mop = buf[0]; /* current mask and opcode */; 12544 /* Overflow case */; 12545 len = body_len - header_len;; 12546 memcpy(data, buf + header_len, len);; 12547 error = 0;; 12548 while ((uint64_t)len < data_len) {; 12549 n = pull_inner(NULL,; 12550 conn,; 12551 (char *)(data + len),; 12552 (int)(data_len - len),; 12553 timeout);; 12554 if (n <= -2) {; 12555 error = 1;; 12556 break;; 12557 } else if (n > 0) {; 12558 len += (size_t)n;; 12559 } else {; 12560 /* Timeout: should retry */; 12561 /* TODO: retry condition */; 12562 }; 12563 }; 12564 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Ma",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:370620,Safety,timeout,timeout,370620,"k_data)) {; 12720 exit_by_callback = 1;; 12721 }; 12722 }; 12723 }; 12724 ; 12725 /* It a buffer has been allocated, free it again */; 12726 if (data != mem) {; 12727 mg_free(data);; 12728 }; 12729 ; 12730 if (exit_by_callback) {; 12731 DEBUG_TRACE(""Callback requests to close connection from %s:%u"",; 12732 conn->request_info.remote_addr,; 12733 conn->request_info.remote_port);; 12734 break;; 12735 }; 12736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:371853,Safety,timeout,timeout,371853,"break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 12785 ; 12786 if (ret <= 0) {; 12787 /* Error: send failed */; 12788 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12789 break;; 12790 }; 12791 ping_count++;; 12792 }; 12793 }; 12794 /* Timeout: should retry */; 12795 /* TODO: get timeout def */; 12796 }; 12797 }; 12798 }; 12799 ; 12800 /* Leave data processing loop */; 12801 mg_set_thread_name(""worker"");; 12802 conn->in_websocket_handling = 0;; 12803 DEBUG_TRACE(""Websocket connection %s:%u left data processing loop"",; 12804 conn->request_info.remote_addr,; 12805 conn->request_info.remote_port);; 12806}; 12807 ; 12808 ; 12809static int; 12810mg_websocket_write_exec(struct mg_connection *conn,; 12811 int opcode,; 12812 const char *data,; 12813 size_t dataLen,; 12814 uint32_t masking_key); 12815{; 12816 unsigned char header[14];; 12817 size_t headerLen;; 12818 int retval;; 12819 ; 12820#if defined(GCC_DIAGNOSTIC); 12821 /* Disable spurious conversion warning for GCC */; 12822#pragma GCC diagnostic push; 12823#pragma GCC diagnostic ignored ""-Wconversion""; 12824#endif; 12825 ; 12826 /* Note that POSIX/Winsock's send() is threadsafe; 12827 * http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socke",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:441490,Safety,detect,detected,441490,"en < vec->len) ? vec->ptr[len] : '\0';; 14886 so->is_ssl = (ch == 's');; 14887 so->ssl_redir = (ch == 'r');; 14888 if ((ch == '\0') || (ch == 's') || (ch == 'r')) {; 14889 return 1;; 14890 }; 14891 }; 14892 ; 14893 /* Reset ip_version to 0 if there is an error */; 14894 *ip_version = 0;; 14895 return 0;; 14896}; 14897 ; 14898 ; 14899/* Is there any SSL port in use? */; 14900static int; 14901is_ssl_port_used(const char *ports); 14902{; 14903 if (ports) {; 14904 /* There are several different allowed syntax variants:; 14905 * - ""80"" for a single port using every network interface; 14906 * - ""localhost:80"" for a single port using only localhost; 14907 * - ""80,localhost:8080"" for two ports, one bound to localhost; 14908 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 14909 * to IPv4 localhost, one to IPv6 localhost; 14910 * - ""+80"" use port 80 for IPv4 and IPv6; 14911 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 14912 * for both: IPv4 and IPv4; 14913 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 14914 * additionally port 8080 bound to localhost connections; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hos",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:445307,Safety,abort,abort,445307,"st of protocol numbers (e.g., TCP==6) see:; 15014 * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml; 15015 */; 15016 if ((so.sock =; 15017 socket(so.lsa.sa.sa_family,; 15018 SOCK_STREAM,; 15019 (ip_version == 99) ? (/* LOCAL */ 0) : (/* TCP */ 6))); 15020 == INVALID_SOCKET) {; 15021 ; 15022 mg_cry_ctx_internal(phys_ctx,; 15023 ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:445657,Safety,abort,abort,445657," ""cannot create socket (entry %i)"",; 15024 portsTotal);; 15025 continue;; 15026 }; 15027 ; 15028#if defined(_WIN32); 15029 /* Windows SO_REUSEADDR lets many procs binds to a; 15030 * socket, SO_EXCLUSIVEADDRUSE makes the bind fail; 15031 * if someone already has the socket -- DTL */; 15032 /* NOTE: If SO_EXCLUSIVEADDRUSE is used,; 15033 * Windows might need a few seconds before; 15034 * the same port can be used again in the; 15035 * same process, so a short Sleep may be; 15036 * required between mg_stop and mg_start.; 15037 */; 15038 if (setsockopt(so.sock,; 15039 SOL_SOCKET,; 15040 SO_EXCLUSIVEADDRUSE,; 15041 (SOCK_OPT_TYPE)&on,; 15042 sizeof(on)); 15043 != 0) {; 15044 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 I",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:446334,Safety,abort,abort,446334,"44 ; 15045 /* Set reuse option, but don't abort on errors. */; 15046 mg_cry_ctx_internal(; 15047 phys_ctx,; 15048 ""cannot set socket option SO_EXCLUSIVEADDRUSE (entry %i)"",; 15049 portsTotal);; 15050 }; 15051#else; 15052 if (setsockopt(so.sock,; 15053 SOL_SOCKET,; 15054 SO_REUSEADDR,; 15055 (SOCK_OPT_TYPE)&on,; 15056 sizeof(on)); 15057 != 0) {; 15058 ; 15059 /* Set reuse option, but don't abort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 IPPROTO_IPV6,; 15095 IPV6_V6ONLY,; 15096 (void *)&on,; 15097 sizeof(on)); 15098 != 0) {; 15099 ; 15100 /* Set IPv6 only option, but don't abort on errors. */; 15101 mg_cry_ctx_internal(phys_ctx,; 15102 ""cannot set socket option ""; 15103 ""IPV6_V6ONLY=on (entry %i)"",; 15104 portsTotal);; 15105 }; 15106 }; 15107#else; 15108 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15109 closesocket(so.sock);; 15110 so.sock = INVALID_SOCKET;; 15111 continue;; 15112#endif; 15113 }; 15114 ; 15115 if (so.lsa.sa.sa_family == AF_INET) {; 15116 ; 15117 len = sizeof(so.lsa.sin);; 15118 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15119 mg_cry_ctx_internal(phys_ctx,; 15120 ""cannot",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:446726,Safety,abort,abort,446726,"bort on errors. */; 15060 mg_cry_ctx_internal(; 15061 phys_ctx,; 15062 ""cannot set socket option SO_REUSEADDR (entry %i)"",; 15063 portsTotal);; 15064 }; 15065#endif; 15066 ; 15067#if defined(USE_X_DOM_SOCKET); 15068 if (ip_version == 99) {; 15069 /* Unix domain socket */; 15070 } else; 15071#endif; 15072 ; 15073 if (ip_version > 4) {; 15074 /* Could be 6 for IPv6 onlyor 10 (4+6) for IPv4+IPv6 */; 15075#if defined(USE_IPV6); 15076 if (ip_version > 6) {; 15077 if (so.lsa.sa.sa_family == AF_INET6; 15078 && setsockopt(so.sock,; 15079 IPPROTO_IPV6,; 15080 IPV6_V6ONLY,; 15081 (void *)&off,; 15082 sizeof(off)); 15083 != 0) {; 15084 ; 15085 /* Set IPv6 only option, but don't abort on errors. */; 15086 mg_cry_ctx_internal(phys_ctx,; 15087 ""cannot set socket option ""; 15088 ""IPV6_V6ONLY=off (entry %i)"",; 15089 portsTotal);; 15090 }; 15091 } else {; 15092 if (so.lsa.sa.sa_family == AF_INET6; 15093 && setsockopt(so.sock,; 15094 IPPROTO_IPV6,; 15095 IPV6_V6ONLY,; 15096 (void *)&on,; 15097 sizeof(on)); 15098 != 0) {; 15099 ; 15100 /* Set IPv6 only option, but don't abort on errors. */; 15101 mg_cry_ctx_internal(phys_ctx,; 15102 ""cannot set socket option ""; 15103 ""IPV6_V6ONLY=on (entry %i)"",; 15104 portsTotal);; 15105 }; 15106 }; 15107#else; 15108 mg_cry_ctx_internal(phys_ctx, ""%s"", ""IPv6 not available"");; 15109 closesocket(so.sock);; 15110 so.sock = INVALID_SOCKET;; 15111 continue;; 15112#endif; 15113 }; 15114 ; 15115 if (so.lsa.sa.sa_family == AF_INET) {; 15116 ; 15117 len = sizeof(so.lsa.sin);; 15118 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15119 mg_cry_ctx_internal(phys_ctx,; 15120 ""cannot bind to %.*s: %d (%s)"",; 15121 (int)vec.len,; 15122 vec.ptr,; 15123 (int)ERRNO,; 15124 strerror(errno));; 15125 closesocket(so.sock);; 15126 so.sock = INVALID_SOCKET;; 15127 continue;; 15128 }; 15129 }; 15130#if defined(USE_IPV6); 15131 else if (so.lsa.sa.sa_family == AF_INET6) {; 15132 ; 15133 len = sizeof(so.lsa.sin6);; 15134 if (bind(so.sock, &so.lsa.sa, len) != 0) {; 15135 mg_cry_ctx_i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:463089,Safety,timeout,timeout,463089,"lock_context(conn->phys_ctx);; 15641 mg_cry_ctx_internal(; 15642 conn->phys_ctx,; 15643 ""SSL_CTX_load_verify_locations error: %s ""; 15644 ""ssl_verify_peer requires setting ""; 15645 ""either ssl_ca_path or ssl_ca_file. Is any of them ""; 15646 ""present in ""; 15647 ""the .conf file?"",; 15648 ssl_error());; 15649 return 0;; 15650 }; 15651 }; 15652 ; 15653 if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain) == 0) {; 15654 mg_unlock_context(conn->phys_ctx);; 15655 return 0;; 15656 }; 15657 }; 15658 mg_unlock_context(conn->phys_ctx);; 15659 ; 15660 return 1;; 15661}; 15662 ; 15663#if defined(OPENSSL_API_1_1); 15664#else; 15665static pthread_mutex_t *ssl_mutexes;; 15666#endif /* OPENSSL_API_1_1 */; 15667 ; 15668static int; 15669sslize(struct mg_connection *conn,; 15670 int (*func)(SSL *),; 15671 const struct mg_client_options *client_options); 15672{; 15673 int ret, err;; 15674 int short_trust;; 15675 unsigned timeout = 1024;; 15676 unsigned i;; 15677 ; 15678 if (!conn) {; 15679 return 0;; 15680 }; 15681 ; 15682 short_trust =; 15683 (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_opt",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464307,Safety,timeout,timeout,464307,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464346,Safety,timeout,timeout,464346,"nn->dom_ctx->config[SSL_SHORT_TRUST] != NULL); 15684 && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], ""yes"") == 0);; 15685 ; 15686 if (short_trust) {; 15687 int trust_ret = refresh_trust(conn);; 15688 if (!trust_ret) {; 15689 return trust_ret;; 15690 }; 15691 }; 15692 ; 15693 mg_lock_context(conn->phys_ctx);; 15694 conn->ssl = SSL_new(conn->dom_ctx->ssl_ctx);; 15695 mg_unlock_context(conn->phys_ctx);; 15696 if (conn->ssl == NULL) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 1573",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464635,Safety,timeout,timeout,464635,"L) {; 15697 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15698 OPENSSL_REMOVE_THREAD_STATE();; 15699 return 0;; 15700 }; 15701 SSL_set_app_data(conn->ssl, (char *)conn);; 15702 ; 15703 ret = SSL_set_fd(conn->ssl, conn->client.sock);; 15704 if (ret != 1) {; 15705 mg_cry_internal(conn, ""sslize error: %s"", ssl_error());; 15706 SSL_free(conn->ssl);; 15707 conn->ssl = NULL;; 15708 OPENSSL_REMOVE_THREAD_STATE();; 15709 return 0;; 15710 }; 15711 ; 15712 if (client_options) {; 15713 if (client_options->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:464909,Safety,timeout,timeout,464909,"->host_name) {; 15714 SSL_set_tlsext_host_name(conn->ssl, client_options->host_name);; 15715 }; 15716 }; 15717 ; 15718 /* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */; 15719 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 15720 /* NOTE: The loop below acts as a back-off, so we can end; 15721 * up sleeping for more (or less) than the REQUEST_TIMEOUT. */; 15722 int to = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]);; 15723 if (to >= 0) {; 15724 timeout = (unsigned)to;; 15725 }; 15726 }; 15727 ; 15728 /* SSL functions may fail and require to be called again:; 15729 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html; 15730 * Here ""func"" could be SSL_connect or SSL_accept. */; 15731 for (i = 0; i <= timeout; i += 50) {; 15732 ERR_clear_error();; 15733 /* conn->dom_ctx may be changed here (see ssl_servername_callback) */; 15734 ret = func(conn->ssl);; 15735 if (ret != 1) {; 15736 err = SSL_get_error(conn->ssl, ret);; 15737 if ((err == SSL_ERROR_WANT_CONNECT); 15738 || (err == SSL_ERROR_WANT_ACCEPT); 15739 || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE); 15740 || (err == SSL_ERROR_WANT_X509_LOOKUP)) {; 15741 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 15742 /* Don't wait if the server is going to be stopped. */; 15743 break;; 15744 }; 15745 if (err == SSL_ERROR_WANT_X509_LOOKUP) {; 15746 /* Simply retry the function call. */; 15747 mg_sleep(50);; 15748 } else {; 15749 /* Need to retry the function call ""later"".; 15750 * See https://linux.die.net/man/3/ssl_get_error; 15751 * This is typical for non-blocking sockets. */; 15752 struct mg_pollfd pfd;; 15753 int pollres;; 15754 pfd.fd = conn->client.sock;; 15755 pfd.events = ((err == SSL_ERROR_WANT_CONNECT); 15756 || (err == SSL_ERROR_WANT_WRITE)); 15757 ? POLLOUT; 15758 : POLLIN;; 15759 pollres =; 15760 mg_poll(&pfd, 1, 50, &(conn->phys_ctx->stop_flag));; 15761 if (pollres < 0) {; 15762 /* Break if error occured (-1); 15763 * or server shutdown (-2) */; 15764 br",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:474587,Safety,safe,safety,474587,"tic void *ssllib_dll_handle; /* Store the ssl library handle. */; 16020static void *cryptolib_dll_handle; /* Store the crypto library handle. */; 16021 ; 16022#endif /* NO_SSL_DL */; 16023 ; 16024 ; 16025#if defined(SSL_ALREADY_INITIALIZED); 16026static volatile ptrdiff_t cryptolib_users =; 16027 1; /* Reference counter for crypto library. */; 16028#else; 16029static volatile ptrdiff_t cryptolib_users =; 16030 0; /* Reference counter for crypto library. */; 16031#endif; 16032 ; 16033 ; 16034static int; 16035initialize_openssl(char *ebuf, size_t ebuf_len); 16036{; 16037#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16038 int i, num_locks;; 16039 size_t size;; 16040#endif; 16041 ; 16042 if (ebuf_len > 0) {; 16043 ebuf[0] = 0;; 16044 }; 16045 ; 16046#if !defined(NO_SSL_DL); 16047 if (!cryptolib_dll_handle) {; 16048 memset(tls_feature_missing, 0, sizeof(tls_feature_missing));; 16049 cryptolib_dll_handle = load_tls_dll(; 16050 ebuf, ebuf_len, CRYPTO_LIB, crypto_sw, tls_feature_missing);; 16051 if (!cryptolib_dll_handle) {; 16052 mg_snprintf(NULL,; 16053 NULL, /* No truncation check for ebuf */; 16054 ebuf,; 16055 ebuf_len,; 16056 ""%s: error loading library %s"",; 16057 __func__,; 16058 CRYPTO_LIB);; 16059 DEBUG_TRACE(""%s"", ebuf);; 16060 return 0;; 16061 }; 16062 }; 16063#endif /* NO_SSL_DL */; 16064 ; 16065 if (mg_atomic_inc(&cryptolib_users) > 1) {; 16066 return 1;; 16067 }; 16068 ; 16069#if !defined(OPENSSL_API_1_1) && !defined(OPENSSL_API_3_0); 16070 /* Initialize locking callbacks, needed for thread safety.; 16071 * http://www.openssl.org/support/faq.html#PROG1; 16072 */; 16073 num_locks = CRYPTO_num_locks();; 16074 if (num_locks < 0) {; 16075 num_locks = 0;; 16076 }; 16077 size = sizeof(pthread_mutex_t) * ((size_t)(num_locks));; 16078 ; 16079 /* allocate mutex array, if required */; 16080 if (num_locks == 0) {; 16081 /* No mutex array required */; 16082 ssl_mutexes = NULL;; 16083 } else {; 16084 /* Mutex array required - allocate it */; 16085 ssl_mutexes",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:503693,Safety,timeout,timeout,503693,"929 ; 16930 ; 16931static int; 16932set_tcp_nodelay(const struct socket *so, int nodelay_on); 16933{; 16934 if ((so->lsa.sa.sa_family == AF_INET); 16935 || (so->lsa.sa.sa_family == AF_INET6)) {; 16936 /* Only for TCP sockets */; 16937 if (setsockopt(so->sock,; 16938 IPPROTO_TCP,; 16939 TCP_NODELAY,; 16940 (SOCK_OPT_TYPE)&nodelay_on,; 16941 sizeof(nodelay_on)); 16942 != 0) {; 16943 /* Error */; 16944 return 1;; 16945 }; 16946 }; 16947 /* OK */; 16948 return 0;; 16949}; 16950 ; 16951 ; 16952#if !defined(__ZEPHYR__); 16953static void; 16954close_socket_gracefully(struct mg_connection *conn); 16955{; 16956#if defined(_WIN32); 16957 char buf[MG_BUF_LEN];; 16958 int n;; 16959#endif; 16960 struct linger linger;; 16961 int error_code = 0;; 16962 int linger_timeout = -2;; 16963 socklen_t opt_len = sizeof(error_code);; 16964 ; 16965 if (!conn) {; 16966 return;; 16967 }; 16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger o",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:504710,Safety,avoid,avoid,504710,"16968 ; 16969 /* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 16970 * ""Note that enabling a nonzero timeout on a nonblocking socket; 16971 * is not recommended."", so set it to blocking now */; 16972 set_blocking_mode(conn->client.sock);; 16973 ; 16974 /* Send FIN to the client */; 16975 shutdown(conn->client.sock, SHUTDOWN_WR);; 16976 ; 16977 ; 16978#if defined(_WIN32); 16979 /* Read and discard pending incoming data. If we do not do that and; 16980 * close; 16981 * the socket, the data in the send buffer may be discarded. This; 16982 * behaviour is seen on Windows, when client keeps sending data; 16983 * when server decides to close the connection; then when client; 16984 * does recv() it gets no data back. */; 16985 do {; 16986 n = pull_inner(NULL, conn, buf, sizeof(buf), /* Timeout in s: */ 1.0);; 16987 } while (n > 0);; 16988#endif; 16989 ; 16990 if (conn->dom_ctx->config[LINGER_TIMEOUT]) {; 16991 linger_timeout = atoi(conn->dom_ctx->config[LINGER_TIMEOUT]);; 16992 }; 16993 ; 16994 /* Set linger option according to configuration */; 16995 if (linger_timeout >= 0) {; 16996 /* Set linger option to avoid socket hanging out after close. This; 16997 * prevent ephemeral port exhaust problem under high QPS. */; 16998 linger.l_onoff = 1;; 16999 ; 17000#if defined(_MSC_VER); 17001#pragma warning(push); 17002#pragma warning(disable : 4244); 17003#endif; 17004#if defined(GCC_DIAGNOSTIC); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:506474,Safety,timeout,timeout,506474,"_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; 17079close_connection(struct mg_connection *conn); 17080{; 17081#if defined(USE_SERVER_STATS); 17082 conn->conn_state = 6; /* to close */; 17083#endif; 17084 ; 17085#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17086 if (conn->lua_websocket_state) ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:506888,Safety,safe,safe,506888,"code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; 17079close_connection(struct mg_connection *conn); 17080{; 17081#if defined(USE_SERVER_STATS); 17082 conn->conn_state = 6; /* to close */; 17083#endif; 17084 ; 17085#if defined(USE_LUA) && defined(USE_WEBSOCKET); 17086 if (conn->lua_websocket_state) {; 17087 lua_websocket_close(conn, conn->lua_websocket_state);; 17088 conn->lua_websocket_state = NULL;; 17089 }; 17090#endif; 17091 ; 17092 mg_lock_connection(conn);; 17093 ; 17094 /* Set close flag, so keep-alive loops will stop */; 17095 conn->must_close = 1;; 17096 ; 17097 /* call the connection_close callback if assigned */; 17098 if (conn->phys_ctx->callbacks.connection_close != NULL) {; 17099 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17100 conn->phys_ctx->callbacks.connection_close(conn);; 17101 }; 17102 }; 17103 ; 17104 /* Reset user data,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:510101,Safety,timeout,timeouts,510101,"7142 }; 17143 }; 17144 ; 17145 mg_unlock_connection(conn);; 17146 ; 17147#if defined(USE_SERVER_STATS); 17148 conn->conn_state = 8; /* closed */; 17149#endif; 17150}; 17151 ; 17152 ; 17153void; 17154mg_close_connection(struct mg_connection *conn); 17155{; 17156 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 17157 return;; 17158 }; 17159 ; 17160#if defined(USE_WEBSOCKET); 17161 if (conn->phys_ctx->context_type == CONTEXT_SERVER) {; 17162 if (conn->in_websocket_handling) {; 17163 /* Set close flag, so the server thread can exit. */; 17164 conn->must_close = 1;; 17165 return;; 17166 }; 17167 }; 17168 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17169 ; 17170 unsigned int i;; 17171 ; 17172 /* client context: loops must end */; 17173 STOP_FLAG_ASSIGN(&conn->phys_ctx->stop_flag, 1);; 17174 conn->must_close = 1;; 17175 ; 17176 /* We need to get the client thread out of the select/recv call; 17177 * here. */; 17178 /* Since we use a sleep quantum of some seconds to check for recv; 17179 * timeouts, we will just wait a few seconds in mg_join_thread. */; 17180 ; 17181 /* join worker thread */; 17182 for (i = 0; i < conn->phys_ctx->cfg_worker_threads; i++) {; 17183 mg_join_thread(conn->phys_ctx->worker_threadids[i]);; 17184 }; 17185 }; 17186#endif /* defined(USE_WEBSOCKET) */; 17187 ; 17188 close_connection(conn);; 17189 ; 17190#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17191 if (((conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT); 17192 || (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT)); 17193 && (conn->phys_ctx->dd.ssl_ctx != NULL)) {; 17194 SSL_CTX_free(conn->phys_ctx->dd.ssl_ctx);; 17195 }; 17196#endif; 17197 ; 17198#if defined(USE_WEBSOCKET); 17199 if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {; 17200 mg_free(conn->phys_ctx->worker_threadids);; 17201 (void)pthread_mutex_destroy(&conn->mutex);; 17202 mg_free(conn);; 17203 } else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {; 17204 (void)pthread_mut",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:526277,Safety,avoid,avoid,526277,"in of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17690 server_domain_len = strlen(server_domain);; 17691 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17692 return 0;; 17693 }; 17694 if ((request_domain_len == server_domain_len); 17695 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17696 /* Request is directed to this server - full name match. */; 17697 } else {; 17698 if (request_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700 * is longer than the request name.; 17701 * Drop this case here to avoid overflows in the; 17702 * following checks. */; 17703 return 0;; 17704 }; 17705 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""I",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:527443,Safety,timeout,timeouts,527443,") {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""Internal error"");; 17743 *err = 500;; 17744 return 0;; 17745 }; 17746 ; 17747 /* Set the time the request was received. This value should be used for; 17748 * timeouts. */; 17749 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17750 ; 17751 conn->request_len =; 17752 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17753 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17754 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17755 mg_snprintf(conn,; 17756 NULL, /* No truncation check for ebuf */; 17757 ebuf,; 17758 ebuf_len,; 17759 ""%s"",; 17760 ""Invalid message size"");; 17761 *err = 500;; 17762 return 0;; 17763 }; 17764 ; 17765 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17766 mg_snprintf(conn,; 17767 NULL, /* No truncation check for ebuf */; 17768 ebuf,; 17769 ebuf_len,; 17770 ""%s"",; 17771 ""Message too large"");; 17772 *err = 413;; 17773 return 0;; 17774 }; 17775 ; 17776 if (conn->request_len <= 0) {; 17777 if (conn->data_len > 0) {; 17778 mg_snprintf(conn,; 17779 NULL, /* No truncation check for ebuf */; 17780 ebuf,; 17781 e",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:533991,Safety,timeout,timeout,533991,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:534619,Safety,timeout,timeout,534619,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:534690,Safety,timeout,timeout,534690,"code == 304) {; 17961 conn->content_len = 0;; 17962 }; 17963 } else {; 17964 /* TODO: we should also consider HEAD method */; 17965 if (((conn->response_info.status_code >= 100); 17966 && (conn->response_info.status_code <= 199)); 17967 || (conn->response_info.status_code == 204); 17968 || (conn->response_info.status_code == 304)) {; 17969 conn->content_len = 0;; 17970 } else {; 17971 conn->content_len = -1; /* unknown content length */; 17972 }; 17973 }; 17974 ; 17975 return 1;; 17976}; 17977 ; 17978 ; 17979int; 17980mg_get_response(struct mg_connection *conn,; 17981 char *ebuf,; 17982 size_t ebuf_len,; 17983 int timeout); 17984{; 17985 int err, ret;; 17986 char txt[32]; /* will not overflow */; 17987 char *save_timeout;; 17988 char *new_timeout;; 17989 ; 17990 if (ebuf_len > 0) {; 17991 ebuf[0] = '\0';; 17992 }; 17993 ; 17994 if (!conn) {; 17995 mg_snprintf(conn,; 17996 NULL, /* No truncation check for ebuf */; 17997 ebuf,; 17998 ebuf_len,; 17999 ""%s"",; 18000 ""Parameter error"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 1802",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:550326,Safety,timeout,timeout,550326,"and; 18514 * conn->phys_ctx must be valid).; 18515 */; 18516static void; 18517process_new_connection(struct mg_connection *conn); 18518{; 18519 struct mg_request_info *ri = &conn->request_info;; 18520 int keep_alive, discard_len;; 18521 char ebuf[100];; 18522 const char *hostend;; 18523 int reqerr, uri_type;; 18524 ; 18525#if defined(USE_SERVER_STATS); 18526 ptrdiff_t mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));; 18527 mg_atomic_add(&(conn->phys_ctx->total_connections), 1);; 18528 mg_atomic_max(&(conn->phys_ctx->max_active_connections), mcon);; 18529#endif; 18530 ; 18531 DEBUG_TRACE(""Start processing connection from %s"",; 18532 conn->request_info.remote_addr);; 18533 ; 18534 /* Loop over multiple requests sent using the same connection; 18535 * (while ""keep alive""). */; 18536 do {; 18537 DEBUG_TRACE(""calling get_request (%i times for this connection)"",; 18538 conn->handled_requests + 1);; 18539 ; 18540#if defined(USE_SERVER_STATS); 18541 conn->conn_state = 3; /* ready */; 18542#endif; 18543 ; 18544 if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {; 18545 /* The request sent by the client could not be understood by; 18546 * the server, or it was incomplete or a timeout. Send an; 18547 * error message and close the connection. */; 18548 if (reqerr > 0) {; 18549 DEBUG_ASSERT(ebuf[0] != '\0');; 18550 mg_send_http_error(conn, reqerr, ""%s"", ebuf);; 18551 }; 18552 ; 18553 } else if (strcmp(ri->http_version, ""1.0""); 18554 && strcmp(ri->http_version, ""1.1"")) {; 18555 /* HTTP/2 is not allowed here */; 18556 mg_snprintf(conn,; 18557 NULL, /* No truncation check for ebuf */; 18558 ebuf,; 18559 sizeof(ebuf),; 18560 ""Bad HTTP version: [%s]"",; 18561 ri->http_version);; 18562 mg_send_http_error(conn, 505, ""%s"", ebuf);; 18563 }; 18564 ; 18565 if (ebuf[0] == '\0') {; 18566 uri_type = get_uri_type(conn->request_info.request_uri);; 18567 switch (uri_type) {; 18568 case 1:; 18569 /* Asterisk */; 18570 conn->request_info.local_uri_raw = 0;; 18571 /* TODO: Deal with '",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:576190,Safety,avoid,avoid,576190," 0) {; 19284 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19285 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19286 * successful poll, and POLLIN is defined as; 19287 * (POLLRDNORM | POLLRDBAND); 19288 * Therefore, we're checking pfd[i].revents & POLLIN, not; 19289 * pfd[i].revents == POLLIN. */; 19290 if (STOP_FLAG_IS_ZERO(&ctx->stop_flag); 19291 && (pfd[i].revents & POLLIN)) {; 19292 accept_new_connection(&ctx->listening_sockets[i], ctx);; 19293 }; 19294 }; 19295 }; 19296 }; 19297 ; 19298 /* Here stop_flag is 1 - Initiate shutdown. */; 19299 DEBUG_TRACE(""%s"", ""stopping workers"");; 19300 ; 19301 /* Stop signal received: somebody called mg_stop. Quit. */; 19302 close_all_listening_sockets(ctx);; 19303 ; 19304 /* Wakeup workers that are waiting for connections to handle. */; 19305#if defined(ALTERNATIVE_QUEUE); 19306 for (i = 0; i < ctx->cfg_worker_threads; i++) {; 19307 event_signal(ctx->client_wait_events[i]);; 19308 }; 19309#else; 19310 (void)pthread_mutex_lock(&ctx->thread_mutex);; 19311 pthread_cond_broadcast(&ctx->sq_full);; 19312 (void)pthread_mutex_unlock(&ctx->thread_mutex);; 19313#endif; 19314 ; 19315 /* Join all worker threads to avoid leaking threads. */; 19316 workerthreadcount = ctx->cfg_worker_threads;; 19317 for (i = 0; i < workerthreadcount; i++) {; 19318 if (ctx->worker_threadids[i] != 0) {; 19319 mg_join_thread(ctx->worker_threadids[i]);; 19320 }; 19321 }; 19322 ; 19323#if defined(USE_LUA); 19324 /* Free Lua state of lua background task */; 19325 if (ctx->lua_background_state) {; 19326 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19327 ctx->lua_bg_log_available = 0;; 19328 ; 19329 /* call ""stop()"" in Lua */; 19330 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19331 lua_getglobal(lstate, ""stop"");; 19332 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19333 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19334 if (ret != 0) {; 19335 struct mg_connection fc;; 19336 lua_cry(fake_connection(&fc, ctx),; 19337 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:587356,Safety,abort,abort,587356,"9660 }; 19661 return NULL;; 19662 }; 19663 ; 19664 /* Random number generator will initialize at the first call */; 19665 ctx->dd.auth_nonce_mask =; 19666 (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);; 19667 ; 19668 /* Save started thread index to reuse in other external API calls; 19669 * For the sake of thread synchronization all non-civetweb threads; 19670 * can be considered as single external thread */; 19671 ctx->starter_thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 19672 tls.is_master = -1; /* Thread calling mg_start */; 19673 tls.thread_idx = ctx->starter_thread_idx;; 19674#if defined(_WIN32); 19675 tls.pthread_cond_helper_mutex = NULL;; 19676#endif; 19677 pthread_setspecific(sTlsKey, &tls);; 19678 ; 19679 ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));; 19680#if !defined(ALTERNATIVE_QUEUE); 19681 ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));; 19682 ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));; 19683 ctx->sq_blocked = 0;; 19684#endif; 19685 ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));; 19686#if defined(USE_LUA); 19687 ok &= (0 == pthread_mutex_init(&ctx->lua_bg_mutex, &pthread_mutex_attr));; 19688#endif; 19689 if (!ok) {; 19690 const char *err_msg =; 19691 ""Cannot initialize thread synchronization objects"";; 19692 /* Fatal error - abort start. However, this situation should never; 19693 * occur in practice. */; 19694 ; 19695 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19696 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19697 mg_snprintf(NULL,; 19698 NULL, /* No truncation check for error buffers */; 19699 error->text,; 19700 error->text_buffer_size,; 19701 ""%s"",; 19702 err_msg);; 19703 }; 19704 ; 19705 mg_free(ctx);; 19706 pthread_setspecific(sTlsKey, NULL);; 19707 return NULL;; 19708 }; 19709 ; 19710 if ((init != NULL) && (init->callbacks != NULL)) {; 19711 /* Set all callbacks except exit_context. */; 19712 ctx->callbacks = *init->callbacks;; 19713 exit_callba",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596727,Safety,abort,abort,596727,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597313,Safety,abort,abort,597313,",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snpri",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:597882,Safety,abort,abort,597882,"(!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:598431,Safety,abort,abort,598431,"ned(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19992 mg_snprintf(NULL,; 19993 NULL, /* No truncation check for error buffers */; 19994 error->text,; 19995 error->text_buffer_size,; 19996 ""%s"",; 19997 err_msg);; 19998 }; 19999 free_context(ctx);; 20000 pthread_setspecific(sTlsKey, NULL);; 20001 return NULL;; 20002 }; 20003 ; 20004#elif !defined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599028,Safety,abort,abort,599028,"efined(NO_SSL); 20005 if (!init_ssl_ctx(ctx, NULL)) {; 20006 const char *err_msg = ""Error initializing SSL context"";; 20007 /* Fatal error - abort start. */; 20008 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20009 ; 20010 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20011 mg_snprintf(NULL,; 20012 NULL, /* No truncation check for error buffers */; 20013 error->text,; 20014 error->text_buffer_size,; 20015 ""%s"",; 20016 err_msg);; 20017 }; 20018 free_context(ctx);; 20019 pthread_setspecific(sTlsKey, NULL);; 20020 return NULL;; 20021 }; 20022#endif; 20023 ; 20024 if (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599582,Safety,abort,abort,599582,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:636648,Safety,safe,safe,636648,"ntf(NULL,; 21332 NULL,; 21333 block,; 21334 sizeof(block),; 21335 ""%s%s\""data\"" : {%s""; 21336 ""\""read\"" : %"" INT64_FMT "",%s""; 21337 ""\""written\"" : %"" INT64_FMT ""%s""; 21338 ""}"",; 21339 (connection_info_length > 1 ? "","" : """"),; 21340 eol,; 21341 eol,; 21342 conn->consumed_content,; 21343 eol,; 21344 conn->num_bytes_sent,; 21345 eol);; 21346 connection_info_length += mg_str_append(&buffer, end, block);; 21347 }; 21348 ; 21349 /* State */; 21350 mg_snprintf(NULL,; 21351 NULL,; 21352 block,; 21353 sizeof(block),; 21354 ""%s%s\""state\"" : \""%s\"""",; 21355 (connection_info_length > 1 ? "","" : """"),; 21356 eol,; 21357 state_str);; 21358 connection_info_length += mg_str_append(&buffer, end, block);; 21359 ; 21360 /* Terminate string */; 21361 if (append_eoobj) {; 21362 strcat(append_eoobj, eoobj);; 21363 }; 21364 connection_info_length += sizeof(eoobj) - 1;; 21365 ; 21366 return (int)connection_info_length;; 21367}; 21368#endif; 21369 ; 21370 ; 21371/* Initialize this library. This function does not need to be thread safe.; 21372 */; 21373unsigned; 21374mg_init_library(unsigned features); 21375{; 21376 unsigned features_to_init = mg_check_feature(features & 0xFFu);; 21377 unsigned features_inited = features_to_init;; 21378 ; 21379 if (mg_init_library_called <= 0) {; 21380 /* Not initialized yet */; 21381 if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {; 21382 return 0;; 21383 }; 21384 }; 21385 ; 21386 mg_global_lock();; 21387 ; 21388 if (mg_init_library_called <= 0) {; 21389#if defined(_WIN32); 21390 int file_mutex_init = 1;; 21391 int wsa = 1;; 21392#else; 21393 int mutexattr_init = 1;; 21394#endif; 21395 int failed = 1;; 21396 int key_create = pthread_key_create(&sTlsKey, tls_dtor);; 21397 ; 21398 if (key_create == 0) {; 21399#if defined(_WIN32); 21400 file_mutex_init =; 21401 pthread_mutex_init(&global_log_file_lock, &pthread_mutex_attr);; 21402 if (file_mutex_init == 0) {; 21403 /* Start WinSock */; 21404 WSADATA data;; 21405 failed = wsa = WSAStartup(MAKEWORD(2, 2), &",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:659544,Safety,timeout,timeout,659544,"finition civetweb.c:486; parse_http_headersstatic int parse_http_headers(char **buf, struct mg_header hdr[(64)])Definition civetweb.c:10421; mg_get_option#define mg_get_optionDefinition civetweb.c:3150; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16231; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3167; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10318; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18032; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20560; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6185; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17980; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1852; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17217; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20497; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6469; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4351; mg_startstruct m",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:659729,Safety,timeout,timeout,659729,"civetweb.c:3150; ssl_get_protocolstatic long ssl_get_protocol(int version_id)Definition civetweb.c:16231; mg_get_user_context_datavoid * mg_get_user_context_data(const struct mg_connection *conn)Definition civetweb.c:3167; mg_init_library_calledstatic int mg_init_library_calledDefinition civetweb.c:1549; mg_store_bodylong long mg_store_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10318; mg_downloadstruct mg_connection * mg_download(const char *host, int port, int use_ssl, char *ebuf, size_t ebuf_len, const char *fmt,...)Definition civetweb.c:18032; DEBUG_ASSERT#define DEBUG_ASSERT(cond)Definition civetweb.c:260; mg_str_appendstatic size_t mg_str_append(char **dst, char *end, const char *src)Definition civetweb.c:20560; pull_innerstatic int pull_inner(FILE *fp, struct mg_connection *conn, char *buf, int len, double timeout)Definition civetweb.c:6185; INT64_FMT#define INT64_FMTDefinition civetweb.c:923; mg_get_responseint mg_get_response(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int timeout)Definition civetweb.c:17980; MG_FILE_COMPRESSION_SIZE_LIMIT#define MG_FILE_COMPRESSION_SIZE_LIMITDefinition civetweb.c:476; USA_IN_PORT_UNSAFE#define USA_IN_PORT_UNSAFE(s)Definition civetweb.c:1852; mg_connect_client_implstatic struct mg_connection * mg_connect_client_impl(const struct mg_client_options *client_options, int use_ssl, char *ebuf, size_t ebuf_len)Definition civetweb.c:17217; mg_check_featureunsigned mg_check_feature(unsigned feature)Definition civetweb.c:20497; mg_read_innerstatic int mg_read_inner(struct mg_connection *conn, void *buf, size_t len)Definition civetweb.c:6469; mg_send_http_error_implstatic int mg_send_http_error_impl(struct mg_connection *conn, int status, const char *fmt, va_list args)Definition civetweb.c:4351; mg_startstruct mg_context * mg_start(const struct mg_callbacks *callbacks, void *user_data, const char **options)Definition civetweb.c:20285; MG_FOPEN_MODE_READ#define MG_FOPEN_MODE_READDefinition civetw",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:689688,Safety,timeout,timeout,689688,"RPRETER@ CGI2_INTERPRETERDefinition civetweb.c:1961; INDEX_FILES@ INDEX_FILESDefinition civetweb.c:1992; EXTRA_MIME_TYPES@ EXTRA_MIME_TYPESDefinition civetweb.c:1994; initialize_opensslstatic int initialize_openssl(char *ebuf, size_t ebuf_len)Definition civetweb.c:16035; substitute_index_filestatic int substitute_index_file(struct mg_connection *conn, char *path, size_t path_len, struct mg_file_stat *filestat)Definition civetweb.c:7390; mg_stopvoid mg_stop(struct mg_context *ctx)Definition civetweb.c:19494; STRUCT_FILE_INITIALIZER#define STRUCT_FILE_INITIALIZERDefinition civetweb.c:1883; thread_idx_maxstatic volatile ptrdiff_t thread_idx_maxDefinition civetweb.c:1573; mg_get_user_datavoid * mg_get_user_data(const struct mg_context *ctx)Definition civetweb.c:3160; scan_directorystatic int scan_directory(struct mg_connection *conn, const char *dir, void *data, int(*cb)(struct de *, void *))Definition civetweb.c:9450; push_innerstatic int push_inner(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len, double timeout)Definition civetweb.c:5971; mg_versionconst char * mg_version(void)Definition civetweb.c:3481; get_randomstatic uint64_t get_random(void)Definition civetweb.c:5880; mg_lock_connectionvoid mg_lock_connection(struct mg_connection *conn)Definition civetweb.c:12307; mg_send_file_bodyint mg_send_file_body(struct mg_connection *conn, const char *path)Definition civetweb.c:10147; mg_cry#define mg_cryDefinition civetweb.c:3477; is_valid_http_methodstatic int is_valid_http_method(const char *method)Definition civetweb.c:10590; url_decode_in_placestatic void url_decode_in_place(char *buf)Definition civetweb.c:6983; civetweb.h; mg_websocket_client_writeint mg_websocket_client_write(struct mg_connection *conn, int opcode, const char *data, size_t data_len); MG_MAX_HEADERS#define MG_MAX_HEADERSDefinition civetweb.h:141; mg_response_header_addint mg_response_header_add(struct mg_connection *conn, const char *header, const char *value, int va",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:3527,Security,expose,expose,3527,"ARNINGS /* Disable deprecation warning in VS2005 */; 51#endif; 52#if !defined(_WIN32_WINNT) /* defined for tdm-gcc so we can use getnameinfo */; 53#define _WIN32_WINNT 0x0502; 54#endif; 55#else; 56#if !defined(_GNU_SOURCE); 57#define _GNU_SOURCE /* for setgroups(), pthread_setname_np() */; 58#endif; 59#if defined(__linux__) && !defined(_XOPEN_SOURCE); 60#define _XOPEN_SOURCE 600 /* For flockfile() on Linux */; 61#endif; 62#if defined(__LSB_VERSION__) || defined(__sun); 63#define NEED_TIMEGM; 64#define NO_THREAD_NAME; 65#endif; 66#if !defined(_LARGEFILE_SOURCE); 67#define _LARGEFILE_SOURCE /* For fseeko(), ftello() */; 68#endif; 69#if !defined(_FILE_OFFSET_BITS); 70#define _FILE_OFFSET_BITS 64 /* Use 64-bit file offsets by default */; 71#endif; 72#if !defined(__STDC_FORMAT_MACROS); 73#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */; 74#endif; 75#if !defined(__STDC_LIMIT_MACROS); 76#define __STDC_LIMIT_MACROS /* C++ wants that for INT64_MAX */; 77#endif; 78#if !defined(_DARWIN_UNLIMITED_SELECT); 79#define _DARWIN_UNLIMITED_SELECT; 80#endif; 81#if defined(__sun); 82#define __EXTENSIONS__ /* to expose flockfile and friends in stdio.h */; 83#define __inline inline /* not recognized on older compiler versions */; 84#endif; 85#endif; 86 ; 87#if defined(__clang__); 88/* Enable reserved-id-macro warning again. */; 89#pragma GCC diagnostic pop; 90#endif; 91 ; 92 ; 93#if defined(USE_LUA); 94#define USE_TIMERS; 95#endif; 96 ; 97#if defined(_MSC_VER); 98/* 'type cast' : conversion from 'int' to 'HANDLE' of greater size */; 99#pragma warning(disable : 4306); 100/* conditional expression is constant: introduced by FD_SET(..) */; 101#pragma warning(disable : 4127); 102/* non-constant aggregate initializer: issued due to missing C99 support */; 103#pragma warning(disable : 4204); 104/* padding added after data member */; 105#pragma warning(disable : 4820); 106/* not defined as a preprocessor macro, replacing with '0' for '#if/#elif' */; 107#pragma warning(disable :",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:6435,Security,access,access,6435,"zeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if le",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:6591,Security,access,access,6591,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:6884,Security,access,access,6884,"eads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""Symbian is no longer maintained. CivetWeb no longer supports Symbian.""; 182#endif /* __SYMBIAN32__ */; 183 ; 184#if defined(__ZEPHYR__); 185#include <time.h>; 186 ; 187#include <ctype.h>; 188#include <net/socket.h>; 189#include <posix/pthread",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:21922,Security,access,access,21922,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:57260,Security,access,access,57260,"{; 1839 if (s->sa.sa_family == AF_INET); 1840 return s->sin.sin_port;; 1841#if defined(USE_IPV6); 1842 if (s->sa.sa_family == AF_INET6); 1843 return s->sin6.sin6_port;; 1844#endif; 1845 return 0;; 1846}; 1847#endif; 1848#if defined(USE_IPV6); 1849#define USA_IN_PORT_UNSAFE(s) \; 1850 (((s)->sa.sa_family == AF_INET6) ? (s)->sin6.sin6_port : (s)->sin.sin_port); 1851#else; 1852#define USA_IN_PORT_UNSAFE(s) ((s)->sin.sin_port); 1853#endif; 1854 ; 1855/* Describes a string (chunk of memory). */; 1856struct vec {; 1857 const char *ptr;; 1858 size_t len;; 1859};; 1860 ; 1861struct mg_file_stat {; 1862 /* File properties filled by mg_stat: */; 1863 uint64_t size;; 1864 time_t last_modified;; 1865 int is_directory; /* Set to 1 if mg_stat is called for a directory */; 1866 int is_gzipped; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:68655,Security,authoriz,authorization,68655,", MG_CONFIG_TYPE_DIRECTORY, NULL},; 2188#if !defined(NO_CACHING); 2189 {""static_file_max_age"", MG_CONFIG_TYPE_NUMBER, ""3600""},; 2190 {""static_file_cache_control"", MG_CONFIG_TYPE_STRING, NULL},; 2191#endif; 2192#if !defined(NO_SSL); 2193 {""strict_transport_security_max_age"", MG_CONFIG_TYPE_NUMBER, NULL},; 2194#endif; 2195 {""additional_header"", MG_CONFIG_TYPE_STRING_MULTILINE, NULL},; 2196 {""allow_index_script_resource"", MG_CONFIG_TYPE_BOOLEAN, ""no""},; 2197 ; 2198 {NULL, MG_CONFIG_TYPE_UNKNOWN, NULL}};; 2199 ; 2200 ; 2201/* Check if the config_options and the corresponding enum have compatible; 2202 * sizes. */; 2203mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2204 == (NUM_OPTIONS + 1),; 2205 ""config_options and enum not sync"");; 2206 ; 2207 ; 2208enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2209 ; 2210 ; 2211struct mg_handler_info {; 2212 /* Name/Pattern of the URI. */; 2213 char *uri;; 2214 size_t uri_len;; 2215 ; 2216 /* handler type */; 2217 int handler_type;; 2218 ; 2219 /* Handler for http/https or authorization requests. */; 2220 mg_request_handler handler;; 2221 unsigned int refcount;; 2222 int removing;; 2223 ; 2224 /* Handler for ws/wss (websocket) requests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:69163,Security,authoriz,authorization,69163,"patible; 2202 * sizes. */; 2203mg_static_assert((sizeof(config_options) / sizeof(config_options[0])); 2204 == (NUM_OPTIONS + 1),; 2205 ""config_options and enum not sync"");; 2206 ; 2207 ; 2208enum { REQUEST_HANDLER, WEBSOCKET_HANDLER, AUTH_HANDLER };; 2209 ; 2210 ; 2211struct mg_handler_info {; 2212 /* Name/Pattern of the URI. */; 2213 char *uri;; 2214 size_t uri_len;; 2215 ; 2216 /* handler type */; 2217 int handler_type;; 2218 ; 2219 /* Handler for http/https or authorization requests. */; 2220 mg_request_handler handler;; 2221 unsigned int refcount;; 2222 int removing;; 2223 ; 2224 /* Handler for ws/wss (websocket) requests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:69969,Security,authenticat,authentication,69969,"equests. */; 2225 mg_websocket_connect_handler connect_handler;; 2226 mg_websocket_ready_handler ready_handler;; 2227 mg_websocket_data_handler data_handler;; 2228 mg_websocket_close_handler close_handler;; 2229 ; 2230 /* accepted subprotocols for ws/wss requests. */; 2231 struct mg_websocket_subprotocols *subprotocols;; 2232 ; 2233 /* Handler for authorization requests */; 2234 mg_authorization_handler auth_handler;; 2235 ; 2236 /* User supplied argument for the handler function. */; 2237 void *cbdata;; 2238 ; 2239 /* next handler in a linked list */; 2240 struct mg_handler_info *next;; 2241};; 2242 ; 2243 ; 2244enum {; 2245 CONTEXT_INVALID,; 2246 CONTEXT_SERVER,; 2247 CONTEXT_HTTP_CLIENT,; 2248 CONTEXT_WS_CLIENT; 2249};; 2250 ; 2251 ; 2252struct mg_domain_context {; 2253 SSL_CTX *ssl_ctx; /* SSL context */; 2254 char *config[NUM_OPTIONS]; /* Civetweb configuration parameters */; 2255 struct mg_handler_info *handlers; /* linked list of uri handlers */; 2256 int64_t ssl_cert_last_mtime;; 2257 ; 2258 /* Server nonce */; 2259 uint64_t auth_nonce_mask; /* Mask for all nonce values */; 2260 unsigned long nonce_count; /* Used nonces, used for authentication */; 2261 ; 2262#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2263 /* linked list of shared lua websockets */; 2264 struct mg_shared_lua_websocket_list *shared_lua_websockets;; 2265#endif; 2266 ; 2267 /* Linked list of domains */; 2268 struct mg_domain_context *next;; 2269};; 2270 ; 2271 ; 2272/* Stop flag can be ""volatile"" or require a lock.; 2273 * MSDN uses volatile for ""Interlocked"" operations, but also explicitly; 2274 * states a read operation for int is always atomic. */; 2275#if defined(STOP_FLAG_NEEDS_LOCK); 2276 ; 2277typedef ptrdiff_t volatile stop_flag_t;; 2278 ; 2279static int; 2280STOP_FLAG_IS_ZERO(stop_flag_t *f); 2281{; 2282 stop_flag_t sf = mg_atomic_add(f, 0);; 2283 return (sf == 0);; 2284}; 2285 ; 2286static int; 2287STOP_FLAG_IS_TWO(stop_flag_t *f); 2288{; 2289 stop_flag_t sf = mg_atomic_add(f, 0);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:73821,Security,authenticat,authentication,73821,";; 2337#endif; 2338 ; 2339 /* Thread related */; 2340 stop_flag_t stop_flag; /* Should we stop event loop */; 2341 pthread_mutex_t thread_mutex; /* Protects client_socks or queue */; 2342 ; 2343 pthread_t masterthreadid; /* The master thread ID */; 2344 unsigned int; 2345 cfg_worker_threads; /* The number of configured worker threads. */; 2346 pthread_t *worker_threadids; /* The worker thread IDs */; 2347 unsigned long starter_thread_idx; /* thread index which called mg_start */; 2348 ; 2349 /* Connection to thread dispatching */; 2350#if defined(ALTERNATIVE_QUEUE); 2351 struct socket *client_socks;; 2352 void **client_wait_events;; 2353#else; 2354 struct socket *squeue; /* Socket queue (sq) : accepted sockets waiting for a; 2355 worker thread */; 2356 volatile int sq_head; /* Head of the socket queue */; 2357 volatile int sq_tail; /* Tail of the socket queue */; 2358 pthread_cond_t sq_full; /* Signaled when socket is produced */; 2359 pthread_cond_t sq_empty; /* Signaled when socket is consumed */; 2360 volatile int sq_blocked; /* Status information: sq is full */; 2361 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:74246,Security,access,access,74246,"61 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_log_available; /* Use Lua background state for access log */; 2388#endif; 2389 ; 2390 /* Server nonce */; 2391 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2392 * ssl_cert_last_mtime, nonce_count, and; 2393 * next (linked list) */; 2394 ; 2395 /* Server callbacks */; 2396 struct mg_callbacks callbacks; /* User-defined callback function */; 2397 void *user_data; /* User-defined data */; 2398 ; 2399 /* Part 2 - Logical domain:; 2400 * This holds hostname, TLS certificate, document root, ...; 2401 * set for a domain hosted at the server.; 2402 * There may be multiple domains hosted at one physical server.; 2403 * The default domain ""dd"" is the first element of a list of; 2404 * domains.; 2405 */; 2406 struct mg_domain_context dd; /* default domain */; 2407};; 2408 ; 2409 ; 2410#if defined(USE_SERVER_STATS); 2411static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2412 ; 2413static struct mg_memory_stat *; 2414get_memory_stat(struct mg_context *ctx); 2415{; 2416 if (ctx) {; 2417 return &(ctx->ctx_memory);; 2418 }; 2419 return &mg_common_memory;; 2420}",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:74677,Security,certificate,certificate,74677,"61 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_log_available; /* Use Lua background state for access log */; 2388#endif; 2389 ; 2390 /* Server nonce */; 2391 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2392 * ssl_cert_last_mtime, nonce_count, and; 2393 * next (linked list) */; 2394 ; 2395 /* Server callbacks */; 2396 struct mg_callbacks callbacks; /* User-defined callback function */; 2397 void *user_data; /* User-defined data */; 2398 ; 2399 /* Part 2 - Logical domain:; 2400 * This holds hostname, TLS certificate, document root, ...; 2401 * set for a domain hosted at the server.; 2402 * There may be multiple domains hosted at one physical server.; 2403 * The default domain ""dd"" is the first element of a list of; 2404 * domains.; 2405 */; 2406 struct mg_domain_context dd; /* default domain */; 2407};; 2408 ; 2409 ; 2410#if defined(USE_SERVER_STATS); 2411static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2412 ; 2413static struct mg_memory_stat *; 2414get_memory_stat(struct mg_context *ctx); 2415{; 2416 if (ctx) {; 2417 return &(ctx->ctx_memory);; 2418 }; 2419 return &mg_common_memory;; 2420}",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:79658,Security,access,access,79658,"deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2553 ; 2554static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2555 struct mg_context *ctx,; 2556 const char *func,; 2557 unsigned line,; 2558 const char *fmt,; 2559 ...) PRINTF_ARGS(5, 6);; 2560 ; 2561 ; 2562#if !defined(NO_THREAD_NAME); 2563#if defined(_WIN32) && defined(_MSC_VER); 2564/* Set the thread name for debugging purposes in Visual Studio; 2565 * http://msdn.microsoft.com/",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:86287,Security,access,access,86287,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:88374,Security,access,access,88374,"; 2845 ; 2846#if defined(_WIN32); 2847 while (*c) {; 2848 if (*c < 32) {; 2849 /* Control character */; 2850 return 1;; 2851 }; 2852 if ((*c == '>') || (*c == '<') || (*c == '|')) {; 2853 /* stdin/stdout redirection character */; 2854 return 1;; 2855 }; 2856 if ((*c == '*') || (*c == '?')) {; 2857 /* Wildcard character */; 2858 return 1;; 2859 }; 2860 if (*c == '""') {; 2861 /* Windows quotation */; 2862 return 1;; 2863 }; 2864 c++;; 2865 }; 2866#endif; 2867 ; 2868 /* Nothing suspicious found */; 2869 return 0;; 2870}; 2871 ; 2872 ; 2873/* mg_fopen will open a file either in memory or on the disk.; 2874 * The input parameter path is a string in UTF-8 encoding.; 2875 * The input parameter mode is MG_FOPEN_MODE_*; 2876 * On success, fp will be set in the output struct mg_file.; 2877 * All status members will also be set.; 2878 * The function returns 1 on success, 0 on error. */; 2879static int; 2880mg_fopen(const struct mg_connection *conn,; 2881 const char *path,; 2882 int mode,; 2883 struct mg_file *filep); 2884{; 2885 int found;; 2886 ; 2887 if (!filep) {; 2888 return 0;; 2889 }; 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 29",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89003,Security,access,access,89003," c++;; 2865 }; 2866#endif; 2867 ; 2868 /* Nothing suspicious found */; 2869 return 0;; 2870}; 2871 ; 2872 ; 2873/* mg_fopen will open a file either in memory or on the disk.; 2874 * The input parameter path is a string in UTF-8 encoding.; 2875 * The input parameter mode is MG_FOPEN_MODE_*; 2876 * On success, fp will be set in the output struct mg_file.; 2877 * All status members will also be set.; 2878 * The function returns 1 on success, 0 on error. */; 2879static int; 2880mg_fopen(const struct mg_connection *conn,; 2881 const char *path,; 2882 int mode,; 2883 struct mg_file *filep); 2884{; 2885 int found;; 2886 ; 2887 if (!filep) {; 2888 return 0;; 2889 }; 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before f",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89095,Security,access,access,89095,"* All status members will also be set.; 2878 * The function returns 1 on success, 0 on error. */; 2879static int; 2880mg_fopen(const struct mg_connection *conn,; 2881 const char *path,; 2882 int mode,; 2883 struct mg_file *filep); 2884{; 2885 int found;; 2886 ; 2887 if (!filep) {; 2888 return 0;; 2889 }; 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 29",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89188,Security,access,access,89188,". */; 2879static int; 2880mg_fopen(const struct mg_connection *conn,; 2881 const char *path,; 2882 int mode,; 2883 struct mg_file *filep); 2884{; 2885 int found;; 2886 ; 2887 if (!filep) {; 2888 return 0;; 2889 }; 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != N",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89393,Security,access,access,89393," 2890 filep->access.fp = NULL;; 2891 ; 2892 if (mg_path_suspicious(conn, path)) {; 2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /*",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89481,Security,access,access,89481,"2893 return 0;; 2894 }; 2895 ; 2896 /* filep is initialized in mg_stat: all fields with memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /* NO_FILESYSTEMS */; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89570,Security,access,access,89570,"memset to,; 2897 * some fields like size and modification date with values */; 2898 found = mg_stat(conn, path, &(filep->stat));; 2899 ; 2900 if ((mode == MG_FOPEN_MODE_READ) && (!found)) {; 2901 /* file does not exist and will not be created */; 2902 return 0;; 2903 }; 2904 ; 2905#if defined(_WIN32); 2906 {; 2907 wchar_t wbuf[UTF16_PATH_MAX];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /* NO_FILESYSTEMS */; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const char *src, size_t n); 2968{; 2969 for (; *src != '\0' && n > 1; n--) {; 2970 *dst++ = *s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:89947,Security,access,access,89947,"];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /* NO_FILESYSTEMS */; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const char *src, size_t n); 2968{; 2969 for (; *src != '\0' && n > 1; n--) {; 2970 *dst++ = *src++;; 2971 }; 2972 *dst = '\0';; 2973}; 2974 ; 2975 ; 2976static int; 2977lowercase(const char *s); 2978{; 2979 return tolower((unsigned char)*s);; 2980}; 2981 ; 2982 ; 2983int; 2984mg_strncasecmp(const char *s1, const char *s2, size_t len); 2985{; 2986 int diff = 0;; 2987 ; 2988 if (len > 0) {; 2989 do {; 2990 diff = lowercase(s1++) - lowe",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:95167,Security,access,access,95167,"urn i;; 3131 }; 3132 }; 3133 return -1;; 3134}; 3135 ; 3136 ; 3137const char *; 3138mg_get_option(const struct mg_context *ctx, const char *name); 3139{; 3140 int i;; 3141 if ((i = get_option_index(name)) == -1) {; 3142 return NULL;; 3143 } else if (!ctx || ctx->dd.config[i] == NULL) {; 3144 return """";; 3145 } else {; 3146 return ctx->dd.config[i];; 3147 }; 3148}; 3149 ; 3150#define mg_get_option DO_NOT_USE_THIS_FUNCTION_INTERNALLY__access_directly; 3151 ; 3152struct mg_context *; 3153mg_get_context(const struct mg_connection *conn); 3154{; 3155 return (conn == NULL) ? (struct mg_context *)NULL : (conn->phys_ctx);; 3156}; 3157 ; 3158 ; 3159void *; 3160mg_get_user_data(const struct mg_context *ctx); 3161{; 3162 return (ctx == NULL) ? NULL : ctx->user_data;; 3163}; 3164 ; 3165 ; 3166void *; 3167mg_get_user_context_data(const struct mg_connection *conn); 3168{; 3169 return mg_get_user_data(mg_get_context(conn));; 3170}; 3171 ; 3172 ; 3173void *; 3174mg_get_thread_pointer(const struct mg_connection *conn); 3175{; 3176 /* both methods should return the same pointer */; 3177 if (conn) {; 3178 /* quick access, in case conn is known */; 3179 return conn->tls_user_ptr;; 3180 } else {; 3181 /* otherwise get pointer from thread local storage (TLS) */; 3182 struct mg_workerTLS *tls =; 3183 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 3184 return tls->user_ptr;; 3185 }; 3186}; 3187 ; 3188 ; 3189void; 3190mg_set_user_connection_data(const struct mg_connection *const_conn, void *data); 3191{; 3192 if (const_conn != NULL) {; 3193 /* Const cast, since ""const struct mg_connection *"" does not mean; 3194 * the connection object is not modified. Here ""const"" is used,; 3195 * to indicate mg_read/mg_write/mg_send/.. must not be called. */; 3196 struct mg_connection *conn = (struct mg_connection *)const_conn;; 3197 conn->request_info.conn_data = data;; 3198 }; 3199}; 3200 ; 3201 ; 3202void *; 3203mg_get_user_connection_data(const struct mg_connection *conn); 3204{; 3205 if (conn !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101091,Security,access,access,101091,";; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101141,Security,access,access,101141,"agma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101187,Security,access,access,101187,"nostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101227,Security,access,access,101227,"66#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101366,Security,access,access,101366," GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101544,Security,access,access,101544,"puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101734,Security,access,access,101734,"ame way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *f",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101778,Security,access,access,101778,"n->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 345",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101806,Security,access,access,101806,"essage == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101839,Security,access,access,101839,"hys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct m",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:101877,Security,access,access,101877," {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct mg_connection fc;; 3459 mg_cry_internal_impl(fak",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:163019,Security,access,access,163019," for additional arguments; 5495 */; 5496 interp_arg =; 5497 conn->dom_ctx->config[CGI_INTERPRETER_ARGS + cgi_config_idx];; 5498 } else {; 5499 /* Otherwise, the interpreter must be stated in the first line of the; 5500 * CGI script file, after a #! (shebang) mark. */; 5501 buf[0] = buf[1] = '\0';; 5502 ; 5503 /* Get the full script path */; 5504 mg_snprintf(; 5505 conn, &truncated, cmdline, sizeof(cmdline), ""%s/%s"", dir, prog);; 5506 ; 5507 if (truncated) {; 5508 pi.hProcess = (pid_t)-1;; 5509 goto spawn_cleanup;; 5510 }; 5511 ; 5512 /* Open the script file, to read the first line */; 5513 if (mg_fopen(conn, cmdline, MG_FOPEN_MODE_READ, &file)) {; 5514 ; 5515 /* Read the first line of the script into the buffer */; 5516 mg_fgets(buf, sizeof(buf), &file);; 5517 (void)mg_fclose(&file.access); /* ignore error on read only file */; 5518 buf[sizeof(buf) - 1] = '\0';; 5519 }; 5520 ; 5521 if ((buf[0] == '#') && (buf[1] == '!')) {; 5522 trim_trailing_whitespaces(buf + 2);; 5523 } else {; 5524 buf[2] = '\0';; 5525 }; 5526 interp = buf + 2;; 5527 }; 5528 ; 5529 GetFullPathNameA(dir, sizeof(full_dir), full_dir, NULL);; 5530 ; 5531 if (interp[0] != '\0') {; 5532 /* This is an interpreted script file. We must call the interpreter. */; 5533 if ((interp_arg != 0) && (interp_arg[0] != 0)) {; 5534 mg_snprintf(conn,; 5535 &truncated,; 5536 cmdline,; 5537 sizeof(cmdline),; 5538 ""\""%s\"" %s \""%s\\%s\"""",; 5539 interp,; 5540 interp_arg,; 5541 full_dir,; 5542 prog);; 5543 } else {; 5544 mg_snprintf(conn,; 5545 &truncated,; 5546 cmdline,; 5547 sizeof(cmdline),; 5548 ""\""%s\"" \""%s\\%s\"""",; 5549 interp,; 5550 full_dir,; 5551 prog);; 5552 }; 5553 } else {; 5554 /* This is (probably) a compiled program. We call it directly. */; 5555 mg_snprintf(conn,; 5556 &truncated,; 5557 cmdline,; 5558 sizeof(cmdline),; 5559 ""\""%s\\%s\"""",; 5560 full_dir,; 5561 prog);; 5562 }; 5563 ; 5564 if (truncated) {; 5565 pi.hProcess = (pid_t)-1;; 5566 goto spawn_cleanup;; 5567 }; 5568 ; 5569 DEBUG_TRACE(""Running [%s]"", ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:190307,Security,access,access,190307,"ed_len = len64;; 6507 }; 6508 body = conn->buf + conn->request_len + conn->consumed_content;; 6509 memcpy(buf, body, (size_t)buffered_len);; 6510 len64 -= buffered_len;; 6511 conn->consumed_content += buffered_len;; 6512 nread += buffered_len;; 6513 buf = (char *)buf + buffered_len;; 6514 }; 6515 ; 6516 /* We have returned all buffered data. Read new data from the remote; 6517 * socket.; 6518 */; 6519 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6520 conn->consumed_content += n;; 6521 nread += n;; 6522 } else {; 6523 nread = ((nread > 0) ? nread : n);; 6524 }; 6525 }; 6526 return (int)nread;; 6527}; 6528 ; 6529 ; 6530/* Forward declarations */; 6531static void handle_request(struct mg_connection *);; 6532static void log_access(const struct mg_connection *);; 6533 ; 6534 ; 6535/* Handle request, update statistics and call access log */; 6536static void; 6537handle_request_stat_log(struct mg_connection *conn); 6538{; 6539#if defined(USE_SERVER_STATS); 6540 struct timespec tnow;; 6541 conn->conn_state = 4; /* processing */; 6542#endif; 6543 ; 6544 handle_request(conn);; 6545 ; 6546 ; 6547#if defined(USE_SERVER_STATS); 6548 conn->conn_state = 5; /* processed */; 6549 ; 6550 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6551 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6552 ; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6554 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6555 conn->num_bytes_sent);; 6556#endif; 6557 ; 6558 DEBUG_TRACE(""%s"", ""handle_request done"");; 6559 ; 6560 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6561 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6562 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6563 }; 6564 log_access(conn);; 6565}; 6566 ; 6567 ; 6568#if defined(USE_HTTP2); 6569#if defined(NO_SSL); 6570#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6571#endif; 6572#define USE_ALPN; 6573#include ""mod_http2.inl""; 6574/* Not sup",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:226824,Security,attack,attacks,226824,"6 if ((sscanf(datetime,; 7817 ""%d/%3s/%d %d:%d:%d"",; 7818 &day,; 7819 month_str,; 7820 &year,; 7821 &hour,; 7822 &minute,; 7823 &second); 7824 == 6); 7825 || (sscanf(datetime,; 7826 ""%d %3s %d %d:%d:%d"",; 7827 &day,; 7828 month_str,; 7829 &year,; 7830 &hour,; 7831 &minute,; 7832 &second); 7833 == 6); 7834 || (sscanf(datetime,; 7835 ""%*3s, %d %3s %d %d:%d:%d"",; 7836 &day,; 7837 month_str,; 7838 &year,; 7839 &hour,; 7840 &minute,; 7841 &second); 7842 == 6); 7843 || (sscanf(datetime,; 7844 ""%d-%3s-%d %d:%d:%d"",; 7845 &day,; 7846 month_str,; 7847 &year,; 7848 &hour,; 7849 &minute,; 7850 &second); 7851 == 6)) {; 7852 month = get_month_index(month_str);; 7853 if ((month >= 0) && (year >= 1970)) {; 7854 memset(&tm, 0, sizeof(tm));; 7855 tm.tm_year = year - 1900;; 7856 tm.tm_mon = month;; 7857 tm.tm_mday = day;; 7858 tm.tm_hour = hour;; 7859 tm.tm_min = minute;; 7860 tm.tm_sec = second;; 7861 result = timegm(&tm);; 7862 }; 7863 }; 7864 ; 7865 return result;; 7866}; 7867#endif /* !NO_CACHING */; 7868 ; 7869 ; 7870/* Pre-process URIs according to RFC + protect against directory disclosure; 7871 * attacks by removing '..', excessive '/' and '\' characters */; 7872static void; 7873remove_dot_segments(char *inout); 7874{; 7875 /* Windows backend protection; 7876 * (https://tools.ietf.org/html/rfc3986#section-7.3): Replace backslash; 7877 * in URI by slash */; 7878 char *out_end = inout;; 7879 char *in = inout;; 7880 ; 7881 if (!in) {; 7882 /* Param error. */; 7883 return;; 7884 }; 7885 ; 7886 while (*in) {; 7887 if (*in == '\\') {; 7888 *in = '/';; 7889 }; 7890 in++;; 7891 }; 7892 ; 7893 /* Algorithm ""remove_dot_segments"" from; 7894 * https://tools.ietf.org/html/rfc3986#section-5.2.4 */; 7895 /* Step 1:; 7896 * The input buffer is initialized.; 7897 * The output buffer is initialized to the empty string.; 7898 */; 7899 in = inout;; 7900 ; 7901 /* Step 2:; 7902 * While the input buffer is not empty, loop as follows:; 7903 */; 7904 /* Less than out_end of the inout buffer is used a",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:236979,Security,hash,hash,236979,"8163 ; 8164 path_len = strlen(path);; 8165 ; 8166 if ((conn == NULL) || (vec == NULL)) {; 8167 if (vec != NULL) {; 8168 memset(vec, '\0', sizeof(struct vec));; 8169 }; 8170 return;; 8171 }; 8172 ; 8173 /* Scan user-defined mime types first, in case user wants to; 8174 * override default mime types. */; 8175 list = conn->dom_ctx->config[EXTRA_MIME_TYPES];; 8176 while ((list = next_option(list, &ext_vec, &mime_vec)) != NULL) {; 8177 /* ext now points to the path suffix */; 8178 ext = path + path_len - ext_vec.len;; 8179 if (mg_strncasecmp(ext, ext_vec.ptr, ext_vec.len) == 0) {; 8180 *vec = mime_vec;; 8181 return;; 8182 }; 8183 }; 8184 ; 8185 vec->ptr = mg_get_builtin_mime_type(path);; 8186 vec->len = strlen(vec->ptr);; 8187}; 8188 ; 8189 ; 8190/* Stringify binary data. Output buffer must be twice as big as input,; 8191 * because each byte takes 2 bytes in string representation */; 8192static void; 8193bin2str(char *to, const unsigned char *p, size_t len); 8194{; 8195 static const char *hex = ""0123456789abcdef"";; 8196 ; 8197 for (; len--; p++) {; 8198 *to++ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:237106,Security,hash,hash,237106,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:237408,Security,hash,hash,237408,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:237434,Security,hash,hash,237434,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:237447,Security,hash,hash,237447,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:237519,Security,password,password,237519,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:238544,Security,password,passwords,238544,"+ = hex[p[0] >> 4];; 8199 *to++ = hex[p[0] & 0x0f];; 8200 }; 8201 *to = '\0';; 8202}; 8203 ; 8204 ; 8205/* Return stringified MD5 hash for list of strings. Buffer must be 33 bytes.; 8206 */; 8207char *; 8208mg_md5(char buf[33], ...); 8209{; 8210 md5_byte_t hash[16];; 8211 const char *p;; 8212 va_list ap;; 8213 md5_state_t ctx;; 8214 ; 8215 md5_init(&ctx);; 8216 ; 8217 va_start(ap, buf);; 8218 while ((p = va_arg(ap, const char *)) != NULL) {; 8219 md5_append(&ctx, (const md5_byte_t *)p, strlen(p));; 8220 }; 8221 va_end(ap);; 8222 ; 8223 md5_finish(&ctx, hash);; 8224 bin2str(buf, hash, sizeof(hash));; 8225 return buf;; 8226}; 8227 ; 8228 ; 8229/* Check the user's password, return 1 if OK */; 8230static int; 8231check_password(const char *method,; 8232 const char *ha1,; 8233 const char *uri,; 8234 const char *nonce,; 8235 const char *nc,; 8236 const char *cnonce,; 8237 const char *qop,; 8238 const char *response); 8239{; 8240 char ha2[32 + 1], expected_response[32 + 1];; 8241 ; 8242 /* Some of the parameters may be NULL */; 8243 if ((method == NULL) || (nonce == NULL) || (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:239031,Security,password,passwords,239031,"| (nc == NULL) || (cnonce == NULL); 8244 || (qop == NULL) || (response == NULL)) {; 8245 return 0;; 8246 }; 8247 ; 8248 /* NOTE(lsm): due to a bug in MSIE, we do not compare the URI */; 8249 if (strlen(response) != 32) {; 8250 return 0;; 8251 }; 8252 ; 8253 mg_md5(ha2, method, "":"", uri, NULL);; 8254 mg_md5(expected_response,; 8255 ha1,; 8256 "":"",; 8257 nonce,; 8258 "":"",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char name[UTF8_PATH_MAX];; 8282 const char *p, *e,; 8283 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8284 int truncated;; 8285 ; 8286 if (gpass != NULL) {; 8287 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but onl",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:240034,Security,password,password,240034,"87 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but only a trace, since; 8313 * this is a typical case. It will occur for every directory; 8314 * without a password file. */; 8315 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8316#endif; 8317 }; 8318 } else {; 8319 /* Try to find .htpasswd in requested directory. */; 8320 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8321 if (e[0] == '/') {; 8322 break;; 8323 }; 8324 }; 8325 mg_snprintf(conn,; 8326 &truncated,; 8327 name,; 8328 sizeof(name),; 8329 ""%.*s/%s"",; 8330 (int)(e - p),; 8331 p,; 8332 PASSWORDS_FILE_NAME);; 8333 ; 8334 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8335#if defined(DEBUG); 8336 /* Don't use mg_cry_internal here, but only a trace, since; 8337 * this is a typical case. It will occur for every directory; 8338 * without a password file. */; 8339 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8340#endif; 8341 }; 8342 }; 8343 }; 8344}; 8345#endif /* NO_FILESYSTEMS */; 8346 ; 8347 ; 8348/* Parsed Authorization header */; 8349struct ah {; 8350 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8351};; 8",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:240719,Security,password,password,240719,"ame,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but only a trace, since; 8313 * this is a typical case. It will occur for every directory; 8314 * without a password file. */; 8315 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8316#endif; 8317 }; 8318 } else {; 8319 /* Try to find .htpasswd in requested directory. */; 8320 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8321 if (e[0] == '/') {; 8322 break;; 8323 }; 8324 }; 8325 mg_snprintf(conn,; 8326 &truncated,; 8327 name,; 8328 sizeof(name),; 8329 ""%.*s/%s"",; 8330 (int)(e - p),; 8331 p,; 8332 PASSWORDS_FILE_NAME);; 8333 ; 8334 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8335#if defined(DEBUG); 8336 /* Don't use mg_cry_internal here, but only a trace, since; 8337 * this is a typical case. It will occur for every directory; 8338 * without a password file. */; 8339 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8340#endif; 8341 }; 8342 }; 8343 }; 8344}; 8345#endif /* NO_FILESYSTEMS */; 8346 ; 8347 ; 8348/* Parsed Authorization header */; 8349struct ah {; 8350 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8351};; 8352 ; 8353 ; 8354/* Return 1 on success. Always initializes the ah structure. */; 8355static int; 8356parse_auth_header(struct mg_connection *conn,; 8357 char *buf,; 8358 size_t buf_size,; 8359 struct ah *ah); 8360{; 8361 char *name, *value, *s;; 8362 const char *auth_header;; 8363 uint64_t nonce;; 8364 ; 8365 if (!ah || !conn) {; 8366 return 0;; 8367 }; 8368 ; 8369 (void)memset(ah, 0, sizeof(*ah));; 8370 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8371 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8372 return 0;; 8373 }; 8374 ; 8375 /* Make modifiable copy of the auth header */; 8376 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8377 s = b",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:241726,Security,authoriz,authorization,241726,"filep)) {; 8335#if defined(DEBUG); 8336 /* Don't use mg_cry_internal here, but only a trace, since; 8337 * this is a typical case. It will occur for every directory; 8338 * without a password file. */; 8339 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8340#endif; 8341 }; 8342 }; 8343 }; 8344}; 8345#endif /* NO_FILESYSTEMS */; 8346 ; 8347 ; 8348/* Parsed Authorization header */; 8349struct ah {; 8350 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8351};; 8352 ; 8353 ; 8354/* Return 1 on success. Always initializes the ah structure. */; 8355static int; 8356parse_auth_header(struct mg_connection *conn,; 8357 char *buf,; 8358 size_t buf_size,; 8359 struct ah *ah); 8360{; 8361 char *name, *value, *s;; 8362 const char *auth_header;; 8363 uint64_t nonce;; 8364 ; 8365 if (!ah || !conn) {; 8366 return 0;; 8367 }; 8368 ; 8369 (void)memset(ah, 0, sizeof(*ah));; 8370 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8371 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8372 return 0;; 8373 }; 8374 ; 8375 /* Make modifiable copy of the auth header */; 8376 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8377 s = buf;; 8378 ; 8379 /* Parse authorization header */; 8380 for (;;) {; 8381 /* Gobble initial spaces */; 8382 while (isspace((unsigned char)*s)) {; 8383 s++;; 8384 }; 8385 name = skip_quoted(&s, ""="", "" "", 0);; 8386 /* Value is either quote-delimited, or ends at first comma or space.; 8387 */; 8388 if (s[0] == '\""') {; 8389 s++;; 8390 value = skip_quoted(&s, ""\"""", "" "", '\\');; 8391 if (s[0] == ',') {; 8392 s++;; 8393 }; 8394 } else {; 8395 value = skip_quoted(&s, "", "", "" "", 0); /* IE uses commas, FF; 8396 * uses spaces */; 8397 }; 8398 if (*name == '\0') {; 8399 break;; 8400 }; 8401 ; 8402 if (!strcmp(name, ""username"")) {; 8403 ah->user = value;; 8404 } else if (!strcmp(name, ""cnonce"")) {; 8405 ah->cnonce = value;; 8406 } else if (!strcmp(name, ""response"")) {; 8407 ah->response = value;; 8408 } else if (!strcmp(name, ""uri"")) {; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:243636,Security,access,access,243636,"->qop = value;; 8412 } else if (!strcmp(name, ""nc"")) {; 8413 ah->nc = value;; 8414 } else if (!strcmp(name, ""nonce"")) {; 8415 ah->nonce = value;; 8416 }; 8417 }; 8418 ; 8419#if !defined(NO_NONCE_CHECK); 8420 /* Read the nonce from the response. */; 8421 if (ah->nonce == NULL) {; 8422 return 0;; 8423 }; 8424 s = NULL;; 8425 nonce = strtoull(ah->nonce, &s, 10);; 8426 if ((s == NULL) || (*s != 0)) {; 8427 return 0;; 8428 }; 8429 ; 8430 /* Convert the nonce from the client to a number. */; 8431 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8432 ; 8433 /* The converted number corresponds to the time the nounce has been; 8434 * created. This should not be earlier than the server start. */; 8435 /* Server side nonce check is valuable in all situations but one:; 8436 * if the server restarts frequently, but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:243856,Security,attack,attack,243856,"sponse. */; 8421 if (ah->nonce == NULL) {; 8422 return 0;; 8423 }; 8424 s = NULL;; 8425 nonce = strtoull(ah->nonce, &s, 10);; 8426 if ((s == NULL) || (*s != 0)) {; 8427 return 0;; 8428 }; 8429 ; 8430 /* Convert the nonce from the client to a number. */; 8431 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8432 ; 8433 /* The converted number corresponds to the time the nounce has been; 8434 * created. This should not be earlier than the server start. */; 8435 /* Server side nonce check is valuable in all situations but one:; 8436 * if the server restarts frequently, but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:244561,Security,access,access,244561,"but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:244624,Security,access,access,244624,"ious start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8506read_auth_file(struct mg_file *filep,; 8507 struct read_auth_file_struct *workdata,; 8508 int depth); 8509{; 8510 int is_authorized = 0;; 8511 struct mg_file fp;; 8512 size_t l;; 8513 ; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:245698,Security,password,passwords,245698,"r even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8506read_auth_file(struct mg_file *filep,; 8507 struct read_auth_file_struct *workdata,; 8508 int depth); 8509{; 8510 int is_authorized = 0;; 8511 struct mg_file fp;; 8512 size_t l;; 8513 ; 8514 if (!filep || !workdata || (0 == depth)) {; 8515 return 0;; 8516 }; 8517 ; 8518 /* Loop over passwords file */; 8519 while (mg_fgets(workdata->buf, sizeof(workdata->buf), filep) != NULL) {; 8520 l = strlen(workdata->buf);; 8521 while (l > 0) {; 8522 if (isspace((unsigned char)workdata->buf[l - 1]); 8523 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8524 l--;; 8525 workdata->buf[l] = 0;; 8526 } else; 8527 break;; 8528 }; 8529 if (l < 1) {; 8530 continue;; 8531 }; 8532 ; 8533 workdata->f_user = workdata->buf;; 8534 ; 8535 if (workdata->f_user[0] == ':') {; 8536 /* user names may not contain a ':' and may not be empty,; 8537 * so lines starting with ':' may be used for a special purpose; 8538 */; 8539 if (workdata->f_user[1] == '#') {; 8540 /* :# is a comment */; 8541 continue;; 8542 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will r",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:246663,Security,access,access,246663,"f, sizeof(workdata->buf), filep) != NULL) {; 8520 l = strlen(workdata->buf);; 8521 while (l > 0) {; 8522 if (isspace((unsigned char)workdata->buf[l - 1]); 8523 || iscntrl((unsigned char)workdata->buf[l - 1])) {; 8524 l--;; 8525 workdata->buf[l] = 0;; 8526 } else; 8527 break;; 8528 }; 8529 if (l < 1) {; 8530 continue;; 8531 }; 8532 ; 8533 workdata->f_user = workdata->buf;; 8534 ; 8535 if (workdata->f_user[0] == ':') {; 8536 /* user names may not contain a ':' and may not be empty,; 8537 * so lines starting with ':' may be used for a special purpose; 8538 */; 8539 if (workdata->f_user[1] == '#') {; 8540 /* :# is a comment */; 8541 continue;; 8542 } else if (!strncmp(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:246987,Security,authoriz,authorization,246987,"p(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Autho",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:247233,Security,authoriz,authorization,247233,"p(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Autho",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:247490,Security,authoriz,authorization,247490,"p(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Autho",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:247814,Security,authoriz,authorization,247814,"p(workdata->f_user + 1, ""include="", 8)) {; 8543 if (mg_fopen(workdata->conn,; 8544 workdata->f_user + 9,; 8545 MG_FOPEN_MODE_READ,; 8546 &fp)) {; 8547 is_authorized = read_auth_file(&fp, workdata, depth - 1);; 8548 (void)mg_fclose(; 8549 &fp.access); /* ignore error on read only file */; 8550 ; 8551 /* No need to continue processing files once we have a; 8552 * match, since nothing will reset it back; 8553 * to 0.; 8554 */; 8555 if (is_authorized) {; 8556 return is_authorized;; 8557 }; 8558 } else {; 8559 mg_cry_internal(workdata->conn,; 8560 ""%s: cannot open authorization file: %s"",; 8561 __func__,; 8562 workdata->buf);; 8563 }; 8564 continue;; 8565 }; 8566 /* everything is invalid for the moment (might change in the; 8567 * future) */; 8568 mg_cry_internal(workdata->conn,; 8569 ""%s: syntax error in authorization file: %s"",; 8570 __func__,; 8571 workdata->buf);; 8572 continue;; 8573 }; 8574 ; 8575 workdata->f_domain = strchr(workdata->f_user, ':');; 8576 if (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Autho",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:248445,Security,password,passwords,248445,"f (workdata->f_domain == NULL) {; 8577 mg_cry_internal(workdata->conn,; 8578 ""%s: syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file fil",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:248473,Security,authoriz,authorized,248473,": syntax error in authorization file: %s"",; 8579 __func__,; 8580 workdata->buf);; 8581 continue;; 8582 }; 8583 *(char *)(workdata->f_domain) = 0;; 8584 (workdata->f_domain)++;; 8585 ; 8586 workdata->f_ha1 = strchr(workdata->f_domain, ':');; 8587 if (workdata->f_ha1 == NULL) {; 8588 mg_cry_internal(workdata->conn,; 8589 ""%s: syntax error in authorization file: %s"",; 8590 __func__,; 8591 workdata->buf);; 8592 continue;; 8593 }; 8594 *(char *)(workdata->f_ha1) = 0;; 8595 (workdata->f_ha1)++;; 8596 ; 8597 if (!strcmp(workdata->ah.user, workdata->f_user); 8598 && !strcmp(workdata->domain, workdata->f_domain)) {; 8599 return check_password(workdata->conn->request_info.request_method,; 8600 workdata->f_ha1,; 8601 workdata->ah.uri,; 8602 workdata->ah.nonce,; 8603 workdata->ah.nc,; 8604 workdata->ah.cnonce,; 8605 workdata->ah.qop,; 8606 workdata->ah.response);; 8607 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filenam",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:249204,Security,authenticat,authentication,249204,"07 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:249613,Security,authoriz,authorize,249613,"07 }; 8608 }; 8609 ; 8610 return is_authorized;; 8611}; 8612 ; 8613 ; 8614/* Authorize against the opened passwords file. Return 1 if authorized. */; 8615static int; 8616authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm); 8617{; 8618 struct read_auth_file_struct workdata;; 8619 char buf[MG_BUF_LEN];; 8620 ; 8621 if (!conn || !conn->dom_ctx) {; 8622 return 0;; 8623 }; 8624 ; 8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 868",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:249673,Security,access,access,249673,"8625 memset(&workdata, 0, sizeof(workdata));; 8626 workdata.conn = conn;; 8627 ; 8628 if (!parse_auth_header(conn, buf, sizeof(buf), &workdata.ah)) {; 8629 return 0;; 8630 }; 8631 ; 8632 if (realm) {; 8633 workdata.domain = realm;; 8634 } else {; 8635 workdata.domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8636 }; 8637 ; 8638 return read_auth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 stre",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250109,Security,authoriz,authorized,250109,"uth_file(filep, &workdata, INITIAL_DEPTH);; 8639}; 8640 ; 8641 ; 8642/* Public function to check http digest authentication header */; 8643int; 8644mg_check_digest_access_authentication(struct mg_connection *conn,; 8645 const char *realm,; 8646 const char *filename); 8647{; 8648 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8649 int auth;; 8650 ; 8651 if (!conn || !filename) {; 8652 return -1;; 8653 }; 8654 if (!mg_fopen(conn, filename, MG_FOPEN_MODE_READ, &file)) {; 8655 return -2;; 8656 }; 8657 ; 8658 auth = authorize(conn, &file, realm);; 8659 ; 8660 mg_fclose(&file.access);; 8661 ; 8662 return auth;; 8663}; 8664#endif /* NO_FILESYSTEMS */; 8665 ; 8666 ; 8667/* Return 1 if request is authorised, 0 otherwise. */; 8668static int; 8669check_authorization(struct mg_connection *conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250835,Security,access,access,250835,"conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250933,Security,access,access,250933,"AX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250950,Security,authoriz,authorized,250950,"AX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:250963,Security,authoriz,authorize,250963,"AX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:251021,Security,access,access,251021,"; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:251095,Security,authoriz,authorized,251095,"; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_header_start(conn, 401);; 8745 send_no_cache_header(conn);; 8746 send_additional_header(conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:253272,Security,authoriz,authorize,253272,"conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,; 8752 buf,; 8753 sizeof(buf),; 8754 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8755 ""nonce=\""%"" UINT64_FMT ""\"""",; 8756 realm,; 8757 nonce);; 8758 ; 8759 if (!trunc) {; 8760 /* !trunc should always be true */; 8761 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8762 }; 8763 ; 8764 /* Send all headers */; 8765 mg_response_header_send(conn);; 8766}; 8767 ; 8768 ; 8769/* Interface function. Parameters are provided by the user, so do; 8770 * at least some basic checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:253330,Security,access,access,253330,"checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ; 8826 /* Other arguments must not be empty */; 8827 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8828 return 0;; 8829 }; 8830 ; 8831 /* Using the given file format, user name and domain must not contain; 8832 * ':'; 8833 */; 8834 if (strchr(user, ':') != NULL) {; 8835 return 0;; 8836 }; 8837 if (strchr(domain, ':') != NULL) {; 8838 return 0;; 8839 }; 8840 ; 8841 /* Do not allow control characters like newline in user name and domain.; 8842 * Do not allow excessively long names either. */; 8843 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8844 if (iscntrl((unsigned char)user[i])) {; 8845 return 0;; 8846 }; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:253840,Security,password,password,253840,"checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ; 8826 /* Other arguments must not be empty */; 8827 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8828 return 0;; 8829 }; 8830 ; 8831 /* Using the given file format, user name and domain must not contain; 8832 * ':'; 8833 */; 8834 if (strchr(user, ':') != NULL) {; 8835 return 0;; 8836 }; 8837 if (strchr(domain, ':') != NULL) {; 8838 return 0;; 8839 }; 8840 ; 8841 /* Do not allow control characters like newline in user name and domain.; 8842 * Do not allow excessively long names either. */; 8843 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8844 if (iscntrl((unsigned char)user[i])) {; 8845 return 0;; 8846 }; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:253855,Security,password,password,253855,"checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ; 8826 /* Other arguments must not be empty */; 8827 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8828 return 0;; 8829 }; 8830 ; 8831 /* Using the given file format, user name and domain must not contain; 8832 * ':'; 8833 */; 8834 if (strchr(user, ':') != NULL) {; 8835 return 0;; 8836 }; 8837 if (strchr(domain, ':') != NULL) {; 8838 return 0;; 8839 }; 8840 ; 8841 /* Do not allow control characters like newline in user name and domain.; 8842 * Do not allow excessively long names either. */; 8843 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8844 if (iscntrl((unsigned char)user[i])) {; 8845 return 0;; 8846 }; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:254898,Security,password,password,254898,"2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ; 8826 /* Other arguments must not be empty */; 8827 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8828 return 0;; 8829 }; 8830 ; 8831 /* Using the given file format, user name and domain must not contain; 8832 * ':'; 8833 */; 8834 if (strchr(user, ':') != NULL) {; 8835 return 0;; 8836 }; 8837 if (strchr(domain, ':') != NULL) {; 8838 return 0;; 8839 }; 8840 ; 8841 /* Do not allow control characters like newline in user name and domain.; 8842 * Do not allow excessively long names either. */; 8843 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8844 if (iscntrl((unsigned char)user[i])) {; 8845 return 0;; 8846 }; 8847 }; 8848 if (user[i]) {; 8849 return 0;; 8850 }; 8851 for (i = 0; ((i < 255) && (domain[i] != 0)); i++) {; 8852 if (iscntrl((unsigned char)domain[i])) {; 8853 return 0;; 8854 }; 8855 }; 8856 if (domain[i]) {; 8857 return 0;; 8858 }; 8859 ; 8860 /* The maximum length of the path to the password file is limited */; 8861 if ((strlen(fname) + 4) >= UTF8_PATH_MAX) {; 8862 return 0;; 8863 }; 8864 ; 8865 /* Create a temporary file name. Length has been checked before. */; 8866 strcpy(tmp, fname);; 8867 strcat(tmp, "".tmp"");; 8868 ; 8869 /* Create the file if does not exist */; 8870 /* Use of fopen here is OK, since fname is only ASCII */; 8871 if ((fp = fopen(fname, ""a+"")) != NULL) {; 8872 (void)fclose(fp);; 8873 }; 8874 ; 8875 /* Open the given file and temporary file */; 8876 if ((fp = fopen(fname, ""r"")) == NULL) {; 8877 return 0;; 8878 } else if ((fp2 = fopen(tmp, ""w+"")) == NULL) {; 8879 fclose(fp);; 8880 return 0;; 8881 }; 8882 ; 8883 /* Copy the stuff to temporary file */; 8884 while (fgets(line, sizeof(line), fp) != NULL) {; 8885 if (sscanf(line, ""%255[^:]:%255[^:]:%*s"", u, d) != 2) {; 8886 continue;; 8887 }; 8888 u[255] = 0;; 8889 d[",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:279078,Security,access,access,279078,"ata.entries != NULL) {; 9710 qsort(data.entries,; 9711 data.num_entries,; 9712 sizeof(data.entries[0]),; 9713 compare_dir_entries);; 9714 for (i = 0; i < data.num_entries; i++) {; 9715 print_dir_entry(&data.entries[i]);; 9716 mg_free(data.entries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file s",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:279440,Security,access,access,279440,"ntries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:280649,Security,access,access,280649,"y page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_sent >= 0));; 9782 ; 9783 if (sf_sent > 0) {; 9784 return; /* OK */; 9785 }; 9786 ; 9787 /* sf_sent<0 means error, thus fall back to the classic way */; 9788 /* This is always the case, if sf_file is not a ""normal"" file,; 9789 * e.g., for sending data from the output of a CGI process. */; 9790 offset = (int64_t)sf_offs;; 9791 }; 9792#endif; 9793 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9794 mg_cry_internal(conn,; 9795 ""%s: fseeko() failed: %s"",; 9796 __func__,; 9797 strerror(ERRNO));; 9798 mg_send_http_error(; 9799 conn,; 9800 500,; 9801 ""%s"",; 9802 ""Error: Unable to access file at requested position."");; 9803 } else {; 9804 while (len > 0) {; 9805 /* Calculate how much to read from the file in the buffer */; 9806 to_read = sizeof(buf);; 9807 if ((int64_t)to_read > len) {; 9808 to_read = (int)len;; 9809 }; 9810 ; 9811 /* Read from file, exit the loop on error */; 9812 if ((num_read =; 9813 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9814 <= 0) {; 9815 break;; 9816 }; 9817 ; 9818 /* Send read bytes to the client, exit the loop on error */; 9819 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9820 != num_read) {; 9821 break;; 9822 }; 9823 ; 9824 /* Both read and were successful, adjust counters */; 9825 len -= num_written;; 9826 }; 9827 }; 9828 }; 9829}; 9830 ; 98",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:280873,Security,access,access,280873,";; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file system.; 9773 * Use the regular user mode copy code instead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_sent >= 0));; 9782 ; 9783 if (sf_sent > 0) {; 9784 return; /* OK */; 9785 }; 9786 ; 9787 /* sf_sent<0 means error, thus fall back to the classic way */; 9788 /* This is always the case, if sf_file is not a ""normal"" file,; 9789 * e.g., for sending data from the output of a CGI process. */; 9790 offset = (int64_t)sf_offs;; 9791 }; 9792#endif; 9793 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9794 mg_cry_internal(conn,; 9795 ""%s: fseeko() failed: %s"",; 9796 __func__,; 9797 strerror(ERRNO));; 9798 mg_send_http_error(; 9799 conn,; 9800 500,; 9801 ""%s"",; 9802 ""Error: Unable to access file at requested position."");; 9803 } else {; 9804 while (len > 0) {; 9805 /* Calculate how much to read from the file in the buffer */; 9806 to_read = sizeof(buf);; 9807 if ((int64_t)to_read > len) {; 9808 to_read = (int)len;; 9809 }; 9810 ; 9811 /* Read from file, exit the loop on error */; 9812 if ((num_read =; 9813 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9814 <= 0) {; 9815 break;; 9816 }; 9817 ; 9818 /* Send read bytes to the client, exit the loop on error */; 9819 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9820 != num_read) {; 9821 break;; 9822 }; 9823 ; 9824 /* Both read and were successful, adjust counters */; 9825 len -= num_written;; 9826 }; 9827 }; 9828 }; 9829}; 9830 ; 9831 ; 9832static int; 9833parse_range_header(const char *header, int64_t *a, int64_t *b); 9834{; 9835 return sscanf(header,; 9836 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9837 a,; 983",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:281245,Security,access,access,281245,"stead. */; 9774 break;; 9775 } else if (sf_sent == 0) {; 9776 /* No error, but 0 bytes sent. May be EOF? */; 9777 return;; 9778 }; 9779 loop_cnt++;; 9780 ; 9781 } while ((len > 0) && (sf_sent >= 0));; 9782 ; 9783 if (sf_sent > 0) {; 9784 return; /* OK */; 9785 }; 9786 ; 9787 /* sf_sent<0 means error, thus fall back to the classic way */; 9788 /* This is always the case, if sf_file is not a ""normal"" file,; 9789 * e.g., for sending data from the output of a CGI process. */; 9790 offset = (int64_t)sf_offs;; 9791 }; 9792#endif; 9793 if ((offset > 0) && (fseeko(filep->access.fp, offset, SEEK_SET) != 0)) {; 9794 mg_cry_internal(conn,; 9795 ""%s: fseeko() failed: %s"",; 9796 __func__,; 9797 strerror(ERRNO));; 9798 mg_send_http_error(; 9799 conn,; 9800 500,; 9801 ""%s"",; 9802 ""Error: Unable to access file at requested position."");; 9803 } else {; 9804 while (len > 0) {; 9805 /* Calculate how much to read from the file in the buffer */; 9806 to_read = sizeof(buf);; 9807 if ((int64_t)to_read > len) {; 9808 to_read = (int)len;; 9809 }; 9810 ; 9811 /* Read from file, exit the loop on error */; 9812 if ((num_read =; 9813 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9814 <= 0) {; 9815 break;; 9816 }; 9817 ; 9818 /* Send read bytes to the client, exit the loop on error */; 9819 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9820 != num_read) {; 9821 break;; 9822 }; 9823 ; 9824 /* Both read and were successful, adjust counters */; 9825 len -= num_written;; 9826 }; 9827 }; 9828 }; 9829}; 9830 ; 9831 ; 9832static int; 9833parse_range_header(const char *header, int64_t *a, int64_t *b); 9834{; 9835 return sscanf(header,; 9836 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9837 a,; 9838 b); // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 9839 // to an integer value, but function will not report; 9840 // conversion errors; consider using 'strtol' instead; 9841}; 9842 ; 9843 ; 9844static void; 9845construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *fil",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:286419,Security,access,access,286419,"h;; 9958 encoding = ""gzip"";; 9959 ; 9960#if defined(USE_ZLIB); 9961 /* File is already compressed. No ""on the fly"" compression. */; 9962 allow_on_the_fly_compression = 0;; 9963#endif; 9964 } else if ((conn->accept_gzip) && (range_hdr == NULL); 9965 && (filep->stat.size >= MG_FILE_COMPRESSION_SIZE_LIMIT)) {; 9966 struct mg_file_stat file_stat;; 9967 ; 9968 mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), ""%s.gz"", path);; 9969 ; 9970 if (!truncated && mg_stat(conn, gz_path, &file_stat); 9971 && !file_stat.is_directory) {; 9972 file_stat.is_gzipped = 1;; 9973 filep->stat = file_stat;; 9974 cl = (int64_t)filep->stat.size;; 9975 path = gz_path;; 9976 encoding = ""gzip"";; 9977 ; 9978#if defined(USE_ZLIB); 9979 /* File is already compressed. No ""on the fly"" compression. */; 9980 allow_on_the_fly_compression = 0;; 9981#endif; 9982 }; 9983 }; 9984 ; 9985 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9986 mg_send_http_error(conn,; 9987 500,; 9988 ""Error: Cannot open file\nfopen(%s): %s"",; 9989 path,; 9990 strerror(ERRNO));; 9991 return;; 9992 }; 9993 ; 9994 fclose_on_exec(&filep->access, conn);; 9995 ; 9996 /* If ""Range"" request was made: parse header, send only selected part; 9997 * of the file. */; 9998 r1 = r2 = 0;; 9999 if ((range_hdr != NULL); 10000 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10001 && (r2 >= 0)) {; 10002 /* actually, range requests don't play well with a pre-gzipped; 10003 * file (since the range is specified in the uncompressed space) */; 10004 if (filep->stat.is_gzipped) {; 10005 mg_send_http_error(; 10006 conn,; 10007 416, /* 416 = Range Not Satisfiable */; 10008 ""%s"",; 10009 ""Error: Range requests in gzipped files are not supported"");; 10010 (void)mg_fclose(; 10011 &filep->access); /* ignore error on read only file */; 10012 return;; 10013 }; 10014 conn->status_code = 206;; 10015 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10016 mg_snprintf(conn,; 10017 NULL, /* range buffer is big enough */",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:287075,Security,access,access,287075," }; 9984 ; 9985 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9986 mg_send_http_error(conn,; 9987 500,; 9988 ""Error: Cannot open file\nfopen(%s): %s"",; 9989 path,; 9990 strerror(ERRNO));; 9991 return;; 9992 }; 9993 ; 9994 fclose_on_exec(&filep->access, conn);; 9995 ; 9996 /* If ""Range"" request was made: parse header, send only selected part; 9997 * of the file. */; 9998 r1 = r2 = 0;; 9999 if ((range_hdr != NULL); 10000 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10001 && (r2 >= 0)) {; 10002 /* actually, range requests don't play well with a pre-gzipped; 10003 * file (since the range is specified in the uncompressed space) */; 10004 if (filep->stat.is_gzipped) {; 10005 mg_send_http_error(; 10006 conn,; 10007 416, /* 416 = Range Not Satisfiable */; 10008 ""%s"",; 10009 ""Error: Range requests in gzipped files are not supported"");; 10010 (void)mg_fclose(; 10011 &filep->access); /* ignore error on read only file */; 10012 return;; 10013 }; 10014 conn->status_code = 206;; 10015 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10016 mg_snprintf(conn,; 10017 NULL, /* range buffer is big enough */; 10018 range,; 10019 sizeof(range),; 10020 ""bytes ""; 10021 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10022 r1,; 10023 r1 + cl - 1,; 10024 filep->stat.size);; 10025 ; 10026#if defined(USE_ZLIB); 10027 /* Do not compress ranges. */; 10028 allow_on_the_fly_compression = 0;; 10029#endif; 10030 }; 10031 ; 10032 /* Do not compress small files. Small files do not benefit from file; 10033 * compression, but there is still some overhead. */; 10034#if defined(USE_ZLIB); 10035 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10036 /* File is below the size limit. */; 10037 allow_on_the_fly_compression = 0;; 10038 }; 10039#endif; 10040 ; 10041 /* Standard CORS header */; 10042 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10043 origin_hdr = mg_get_header(conn, ""Origin"");; 10044 if (cors_orig_cfg && *cors_orig_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:291601,Security,access,access,291601,"8#endif; 10099 {; 10100 /* Without on-the-fly compression, we know the content-length; 10101 * and we can use ranges (with on-the-fly compression we cannot).; 10102 * So we send these response headers only in this case. */; 10103 char len[32];; 10104 int trunc = 0;; 10105 mg_snprintf(conn, &trunc, len, sizeof(len), ""%"" INT64_FMT, cl);; 10106 ; 10107 if (!trunc) {; 10108 mg_response_header_add(conn, ""Content-Length"", len, -1);; 10109 }; 10110 ; 10111 mg_response_header_add(conn, ""Accept-Ranges"", ""bytes"", -1);; 10112 }; 10113 ; 10114 if (encoding) {; 10115 mg_response_header_add(conn, ""Content-Encoding"", encoding, -1);; 10116 }; 10117 if (range[0] != 0) {; 10118 mg_response_header_add(conn, ""Content-Range"", range, -1);; 10119 }; 10120 ; 10121 /* The code above does not add any header starting with X- to make; 10122 * sure no one of the additional_headers is included twice */; 10123 if ((additional_headers != NULL) && (*additional_headers != 0)) {; 10124 mg_response_header_add_lines(conn, additional_headers);; 10125 }; 10126 ; 10127 /* Send all headers */; 10128 mg_response_header_send(conn);; 10129 ; 10130 if (!is_head_request) {; 10131#if defined(USE_ZLIB); 10132 if (allow_on_the_fly_compression) {; 10133 /* Compress and send */; 10134 send_compressed_data(conn, filep);; 10135 } else; 10136#endif; 10137 {; 10138 /* Send file directly */; 10139 send_file_data(conn, filep, r1, cl);; 10140 }; 10141 }; 10142 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10143}; 10144 ; 10145 ; 10146int; 10147mg_send_file_body(struct mg_connection *conn, const char *path); 10148{; 10149 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10150 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10151 return -1;; 10152 }; 10153 fclose_on_exec(&file.access, conn);; 10154 send_file_data(conn, &file, 0, INT64_MAX);; 10155 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10156 return 0; /* >= 0 for OK */; 10157}; 10158#endif /* NO_FILESYSTEMS */;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:291931,Security,access,access,291931,"ure no one of the additional_headers is included twice */; 10123 if ((additional_headers != NULL) && (*additional_headers != 0)) {; 10124 mg_response_header_add_lines(conn, additional_headers);; 10125 }; 10126 ; 10127 /* Send all headers */; 10128 mg_response_header_send(conn);; 10129 ; 10130 if (!is_head_request) {; 10131#if defined(USE_ZLIB); 10132 if (allow_on_the_fly_compression) {; 10133 /* Compress and send */; 10134 send_compressed_data(conn, filep);; 10135 } else; 10136#endif; 10137 {; 10138 /* Send file directly */; 10139 send_file_data(conn, filep, r1, cl);; 10140 }; 10141 }; 10142 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10143}; 10144 ; 10145 ; 10146int; 10147mg_send_file_body(struct mg_connection *conn, const char *path); 10148{; 10149 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10150 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10151 return -1;; 10152 }; 10153 fclose_on_exec(&file.access, conn);; 10154 send_file_data(conn, &file, 0, INT64_MAX);; 10155 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10156 return 0; /* >= 0 for OK */; 10157}; 10158#endif /* NO_FILESYSTEMS */; 10159 ; 10160 ; 10161#if !defined(NO_CACHING); 10162/* Return True if we should reply 304 Not Modified. */; 10163static int; 10164is_not_modified(const struct mg_connection *conn,; 10165 const struct mg_file_stat *filestat); 10166{; 10167 char etag[64];; 10168 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10169 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10170 construct_etag(etag, sizeof(etag), filestat);; 10171 ; 10172 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10173 || ((ims != NULL); 10174 && (filestat->last_modified <= parse_date_string(ims)));; 10175}; 10176 ; 10177 ; 10178static void; 10179handle_not_modified_static_file_request(struct mg_connection *conn,; 10180 struct mg_file *filep); 10181{; 10182 char lm[64], etag[64];; 10183 ; 10184 if ((conn == NULL) || (filep == NUL",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:292025,Security,access,access,292025,"lines(conn, additional_headers);; 10125 }; 10126 ; 10127 /* Send all headers */; 10128 mg_response_header_send(conn);; 10129 ; 10130 if (!is_head_request) {; 10131#if defined(USE_ZLIB); 10132 if (allow_on_the_fly_compression) {; 10133 /* Compress and send */; 10134 send_compressed_data(conn, filep);; 10135 } else; 10136#endif; 10137 {; 10138 /* Send file directly */; 10139 send_file_data(conn, filep, r1, cl);; 10140 }; 10141 }; 10142 (void)mg_fclose(&filep->access); /* ignore error on read only file */; 10143}; 10144 ; 10145 ; 10146int; 10147mg_send_file_body(struct mg_connection *conn, const char *path); 10148{; 10149 struct mg_file file = STRUCT_FILE_INITIALIZER;; 10150 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 10151 return -1;; 10152 }; 10153 fclose_on_exec(&file.access, conn);; 10154 send_file_data(conn, &file, 0, INT64_MAX);; 10155 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 10156 return 0; /* >= 0 for OK */; 10157}; 10158#endif /* NO_FILESYSTEMS */; 10159 ; 10160 ; 10161#if !defined(NO_CACHING); 10162/* Return True if we should reply 304 Not Modified. */; 10163static int; 10164is_not_modified(const struct mg_connection *conn,; 10165 const struct mg_file_stat *filestat); 10166{; 10167 char etag[64];; 10168 const char *ims = mg_get_header(conn, ""If-Modified-Since"");; 10169 const char *inm = mg_get_header(conn, ""If-None-Match"");; 10170 construct_etag(etag, sizeof(etag), filestat);; 10171 ; 10172 return ((inm != NULL) && !mg_strcasecmp(etag, inm)); 10173 || ((ims != NULL); 10174 && (filestat->last_modified <= parse_date_string(ims)));; 10175}; 10176 ; 10177 ; 10178static void; 10179handle_not_modified_static_file_request(struct mg_connection *conn,; 10180 struct mg_file *filep); 10181{; 10182 char lm[64], etag[64];; 10183 ; 10184 if ((conn == NULL) || (filep == NULL)) {; 10185 return;; 10186 }; 10187 ; 10188 gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);; 10189 construct_etag(etag, sizeof(etag), &filep->stat);",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:297436,Security,access,access,297436,"08 if (r != 0) {; 10309 mg_cry_internal(conn,; 10310 ""%s: Cannot remove invalid file %s"",; 10311 __func__,; 10312 path);; 10313 }; 10314}; 10315 ; 10316 ; 10317long long; 10318mg_store_body(struct mg_connection *conn, const char *path); 10319{; 10320 char buf[MG_BUF_LEN];; 10321 long long len = 0;; 10322 int ret, n;; 10323 struct mg_file fi;; 10324 ; 10325 if (conn->consumed_content != 0) {; 10326 mg_cry_internal(conn, ""%s: Contents already consumed"", __func__);; 10327 return -11;; 10328 }; 10329 ; 10330 ret = put_dir(conn, path);; 10331 if (ret < 0) {; 10332 /* -1 for path too long,; 10333 * -2 for path can not be created. */; 10334 return ret;; 10335 }; 10336 if (ret != 1) {; 10337 /* Return 0 means, path itself is a directory. */; 10338 return 0;; 10339 }; 10340 ; 10341 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10342 return -12;; 10343 }; 10344 ; 10345 ret = mg_read(conn, buf, sizeof(buf));; 10346 while (ret > 0) {; 10347 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10348 if (n != ret) {; 10349 (void)mg_fclose(; 10350 &fi.access); /* File is bad and will be removed anyway. */; 10351 remove_bad_file(conn, path);; 10352 return -13;; 10353 }; 10354 len += ret;; 10355 ret = mg_read(conn, buf, sizeof(buf));; 10356 }; 10357 ; 10358 /* File is open for writing. If fclose fails, there was probably an; 10359 * error flushing the buffer to disk, so the file on disk might be; 10360 * broken. Delete it and return an error to the caller. */; 10361 if (mg_fclose(&fi.access) != 0) {; 10362 remove_bad_file(conn, path);; 10363 return -14;; 10364 }; 10365 ; 10366 return len;; 10367}; 10368#endif /* NO_FILESYSTEMS */; 10369 ; 10370 ; 10371/* Parse a buffer:; 10372 * Forward the string pointer till the end of a word, then; 10373 * terminate it and forward till the begin of the next word.; 10374 */; 10375static int; 10376skip_to_end_of_word_and_terminate(char **ppw, int eol); 10377{; 10378 /* Forward until a space is found - use isgraph here */; 10379 /* See ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:297506,Security,access,access,297506,"0311 __func__,; 10312 path);; 10313 }; 10314}; 10315 ; 10316 ; 10317long long; 10318mg_store_body(struct mg_connection *conn, const char *path); 10319{; 10320 char buf[MG_BUF_LEN];; 10321 long long len = 0;; 10322 int ret, n;; 10323 struct mg_file fi;; 10324 ; 10325 if (conn->consumed_content != 0) {; 10326 mg_cry_internal(conn, ""%s: Contents already consumed"", __func__);; 10327 return -11;; 10328 }; 10329 ; 10330 ret = put_dir(conn, path);; 10331 if (ret < 0) {; 10332 /* -1 for path too long,; 10333 * -2 for path can not be created. */; 10334 return ret;; 10335 }; 10336 if (ret != 1) {; 10337 /* Return 0 means, path itself is a directory. */; 10338 return 0;; 10339 }; 10340 ; 10341 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10342 return -12;; 10343 }; 10344 ; 10345 ret = mg_read(conn, buf, sizeof(buf));; 10346 while (ret > 0) {; 10347 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10348 if (n != ret) {; 10349 (void)mg_fclose(; 10350 &fi.access); /* File is bad and will be removed anyway. */; 10351 remove_bad_file(conn, path);; 10352 return -13;; 10353 }; 10354 len += ret;; 10355 ret = mg_read(conn, buf, sizeof(buf));; 10356 }; 10357 ; 10358 /* File is open for writing. If fclose fails, there was probably an; 10359 * error flushing the buffer to disk, so the file on disk might be; 10360 * broken. Delete it and return an error to the caller. */; 10361 if (mg_fclose(&fi.access) != 0) {; 10362 remove_bad_file(conn, path);; 10363 return -14;; 10364 }; 10365 ; 10366 return len;; 10367}; 10368#endif /* NO_FILESYSTEMS */; 10369 ; 10370 ; 10371/* Parse a buffer:; 10372 * Forward the string pointer till the end of a word, then; 10373 * terminate it and forward till the begin of the next word.; 10374 */; 10375static int; 10376skip_to_end_of_word_and_terminate(char **ppw, int eol); 10377{; 10378 /* Forward until a space is found - use isgraph here */; 10379 /* See http://www.cplusplus.com/reference/cctype/ */; 10380 while (isgraph((unsigned char)**ppw)) {",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:297945,Security,access,access,297945,"336 if (ret != 1) {; 10337 /* Return 0 means, path itself is a directory. */; 10338 return 0;; 10339 }; 10340 ; 10341 if (mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &fi) == 0) {; 10342 return -12;; 10343 }; 10344 ; 10345 ret = mg_read(conn, buf, sizeof(buf));; 10346 while (ret > 0) {; 10347 n = (int)fwrite(buf, 1, (size_t)ret, fi.access.fp);; 10348 if (n != ret) {; 10349 (void)mg_fclose(; 10350 &fi.access); /* File is bad and will be removed anyway. */; 10351 remove_bad_file(conn, path);; 10352 return -13;; 10353 }; 10354 len += ret;; 10355 ret = mg_read(conn, buf, sizeof(buf));; 10356 }; 10357 ; 10358 /* File is open for writing. If fclose fails, there was probably an; 10359 * error flushing the buffer to disk, so the file on disk might be; 10360 * broken. Delete it and return an error to the caller. */; 10361 if (mg_fclose(&fi.access) != 0) {; 10362 remove_bad_file(conn, path);; 10363 return -14;; 10364 }; 10365 ; 10366 return len;; 10367}; 10368#endif /* NO_FILESYSTEMS */; 10369 ; 10370 ; 10371/* Parse a buffer:; 10372 * Forward the string pointer till the end of a word, then; 10373 * terminate it and forward till the begin of the next word.; 10374 */; 10375static int; 10376skip_to_end_of_word_and_terminate(char **ppw, int eol); 10377{; 10378 /* Forward until a space is found - use isgraph here */; 10379 /* See http://www.cplusplus.com/reference/cctype/ */; 10380 while (isgraph((unsigned char)**ppw)) {; 10381 (*ppw)++;; 10382 }; 10383 ; 10384 /* Check end of word */; 10385 if (eol) {; 10386 /* must be a end of line */; 10387 if ((**ppw != '\r') && (**ppw != '\n')) {; 10388 return -1;; 10389 }; 10390 } else {; 10391 /* must be a end of a word, but not a line */; 10392 if (**ppw != ' ') {; 10393 return -1;; 10394 }; 10395 }; 10396 ; 10397 /* Terminate and forward to the next word */; 10398 do {; 10399 **ppw = 0;; 10400 (*ppw)++;; 10401 } while (isspace((unsigned char)**ppw));; 10402 ; 10403 /* Check after term */; 10404 if (!eol) {; 10405 /* if it's not the end of li",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:301933,Security,secur,security,301933," -1;; 10473 }; 10474 }; 10475 ; 10476 /* here *dp is either 0 or '\n' */; 10477 /* in any case, we have a new header */; 10478 num_headers = i + 1;; 10479 ; 10480 if (*dp) {; 10481 *dp = 0;; 10482 dp++;; 10483 *buf = dp;; 10484 ; 10485 if ((dp[0] == '\r') || (dp[0] == '\n')) {; 10486 /* This is the end of the header */; 10487 break;; 10488 }; 10489 } else {; 10490 *buf = dp;; 10491 break;; 10492 }; 10493 }; 10494 return num_headers;; 10495}; 10496 ; 10497 ; 10498struct mg_http_method_info {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:302320,Security,validat,validation,302320,"o {; 10499 const char *name;; 10500 int request_has_body;; 10501 int response_has_body;; 10502 int is_safe;; 10503 int is_idempotent;; 10504 int is_cacheable;; 10505};; 10506 ; 10507 ; 10508/* https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods */; 10509static const struct mg_http_method_info http_methods[] = {; 10510 /* HTTP (RFC 2616) */; 10511 {""GET"", 0, 1, 1, 1, 1},; 10512 {""POST"", 1, 1, 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:303060,Security,access,access,303060,"ROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for WEBDAV in RFC 3253, Sec. 3.6; 10561 * (https://tools.ietf.org/html/rfc3253#section-3.6), but seems; 10562 * to be useful for REST in case a ""GET request with body"" is; 10563 * required. */; 10564 ; 10565 {NULL, 0, 0, 0, 0, 0}; 10566 /* end of list */; 10567};; 10568 ; 10569 ; 10570static const struct mg_http_method_info *; 10571get_http_method_info(const char *method); 10572{; 10573 /* Check if the method is known to the server. The list of all known; 10574 * HTTP methods can be found here at; 10575 * http://www.iana.org/assignments/http-met",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:330389,Security,access,access,330389,"1390 (void *)proc,; 11391 NULL);; 11392 }; 11393#endif; 11394 ; 11395 /* Parent closes only one side of the pipes.; 11396 * If we don't mark them as closed, close() attempt before; 11397 * return from this function throws an exception on Windows.; 11398 * Windows does not like when closed descriptor is closed again. */; 11399 (void)close(fdin[0]);; 11400 (void)close(fdout[1]);; 11401 (void)close(fderr[1]);; 11402 fdin[0] = fdout[1] = fderr[1] = -1;; 11403 ; 11404 if (((in = fdopen(fdin[1], ""wb"")) == NULL); 11405 || ((out = fdopen(fdout[0], ""rb"")) == NULL); 11406 || ((err = fdopen(fderr[0], ""rb"")) == NULL)) {; 11407 status = strerror(ERRNO);; 11408 mg_cry_internal(conn,; 11409 ""Error: CGI program \""%s\"": Can not open fd: %s"",; 11410 prog,; 11411 status);; 11412 mg_send_http_error(conn,; 11413 500,; 11414 ""Error: CGI can not open fd\nfdopen: %s"",; 11415 status);; 11416 goto done;; 11417 }; 11418 ; 11419 setbuf(in, NULL);; 11420 setbuf(out, NULL);; 11421 setbuf(err, NULL);; 11422 fout.access.fp = out;; 11423 ; 11424 if ((conn->content_len != 0) || (conn->is_chunked)) {; 11425 DEBUG_TRACE(""CGI: send body data (%"" INT64_FMT "")\n"",; 11426 conn->content_len);; 11427 ; 11428 /* This is a POST/PUT request, or another request with body data. */; 11429 if (!forward_body_data(conn, in, INVALID_SOCKET, NULL)) {; 11430 /* Error sending the body data */; 11431 mg_cry_internal(; 11432 conn,; 11433 ""Error: CGI program \""%s\"": Forward body data failed"",; 11434 prog);; 11435 goto done;; 11436 }; 11437 }; 11438 ; 11439 /* Close so child gets an EOF. */; 11440 fclose(in);; 11441 in = NULL;; 11442 fdin[1] = -1;; 11443 ; 11444 /* Now read CGI reply into a buffer. We need to set correct; 11445 * status code, thus we need to see all HTTP headers first.; 11446 * Do not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 50",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:338402,Security,access,access,338402,"mg_file file = STRUCT_FILE_INITIALIZER;; 11674 const char *range;; 11675 int64_t r1, r2;; 11676 int rc;; 11677 ; 11678 if (conn == NULL) {; 11679 return;; 11680 }; 11681 ; 11682 if (mg_stat(conn, path, &file.stat)) {; 11683 /* File already exists */; 11684 conn->status_code = 200;; 11685 ; 11686 if (file.stat.is_directory) {; 11687 /* This is an already existing directory,; 11688 * so there is nothing to do for the server. */; 11689 rc = 0;; 11690 ; 11691 } else {; 11692 /* File exists and is not a directory. */; 11693 /* Can it be replaced? */; 11694 ; 11695 /* Check if the server may write this file */; 11696 if (access(path, W_OK) == 0) {; 11697 /* Access granted */; 11698 rc = 1;; 11699 } else {; 11700 mg_send_http_error(; 11701 conn,; 11702 403,; 11703 ""Error: Put not possible\nReplacing %s is not allowed"",; 11704 path);; 11705 return;; 11706 }; 11707 }; 11708 } else {; 11709 /* File should be created */; 11710 conn->status_code = 201;; 11711 rc = put_dir(conn, path);; 11712 }; 11713 ; 11714 if (rc == 0) {; 11715 /* put_dir returns 0 if path is a directory */; 11716 ; 11717 /* Create response */; 11718 mg_response_header_start(conn, conn->status_code);; 11719 send_no_cache_header(conn);; 11720 send_additional_header(conn);; 11721 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:339947,Security,access,access,339947,"r_start(conn, conn->status_code);; 11719 send_no_cache_header(conn);; 11720 send_additional_header(conn);; 11721 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose fail",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340034,Security,access,access,340034,"response_header_add(conn, ""Content-Length"", ""0"", -1);; 11722 ; 11723 /* Send all headers - there is no body */; 11724 mg_response_header_send(conn);; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->st",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340084,Security,access,access,340084,"; 11725 ; 11726 /* Request to create a directory has been fulfilled successfully.; 11727 * No need to put a file. */; 11728 return;; 11729 }; 11730 ; 11731 if (rc == -1) {; 11732 /* put_dir returns -1 if the path is too long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340287,Security,access,access,340287," long */; 11733 mg_send_http_error(conn,; 11734 414,; 11735 ""Error: Path too long\nput_dir(%s): %s"",; 11736 path,; 11737 strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340521,Security,access,access,340521," strerror(ERRNO));; 11738 return;; 11739 }; 11740 ; 11741 if (rc == -2) {; 11742 /* put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *p",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340605,Security,access,access,340605,"put_dir returns -2 if the directory can not be created */; 11743 mg_send_http_error(conn,; 11744 500,; 11745 ""Error: Can not create directory\nput_dir(%s): %s"",; 11746 path,; 11747 strerror(ERRNO));; 11748 return;; 11749 }; 11750 ; 11751 /* A file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 1180",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340817,Security,access,access,340817,"file should be created or overwritten. */; 11752 /* Currently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 11802 if (!mg_stat(conn, path, &de.file)) {; 11803 /* mg_stat returns 0 if the file does not exist */; 11804 mg_send_http_error(conn,; 11805 404,; 11806 ""Error: Cannot delete file\nFile %s not found"",; 11807 path);; 11808 return;; 11809 }; 11810 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:340885,Security,access,access,340885,"rrently CivetWeb does not nead read+write access. */; 11753 if (!mg_fopen(conn, path, MG_FOPEN_MODE_WRITE, &file); 11754 || file.access.fp == NULL) {; 11755 (void)mg_fclose(&file.access);; 11756 mg_send_http_error(conn,; 11757 500,; 11758 ""Error: Can not create file\nfopen(%s): %s"",; 11759 path,; 11760 strerror(ERRNO));; 11761 return;; 11762 }; 11763 ; 11764 fclose_on_exec(&file.access, conn);; 11765 range = mg_get_header(conn, ""Content-Range"");; 11766 r1 = r2 = 0;; 11767 if ((range != NULL) && parse_range_header(range, &r1, &r2) > 0) {; 11768 conn->status_code = 206; /* Partial content */; 11769 fseeko(file.access.fp, r1, SEEK_SET);; 11770 }; 11771 ; 11772 if (!forward_body_data(conn, file.access.fp, INVALID_SOCKET, NULL)) {; 11773 /* forward_body_data failed.; 11774 * The error code has already been sent to the client,; 11775 * and conn->status_code is already set. */; 11776 (void)mg_fclose(&file.access);; 11777 return;; 11778 }; 11779 ; 11780 if (mg_fclose(&file.access) != 0) {; 11781 /* fclose failed. This might have different reasons, but a likely; 11782 * one is ""no space on disk"", http 507. */; 11783 conn->status_code = 507;; 11784 }; 11785 ; 11786 /* Create response (status_code has been set before) */; 11787 mg_response_header_start(conn, conn->status_code);; 11788 send_no_cache_header(conn);; 11789 send_additional_header(conn);; 11790 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11791 ; 11792 /* Send all headers - there is no body */; 11793 mg_response_header_send(conn);; 11794}; 11795 ; 11796 ; 11797static void; 11798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 11802 if (!mg_stat(conn, path, &de.file)) {; 11803 /* mg_stat returns 0 if the file does not exist */; 11804 mg_send_http_error(conn,; 11805 404,; 11806 ""Error: Cannot delete file\nFile %s not found"",; 11807 path);; 11808 return;; 11809 }; 11810 ; 11811 if (de.file.is_directory) {; 11812 if (remove_",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:342353,Security,access,access,342353,"798delete_file(struct mg_connection *conn, const char *path); 11799{; 11800 struct de de;; 11801 memset(&de.file, 0, sizeof(de.file));; 11802 if (!mg_stat(conn, path, &de.file)) {; 11803 /* mg_stat returns 0 if the file does not exist */; 11804 mg_send_http_error(conn,; 11805 404,; 11806 ""Error: Cannot delete file\nFile %s not found"",; 11807 path);; 11808 return;; 11809 }; 11810 ; 11811 if (de.file.is_directory) {; 11812 if (remove_directory(conn, path)) {; 11813 /* Delete is successful: Return 204 without content. */; 11814 mg_send_http_error(conn, 204, ""%s"", """");; 11815 } else {; 11816 /* Delete is not successful: Return 500 (Server error). */; 11817 mg_send_http_error(conn, 500, ""Error: Could not delete %s"", path);; 11818 }; 11819 return;; 11820 }; 11821 ; 11822 /* This is an existing file (not a directory).; 11823 * Check if write permission is granted. */; 11824 if (access(path, W_OK) != 0) {; 11825 /* File is read only */; 11826 mg_send_http_error(; 11827 conn,; 11828 403,; 11829 ""Error: Delete not possible\nDeleting %s is not allowed"",; 11830 path);; 11831 return;; 11832 }; 11833 ; 11834 /* Try to delete it. */; 11835 if (mg_remove(conn, path) == 0) {; 11836 /* Delete was successful: Return 204 without content. */; 11837 mg_response_header_start(conn, 204);; 11838 send_no_cache_header(conn);; 11839 send_additional_header(conn);; 11840 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11841 mg_response_header_send(conn);; 11842 ; 11843 } else {; 11844 /* Delete not successful (file locked). */; 11845 mg_send_http_error(conn,; 11846 423,; 11847 ""Error: Cannot delete file\nremove(%s): %s"",; 11848 path,; 11849 strerror(ERRNO));; 11850 }; 11851}; 11852#endif /* !NO_FILES */; 11853 ; 11854 ; 11855#if !defined(NO_FILESYSTEMS); 11856static void; 11857send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int);; 11858 ; 11859 ; 11860static void; 11861do_ssi_include(struct mg_connection *conn,; 11862 const char *ssi,; 11863 char *tag,; 11864 int i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:345566,Security,access,access,345566,"1899 file_name[511] = 0;; 11900 (void)mg_snprintf(conn, &truncated, path, sizeof(path), ""%s"", ssi);; 11901 ; 11902 if (!truncated) {; 11903 if ((p = strrchr(path, '/')) != NULL) {; 11904 p[1] = '\0';; 11905 }; 11906 len = strlen(path);; 11907 (void)mg_snprintf(conn,; 11908 &truncated,; 11909 path + len,; 11910 sizeof(path) - len,; 11911 ""%s"",; 11912 file_name);; 11913 }; 11914 ; 11915 } else {; 11916 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11917 return;; 11918 }; 11919 ; 11920 if (truncated) {; 11921 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:345835,Security,access,access,345835,"e);; 11913 }; 11914 ; 11915 } else {; 11916 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11917 return;; 11918 }; 11919 ; 11920 if (truncated) {; 11921 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:346286,Security,access,access,346286,");; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 int ch, len, in_tag, in_ssi_tag;; 11992 ; 11993 if (include_level > 10) {; 11994 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11995 return;; 11996 }; 11997 ; 11998 in_tag = in_ssi_tag = len = 0;; 11999 ; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:346514,Security,access,access,346514,"O));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 int ch, len, in_tag, in_ssi_tag;; 11992 ; 11993 if (include_level > 10) {; 11994 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11995 return;; 11996 }; 11997 ; 11998 in_tag = in_ssi_tag = len = 0;; 11999 ; 12000 /* Read file, byte by byte, and look for SSI include tags */; 12001 while ((ch = mg_fgetc(filep)) != EOF) {; 12002 ; 12003 if (in_tag) {; 12004 /* We are in a tag, either SSI tag or html tag */; 12005 ; 12006 if (ch == '>')",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:346742,Security,access,access,346742,"SI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 int ch, len, in_tag, in_ssi_tag;; 11992 ; 11993 if (include_level > 10) {; 11994 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11995 return;; 11996 }; 11997 ; 11998 in_tag = in_ssi_tag = len = 0;; 11999 ; 12000 /* Read file, byte by byte, and look for SSI include tags */; 12001 while ((ch = mg_fgetc(filep)) != EOF) {; 12002 ; 12003 if (in_tag) {; 12004 /* We are in a tag, either SSI tag or html tag */; 12005 ; 12006 if (ch == '>') {; 12007 /* Tag is closing */; 12008 buf[len++] = '>';; 12009 ; 12010 if (in_ssi_tag) {; 12011 /* Handle SSI tag */;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:346790,Security,access,access,346790,", &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 int ch, len, in_tag, in_ssi_tag;; 11992 ; 11993 if (include_level > 10) {; 11994 mg_cry_internal(conn, ""SSI #include level is too deep (%s)"", path);; 11995 return;; 11996 }; 11997 ; 11998 in_tag = in_ssi_tag = len = 0;; 11999 ; 12000 /* Read file, byte by byte, and look for SSI include tags */; 12001 while ((ch = mg_fgetc(filep)) != EOF) {; 12002 ; 12003 if (in_tag) {; 12004 /* We are in a tag, either SSI tag or html tag */; 12005 ; 12006 if (ch == '>') {; 12007 /* Tag is closing */; 12008 buf[len++] = '>';; 12009 ; 12010 if (in_ssi_tag) {; 12011 /* Handle SSI tag */; 12012 buf[len] = 0;; 12013 ; 12014 if ((len > 12) && !memcmp(buf + 5, ""include"", 7)) {; 12015 do_ssi_include(conn, path, buf + 12, includ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:351110,Security,access,access,351110,"als"";; 12117 cors4 = cors_cred_cfg;; 12118 } else {; 12119 cors3 = cors4 = """";; 12120 }; 12121 ; 12122 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12123 /* File exists (precondition for calling this function),; 12124 * but can not be opened by the server. */; 12125 mg_send_http_error(conn,; 12126 500,; 12127 ""Error: Cannot read file\nfopen(%s): %s"",; 12128 path,; 12129 strerror(ERRNO));; 12130 } else {; 12131 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12132 * content length */; 12133 conn->must_close = 1;; 12134 gmt_time_string(date, sizeof(date), &curtime);; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12144 }; 12145 if (cors3[0]) {; 12146 mg_response_header_add(conn, cors3, cors4, -1);; 12147 }; 12148 mg_response_header_send(conn);; 12149 ; 12150 /* Header sent, now send body */; 12151 send_ssi_file(conn, path, filep, 0);; 12152 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12153 }; 12154}; 12155#endif /* NO_FILESYSTEMS */; 12156 ; 12157 ; 12158#if !defined(NO_FILES); 12159static void; 12160send_options(struct mg_connection *conn); 12161{; 12162 if (!conn) {; 12163 return;; 12164 }; 12165 ; 12166 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12167 * Since browsers do not send an OPTIONS request, we can not test the; 12168 * effect anyway. */; 12169 ; 12170 mg_response_header_start(conn, 200);; 12171 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12172 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12173 /* Use the same as before */; 12174 mg_response_header_add(; 12175 conn,; 12176 ""Allow"",; 12177 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:351683,Security,access,access,351683,"als"";; 12117 cors4 = cors_cred_cfg;; 12118 } else {; 12119 cors3 = cors4 = """";; 12120 }; 12121 ; 12122 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12123 /* File exists (precondition for calling this function),; 12124 * but can not be opened by the server. */; 12125 mg_send_http_error(conn,; 12126 500,; 12127 ""Error: Cannot read file\nfopen(%s): %s"",; 12128 path,; 12129 strerror(ERRNO));; 12130 } else {; 12131 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12132 * content length */; 12133 conn->must_close = 1;; 12134 gmt_time_string(date, sizeof(date), &curtime);; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12144 }; 12145 if (cors3[0]) {; 12146 mg_response_header_add(conn, cors3, cors4, -1);; 12147 }; 12148 mg_response_header_send(conn);; 12149 ; 12150 /* Header sent, now send body */; 12151 send_ssi_file(conn, path, filep, 0);; 12152 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12153 }; 12154}; 12155#endif /* NO_FILESYSTEMS */; 12156 ; 12157 ; 12158#if !defined(NO_FILES); 12159static void; 12160send_options(struct mg_connection *conn); 12161{; 12162 if (!conn) {; 12163 return;; 12164 }; 12165 ; 12166 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12167 * Since browsers do not send an OPTIONS request, we can not test the; 12168 * effect anyway. */; 12169 ; 12170 mg_response_header_start(conn, 200);; 12171 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12172 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12173 /* Use the same as before */; 12174 mg_response_header_add(; 12175 conn,; 12176 ""Allow"",; 12177 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:390318,Security,validat,validation,390318,"3313 if (sscanf(vec->ptr, ""[%49[^]]]%n"", ad, &n) != 1) {; 13314 n = 0;; 13315 }; 13316 }; 13317 ; 13318 if ((n <= 0) && no_strict) {; 13319 /* no square brackets? */; 13320 p = strchr(vec->ptr, '/');; 13321 if (p && (p < (vec->ptr + vec->len))) {; 13322 if (((size_t)(p - vec->ptr) < sizeof(ad)); 13323 && (sscanf(p, ""/%u%n"", &slash, &n) == 1)) {; 13324 n += (int)(p - vec->ptr);; 13325 mg_strlcpy(ad, vec->ptr, (size_t)(p - vec->ptr) + 1);; 13326 } else {; 13327 n = 0;; 13328 }; 13329 } else if (vec->len < sizeof(ad)) {; 13330 n = (int)vec->len;; 13331 slash = 128;; 13332 mg_strlcpy(ad, vec->ptr, vec->len + 1);; 13333 }; 13334 }; 13335 ; 13336 if ((n > 0) && ((size_t)n == vec->len) && (slash < 129)) {; 13337 p = ad;; 13338 c = 0;; 13339 /* zone indexes are unsupported, at least two colons are needed */; 13340 while (isxdigit((unsigned char)*p) || (*p == '.') || (*p == ':')) {; 13341 if (*(p++) == ':') {; 13342 c++;; 13343 }; 13344 }; 13345 if ((*p == '\0') && (c >= 2)) {; 13346 struct sockaddr_in6 sin6;; 13347 unsigned int i;; 13348 ; 13349 /* for strict validation, an actual IPv6 argument is needed */; 13350 if (sa->sa.sa_family != AF_INET6) {; 13351 return 0;; 13352 }; 13353 if (mg_inet_pton(AF_INET6, ad, &sin6, sizeof(sin6), 0)) {; 13354 /* IPv6 format */; 13355 for (i = 0; i < 16; i++) {; 13356 uint8_t ip = sa->sin6.sin6_addr.s6_addr[i];; 13357 uint8_t net = sin6.sin6_addr.s6_addr[i];; 13358 uint8_t mask = 0;; 13359 ; 13360 if (8 * i + 8 < slash) {; 13361 mask = 0xFFu;; 13362 } else if (8 * i < slash) {; 13363 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13364 }; 13365 if ((ip & mask) != net) {; 13366 return 0;; 13367 }; 13368 }; 13369 return 1;; 13370 }; 13371 }; 13372 }; 13373 }; 13374#else; 13375 (void)no_strict;; 13376#endif; 13377 ; 13378 /* malformed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 ch",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:409950,Security,validat,validated,409950," assume ""OK"" */; 13977 return 1;; 13978}; 13979 ; 13980 ; 13981static void; 13982experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13983 void *cbdata); 13984{; 13985 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13986 if (pcallbacks->connection_close) {; 13987 pcallbacks->connection_close(conn);; 13988 }; 13989}; 13990#endif; 13991 ; 13992 ; 13993/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13994 */; 13995static void; 13996release_handler_ref(struct mg_connection *conn,; 13997 struct mg_handler_info *handler_info); 13998{; 13999 if (handler_info != NULL) {; 14000 /* Use context lock for ref counter */; 14001 mg_lock_context(conn->phys_ctx);; 14002 handler_info->refcount--;; 14003 mg_unlock_context(conn->phys_ctx);; 14004 }; 14005}; 14006 ; 14007 ; 14008/* This is the heart of the Civetweb's logic.; 14009 * This function is called when the request is read, parsed and validated,; 14010 * and Civetweb must decide what action to take: serve a file, or; 14011 * a directory, or call embedded function, etcetera. */; 14012static void; 14013handle_request(struct mg_connection *conn); 14014{; 14015 struct mg_request_info *ri = &conn->request_info;; 14016 char path[UTF8_PATH_MAX];; 14017 int uri_len, ssl_index;; 14018 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14019 is_put_or_delete_request = 0, is_callback_resource = 0,; 14020 is_template_text_file = 0;; 14021 int i;; 14022 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14023 mg_request_handler callback_handler = NULL;; 14024 struct mg_handler_info *handler_info = NULL;; 14025 struct mg_websocket_subprotocols *subprotocols;; 14026 mg_websocket_connect_handler ws_connect_handler = NULL;; 14027 mg_websocket_ready_handler ws_ready_handler = NULL;; 14028 mg_websocket_data_handler ws_data_handler = NULL;; 14029 mg_websocket_close_handler ws_close_handler = NULL;; 14030 void *callback_data = NULL;; 14031 mg_authorization",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:413994,Security,authoriz,authorization,413994,"the; 14087 * pointer to ri->local_ur and ri->local_uri_raw are now different.; 14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a respo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:414021,Security,authoriz,authorization,414021,"14088 * ri->local_uri_raw still points to memory allocated in; 14089 * worker_thread_run(). ri->local_uri is private to the request so we; 14090 * don't have to use preallocated memory here. */; 14091 tmp = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:414280,Security,access,access,414280," = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_or",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:419349,Security,authoriz,authorization,419349,"ols,; 14228 &ws_connect_handler,; 14229 &ws_ready_handler,; 14230 &ws_data_handler,; 14231 &ws_close_handler,; 14232 NULL,; 14233 &callback_data,; 14234 &handler_info)) {; 14235 /* 5.2.1. A callback will handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script_resource = 1;; 14240 is_put_or_delete_request = is_put_or_delete_method(conn);; 14241 } else {; 14242 no_callback_resource:; 14243 ; 14244 /* 5.2.2. No callback is responsible for this request. The URI; 14245 * addresses a file based resource (static content or Lua/cgi; 14246 * scripts in the file system). */; 14247 is_callback_resource = 0;; 14248 interpret_uri(conn,; 14249 path,; 14250 sizeof(path),; 14251 &file.stat,; 14252 &is_found,; 14253 &is_script_resource,; 14254 &is_websocket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not hav",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:419396,Security,authoriz,authorization,419396,"l handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script_resource = 1;; 14240 is_put_or_delete_request = is_put_or_delete_method(conn);; 14241 } else {; 14242 no_callback_resource:; 14243 ; 14244 /* 5.2.2. No callback is responsible for this request. The URI; 14245 * addresses a file based resource (static content or Lua/cgi; 14246 * scripts in the file system). */; 14247 is_callback_resource = 0;; 14248 interpret_uri(conn,; 14249 path,; 14250 sizeof(path),; 14251 &file.stat,; 14252 &is_found,; 14253 &is_script_resource,; 14254 &is_websocket_request,; 14255 &is_put_or_delete_request,; 14256 &is_template_text_file);; 14257 }; 14258 ; 14259 /* 6. authorization check */; 14260 /* 6.1. a custom authorization handler is installed */; 14261 if (get_request_handler(conn,; 14262 AUTH_HANDLER,; 14263 NULL,; 14264 NULL,; 14265 NULL,; 14266 NULL,; 14267 NULL,; 14268 NULL,; 14269 &auth_handler,; 14270 &auth_callback_data,; 14271 NULL)) {; 14272 if (!auth_handler(conn, auth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 ret",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:420649,Security,authoriz,authorization,420649,"uth_callback_data)) {; 14273 ; 14274 /* Callback handler will not be used anymore. Release it */; 14275 release_handler_ref(conn, handler_info);; 14276 ; 14277 return;; 14278 }; 14279 } else if (is_put_or_delete_request && !is_script_resource; 14280 && !is_callback_resource) {; 14281 HTTP1_only;; 14282 /* 6.2. this request is a PUT/DELETE to a real file */; 14283 /* 6.2.1. thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Releas",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:421039,Security,authoriz,authorization,421039,". thus, the server must have real files */; 14284#if defined(NO_FILES); 14285 if (1) {; 14286#else; 14287 if (conn->dom_ctx->config[DOCUMENT_ROOT] == NULL) {; 14288#endif; 14289 /* This code path will not be called for request handlers */; 14290 DEBUG_ASSERT(handler_info == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(con",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:421344,Security,authoriz,authorized,421344,"nfo == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:421372,Security,authoriz,authorization,421372,"nfo == NULL);; 14291 ; 14292 /* This server does not have any real files, thus the; 14293 * PUT/DELETE methods are not valid. */; 14294 mg_send_http_error(conn,; 14295 405,; 14296 ""%s method not allowed"",; 14297 conn->request_info.request_method);; 14298 return;; 14299 }; 14300 ; 14301#if !defined(NO_FILES); 14302 /* 6.2.2. Check if put authorization for static files is; 14303 * available.; 14304 */; 14305 if (!is_authorized_for_put(conn)) {; 14306 send_authorization_request(conn, NULL);; 14307 return;; 14308 }; 14309#endif; 14310 ; 14311 } else {; 14312 /* 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:422793,Security,authoriz,authorization,422793,"35 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI; 14350 * It would be possible to do a, b or c in the callback; 14351 * implementation, and return 1 - we cannot do anything; 14352 * here, that is not possible in the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 path,; 14364 sizeof(path),; 14365 &file.stat,; 14366 &is_found,; 14367 &is_script_resource,; 14368 &is_websocket_request,; 14369 &is_put_or_delete_request,; 14370 &is_template_text_file);; 14371 callback_handler = NULL;; 14372 ; 14373 /* Here we are at a dead end:; 14374 * According to URI matching, a callback should be; 14375 * responsible for handling the request,; 14376 * we called it, but the callback declared itself; 14377 * not responsible.; 14378 * We use a goto here, to get out of this dead end,; 14379 * and continue with the default handling.; 14380 * A goto here is simpler and better to understand; 14381 * than some curious loop. */; 14382 goto no_callback_resource;; 14383 }; 14384 } else {; 14385#if defined(USE_WEBSOCKET); 14386 handle_websocket_request(conn,; 14387 path,; 14388 is_callback_resource,; 14389 subprotocols,; 14390 ws_conne",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:428363,Security,access,access,428363,"od, ""PROPFIND"")) {; 14511 handle_propfind(conn, path, &file.stat);; 14512 return;; 14513 }; 14514 /* 13.2. Handle OPTIONS for files */; 14515 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14516 /* This standard handler is only used for real files.; 14517 * Scripts should support the OPTIONS method themselves, to allow a; 14518 * maximum flexibility.; 14519 * Lua and CGI scripts may fully support CORS this way (including; 14520 * preflights). */; 14521 send_options(conn);; 14522 return;; 14523 }; 14524 /* 13.3. everything but GET and HEAD (e.g. POST) */; 14525 if ((0 != strcmp(ri->request_method, ""GET"")); 14526 && (0 != strcmp(ri->request_method, ""HEAD""))) {; 14527 mg_send_http_error(conn,; 14528 405,; 14529 ""%s method not allowed"",; 14530 conn->request_info.request_method);; 14531 return;; 14532 }; 14533 ; 14534 /* 14. directories */; 14535 if (file.stat.is_directory) {; 14536 /* Substitute files have already been handled above. */; 14537 /* Here we can either generate and send a directory listing,; 14538 * or send an ""access denied"" error. */; 14539 if (!mg_strcasecmp(conn->dom_ctx->config[ENABLE_DIRECTORY_LISTING],; 14540 ""yes"")) {; 14541 handle_directory_request(conn, path);; 14542 } else {; 14543 mg_send_http_error(conn,; 14544 403,; 14545 ""%s"",; 14546 ""Error: Directory listing denied"");; 14547 }; 14548 return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &fil",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453843,Security,access,access,453843,"returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453896,Security,access,access,453896,"lock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_bu",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:454082,Security,access,access,454082,"olstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:454850,Security,access,access,454850,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455641,Security,access,access,455641,"sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 1544",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455675,Security,access,access,455675,");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455775,Security,access,access,455775,";; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCE",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455827,Security,access,access,455827,"gnore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is se",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455861,Security,access,access,455861," 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allow",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455941,Security,access,access,455941,"\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:456006,Security,access,access,456006,"remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:456043,Security,access,access,456043,": """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched = -1;; 15457 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15458 vec.ptr++;; 15459 vec.len--;; 15460 matched = parse_match_net(&vec, sa, 1);; 15461 }; 15462 if (matched < 0) {; 15463 mg_cry_ctx_internal(phys_ctx,; 15464 ""%s: su",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:477174,Security,certificate,certificate,477174,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16121 ; 16122#if !defined(NO_SSL_DL); 16123 if (!ssllib_dll_handle) {; 16124 ssllib_dll_handle =; 16125 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16126 if (!ssllib_dll_handle) {; 16127#if !defined(OPENSSL_API_1_1); 16128 mg_free(ssl_mutexes);; 16129#endif; 16130 DEBUG_TRACE(""%s"", ebuf);; 16131 return 0;; 16132 }; 16133 }; 16134#endif /* NO_SSL_DL */; 16135 ; 16136#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16137 && !defined(NO_SSL_DL); 16138 /* Initialize SSL library */; 16139 OPENSSL_init_ssl(0, NULL);; 16140 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16141 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16142 NULL);; 16143#else; 16144 /* Initialize SSL library */; 16145 SSL_library_init();; 16146 SSL_load_error_strings();; 16147#endif; 16148 ; 16149 return 1;; 16150}; 16151 ; 16152 ; 16153static int; 16154ssl_use_pem_file(struct mg_context *phys_ctx,; 16155 struct mg_domain_context *dom_ctx,; 16156 const char *pem,; 16157 const char *chain); 16158{; 16159 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16160 mg_cry_ctx_internal(phys_ctx,; 16161 ""%s: cannot open certificate file %s: %s"",; 16162 __func__,; 16163 pem,; 16164 ssl_error());; 16165 return 0;; 16166 }; 16167 ; 16168 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16169 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16170 mg_cry_ctx_internal(phys_ctx,; 16171 ""%s: cannot open private key file %s: %s"",; 16172 __func__,; 16173 pem,; 16174 ssl_error());; 16175 return 0;; 16176 }; 16177 ; 16178 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16179 mg_cry_ctx_internal(phys_ctx,; 16180 ""%s: certificate and private key do not match: %s"",; 16181 __func__,; 16182 pem);; 16183 return 0;; 16184 }; 16185 ; 16186 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16187 * chain files that contain private keys and certificates in; 16188 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:477702,Security,certificate,certificate,477702,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16121 ; 16122#if !defined(NO_SSL_DL); 16123 if (!ssllib_dll_handle) {; 16124 ssllib_dll_handle =; 16125 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16126 if (!ssllib_dll_handle) {; 16127#if !defined(OPENSSL_API_1_1); 16128 mg_free(ssl_mutexes);; 16129#endif; 16130 DEBUG_TRACE(""%s"", ebuf);; 16131 return 0;; 16132 }; 16133 }; 16134#endif /* NO_SSL_DL */; 16135 ; 16136#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16137 && !defined(NO_SSL_DL); 16138 /* Initialize SSL library */; 16139 OPENSSL_init_ssl(0, NULL);; 16140 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16141 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16142 NULL);; 16143#else; 16144 /* Initialize SSL library */; 16145 SSL_library_init();; 16146 SSL_load_error_strings();; 16147#endif; 16148 ; 16149 return 1;; 16150}; 16151 ; 16152 ; 16153static int; 16154ssl_use_pem_file(struct mg_context *phys_ctx,; 16155 struct mg_domain_context *dom_ctx,; 16156 const char *pem,; 16157 const char *chain); 16158{; 16159 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16160 mg_cry_ctx_internal(phys_ctx,; 16161 ""%s: cannot open certificate file %s: %s"",; 16162 __func__,; 16163 pem,; 16164 ssl_error());; 16165 return 0;; 16166 }; 16167 ; 16168 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16169 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16170 mg_cry_ctx_internal(phys_ctx,; 16171 ""%s: cannot open private key file %s: %s"",; 16172 __func__,; 16173 pem,; 16174 ssl_error());; 16175 return 0;; 16176 }; 16177 ; 16178 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16179 mg_cry_ctx_internal(phys_ctx,; 16180 ""%s: certificate and private key do not match: %s"",; 16181 __func__,; 16182 pem);; 16183 return 0;; 16184 }; 16185 ; 16186 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16187 * chain files that contain private keys and certificates in; 16188 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:477872,Security,certificate,certificate,477872,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16121 ; 16122#if !defined(NO_SSL_DL); 16123 if (!ssllib_dll_handle) {; 16124 ssllib_dll_handle =; 16125 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16126 if (!ssllib_dll_handle) {; 16127#if !defined(OPENSSL_API_1_1); 16128 mg_free(ssl_mutexes);; 16129#endif; 16130 DEBUG_TRACE(""%s"", ebuf);; 16131 return 0;; 16132 }; 16133 }; 16134#endif /* NO_SSL_DL */; 16135 ; 16136#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16137 && !defined(NO_SSL_DL); 16138 /* Initialize SSL library */; 16139 OPENSSL_init_ssl(0, NULL);; 16140 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16141 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16142 NULL);; 16143#else; 16144 /* Initialize SSL library */; 16145 SSL_library_init();; 16146 SSL_load_error_strings();; 16147#endif; 16148 ; 16149 return 1;; 16150}; 16151 ; 16152 ; 16153static int; 16154ssl_use_pem_file(struct mg_context *phys_ctx,; 16155 struct mg_domain_context *dom_ctx,; 16156 const char *pem,; 16157 const char *chain); 16158{; 16159 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16160 mg_cry_ctx_internal(phys_ctx,; 16161 ""%s: cannot open certificate file %s: %s"",; 16162 __func__,; 16163 pem,; 16164 ssl_error());; 16165 return 0;; 16166 }; 16167 ; 16168 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16169 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16170 mg_cry_ctx_internal(phys_ctx,; 16171 ""%s: cannot open private key file %s: %s"",; 16172 __func__,; 16173 pem,; 16174 ssl_error());; 16175 return 0;; 16176 }; 16177 ; 16178 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16179 mg_cry_ctx_internal(phys_ctx,; 16180 ""%s: certificate and private key do not match: %s"",; 16181 __func__,; 16182 pem);; 16183 return 0;; 16184 }; 16185 ; 16186 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16187 * chain files that contain private keys and certificates in; 16188 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:477935,Security,certificate,certificates,477935,"* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16121 ; 16122#if !defined(NO_SSL_DL); 16123 if (!ssllib_dll_handle) {; 16124 ssllib_dll_handle =; 16125 load_tls_dll(ebuf, ebuf_len, SSL_LIB, ssl_sw, tls_feature_missing);; 16126 if (!ssllib_dll_handle) {; 16127#if !defined(OPENSSL_API_1_1); 16128 mg_free(ssl_mutexes);; 16129#endif; 16130 DEBUG_TRACE(""%s"", ebuf);; 16131 return 0;; 16132 }; 16133 }; 16134#endif /* NO_SSL_DL */; 16135 ; 16136#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16137 && !defined(NO_SSL_DL); 16138 /* Initialize SSL library */; 16139 OPENSSL_init_ssl(0, NULL);; 16140 OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS; 16141 | OPENSSL_INIT_LOAD_CRYPTO_STRINGS,; 16142 NULL);; 16143#else; 16144 /* Initialize SSL library */; 16145 SSL_library_init();; 16146 SSL_load_error_strings();; 16147#endif; 16148 ; 16149 return 1;; 16150}; 16151 ; 16152 ; 16153static int; 16154ssl_use_pem_file(struct mg_context *phys_ctx,; 16155 struct mg_domain_context *dom_ctx,; 16156 const char *pem,; 16157 const char *chain); 16158{; 16159 if (SSL_CTX_use_certificate_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16160 mg_cry_ctx_internal(phys_ctx,; 16161 ""%s: cannot open certificate file %s: %s"",; 16162 __func__,; 16163 pem,; 16164 ssl_error());; 16165 return 0;; 16166 }; 16167 ; 16168 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16169 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16170 mg_cry_ctx_internal(phys_ctx,; 16171 ""%s: cannot open private key file %s: %s"",; 16172 __func__,; 16173 pem,; 16174 ssl_error());; 16175 return 0;; 16176 }; 16177 ; 16178 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16179 mg_cry_ctx_internal(phys_ctx,; 16180 ""%s: certificate and private key do not match: %s"",; 16181 __func__,; 16182 pem);; 16183 return 0;; 16184 }; 16185 ; 16186 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16187 * chain files that contain private keys and certificates in; 16188 * SSL_CTX_use_certificate_chain_file.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:478179,Security,certificate,certificate,478179,"16162 __func__,; 16163 pem,; 16164 ssl_error());; 16165 return 0;; 16166 }; 16167 ; 16168 /* could use SSL_CTX_set_default_passwd_cb_userdata */; 16169 if (SSL_CTX_use_PrivateKey_file(dom_ctx->ssl_ctx, pem, 1) == 0) {; 16170 mg_cry_ctx_internal(phys_ctx,; 16171 ""%s: cannot open private key file %s: %s"",; 16172 __func__,; 16173 pem,; 16174 ssl_error());; 16175 return 0;; 16176 }; 16177 ; 16178 if (SSL_CTX_check_private_key(dom_ctx->ssl_ctx) == 0) {; 16179 mg_cry_ctx_internal(phys_ctx,; 16180 ""%s: certificate and private key do not match: %s"",; 16181 __func__,; 16182 pem);; 16183 return 0;; 16184 }; 16185 ; 16186 /* In contrast to OpenSSL, wolfSSL does not support certificate; 16187 * chain files that contain private keys and certificates in; 16188 * SSL_CTX_use_certificate_chain_file.; 16189 * The CivetWeb-Server used pem-Files that contained both information.; 16190 * In order to make wolfSSL work, it is split in two files.; 16191 * One file that contains key and certificate used by the server and; 16192 * an optional chain file for the ssl stack.; 16193 */; 16194 if (chain) {; 16195 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16196 mg_cry_ctx_internal(phys_ctx,; 16197 ""%s: cannot use certificate chain file %s: %s"",; 16198 __func__,; 16199 chain,; 16200 ssl_error());; 16201 return 0;; 16202 }; 16203 }; 16204 return 1;; 16205}; 16206 ; 16207 ; 16208#if defined(OPENSSL_API_1_1); 16209static unsigned long; 16210ssl_get_protocol(int version_id); 16211{; 16212 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16213 if (version_id > 0); 16214 ret |= SSL_OP_NO_SSLv2;; 16215 if (version_id > 1); 16216 ret |= SSL_OP_NO_SSLv3;; 16217 if (version_id > 2); 16218 ret |= SSL_OP_NO_TLSv1;; 16219 if (version_id > 3); 16220 ret |= SSL_OP_NO_TLSv1_1;; 16221 if (version_id > 4); 16222 ret |= SSL_OP_NO_TLSv1_2;; 16223#if defined(SSL_OP_NO_TLSv1_3); 16224 if (version_id > 5); 16225 ret |= SSL_OP_NO_TLSv1_3;; 16226#endif; 16227 return ret;; 16228}; 16229#else; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:478434,Security,certificate,certificate,478434,"rmation.; 16190 * In order to make wolfSSL work, it is split in two files.; 16191 * One file that contains key and certificate used by the server and; 16192 * an optional chain file for the ssl stack.; 16193 */; 16194 if (chain) {; 16195 if (SSL_CTX_use_certificate_chain_file(dom_ctx->ssl_ctx, chain) == 0) {; 16196 mg_cry_ctx_internal(phys_ctx,; 16197 ""%s: cannot use certificate chain file %s: %s"",; 16198 __func__,; 16199 chain,; 16200 ssl_error());; 16201 return 0;; 16202 }; 16203 }; 16204 return 1;; 16205}; 16206 ; 16207 ; 16208#if defined(OPENSSL_API_1_1); 16209static unsigned long; 16210ssl_get_protocol(int version_id); 16211{; 16212 long unsigned ret = (long unsigned)SSL_OP_ALL;; 16213 if (version_id > 0); 16214 ret |= SSL_OP_NO_SSLv2;; 16215 if (version_id > 1); 16216 ret |= SSL_OP_NO_SSLv3;; 16217 if (version_id > 2); 16218 ret |= SSL_OP_NO_TLSv1;; 16219 if (version_id > 3); 16220 ret |= SSL_OP_NO_TLSv1_1;; 16221 if (version_id > 4); 16222 ret |= SSL_OP_NO_TLSv1_2;; 16223#if defined(SSL_OP_NO_TLSv1_3); 16224 if (version_id > 5); 16225 ret |= SSL_OP_NO_TLSv1_3;; 16226#endif; 16227 return ret;; 16228}; 16229#else; 16230static long; 16231ssl_get_protocol(int version_id); 16232{; 16233 unsigned long ret = (unsigned long)SSL_OP_ALL;; 16234 if (version_id > 0); 16235 ret |= SSL_OP_NO_SSLv2;; 16236 if (version_id > 1); 16237 ret |= SSL_OP_NO_SSLv3;; 16238 if (version_id > 2); 16239 ret |= SSL_OP_NO_TLSv1;; 16240 if (version_id > 3); 16241 ret |= SSL_OP_NO_TLSv1_1;; 16242 if (version_id > 4); 16243 ret |= SSL_OP_NO_TLSv1_2;; 16244#if defined(SSL_OP_NO_TLSv1_3); 16245 if (version_id > 5); 16246 ret |= SSL_OP_NO_TLSv1_3;; 16247#endif; 16248 return (long)ret;; 16249}; 16250#endif /* OPENSSL_API_1_1 */; 16251 ; 16252 ; 16253/* SSL callback documentation:; 16254 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16255 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16256 * https://linux.die.net/man/3/ssl_set_info_callback */; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:481930,Security,certificate,certificate,481930,"IATE_CIPHERS;; 16275 }; 16276}; 16277 ; 16278 ; 16279static int; 16280ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16281{; 16282#if defined(GCC_DIAGNOSTIC); 16283#pragma GCC diagnostic push; 16284#pragma GCC diagnostic ignored ""-Wcast-align""; 16285#endif /* defined(GCC_DIAGNOSTIC) */; 16286 ; 16287 /* We used an aligned pointer in SSL_set_app_data */; 16288 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);; 16289 ; 16290#if defined(GCC_DIAGNOSTIC); 16291#pragma GCC diagnostic pop; 16292#endif /* defined(GCC_DIAGNOSTIC) */; 16293 ; 16294 const char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);; 16295 ; 16296 (void)ad;; 16297 (void)arg;; 16298 ; 16299 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16300 DEBUG_ASSERT(0);; 16301 return SSL_TLSEXT_ERR_NOACK;; 16302 }; 16303 conn->dom_ctx = &(conn->phys_ctx->dd);; 16304 ; 16305 /* Old clients (Win XP) will not support SNI. Then, there; 16306 * is no server name available in the request - we can; 16307 * only work with the default certificate.; 16308 * Multiple HTTPS hosts on one IP+port are only possible; 16309 * with a certificate containing all alternative names.; 16310 */; 16311 if ((servername == NULL) || (*servername == 0)) {; 16312 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16313 mg_lock_context(conn->phys_ctx);; 16314 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16315 mg_unlock_context(conn->phys_ctx);; 16316 return SSL_TLSEXT_ERR_NOACK;; 16317 }; 16318 ; 16319 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16320 ; 16321 while (conn->dom_ctx) {; 16322 if (!mg_strcasecmp(servername,; 16323 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16324 /* Found matching domain */; 16325 DEBUG_TRACE(""TLS domain %s found"",; 16326 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16327 break;; 16328 }; 16329 mg_lock_context(conn->phys_ctx);; 16330 conn->dom_ctx = conn->dom_ctx->next;; 16331 mg_unlock_context(conn->phys_ctx);; 16332 }; 16333 ; 163",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:482022,Security,certificate,certificate,482022,"; 16281{; 16282#if defined(GCC_DIAGNOSTIC); 16283#pragma GCC diagnostic push; 16284#pragma GCC diagnostic ignored ""-Wcast-align""; 16285#endif /* defined(GCC_DIAGNOSTIC) */; 16286 ; 16287 /* We used an aligned pointer in SSL_set_app_data */; 16288 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data(ssl);; 16289 ; 16290#if defined(GCC_DIAGNOSTIC); 16291#pragma GCC diagnostic pop; 16292#endif /* defined(GCC_DIAGNOSTIC) */; 16293 ; 16294 const char *servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);; 16295 ; 16296 (void)ad;; 16297 (void)arg;; 16298 ; 16299 if ((conn == NULL) || (conn->phys_ctx == NULL)) {; 16300 DEBUG_ASSERT(0);; 16301 return SSL_TLSEXT_ERR_NOACK;; 16302 }; 16303 conn->dom_ctx = &(conn->phys_ctx->dd);; 16304 ; 16305 /* Old clients (Win XP) will not support SNI. Then, there; 16306 * is no server name available in the request - we can; 16307 * only work with the default certificate.; 16308 * Multiple HTTPS hosts on one IP+port are only possible; 16309 * with a certificate containing all alternative names.; 16310 */; 16311 if ((servername == NULL) || (*servername == 0)) {; 16312 DEBUG_TRACE(""%s"", ""SSL connection not supporting SNI"");; 16313 mg_lock_context(conn->phys_ctx);; 16314 SSL_set_SSL_CTX(ssl, conn->dom_ctx->ssl_ctx);; 16315 mg_unlock_context(conn->phys_ctx);; 16316 return SSL_TLSEXT_ERR_NOACK;; 16317 }; 16318 ; 16319 DEBUG_TRACE(""TLS connection to host %s"", servername);; 16320 ; 16321 while (conn->dom_ctx) {; 16322 if (!mg_strcasecmp(servername,; 16323 conn->dom_ctx->config[AUTHENTICATION_DOMAIN])) {; 16324 /* Found matching domain */; 16325 DEBUG_TRACE(""TLS domain %s found"",; 16326 conn->dom_ctx->config[AUTHENTICATION_DOMAIN]);; 16327 break;; 16328 }; 16329 mg_lock_context(conn->phys_ctx);; 16330 conn->dom_ctx = conn->dom_ctx->next;; 16331 mg_unlock_context(conn->phys_ctx);; 16332 }; 16333 ; 16334 if (conn->dom_ctx == NULL) {; 16335 /* Default domain */; 16336 DEBUG_TRACE(""TLS default domain %s used"",; 16337 conn->ph",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:489937,Security,certificate,certificate,489937,"6518 * https://www.openssl.org/docs/man1.1.0/ssl/ssl.html; 16519 * But in the source code const SSL is used:; 16520 * 'void (*)(const SSL *, int, int)' See:; 16521 * https://github.com/openssl/openssl/blob/1d97c8435171a7af575f73c526d79e1ef0ee5960/ssl/ssl.h#L1173; 16522 * Problem about wrong documentation described, but not resolved:; 16523 * https://bugs.launchpad.net/ubuntu/+source/openssl/+bug/1147526; 16524 * Wrong const cast ignored on C or can be suppressed by compiler flags.; 16525 * But when compiled with modern C++ compiler, correct const should be; 16526 * provided; 16527 */; 16528 SSL_CTX_set_info_callback(dom_ctx->ssl_ctx, ssl_info_callback);; 16529 ; 16530 SSL_CTX_set_tlsext_servername_callback(dom_ctx->ssl_ctx,; 16531 ssl_servername_callback);; 16532 ; 16533 /* If a callback has been specified, call it. */; 16534 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16535 ? 0; 16536 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16537 phys_ctx->user_data));; 16538 ; 16539 /* If callback returns 0, civetweb sets up the SSL certificate.; 16540 * If it returns 1, civetweb assumes the calback already did this.; 16541 * If it returns -1, initializing ssl fails. */; 16542 if (callback_ret < 0) {; 16543 mg_cry_ctx_internal(phys_ctx,; 16544 ""SSL callback returned error: %i"",; 16545 callback_ret);; 16546 return 0;; 16547 }; 16548 if (callback_ret > 0) {; 16549 /* Callback did everything. */; 16550 return 1;; 16551 }; 16552 ; 16553 /* If a domain callback has been specified, call it. */; 16554 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16555 ? 0; 16556 : (phys_ctx->callbacks.init_ssl_domain(; 16557 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16558 dom_ctx->ssl_ctx,; 16559 phys_ctx->user_data));; 16560 ; 16561 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16562 * If it returns 1, civetweb assumes the calback already did this.; 16563 * If it returns -1, initializing ssl fails. */; 16564 if (callback_ret < 0) {; 16565 mg",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:490702,Security,certificate,certificate,490702,"x,; 16531 ssl_servername_callback);; 16532 ; 16533 /* If a callback has been specified, call it. */; 16534 callback_ret = (phys_ctx->callbacks.init_ssl == NULL); 16535 ? 0; 16536 : (phys_ctx->callbacks.init_ssl(dom_ctx->ssl_ctx,; 16537 phys_ctx->user_data));; 16538 ; 16539 /* If callback returns 0, civetweb sets up the SSL certificate.; 16540 * If it returns 1, civetweb assumes the calback already did this.; 16541 * If it returns -1, initializing ssl fails. */; 16542 if (callback_ret < 0) {; 16543 mg_cry_ctx_internal(phys_ctx,; 16544 ""SSL callback returned error: %i"",; 16545 callback_ret);; 16546 return 0;; 16547 }; 16548 if (callback_ret > 0) {; 16549 /* Callback did everything. */; 16550 return 1;; 16551 }; 16552 ; 16553 /* If a domain callback has been specified, call it. */; 16554 callback_ret = (phys_ctx->callbacks.init_ssl_domain == NULL); 16555 ? 0; 16556 : (phys_ctx->callbacks.init_ssl_domain(; 16557 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16558 dom_ctx->ssl_ctx,; 16559 phys_ctx->user_data));; 16560 ; 16561 /* If domain callback returns 0, civetweb sets up the SSL certificate.; 16562 * If it returns 1, civetweb assumes the calback already did this.; 16563 * If it returns -1, initializing ssl fails. */; 16564 if (callback_ret < 0) {; 16565 mg_cry_ctx_internal(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:492222,Security,certificate,certificates,492222,"al(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_c",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:498124,Security,certificate,certificate,498124,"tx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptoli",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:498405,Security,certificate,certificate,498405,"6761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16813 ; 16814 /* Shutdown according to; 16815 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modul",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:498551,Security,certificate,certificate,498551," 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 16784 return 0;; 16785 }; 16786 ; 16787 /* If a certificate chain is configured, use it. */; 16788 chain = dom_ctx->config[SSL_CERTIFICATE_CHAIN];; 16789 if (chain == NULL) {; 16790 /* Default: certificate chain in PEM file */; 16791 chain = pem;; 16792 }; 16793 if ((chain != NULL) && (*chain == 0)) {; 16794 /* If the chain is an empty string, don't use it. */; 16795 chain = NULL;; 16796 }; 16797 ; 16798 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16799 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16800 return 0;; 16801 }; 16802 ; 16803 return init_ssl_ctx_impl(phys_ctx, dom_ctx, pem, chain);; 16804}; 16805 ; 16806 ; 16807static void; 16808uninitialize_openssl(void); 16809{; 16810#if defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0); 16811 ; 16812 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16813 ; 16814 /* Shutdown according to; 16815 * https://wiki.openssl.org/index.php/Library_Initialization#Cleanup; 16816 * http://stackoverflow.com/questions/29845527/how-to-properly-uninitialize-openssl; 16817 */; 16818 CONF_modules_unload(1);; 16819#else; 16820 int i;; 16821 ; 16822 if (mg_atomic_dec(&cryptolib_users) == 0) {; 16823 ; 16824 /* Shutdown according to; 16825 * https://wiki.openssl.org/index.php/L",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:515647,Security,certificate,certificate,515647,"client.rsa.sin);; 17323#endif; 17324 ; 17325 conn->client.sock = sock;; 17326 conn->client.lsa = sa;; 17327 ; 17328 if (getsockname(sock, psa, &len) != 0) {; 17329 mg_cry_internal(conn,; 17330 ""%s: getsockname() failed: %s"",; 17331 __func__,; 17332 strerror(ERRNO));; 17333 }; 17334 ; 17335 conn->client.is_ssl = use_ssl ? 1 : 0;; 17336 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 17337 mg_snprintf(NULL,; 17338 NULL, /* No truncation check for ebuf */; 17339 ebuf,; 17340 ebuf_len,; 17341 ""Can not create mutex"");; 17342#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17343 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17344#endif; 17345 closesocket(sock);; 17346 mg_free(conn);; 17347 return NULL;; 17348 }; 17349 ; 17350 ; 17351#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17352 if (use_ssl) {; 17353 /* TODO: Check ssl_verify_peer and ssl_ca_path here.; 17354 * SSL_CTX_set_verify call is needed to switch off server; 17355 * certificate checking, which is off by default in OpenSSL and; 17356 * on in yaSSL. */; 17357 /* TODO: SSL_CTX_set_verify(conn->dom_ctx,; 17358 * SSL_VERIFY_PEER, verify_ssl_server); */; 17359 ; 17360 if (client_options->client_cert) {; 17361 if (!ssl_use_pem_file(conn->phys_ctx,; 17362 conn->dom_ctx,; 17363 client_options->client_cert,; 17364 NULL)) {; 17365 mg_snprintf(NULL,; 17366 NULL, /* No truncation check for ebuf */; 17367 ebuf,; 17368 ebuf_len,; 17369 ""Can not use SSL client certificate"");; 17370 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17371 closesocket(sock);; 17372 mg_free(conn);; 17373 return NULL;; 17374 }; 17375 }; 17376 ; 17377 if (client_options->server_cert) {; 17378 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 17379 client_options->server_cert,; 17380 NULL); 17381 != 1) {; 17382 mg_cry_internal(conn,; 17383 ""SSL_CTX_load_verify_locations error: %s "",; 17384 ssl_error());; 17385 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17386 closesocket(sock);; 17387 mg_free(conn",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:516135,Security,certificate,certificate,516135,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:525257,Security,authenticat,authentication,525257,"stend = strchr(hostbegin, '/');; 17648 if (!hostend) {; 17649 return 0;; 17650 }; 17651 portbegin = strchr(hostbegin, ':');; 17652 if ((!portbegin) || (portbegin > hostend)) {; 17653 port = abs_uri_protocols[i].default_port;; 17654 request_domain_len = (size_t)(hostend - hostbegin);; 17655 } else {; 17656 port = strtoul(portbegin + 1, &portend, 10);; 17657 if ((portend != hostend) || (port <= 0); 17658 || !is_valid_port(port)) {; 17659 return 0;; 17660 }; 17661 request_domain_len = (size_t)(portbegin - hostbegin);; 17662 }; 17663 /* protocol found, port set */; 17664 break;; 17665 }; 17666 }; 17667 ; 17668 if (!port) {; 17669 /* port remains 0 if the protocol is not found */; 17670 return 0;; 17671 }; 17672 ; 17673 /* Check if the request is directed to a different server. */; 17674 /* First check if the port is the same. */; 17675 if (ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa)) != port) {; 17676 /* Request is directed to a different port */; 17677 return 0;; 17678 }; 17679 ; 17680 /* Finally check if the server corresponds to the authentication; 17681 * domain of the server (the server domain).; 17682 * Allow full matches (like http://mydomain.com/path/file.ext), and; 17683 * allow subdomain matches (like http://www.mydomain.com/path/file.ext),; 17684 * but do not allow substrings (like; 17685 * http://notmydomain.com/path/file.ext; 17686 * or http://mydomain.com.fake/path/file.ext).; 17687 */; 17688 if (auth_domain_check_enabled) {; 17689 server_domain = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 17690 server_domain_len = strlen(server_domain);; 17691 if ((server_domain_len == 0) || (hostbegin == NULL)) {; 17692 return 0;; 17693 }; 17694 if ((request_domain_len == server_domain_len); 17695 && (!memcmp(server_domain, hostbegin, server_domain_len))) {; 17696 /* Request is directed to this server - full name match. */; 17697 } else {; 17698 if (request_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:562242,Security,access,access,562242,"re-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, thread_index)) {; 18925 ; 18926 /* New connections must start with new protocol negotiation */; 18927 tls.alpn_proto = NULL;; 18928 ; 18929#if defined(USE_SERVER_STATS); 18930 conn->conn_close_time = 0;; 18931#endif; 18932 conn->conn_birth_time = time(NULL);; ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:564826,Security,certificate,certificate,564826," ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18943 ; 18944 sockaddr_to_string(conn->request_info.remote_addr,; 18945 sizeof(conn->request_info.remote_addr),; 18946 &conn->client.rsa);; 18947 ; 18948 DEBUG_TRACE(""Incomming %sconnection from %s"",; 18949 (conn->client.is_ssl ? ""SSL "" : """"),; 18950 conn->request_info.remote_addr);; 18951 ; 18952 conn->request_info.is_ssl = conn->client.is_ssl;; 18953 ; 18954 if (conn->client.is_ssl) {; 18955 ; 18956#if defined(USE_MBEDTLS); 18957 /* HTTPS connection */; 18958 if (mbed_ssl_accept(&(conn->ssl),; 18959 conn->dom_ctx->ssl_ctx,; 18960 (int *)&(conn->client.sock),; 18961 conn->phys_ctx); 18962 == 0) {; 18963 /* conn->dom_ctx is set in get_request */; 18964 /* process HTTPS connection */; 18965 init_connection(conn);; 18966 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18967 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18968 process_new_connection(conn);; 18969 } else {; 18970 /* make sure the connection is cleaned up on SSL failure */; 18971 close_connection(conn);; 18972 }; 18973 ; 18974#elif !defined(NO_SSL); 18975 /* HTTPS connection */; 18976 if (sslize(conn, SSL_accept, NULL)) {; 18977 /* conn->dom_ctx is set in get_request */; 18978 ; 18979 /* Get SSL client certificate information (if set) */; 18980 struct mg_client_cert client_cert;; 18981 if (ssl_get_client_cert_info(conn, &client_cert)) {; 18982 conn->request_info.client_cert = &client_cert;; 18983 }; 18984 ; 18985 /* process HTTPS connection */; 18986#if defined(USE_HTTP2); 18987 if ((tls.alpn_proto != NULL); 18988 && (!memcmp(tls.alpn_proto, ""\x02h2"", 3))) {; 18989 /* process HTTPS/2 connection */; 18990 init_connection(conn);; 18991 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18992 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18993 conn->content_len =; 18994 -1; /* content length is not predefined */; 18995 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18996 process_new_http2_connection(conn);; 18997 } else; 18998#endif; 18999 {; 19000 /* process ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:565921,Security,certificate,certificate,565921,"t */; 18978 ; 18979 /* Get SSL client certificate information (if set) */; 18980 struct mg_client_cert client_cert;; 18981 if (ssl_get_client_cert_info(conn, &client_cert)) {; 18982 conn->request_info.client_cert = &client_cert;; 18983 }; 18984 ; 18985 /* process HTTPS connection */; 18986#if defined(USE_HTTP2); 18987 if ((tls.alpn_proto != NULL); 18988 && (!memcmp(tls.alpn_proto, ""\x02h2"", 3))) {; 18989 /* process HTTPS/2 connection */; 18990 init_connection(conn);; 18991 conn->connection_type = CONNECTION_TYPE_REQUEST;; 18992 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18993 conn->content_len =; 18994 -1; /* content length is not predefined */; 18995 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18996 process_new_http2_connection(conn);; 18997 } else; 18998#endif; 18999 {; 19000 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19001 init_connection(conn);; 19002 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19003 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19004 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19005 process_new_connection(conn);; 19006 }; 19007 ; 19008 /* Free client certificate info */; 19009 if (conn->request_info.client_cert) {; 19010 mg_free((void *)(conn->request_info.client_cert->subject));; 19011 mg_free((void *)(conn->request_info.client_cert->issuer));; 19012 mg_free((void *)(conn->request_info.client_cert->serial));; 19013 mg_free((void *)(conn->request_info.client_cert->finger));; 19014 /* Free certificate memory */; 19015 X509_free(; 19016 (X509 *)conn->request_info.client_cert->peer_cert);; 19017 conn->request_info.client_cert->peer_cert = 0;; 19018 conn->request_info.client_cert->subject = 0;; 19019 conn->request_info.client_cert->issuer = 0;; 19020 conn->request_info.client_cert->serial = 0;; 19021 conn->request_info.client_cert->finger = 0;; 19022 conn->request_info.client_cert = 0;; 19023 }; 19024 } else {; 19025 /* make sure the connection is cleaned up on SSL failure */; 19026 close_connection(conn)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:566266,Security,certificate,certificate,566266,"ype = CONNECTION_TYPE_REQUEST;; 18992 conn->protocol_type = PROTOCOL_TYPE_HTTP2;; 18993 conn->content_len =; 18994 -1; /* content length is not predefined */; 18995 conn->is_chunked = 0; /* HTTP2 is never chunked */; 18996 process_new_http2_connection(conn);; 18997 } else; 18998#endif; 18999 {; 19000 /* process HTTPS/1.x or WEBSOCKET-SECURE connection */; 19001 init_connection(conn);; 19002 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19003 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19004 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19005 process_new_connection(conn);; 19006 }; 19007 ; 19008 /* Free client certificate info */; 19009 if (conn->request_info.client_cert) {; 19010 mg_free((void *)(conn->request_info.client_cert->subject));; 19011 mg_free((void *)(conn->request_info.client_cert->issuer));; 19012 mg_free((void *)(conn->request_info.client_cert->serial));; 19013 mg_free((void *)(conn->request_info.client_cert->finger));; 19014 /* Free certificate memory */; 19015 X509_free(; 19016 (X509 *)conn->request_info.client_cert->peer_cert);; 19017 conn->request_info.client_cert->peer_cert = 0;; 19018 conn->request_info.client_cert->subject = 0;; 19019 conn->request_info.client_cert->issuer = 0;; 19020 conn->request_info.client_cert->serial = 0;; 19021 conn->request_info.client_cert->finger = 0;; 19022 conn->request_info.client_cert = 0;; 19023 }; 19024 } else {; 19025 /* make sure the connection is cleaned up on SSL failure */; 19026 close_connection(conn);; 19027 }; 19028#endif; 19029 ; 19030 } else {; 19031 /* process HTTP connection */; 19032 init_connection(conn);; 19033 conn->connection_type = CONNECTION_TYPE_REQUEST;; 19034 /* Start with HTTP, WS will be an ""upgrade"" request later */; 19035 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 19036 process_new_connection(conn);; 19037 }; 19038 ; 19039 DEBUG_TRACE(""%s"", ""Connection closed"");; 19040 ; 19041#if defined(USE_SERVER_STATS); 19042 conn->conn_close_time = time(NULL);; 19043#endif; 19044",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:596687,Security,password,password,596687,"r, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19927 }; 19928 ; 19929 /* Call script */; 19930 state = mg_lua_context_script_run(state,; 19931 ctx->dd.config[LUA_BACKGROUND_SCRIPT],; 19932 ctx,; 19933 ebuf,; 19934 sizeof(ebuf));; 19935 if (!state) {; 19936 mg_cry_ctx_internal(ctx,; 19937 ""lua_background_script start error: %s"",; 19938 ebuf);; 19939 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19940 mg_snprintf(NULL,; 19941 NULL, /* No truncation check for error buffers */; 19942 error->text,; 19943 error->text_buffer_size,; 19944 ""Error in script %s: %s"",; 19945 config_options[DOCUMENT_ROOT].name,; 19946 ebuf);; 19947 }; 19948 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19949 ; 19950 free_context(ctx);; 19951 pthread_setspecific(sTlsKey, NULL);; 19952 return NULL;; 19953 }; 19954 ; 19955 /* state remains valid */; 19956 ctx->lua_background_state = (void *)state;; 19957 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19958 ; 19959 } else {; 19960 ctx->lua_background_state = 0;; 19961 }; 19962#endif; 19963 ; 19964 /* Step by step initialization of ctx - depending on build options */; 19965#if !defined(NO_FILESYSTEMS); 19966 if (!set_gpass_option(ctx, NULL)) {; 19967 const char *err_msg = ""Invalid global password file"";; 19968 /* Fatal error - abort start. */; 19969 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19970 ; 19971 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19972 mg_snprintf(NULL,; 19973 NULL, /* No truncation check for error buffers */; 19974 error->text,; 19975 error->text_buffer_size,; 19976 ""%s"",; 19977 err_msg);; 19978 }; 19979 free_context(ctx);; 19980 pthread_setspecific(sTlsKey, NULL);; 19981 return NULL;; 19982 }; 19983#endif; 19984 ; 19985#if defined(USE_MBEDTLS); 19986 if (!mg_sslctx_init(ctx, NULL)) {; 19987 const char *err_msg = ""Error initializing SSL context"";; 19988 /* Fatal error - abort start. */; 19989 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 19990 ; 19991 if ((error !=",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:599536,Security,access,access,599536,"f (!set_ports_option(ctx)) {; 20025 const char *err_msg = ""Failed to setup server ports"";; 20026 /* Fatal error - abort start. */; 20027 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20028 ; 20029 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20030 mg_snprintf(NULL,; 20031 NULL, /* No truncation check for error buffers */; 20032 error->text,; 20033 error->text_buffer_size,; 20034 ""%s"",; 20035 err_msg);; 20036 }; 20037 free_context(ctx);; 20038 pthread_setspecific(sTlsKey, NULL);; 20039 return NULL;; 20040 }; 20041 ; 20042 ; 20043#if !defined(_WIN32) && !defined(__ZEPHYR__); 20044 if (!set_uid_option(ctx)) {; 20045 const char *err_msg = ""Failed to run as configured user"";; 20046 /* Fatal error - abort start. */; 20047 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20048 ; 20049 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20050 mg_snprintf(NULL,; 20051 NULL, /* No truncation check for error buffers */; 20052 error->text,; 20053 error->text_buffer_size,; 20054 ""%s"",; 20055 err_msg);; 20056 }; 20057 free_context(ctx);; 20058 pthread_setspecific(sTlsKey, NULL);; 20059 return NULL;; 20060 }; 20061#endif; 20062 ; 20063 if (!set_acl_option(ctx)) {; 20064 const char *err_msg = ""Failed to setup access control list"";; 20065 /* Fatal error - abort start. */; 20066 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20067 ; 20068 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20069 mg_snprintf(NULL,; 20070 NULL, /* No truncation check for error buffers */; 20071 error->text,; 20072 error->text_buffer_size,; 20073 ""%s"",; 20074 err_msg);; 20075 }; 20076 free_context(ctx);; 20077 pthread_setspecific(sTlsKey, NULL);; 20078 return NULL;; 20079 }; 20080 ; 20081 ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));; 20082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:609906,Security,authenticat,authentication,609906,"nvalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 20380 name);; 20381 }; 20382 mg_free(new_dom);; 20383 return -2;; 20384 }; 20385 if (new_dom->config[idx] != NULL) {; 20386 /* Duplicate option: Later values overwrite earlier ones. */; 20387 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 20388 mg_free(new_dom->config[idx]);; 20389 }; 20390 new_dom->config[idx] = mg_strdup_ctx(value, ctx);; 20391 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 20392 }; 20393 ; 20394 /* Authentication domain is mandatory */; 20395 /* TODO: Maybe use a new option hostname? */; 20396 if (!new_dom->config[AUTHENTICATION_DOMAIN]) {; 20397 mg_cry_ctx_internal(ctx, ""%s"", ""authentication domain required"");; 20398 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20399 mg_snprintf(NULL,; 20400 NULL, /* No truncation check for error buffers */; 20401 error->text,; 20402 error->text_buffer_size,; 20403 ""Mandatory option %s missing"",; 20404 config_options[AUTHENTICATION_DOMAIN].name);; 20405 }; 20406 mg_free(new_dom);; 20407 return -4;; 20408 }; 20409 ; 20410 /* Set default value if needed. Take the config value from; 20411 * ctx as a default value. */; 20412 for (i = 0; config_options[i].name != NULL; i++) {; 20413 default_value = ctx->dd.config[i];; 20414 if ((new_dom->config[i] == NULL) && (default_value != NULL)) {; 20415 new_dom->config[i] = mg_strdup_ctx(default_value, ctx);; 20416 }; 20417 }; 20418 ; 20419 new_dom->handlers = NULL;; 20420 new_dom->next = NULL;; 20421 new_dom->nonce_count = 0;; 20422 new_dom->auth_nonce_mask =; 20423 (uint64_t)get_random() ^ ((uint64_t)get_random() <<",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:675133,Security,authoriz,authorizestatic,675133,"(struct mg_connection *conn, const char *fmt, va_list ap)Definition civetweb.c:6919; mg_realloc_ctx#define mg_realloc_ctx(a, b, c)Definition civetweb.c:1496; send_additional_headerstatic void send_additional_header(struct mg_connection *conn)Definition civetweb.c:4118; push_allstatic int push_all(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len)Definition civetweb.c:6137; is_put_or_delete_methodstatic int is_put_or_delete_method(const struct mg_connection *conn)Definition civetweb.c:7306; read_messagestatic int read_message(FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread)Definition civetweb.c:10799; print_dir_entrystatic int print_dir_entry(struct de *de)Definition civetweb.c:9290; MG_FOPEN_MODE_WRITE#define MG_FOPEN_MODE_WRITEDefinition civetweb.c:2811; mg_get_user_connection_datavoid * mg_get_user_connection_data(const struct mg_connection *conn)Definition civetweb.c:3203; authorizestatic int authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)Definition civetweb.c:8616; send_ssi_filestatic void send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int)Definition civetweb.c:11985; mg_static_assert#define mg_static_assert(cond, txt)Definition civetweb.c:124; SOCKET_TIMEOUT_QUANTUM#define SOCKET_TIMEOUT_QUANTUMDefinition civetweb.c:471; produce_socketstatic void produce_socket(struct mg_context *ctx, const struct socket *sp)Definition civetweb.c:18810; match_prefixstatic ptrdiff_t match_prefix(const char *pattern, size_t pattern_len, const char *str)Definition civetweb.c:3922; mg_send_chunkint mg_send_chunk(struct mg_connection *conn, const char *chunk, unsigned int chunk_len)Definition civetweb.c:6777; remove_dot_segmentsstatic void remove_dot_segments(char *inout)Definition civetweb.c:7873; get_request_handlerstatic int get_request_handler(struct mg_connection *conn, int handler_type, mg_request_handler *handler, struct mg_websocket_subprotocols **subprotocols, mg_we",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:675153,Security,authoriz,authorize,675153,"(struct mg_connection *conn, const char *fmt, va_list ap)Definition civetweb.c:6919; mg_realloc_ctx#define mg_realloc_ctx(a, b, c)Definition civetweb.c:1496; send_additional_headerstatic void send_additional_header(struct mg_connection *conn)Definition civetweb.c:4118; push_allstatic int push_all(struct mg_context *ctx, FILE *fp, SOCKET sock, SSL *ssl, const char *buf, int len)Definition civetweb.c:6137; is_put_or_delete_methodstatic int is_put_or_delete_method(const struct mg_connection *conn)Definition civetweb.c:7306; read_messagestatic int read_message(FILE *fp, struct mg_connection *conn, char *buf, int bufsiz, int *nread)Definition civetweb.c:10799; print_dir_entrystatic int print_dir_entry(struct de *de)Definition civetweb.c:9290; MG_FOPEN_MODE_WRITE#define MG_FOPEN_MODE_WRITEDefinition civetweb.c:2811; mg_get_user_connection_datavoid * mg_get_user_connection_data(const struct mg_connection *conn)Definition civetweb.c:3203; authorizestatic int authorize(struct mg_connection *conn, struct mg_file *filep, const char *realm)Definition civetweb.c:8616; send_ssi_filestatic void send_ssi_file(struct mg_connection *, const char *, struct mg_file *, int)Definition civetweb.c:11985; mg_static_assert#define mg_static_assert(cond, txt)Definition civetweb.c:124; SOCKET_TIMEOUT_QUANTUM#define SOCKET_TIMEOUT_QUANTUMDefinition civetweb.c:471; produce_socketstatic void produce_socket(struct mg_context *ctx, const struct socket *sp)Definition civetweb.c:18810; match_prefixstatic ptrdiff_t match_prefix(const char *pattern, size_t pattern_len, const char *str)Definition civetweb.c:3922; mg_send_chunkint mg_send_chunk(struct mg_connection *conn, const char *chunk, unsigned int chunk_len)Definition civetweb.c:6777; remove_dot_segmentsstatic void remove_dot_segments(char *inout)Definition civetweb.c:7873; get_request_handlerstatic int get_request_handler(struct mg_connection *conn, int handler_type, mg_request_handler *handler, struct mg_websocket_subprotocols **subprotocols, mg_we",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:708763,Security,access,accessstruct,708763,; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2253; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2255; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1872; mg_file_access::fpFILE * fpDefinition civetweb.c:1874; mg_file_statDefinition civetweb.c:1861; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1863; mg_file_stat::locationint locationDefinition civetweb.c:1868; mg_file_stat::is_directoryint is_directoryDefinition civetweb.c:1865; mg_file_stat::last_modifiedtime_t last_modifiedDefinition civetweb.c:1864; mg_file_stat::is_gzippedint is_gzippedDefinition civetweb.c:1866; mg_fileDefinition civetweb.c:1877; mg_file::statstruct mg_file_stat statDefinition civetweb.c:1878; mg_file::accessstruct mg_file_access accessDefinition civetweb.c:1879; mg_handler_infoDefinition civetweb.c:2211; mg_handler_info::handlermg_request_handler handlerDefinition civetweb.c:2220; mg_handler_info::uri_lensize_t uri_lenDefinition civetweb.c:2214; mg_handler_info::auth_handlermg_authorization_handler auth_handlerDefinition civetweb.c:2234; mg_handler_info::close_handlermg_websocket_close_handler close_handlerDefinition civetweb.c:2228; mg_handler_info::nextstruct mg_handler_info * nextDefinition civetweb.c:2240; mg_handler_info::urichar * uriDefinition civetweb.c:2213; mg_handler_info::refcountunsigned int refcountDefinition civetweb.c:2221; mg_handler_info::connect_handlermg_websocket_connect_handler connect_handlerDefinition civetweb.c:2225; mg_handler_info::cbdatavoid * cbdataDefinition civetweb.c:2237; mg_handler_info::subprotocolsstruct mg_websocket_subprotocols * subprotocolsDefinition civetweb.c:2231; mg_handler_info::handler_typeint handler_typeDefinition civetweb.c:2217; mg_handler_info::removi,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:708791,Security,access,accessDefinition,708791,; mg_domain_context::ssl_ctxSSL_CTX * ssl_ctxDefinition civetweb.c:2253; mg_domain_context::handlersstruct mg_handler_info * handlersDefinition civetweb.c:2255; mg_error_dataDefinition civetweb.h:1671; mg_error_data::codeunsigned * codeDefinition civetweb.h:1672; mg_error_data::text_buffer_sizesize_t text_buffer_sizeDefinition civetweb.h:1674; mg_error_data::textchar * textDefinition civetweb.h:1673; mg_file_accessDefinition civetweb.c:1872; mg_file_access::fpFILE * fpDefinition civetweb.c:1874; mg_file_statDefinition civetweb.c:1861; mg_file_stat::sizeuint64_t sizeDefinition civetweb.c:1863; mg_file_stat::locationint locationDefinition civetweb.c:1868; mg_file_stat::is_directoryint is_directoryDefinition civetweb.c:1865; mg_file_stat::last_modifiedtime_t last_modifiedDefinition civetweb.c:1864; mg_file_stat::is_gzippedint is_gzippedDefinition civetweb.c:1866; mg_fileDefinition civetweb.c:1877; mg_file::statstruct mg_file_stat statDefinition civetweb.c:1878; mg_file::accessstruct mg_file_access accessDefinition civetweb.c:1879; mg_handler_infoDefinition civetweb.c:2211; mg_handler_info::handlermg_request_handler handlerDefinition civetweb.c:2220; mg_handler_info::uri_lensize_t uri_lenDefinition civetweb.c:2214; mg_handler_info::auth_handlermg_authorization_handler auth_handlerDefinition civetweb.c:2234; mg_handler_info::close_handlermg_websocket_close_handler close_handlerDefinition civetweb.c:2228; mg_handler_info::nextstruct mg_handler_info * nextDefinition civetweb.c:2240; mg_handler_info::urichar * uriDefinition civetweb.c:2213; mg_handler_info::refcountunsigned int refcountDefinition civetweb.c:2221; mg_handler_info::connect_handlermg_websocket_connect_handler connect_handlerDefinition civetweb.c:2225; mg_handler_info::cbdatavoid * cbdataDefinition civetweb.c:2237; mg_handler_info::subprotocolsstruct mg_websocket_subprotocols * subprotocolsDefinition civetweb.c:2231; mg_handler_info::handler_typeint handler_typeDefinition civetweb.c:2217; mg_handler_info::removi,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:6575,Testability,log,log,6575,"lementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""S",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:58111,Testability,test,tested,58111,"ed; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_options[]; 1907 * This is tested in the unit test (test/private.c); 1908 * ""Private Config Options""; 1909 */; 1910enum {; 1911 /* Once for each server */; 1912 LISTENING_PORTS,; 1913 NUM_THREADS,; 1914 RUN_AS_USER,; 1915 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1916 * socket option typedef TCP_NODELAY. */; 1917 MAX_REQUEST_SIZE,; 1918 LINGER_TIMEOUT,; 1919 CONNECTION_QUEUE_SIZE,; 1920 LISTEN_BACKLOG_SIZE,; 1921#if defined(__linux__); 1922 ALLOW_SENDFILE_CALL,; 1923#endif; 1924#if defined(_WIN32); 1925 CASE_SENSITIVE_FILES,; 1926#endif; 1927 THROTTLE,; 1928 ENABLE_KEEP_ALIVE,; 1929 REQUEST_TIMEOUT,; 1930 KEEP_ALIVE_TIMEOUT,; 1931#if defined(USE_WEBSOCKET); 1932 WEBSOCKET_TIMEOUT,; 1933 ENABLE_WEBSOCKET_PING_PONG,; 1934#endif; 1935 DECODE_URL,; 1936 D",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:58130,Testability,test,test,58130,"ed; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_options[]; 1907 * This is tested in the unit test (test/private.c); 1908 * ""Private Config Options""; 1909 */; 1910enum {; 1911 /* Once for each server */; 1912 LISTENING_PORTS,; 1913 NUM_THREADS,; 1914 RUN_AS_USER,; 1915 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1916 * socket option typedef TCP_NODELAY. */; 1917 MAX_REQUEST_SIZE,; 1918 LINGER_TIMEOUT,; 1919 CONNECTION_QUEUE_SIZE,; 1920 LISTEN_BACKLOG_SIZE,; 1921#if defined(__linux__); 1922 ALLOW_SENDFILE_CALL,; 1923#endif; 1924#if defined(_WIN32); 1925 CASE_SENSITIVE_FILES,; 1926#endif; 1927 THROTTLE,; 1928 ENABLE_KEEP_ALIVE,; 1929 REQUEST_TIMEOUT,; 1930 KEEP_ALIVE_TIMEOUT,; 1931#if defined(USE_WEBSOCKET); 1932 WEBSOCKET_TIMEOUT,; 1933 ENABLE_WEBSOCKET_PING_PONG,; 1934#endif; 1935 DECODE_URL,; 1936 D",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:58136,Testability,test,test,58136,"ed; /* Set to 1 if the content is gzipped, in which; 1867 * case we need a ""Content-Eencoding: gzip"" header */; 1868 int location; /* 0 = nowhere, 1 = on disk, 2 = in memory */; 1869};; 1870 ; 1871 ; 1872struct mg_file_access {; 1873 /* File properties filled by mg_fopen: */; 1874 FILE *fp;; 1875};; 1876 ; 1877struct mg_file {; 1878 struct mg_file_stat stat;; 1879 struct mg_file_access access;; 1880};; 1881 ; 1882 ; 1883#define STRUCT_FILE_INITIALIZER \; 1884 { \; 1885 {(uint64_t)0, (time_t)0, 0, 0, 0}, \; 1886 { \; 1887 (FILE *)NULL \; 1888 } \; 1889 }; 1890 ; 1891 ; 1892/* Describes listening socket, or socket which was accept()-ed by the master; 1893 * thread and queued for future handling by the worker thread. */; 1894struct socket {; 1895 SOCKET sock; /* Listening socket */; 1896 union usa lsa; /* Local socket address */; 1897 union usa rsa; /* Remote socket address */; 1898 unsigned char is_ssl; /* Is port SSL-ed */; 1899 unsigned char ssl_redir; /* Is port supposed to redirect everything to SSL; 1900 * port */; 1901 unsigned char in_use; /* 0: invalid, 1: valid, 2: free */; 1902};; 1903 ; 1904 ; 1905/* Enum const for all options must be in sync with; 1906 * static struct mg_option config_options[]; 1907 * This is tested in the unit test (test/private.c); 1908 * ""Private Config Options""; 1909 */; 1910enum {; 1911 /* Once for each server */; 1912 LISTENING_PORTS,; 1913 NUM_THREADS,; 1914 RUN_AS_USER,; 1915 CONFIG_TCP_NODELAY, /* Prepended CONFIG_ to avoid conflict with the; 1916 * socket option typedef TCP_NODELAY. */; 1917 MAX_REQUEST_SIZE,; 1918 LINGER_TIMEOUT,; 1919 CONNECTION_QUEUE_SIZE,; 1920 LISTEN_BACKLOG_SIZE,; 1921#if defined(__linux__); 1922 ALLOW_SENDFILE_CALL,; 1923#endif; 1924#if defined(_WIN32); 1925 CASE_SENSITIVE_FILES,; 1926#endif; 1927 THROTTLE,; 1928 ENABLE_KEEP_ALIVE,; 1929 REQUEST_TIMEOUT,; 1930 KEEP_ALIVE_TIMEOUT,; 1931#if defined(USE_WEBSOCKET); 1932 WEBSOCKET_TIMEOUT,; 1933 ENABLE_WEBSOCKET_PING_PONG,; 1934#endif; 1935 DECODE_URL,; 1936 D",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:74253,Testability,log,log,74253,"61 int sq_size; /* No of elements in socket queue */; 2362#if defined(USE_SERVER_STATS); 2363 int sq_max_fill;; 2364#endif /* USE_SERVER_STATS */; 2365#endif /* ALTERNATIVE_QUEUE */; 2366 ; 2367 /* Memory related */; 2368 unsigned int max_request_size; /* The max request size */; 2369 ; 2370#if defined(USE_SERVER_STATS); 2371 struct mg_memory_stat ctx_memory;; 2372#endif; 2373 ; 2374 /* Operating system related */; 2375 char *systemName; /* What operating system is running */; 2376 time_t start_time; /* Server start time, used for authentication; 2377 * and for diagnstics. */; 2378 ; 2379#if defined(USE_TIMERS); 2380 struct ttimers *timers;; 2381#endif; 2382 ; 2383 /* Lua specific: Background operations and shared websockets */; 2384#if defined(USE_LUA); 2385 void *lua_background_state; /* lua_State (here as void *) */; 2386 pthread_mutex_t lua_bg_mutex; /* Protect background state */; 2387 int lua_bg_log_available; /* Use Lua background state for access log */; 2388#endif; 2389 ; 2390 /* Server nonce */; 2391 pthread_mutex_t nonce_mutex; /* Protects ssl_ctx, handlers,; 2392 * ssl_cert_last_mtime, nonce_count, and; 2393 * next (linked list) */; 2394 ; 2395 /* Server callbacks */; 2396 struct mg_callbacks callbacks; /* User-defined callback function */; 2397 void *user_data; /* User-defined data */; 2398 ; 2399 /* Part 2 - Logical domain:; 2400 * This holds hostname, TLS certificate, document root, ...; 2401 * set for a domain hosted at the server.; 2402 * There may be multiple domains hosted at one physical server.; 2403 * The default domain ""dd"" is the first element of a list of; 2404 * domains.; 2405 */; 2406 struct mg_domain_context dd; /* default domain */; 2407};; 2408 ; 2409 ; 2410#if defined(USE_SERVER_STATS); 2411static struct mg_memory_stat mg_common_memory = {0, 0, 0};; 2412 ; 2413static struct mg_memory_stat *; 2414get_memory_stat(struct mg_context *ctx); 2415{; 2416 if (ctx) {; 2417 return &(ctx->ctx_memory);; 2418 }; 2419 return &mg_common_memory;; 2420}",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:99723,Testability,log,log,99723,"ULL);; 3313 if (tm != NULL) {; 3314#else; 3315 struct tm _tm;; 3316 struct tm *tm = &_tm;; 3317 ; 3318 if (t != NULL) {; 3319 gmtime_r(t, tm);; 3320#endif; 3321 strftime(buf, buf_len, ""%a, %d %b %Y %H:%M:%S GMT"", tm);; 3322 } else {; 3323 mg_strlcpy(buf, ""Thu, 01 Jan 1970 00:00:00 GMT"", buf_len);; 3324 buf[buf_len - 1] = '\0';; 3325 }; 3326}; 3327 ; 3328 ; 3329/* difftime for struct timespec. Return value is in seconds. */; 3330static double; 3331mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before); 3332{; 3333 return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9; 3334 + (double)(ts_now->tv_sec - ts_before->tv_sec);; 3335}; 3336 ; 3337 ; 3338#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl); 3339static void mg_cry_internal_impl(const struct mg_connection *conn,; 3340 const char *func,; 3341 unsigned line,; 3342 const char *fmt,; 3343 va_list ap);; 3344#include ""external_mg_cry_internal_impl.inl""; 3345#elif !defined(NO_FILESYSTEMS); 3346 ; 3347/* Print error message to the opened error log stream. */; 3348static void; 3349mg_cry_internal_impl(const struct mg_connection *conn,; 3350 const char *func,; 3351 unsigned line,; 3352 const char *fmt,; 3353 va_list ap); 3354{; 3355 char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];; 3356 struct mg_file fi;; 3357 time_t timestamp;; 3358 ; 3359 /* Unused, in the RELEASE build */; 3360 (void)func;; 3361 (void)line;; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this i",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:102200,Testability,log,logging,102200,"s.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct mg_connection fc;; 3459 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3460 } else {; 3461 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3462 }; 3463 va_end(ap);; 3464}; 3465 ; 3466 ; 3467void; 3468mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3469{; 3470 va_list ap;; 3471 va_start(ap, fmt);; 3472 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:102266,Testability,log,logging,102266,"s.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *fmt,; 3453 ...); 3454{; 3455 va_list ap;; 3456 va_start(ap, fmt);; 3457 if (!conn && ctx) {; 3458 struct mg_connection fc;; 3459 mg_cry_internal_impl(fake_connection(&fc, ctx), func, line, fmt, ap);; 3460 } else {; 3461 mg_cry_internal_impl(conn, func, line, fmt, ap);; 3462 }; 3463 va_end(ap);; 3464}; 3465 ; 3466 ; 3467void; 3468mg_cry(const struct mg_connection *conn, const char *fmt, ...); 3469{; 3470 va_list ap;; 3471 va_start(ap, fmt);; 3472 mg_cry_internal_impl(conn, ""user"", 0, fmt, ap",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:130537,Testability,log,log,130537,"ode: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server error code */; 4341 return ""Server Error"";; 4342 }; 4343 ; 4344 /* Response code not even within reasonable range */; 4345 return """";; 4346 }; 4347}; 4348 ; 4349 ; 4350static int; 4351mg_send_http_error_impl(struct mg_connection *conn,; 4352 int status,; 4353 const char *fmt,; 4354 va_list args); 4355{; 4356 char errmsg_buf[MG_BUF_LEN];; 4357 va_list ap;; 4358 int has_body;; 4359 ; 4360#if !defined(NO_FILESYSTEMS); 4361 char path_buf[UTF8_PATH_MAX];; 4362 int len, i, page_handler_found, scope, truncated;; 4363 const char *error_handler = NULL;; 4364 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4365 const char *error_page_file_ext, *tstr;; 4366#endif /* NO_FILESYSTEMS */; 4367 int handled_by_callback = 0;; 4368 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:170095,Testability,log,log,170095,"e the child-side immediately. */; 5760 set_close_on_exec(fdin[1], conn, NULL); /* stdin write */; 5761 set_close_on_exec(fdout[0], conn, NULL); /* stdout read */; 5762 set_close_on_exec(fderr[0], conn, NULL); /* stderr read */; 5763 } else {; 5764 /* Child */; 5765 if (chdir(dir) != 0) {; 5766 mg_cry_internal(; 5767 conn, ""%s: chdir(%s): %s"", __func__, dir, strerror(ERRNO));; 5768 } else if (dup2(fdin[0], 0) == -1) {; 5769 mg_cry_internal(conn,; 5770 ""%s: dup2(%d, 0): %s"",; 5771 __func__,; 5772 fdin[0],; 5773 strerror(ERRNO));; 5774 } else if (dup2(fdout[1], 1) == -1) {; 5775 mg_cry_internal(conn,; 5776 ""%s: dup2(%d, 1): %s"",; 5777 __func__,; 5778 fdout[1],; 5779 strerror(ERRNO));; 5780 } else if (dup2(fderr[1], 2) == -1) {; 5781 mg_cry_internal(conn,; 5782 ""%s: dup2(%d, 2): %s"",; 5783 __func__,; 5784 fderr[1],; 5785 strerror(ERRNO));; 5786 } else {; 5787 struct sigaction sa;; 5788 ; 5789 /* Keep stderr and stdout in two different pipes.; 5790 * Stdout will be sent back to the client,; 5791 * stderr should go into a server error log. */; 5792 (void)close(fdin[0]);; 5793 (void)close(fdout[1]);; 5794 (void)close(fderr[1]);; 5795 ; 5796 /* Close write end fdin and read end fdout and fderr */; 5797 (void)close(fdin[1]);; 5798 (void)close(fdout[0]);; 5799 (void)close(fderr[0]);; 5800 ; 5801 /* After exec, all signal handlers are restored to their default; 5802 * values, with one exception of SIGCHLD. According to; 5803 * POSIX.1-2001 and Linux's implementation, SIGCHLD's handler; 5804 * will leave unchanged after exec if it was set to be ignored.; 5805 * Restore it to default action. */; 5806 memset(&sa, 0, sizeof(sa));; 5807 sa.sa_handler = SIG_DFL;; 5808 sigaction(SIGCHLD, &sa, NULL);; 5809 ; 5810 interp = conn->dom_ctx->config[CGI_INTERPRETER + cgi_config_idx];; 5811 if (interp == NULL) {; 5812 /* no interpreter configured, call the programm directly */; 5813 (void)execle(prog, prog, NULL, envp);; 5814 mg_cry_internal(conn,; 5815 ""%s: execle(%s): %s"",; 5816 __func__,;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:190314,Testability,log,log,190314,"ed_len = len64;; 6507 }; 6508 body = conn->buf + conn->request_len + conn->consumed_content;; 6509 memcpy(buf, body, (size_t)buffered_len);; 6510 len64 -= buffered_len;; 6511 conn->consumed_content += buffered_len;; 6512 nread += buffered_len;; 6513 buf = (char *)buf + buffered_len;; 6514 }; 6515 ; 6516 /* We have returned all buffered data. Read new data from the remote; 6517 * socket.; 6518 */; 6519 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6520 conn->consumed_content += n;; 6521 nread += n;; 6522 } else {; 6523 nread = ((nread > 0) ? nread : n);; 6524 }; 6525 }; 6526 return (int)nread;; 6527}; 6528 ; 6529 ; 6530/* Forward declarations */; 6531static void handle_request(struct mg_connection *);; 6532static void log_access(const struct mg_connection *);; 6533 ; 6534 ; 6535/* Handle request, update statistics and call access log */; 6536static void; 6537handle_request_stat_log(struct mg_connection *conn); 6538{; 6539#if defined(USE_SERVER_STATS); 6540 struct timespec tnow;; 6541 conn->conn_state = 4; /* processing */; 6542#endif; 6543 ; 6544 handle_request(conn);; 6545 ; 6546 ; 6547#if defined(USE_SERVER_STATS); 6548 conn->conn_state = 5; /* processed */; 6549 ; 6550 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6551 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6552 ; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6554 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6555 conn->num_bytes_sent);; 6556#endif; 6557 ; 6558 DEBUG_TRACE(""%s"", ""handle_request done"");; 6559 ; 6560 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6561 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6562 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6563 }; 6564 log_access(conn);; 6565}; 6566 ; 6567 ; 6568#if defined(USE_HTTP2); 6569#if defined(NO_SSL); 6570#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6571#endif; 6572#define USE_ALPN; 6573#include ""mod_http2.inl""; 6574/* Not sup",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:239355,Testability,test,test,239355,",; 8259 nc,; 8260 "":"",; 8261 cnonce,; 8262 "":"",; 8263 qop,; 8264 "":"",; 8265 ha2,; 8266 NULL);; 8267 ; 8268 return mg_strcasecmp(response, expected_response) == 0;; 8269}; 8270 ; 8271 ; 8272#if !defined(NO_FILESYSTEMS); 8273/* Use the global passwords file, if specified by auth_gpass option,; 8274 * or search for .htpasswd in the requested directory. */; 8275static void; 8276open_auth_file(struct mg_connection *conn,; 8277 const char *path,; 8278 struct mg_file *filep); 8279{; 8280 if ((conn != NULL) && (conn->dom_ctx != NULL)) {; 8281 char name[UTF8_PATH_MAX];; 8282 const char *p, *e,; 8283 *gpass = conn->dom_ctx->config[GLOBAL_PASSWORDS_FILE];; 8284 int truncated;; 8285 ; 8286 if (gpass != NULL) {; 8287 /* Use global passwords file */; 8288 if (!mg_fopen(conn, gpass, MG_FOPEN_MODE_READ, filep)) {; 8289#if defined(DEBUG); 8290 /* Use mg_cry_internal here, since gpass has been; 8291 * configured. */; 8292 mg_cry_internal(conn, ""fopen(%s): %s"", gpass, strerror(ERRNO));; 8293#endif; 8294 }; 8295 /* Important: using local struct mg_file to test path for; 8296 * is_directory flag. If filep is used, mg_stat() makes it; 8297 * appear as if auth file was opened.; 8298 * TODO(mid): Check if this is still required after rewriting; 8299 * mg_stat */; 8300 } else if (mg_stat(conn, path, &filep->stat); 8301 && filep->stat.is_directory) {; 8302 mg_snprintf(conn,; 8303 &truncated,; 8304 name,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but only a trace, since; 8313 * this is a typical case. It will occur for every directory; 8314 * without a password file. */; 8315 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8316#endif; 8317 }; 8318 } else {; 8319 /* Try to find .htpasswd in requested directory. */; 8320 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8321 if (e[0] == '/') {; 8322 break;; 83",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:243686,Testability,log,login,243686,"->qop = value;; 8412 } else if (!strcmp(name, ""nc"")) {; 8413 ah->nc = value;; 8414 } else if (!strcmp(name, ""nonce"")) {; 8415 ah->nonce = value;; 8416 }; 8417 }; 8418 ; 8419#if !defined(NO_NONCE_CHECK); 8420 /* Read the nonce from the response. */; 8421 if (ah->nonce == NULL) {; 8422 return 0;; 8423 }; 8424 s = NULL;; 8425 nonce = strtoull(ah->nonce, &s, 10);; 8426 if ((s == NULL) || (*s != 0)) {; 8427 return 0;; 8428 }; 8429 ; 8430 /* Convert the nonce from the client to a number. */; 8431 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8432 ; 8433 /* The converted number corresponds to the time the nounce has been; 8434 * created. This should not be earlier than the server start. */; 8435 /* Server side nonce check is valuable in all situations but one:; 8436 * if the server restarts frequently, but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:332196,Testability,log,log,332196,"o not send anything back to client, until we buffer in all; 11447 * HTTP headers. */; 11448 data_len = 0;; 11449 buf = (char *)mg_malloc_ctx(buflen, conn->phys_ctx);; 11450 if (buf == NULL) {; 11451 mg_send_http_error(conn,; 11452 500,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:336341,Testability,test,test,336341,"[1]);; 11581 }; 11582 ; 11583 if (out != NULL) {; 11584 fclose(out);; 11585 } else if (fdout[0] != -1) {; 11586 close(fdout[0]);; 11587 }; 11588 ; 11589 if (err != NULL) {; 11590 fclose(err);; 11591 } else if (fderr[0] != -1) {; 11592 close(fderr[0]);; 11593 }; 11594 ; 11595 mg_free(buf);; 11596}; 11597#endif /* !NO_CGI */; 11598 ; 11599 ; 11600#if !defined(NO_FILES); 11601static void; 11602mkcol(struct mg_connection *conn, const char *path); 11603{; 11604 int rc, body_len;; 11605 struct de de;; 11606 ; 11607 if (conn == NULL) {; 11608 return;; 11609 }; 11610 ; 11611 /* TODO (mid): Check the mg_send_http_error situations in this function; 11612 */; 11613 ; 11614 memset(&de.file, 0, sizeof(de.file));; 11615 if (!mg_stat(conn, path, &de.file)) {; 11616 mg_cry_internal(conn,; 11617 ""%s: mg_stat(%s) failed: %s"",; 11618 __func__,; 11619 path,; 11620 strerror(ERRNO));; 11621 }; 11622 ; 11623 if (de.file.last_modified) {; 11624 /* TODO (mid): This check does not seem to make any sense ! */; 11625 /* TODO (mid): Add a webdav unit test first, before changing; 11626 * anything here. */; 11627 mg_send_http_error(; 11628 conn, 405, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11629 return;; 11630 }; 11631 ; 11632 body_len = conn->data_len - conn->request_len;; 11633 if (body_len > 0) {; 11634 mg_send_http_error(; 11635 conn, 415, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11636 return;; 11637 }; 11638 ; 11639 rc = mg_mkdir(conn, path, 0755);; 11640 ; 11641 if (rc == 0) {; 11642 ; 11643 /* Create 201 ""Created"" response */; 11644 mg_response_header_start(conn, 201);; 11645 send_static_cache_header(conn);; 11646 send_additional_header(conn);; 11647 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 11648 ; 11649 /* Send all headers - there is no body */; 11650 mg_response_header_send(conn);; 11651 ; 11652 } else {; 11653 if (errno == EEXIST) {; 11654 mg_send_http_error(; 11655 conn, 405, ""Error: mkcol(%s): %s"", path, strerror(ERRNO));; 11656 } else if (errno == EA",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:352097,Testability,test,test,352097,"; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12144 }; 12145 if (cors3[0]) {; 12146 mg_response_header_add(conn, cors3, cors4, -1);; 12147 }; 12148 mg_response_header_send(conn);; 12149 ; 12150 /* Header sent, now send body */; 12151 send_ssi_file(conn, path, filep, 0);; 12152 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12153 }; 12154}; 12155#endif /* NO_FILESYSTEMS */; 12156 ; 12157 ; 12158#if !defined(NO_FILES); 12159static void; 12160send_options(struct mg_connection *conn); 12161{; 12162 if (!conn) {; 12163 return;; 12164 }; 12165 ; 12166 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12167 * Since browsers do not send an OPTIONS request, we can not test the; 12168 * effect anyway. */; 12169 ; 12170 mg_response_header_start(conn, 200);; 12171 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12172 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12173 /* Use the same as before */; 12174 mg_response_header_add(; 12175 conn,; 12176 ""Allow"",; 12177 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 12178 -1);; 12179 mg_response_header_add(conn, ""DAV"", ""1"", -1);; 12180 } else {; 12181 /* TODO: Check this later for HTTP/2 */; 12182 mg_response_header_add(conn, ""Allow"", ""GET, POST"", -1);; 12183 }; 12184 send_additional_header(conn);; 12185 mg_response_header_send(conn);; 12186}; 12187 ; 12188 ; 12189/* Writes PROPFIND properties for a collection element */; 12190static int; 12191print_props(struct mg_connection *conn,; 12192 const char *uri,; 12193 const char *name,; 12194 struct mg_file_stat *filep); 12195{; 12196 size_t href_size, i, j;; 12197 int len;; 12198 char *href, mtime[64];; 1",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:409873,Testability,log,logic,409873,"data_wrapper(struct mg_connection *conn,; 13967 int bits,; 13968 char *data,; 13969 size_t len,; 13970 void *cbdata); 13971{; 13972 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13973 if (pcallbacks->websocket_data) {; 13974 return pcallbacks->websocket_data(conn, bits, data, len);; 13975 }; 13976 /* No handler set - assume ""OK"" */; 13977 return 1;; 13978}; 13979 ; 13980 ; 13981static void; 13982experimental_websocket_client_close_wrapper(const struct mg_connection *conn,; 13983 void *cbdata); 13984{; 13985 struct mg_callbacks *pcallbacks = (struct mg_callbacks *)cbdata;; 13986 if (pcallbacks->connection_close) {; 13987 pcallbacks->connection_close(conn);; 13988 }; 13989}; 13990#endif; 13991 ; 13992 ; 13993/* Decrement recount of handler. conn must not be NULL, handler_info may be NULL; 13994 */; 13995static void; 13996release_handler_ref(struct mg_connection *conn,; 13997 struct mg_handler_info *handler_info); 13998{; 13999 if (handler_info != NULL) {; 14000 /* Use context lock for ref counter */; 14001 mg_lock_context(conn->phys_ctx);; 14002 handler_info->refcount--;; 14003 mg_unlock_context(conn->phys_ctx);; 14004 }; 14005}; 14006 ; 14007 ; 14008/* This is the heart of the Civetweb's logic.; 14009 * This function is called when the request is read, parsed and validated,; 14010 * and Civetweb must decide what action to take: serve a file, or; 14011 * a directory, or call embedded function, etcetera. */; 14012static void; 14013handle_request(struct mg_connection *conn); 14014{; 14015 struct mg_request_info *ri = &conn->request_info;; 14016 char path[UTF8_PATH_MAX];; 14017 int uri_len, ssl_index;; 14018 int is_found = 0, is_script_resource = 0, is_websocket_request = 0,; 14019 is_put_or_delete_request = 0, is_callback_resource = 0,; 14020 is_template_text_file = 0;; 14021 int i;; 14022 struct mg_file file = STRUCT_FILE_INITIALIZER;; 14023 mg_request_handler callback_handler = NULL;; 14024 struct mg_handler_info *handler_info = NULL;; 14025 struct",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:414287,Testability,log,log,414287," = mg_strdup(ri->local_uri_raw);; 14092 if (!tmp) {; 14093 /* Out of memory. We cannot do anything reasonable here. */; 14094 return;; 14095 }; 14096 remove_dot_segments(tmp);; 14097 ri->local_uri = tmp;; 14098 ; 14099 /* step 1. completed, the url is known now */; 14100 DEBUG_TRACE(""URL: %s"", ri->local_uri);; 14101 ; 14102 /* 2. if this ip has limited speed, set it for this connection */; 14103 conn->throttle = set_throttle(conn->dom_ctx->config[THROTTLE],; 14104 &conn->client.rsa,; 14105 ri->local_uri);; 14106 ; 14107 /* 3. call a ""handle everything"" callback, if registered */; 14108 if (conn->phys_ctx->callbacks.begin_request != NULL) {; 14109 /* Note that since V1.7 the ""begin_request"" function is called; 14110 * before an authorization check. If an authorization check is; 14111 * required, use a request_handler instead. */; 14112 i = conn->phys_ctx->callbacks.begin_request(conn);; 14113 if (i > 0) {; 14114 /* callback already processed the request. Store the; 14115 return value as a status code for the access log. */; 14116 conn->status_code = i;; 14117 if (!conn->must_close) {; 14118 discard_unread_request_data(conn);; 14119 }; 14120 return;; 14121 } else if (i == 0) {; 14122 /* civetweb should process the request */; 14123 } else {; 14124 /* unspecified - may change with the next version */; 14125 return;; 14126 }; 14127 }; 14128 ; 14129 /* request not yet handled by a handler or redirect, so the request; 14130 * is processed here */; 14131 ; 14132 /* 4. Check for CORS preflight requests and handle them (if configured).; 14133 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS; 14134 */; 14135 if (!strcmp(ri->request_method, ""OPTIONS"")) {; 14136 /* Send a response to CORS preflights only if; 14137 * access_control_allow_methods is not NULL and not an empty string.; 14138 * In this case, scripts can still handle CORS. */; 14139 const char *cors_meth_cfg =; 14140 conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_METHODS];; 14141 const char *cors_or",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:417693,Testability,test,test,417693,"conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_HEADERS];; 14181 ; 14182 if ((cors_hdr_cfg != NULL) && (*cors_hdr_cfg != 0)) {; 14183 /* Allow only if access_control_allow_headers is; 14184 * not NULL and not an empty string. If this; 14185 * configuration is set to *, allow everything.; 14186 * Otherwise this configuration must be a list; 14187 * of allowed HTTP header names. */; 14188 mg_printf(conn,; 14189 ""Access-Control-Allow-Headers: %s\r\n"",; 14190 ((cors_hdr_cfg[0] == '*') ? cors_acrh; 14191 : cors_hdr_cfg));; 14192 }; 14193 }; 14194 if (cors_cred_cfg && *cors_cred_cfg) {; 14195 mg_printf(conn,; 14196 ""Access-Control-Allow-Credentials: %s\r\n"",; 14197 cors_cred_cfg);; 14198 }; 14199 ; 14200 mg_printf(conn, ""Access-Control-Max-Age: 60\r\n"");; 14201 ; 14202 mg_printf(conn, ""\r\n"");; 14203 return;; 14204 }; 14205 }; 14206 ; 14207 /* 5. interpret the url to find out how the request must be handled; 14208 */; 14209 /* 5.1. first test, if the request targets the regular http(s)://; 14210 * protocol namespace or the websocket ws(s):// protocol namespace.; 14211 */; 14212 is_websocket_request = (conn->protocol_type == PROTOCOL_TYPE_WEBSOCKET);; 14213#if defined(USE_WEBSOCKET); 14214 handler_type = is_websocket_request ? WEBSOCKET_HANDLER : REQUEST_HANDLER;; 14215#else; 14216 handler_type = REQUEST_HANDLER;; 14217#endif /* defined(USE_WEBSOCKET) */; 14218 ; 14219 if (is_websocket_request) {; 14220 HTTP1_only;; 14221 }; 14222 ; 14223 /* 5.2. check if the request will be handled by a callback */; 14224 if (get_request_handler(conn,; 14225 handler_type,; 14226 &callback_handler,; 14227 &subprotocols,; 14228 &ws_connect_handler,; 14229 &ws_ready_handler,; 14230 &ws_data_handler,; 14231 &ws_close_handler,; 14232 NULL,; 14233 &callback_data,; 14234 &handler_info)) {; 14235 /* 5.2.1. A callback will handle this request. All requests; 14236 * handled by a callback have to be considered as requests; 14237 * to a script resource. */; 14238 is_callback_resource = 1;; 14239 is_script",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:421864,Testability,log,log,421864," 6.3. This is either a OPTIONS, GET, HEAD or POST request,; 14313 * or it is a PUT or DELETE request to a resource that does not; 14314 * correspond to a file. Check authorization. */; 14315 if (!check_authorization(conn, path)) {; 14316 send_authorization_request(conn, NULL);; 14317 ; 14318 /* Callback handler will not be used anymore. Release it */; 14319 release_handler_ref(conn, handler_info);; 14320 ; 14321 return;; 14322 }; 14323 }; 14324 ; 14325 /* request is authorized or does not need authorization */; 14326 ; 14327 /* 7. check if there are request handlers for this uri */; 14328 if (is_callback_resource) {; 14329 HTTP1_only;; 14330 if (!is_websocket_request) {; 14331 i = callback_handler(conn, callback_data);; 14332 ; 14333 /* Callback handler will not be used anymore. Release it */; 14334 release_handler_ref(conn, handler_info);; 14335 ; 14336 if (i > 0) {; 14337 /* Do nothing, callback has served the request. Store; 14338 * then return value as status code for the log and discard; 14339 * all data from the client not used by the callback. */; 14340 conn->status_code = i;; 14341 if (!conn->must_close) {; 14342 discard_unread_request_data(conn);; 14343 }; 14344 } else {; 14345 /* The handler did NOT handle the request. */; 14346 /* Some proper reactions would be:; 14347 * a) close the connections without sending anything; 14348 * b) send a 404 not found; 14349 * c) try if there is a file matching the URI; 14350 * It would be possible to do a, b or c in the callback; 14351 * implementation, and return 1 - we cannot do anything; 14352 * here, that is not possible in the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 pat",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:434445,Testability,test,tested,434445,"h));; 14697 }; 14698#endif; 14699 ctx->listening_sockets[i].sock = INVALID_SOCKET;; 14700 }; 14701 mg_free(ctx->listening_sockets);; 14702 ctx->listening_sockets = NULL;; 14703 mg_free(ctx->listening_socket_fds);; 14704 ctx->listening_socket_fds = NULL;; 14705}; 14706 ; 14707 ; 14708/* Valid listening port specification is: [ip_address:]port[s]; 14709 * Examples for IPv4: 80, 443s, 127.0.0.1:3128, 192.0.2.3:8080s; 14710 * Examples for IPv6: [::]:80, [::1]:80,; 14711 * [2001:0db8:7654:3210:FEDC:BA98:7654:3210]:443s; 14712 * see https://tools.ietf.org/html/rfc3513#section-2.2; 14713 * In order to bind to both, IPv4 and IPv6, you can either add; 14714 * both ports using 8080,[::]:8080, or the short form +8080.; 14715 * Both forms differ in detail: 8080,[::]:8080 create two sockets,; 14716 * one only accepting IPv4 the other only IPv6. +8080 creates; 14717 * one socket accepting IPv4 and IPv6. Depending on the IPv6; 14718 * environment, they might work differently, or might not work; 14719 * at all - it must be tested what options work best in the; 14720 * relevant network environment.; 14721 */; 14722static int; 14723parse_port_string(const struct vec *vec, struct socket *so, int *ip_version); 14724{; 14725 unsigned int a, b, c, d;; 14726 unsigned port;; 14727 unsigned long portUL;; 14728 int ch, len;; 14729 const char *cb;; 14730 char *endptr;; 14731#if defined(USE_IPV6); 14732 char buf[100] = {0};; 14733#endif; 14734 ; 14735 /* MacOS needs that. If we do not zero it, subsequent bind() will fail.; 14736 * Also, all-zeroes in the socket address means binding to all addresses; 14737 * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT). */; 14738 memset(so, 0, sizeof(*so));; 14739 so->lsa.sin.sin_family = AF_INET;; 14740 *ip_version = 0;; 14741 ; 14742 /* Initialize len as invalid. */; 14743 port = 0;; 14744 len = 0;; 14745 ; 14746 /* Test for different ways to format this string */; 14747 if (sscanf(vec->ptr,; 14748 ""%u.%u.%u.%u:%u%n"",; 14749 &a,; 14750 &b,; 14751",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452134,Testability,log,log,452134,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452463,Testability,log,log,452463,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452510,Testability,log,log,452510,,MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452840,Testability,log,log,452840,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452869,Testability,log,log,452869,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452959,Testability,log,log,452959,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:452987,Testability,log,logging,452987,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453163,Testability,log,log,453163,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453199,Testability,log,log,453199,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453294,Testability,test,test,453294,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:453548,Testability,log,log,453548,"; 15288 struct mg_file fi;; 15289 char date[64], src_addr[IP_ADDR_STR_LEN];; 15290 struct tm *tm;; 15291 ; 15292 const char *referer;; 15293 const char *user_agent;; 15294 ; 15295 char log_buf[4096];; 15296 ; 15297 if (!conn || !conn->dom_ctx) {; 15298 return;; 15299 }; 15300 ; 15301 /* Set log message to ""empty"" */; 15302 log_buf[0] = 0;; 15303 ; 15304#if defined(USE_LUA); 15305 if (conn->phys_ctx->lua_bg_log_available) {; 15306 int ret;; 15307 struct mg_context *ctx = conn->phys_ctx;; 15308 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 15309 pthread_mutex_lock(&ctx->lua_bg_mutex);; 15310 /* call ""log()"" in Lua */; 15311 lua_getglobal(lstate, ""log"");; 15312 prepare_lua_request_info_inner(conn, lstate);; 15313 push_lua_response_log_data(conn, lstate);; 15314 ; 15315 ret = lua_pcall(lstate, /* args */ 2, /* results */ 1, 0);; 15316 if (ret == 0) {; 15317 int t = lua_type(lstate, -1);; 15318 if (t == LUA_TBOOLEAN) {; 15319 if (lua_toboolean(lstate, -1) == 0) {; 15320 /* log() returned false: do not log */; 15321 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15322 return;; 15323 }; 15324 /* log returned true: continue logging */; 15325 } else if (t == LUA_TSTRING) {; 15326 size_t len;; 15327 const char *txt = lua_tolstring(lstate, -1, &len);; 15328 if ((len == 0) || (*txt == 0)) {; 15329 /* log() returned empty string: do not log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:454223,Testability,log,log,454223,"log */; 15330 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15331 return;; 15332 }; 15333 /* Copy test from Lua into log_buf */; 15334 if (len >= sizeof(log_buf)) {; 15335 len = sizeof(log_buf) - 1;; 15336 }; 15337 memcpy(log_buf, txt, len);; 15338 log_buf[len] = 0;; 15339 }; 15340 } else {; 15341 lua_cry(conn, ret, lstate, ""lua_background_script"", ""log"");; 15342 }; 15343 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 15344 }; 15345#endif; 15346 ; 15347 if (conn->dom_ctx->config[ACCESS_LOG_FILE] != NULL) {; 15348 if (mg_fopen(conn,; 15349 conn->dom_ctx->config[ACCESS_LOG_FILE],; 15350 MG_FOPEN_MODE_APPEND,; 15351 &fi); 15352 == 0) {; 15353 fi.access.fp = NULL;; 15354 }; 15355 } else {; 15356 fi.access.fp = NULL;; 15357 }; 15358 ; 15359 /* Log is written to a file and/or a callback. If both are not set,; 15360 * executing the rest of the function is pointless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?""",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:454857,Testability,log,log,454857,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455413,Testability,log,log,455413,"ntless. */; 15361 if ((fi.access.fp == NULL); 15362 && (conn->phys_ctx->callbacks.log_access == NULL)) {; 15363 return;; 15364 }; 15365 ; 15366 /* If we did not get a log message from Lua, create it here. */; 15367 if (!log_buf[0]) {; 15368 tm = localtime(&conn->conn_birth_time);; 15369 if (tm != NULL) {; 15370 strftime(date, sizeof(date), ""%d/%b/%Y:%H:%M:%S %z"", tm);; 15371 } else {; 15372 mg_strlcpy(date, ""01/Jan/1970:00:00:00 +0000"", sizeof(date));; 15373 date[sizeof(date) - 1] = '\0';; 15374 }; 15375 ; 15376 ri = &conn->request_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0)",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:455592,Testability,log,log,455592,"_info;; 15377 ; 15378 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 15379 referer = header_val(conn, ""Referer"");; 15380 user_agent = header_val(conn, ""User-Agent"");; 15381 ; 15382 mg_snprintf(conn,; 15383 NULL, /* Ignore truncation in access log */; 15384 log_buf,; 15385 sizeof(log_buf),; 15386 ""%s - %s [%s] \""%s %s%s%s HTTP/%s\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_co",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:456152,Testability,log,log,456152,": """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list, &vec, NULL)) != NULL) {; 15455 flag = vec.ptr[0];; 15456 matched = -1;; 15457 if ((vec.len > 0) && ((flag == '+') || (flag == '-'))) {; 15458 vec.ptr++;; 15459 vec.len--;; 15460 matched = parse_match_net(&vec, sa, 1);; 15461 }; 15462 if (matched < 0) {; 15463 mg_cry_ctx_internal(phys_ctx,; 15464 ""%s: su",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:506016,Testability,test,test,506016,"C); 17005#pragma GCC diagnostic push; 17006#pragma GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:519790,Testability,test,test,519790,"e,; 17468 ""%s"",; 17469 ""Invalid parameters"");; 17470 }; 17471 return NULL;; 17472 }; 17473 ; 17474 /* check all known protocolls */; 17475 if (!mg_strcasecmp(protocol, ""http"")) {; 17476 is_ssl = 0;; 17477 is_ws = 0;; 17478 } else if (!mg_strcasecmp(protocol, ""https"")) {; 17479 is_ssl = 1;; 17480 is_ws = 0;; 17481#if defined(USE_WEBSOCKET); 17482 } else if (!mg_strcasecmp(protocol, ""ws"")) {; 17483 is_ssl = 0;; 17484 is_ws = 1;; 17485 } else if (!mg_strcasecmp(protocol, ""wss"")) {; 17486 is_ssl = 1;; 17487 is_ws = 1;; 17488#endif; 17489 } else {; 17490 if ((error != NULL) && (error->text_buffer_size > 0)) {; 17491 mg_snprintf(NULL,; 17492 NULL, /* No truncation check for error buffers */; 17493 error->text,; 17494 error->text_buffer_size,; 17495 ""Protocol %s not supported"",; 17496 protocol);; 17497 }; 17498 return NULL;; 17499 }; 17500 ; 17501 /* TODO: The current implementation here just calls the old; 17502 * implementations, without using any new options. This is just a first; 17503 * step to test the new interfaces. */; 17504#if defined(USE_WEBSOCKET); 17505 if (is_ws) {; 17506 /* TODO: implement all options */; 17507 return mg_connect_websocket_client(; 17508 host,; 17509 port,; 17510 is_ssl,; 17511 ((error != NULL) ? error->text : NULL),; 17512 ((error != NULL) ? error->text_buffer_size : 0),; 17513 (path ? path : """"),; 17514 NULL /* TODO: origin */,; 17515 experimental_websocket_client_data_wrapper,; 17516 experimental_websocket_client_close_wrapper,; 17517 (void *)init->callbacks);; 17518 }; 17519#endif; 17520 ; 17521 /* TODO: all additional options */; 17522 struct mg_client_options opts;; 17523 memset(&opts, 0, sizeof(opts));; 17524 opts.host = host;; 17525 opts.port = port;; 17526 return mg_connect_client_impl(&opts,; 17527 is_ssl,; 17528 ((error != NULL) ? error->text : NULL),; 17529 ((error != NULL) ? error->text_buffer_size; 17530 : 0));; 17531}; 17532#endif; 17533 ; 17534 ; 17535static const struct {; 17536 const char *proto;; 17537 size_t proto_len;; 175",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:535281,Testability,test,test,535281,"or"");; 18001 return -1;; 18002 }; 18003 ; 18004 /* Reset the previous responses */; 18005 conn->data_len = 0;; 18006 ; 18007 /* Implementation of API function for HTTP clients */; 18008 save_timeout = conn->dom_ctx->config[REQUEST_TIMEOUT];; 18009 ; 18010 if (timeout >= 0) {; 18011 mg_snprintf(conn, NULL, txt, sizeof(txt), ""%i"", timeout);; 18012 new_timeout = txt;; 18013 } else {; 18014 new_timeout = NULL;; 18015 }; 18016 ; 18017 conn->dom_ctx->config[REQUEST_TIMEOUT] = new_timeout;; 18018 ret = get_response(conn, ebuf, ebuf_len, &err);; 18019 conn->dom_ctx->config[REQUEST_TIMEOUT] = save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 18029 ; 18030 ; 18031struct mg_connection *; 18032mg_download(const char *host,; 18033 int port,; 18034 int use_ssl,; 18035 char *ebuf,; 18036 size_t ebuf_len,; 18037 const char *fmt,; 18038 ...); 18039{; 18040 struct mg_connection *conn;; 18041 va_list ap;; 18042 int i;; 18043 int reqerr;; 18044 ; 18045 if (ebuf_len > 0) {; 18046 ebuf[0] = '\0';; 18047 }; 18048 ; 18049 va_start(ap, fmt);; 18050 ; 18051 /* open a connection */; 18052 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18053 ; 18054 if (conn != NULL) {; 18055 i = mg_vprintf(conn, fmt, ap);; 18056 if (i <= 0) {; 18057 mg_snprintf(conn,; 18058 NULL, /* No truncation check for ebuf */; 18059 ebuf,; 18060 ebuf_len,; 18061 ""%s"",; 18062 ""Error sending request"");; 18063 } else {; 18064 /* make sure the buffer is clear */; 18065 conn->data_len = 0;; 18066 get_response(conn, ebuf, ebuf_len, &reqerr);; 18067 ; 18068 /* TODO: here, the URI is the http response code */; 18069 conn->request_info.local_uri = conn->re",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:552474,Testability,test,test,552474,"est_uri, conn);; 18583 if (hostend) {; 18584 conn->request_info.local_uri_raw = hostend;; 18585 } else {; 18586 conn->request_info.local_uri_raw = NULL;; 18587 }; 18588 break;; 18589 default:; 18590 mg_snprintf(conn,; 18591 NULL, /* No truncation check for ebuf */; 18592 ebuf,; 18593 sizeof(ebuf),; 18594 ""Invalid URI"");; 18595 mg_send_http_error(conn, 400, ""%s"", ebuf);; 18596 conn->request_info.local_uri_raw = NULL;; 18597 break;; 18598 }; 18599 conn->request_info.local_uri =; 18600 (char *)conn->request_info.local_uri_raw;; 18601 }; 18602 ; 18603 if (ebuf[0] != '\0') {; 18604 conn->protocol_type = -1;; 18605 ; 18606 } else {; 18607 /* HTTP/1 allows protocol upgrade */; 18608 conn->protocol_type = should_switch_to_protocol(conn);; 18609 ; 18610 if (conn->protocol_type == PROTOCOL_TYPE_HTTP2) {; 18611 /* This will occur, if a HTTP/1.1 request should be upgraded; 18612 * to HTTP/2 - but not if HTTP/2 is negotiated using ALPN.; 18613 * Since most (all?) major browsers only support HTTP/2 using; 18614 * ALPN, this is hard to test and very low priority.; 18615 * Deactivate it (at least for now).; 18616 */; 18617 conn->protocol_type = PROTOCOL_TYPE_HTTP1;; 18618 }; 18619 }; 18620 ; 18621 DEBUG_TRACE(""http: %s, error: %s"",; 18622 (ri->http_version ? ri->http_version : ""none""),; 18623 (ebuf[0] ? ebuf : ""none""));; 18624 ; 18625 if (ebuf[0] == '\0') {; 18626 if (conn->request_info.local_uri) {; 18627 ; 18628 /* handle request to local server */; 18629 handle_request_stat_log(conn);; 18630 ; 18631 } else {; 18632 /* TODO: handle non-local request (PROXY) */; 18633 conn->must_close = 1;; 18634 }; 18635 } else {; 18636 conn->must_close = 1;; 18637 }; 18638 ; 18639 /* Response complete. Free header buffer */; 18640 free_buffered_response_header_list(conn);; 18641 ; 18642 if (ri->remote_user != NULL) {; 18643 mg_free((void *)ri->remote_user);; 18644 /* Important! When having connections with and without auth; 18645 * would cause double free and then crash */; 18646 ri->remote_user ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:574235,Testability,log,log,574235,"223 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 19224#endif; 19225 tls.is_master = 1;; 19226 pthread_setspecific(sTlsKey, &tls);; 19227 ; 19228 if (ctx->callbacks.init_thread) {; 19229 /* Callback for the master thread (type 0) */; 19230 tls.user_ptr = ctx->callbacks.init_thread(ctx, 0);; 19231 } else {; 19232 tls.user_ptr = NULL;; 19233 }; 19234 ; 19235 /* Lua background script ""start"" event */; 19236#if defined(USE_LUA); 19237 if (ctx->lua_background_state) {; 19238 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19239 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19240 ; 19241 /* call ""start()"" in Lua */; 19242 lua_getglobal(lstate, ""start"");; 19243 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19244 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19245 if (ret != 0) {; 19246 struct mg_connection fc;; 19247 lua_cry(fake_connection(&fc, ctx),; 19248 ret,; 19249 lstate,; 19250 ""lua_background_script"",; 19251 ""start"");; 19252 }; 19253 } else {; 19254 lua_pop(lstate, 1);; 19255 }; 19256 ; 19257 /* determine if there is a ""log()"" function in Lua background script */; 19258 lua_getglobal(lstate, ""log"");; 19259 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19260 ctx->lua_bg_log_available = 1;; 19261 }; 19262 lua_pop(lstate, 1);; 19263 ; 19264 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19265 }; 19266#endif; 19267 ; 19268 /* Server starts *now* */; 19269 ctx->start_time = time(NULL);; 19270 ; 19271 /* Server accept loop */; 19272 pfd = ctx->listening_socket_fds;; 19273 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 19274 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19275 pfd[i].fd = ctx->listening_sockets[i].sock;; 19276 pfd[i].events = POLLIN;; 19277 }; 19278 ; 19279 if (mg_poll(pfd,; 19280 ctx->num_listening_sockets,; 19281 SOCKET_TIMEOUT_QUANTUM,; 19282 &(ctx->stop_flag)); 19283 > 0) {; 19284 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19285 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19286",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:574309,Testability,log,log,574309,"223 tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);; 19224#endif; 19225 tls.is_master = 1;; 19226 pthread_setspecific(sTlsKey, &tls);; 19227 ; 19228 if (ctx->callbacks.init_thread) {; 19229 /* Callback for the master thread (type 0) */; 19230 tls.user_ptr = ctx->callbacks.init_thread(ctx, 0);; 19231 } else {; 19232 tls.user_ptr = NULL;; 19233 }; 19234 ; 19235 /* Lua background script ""start"" event */; 19236#if defined(USE_LUA); 19237 if (ctx->lua_background_state) {; 19238 lua_State *lstate = (lua_State *)ctx->lua_background_state;; 19239 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19240 ; 19241 /* call ""start()"" in Lua */; 19242 lua_getglobal(lstate, ""start"");; 19243 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19244 int ret = lua_pcall(lstate, /* args */ 0, /* results */ 0, 0);; 19245 if (ret != 0) {; 19246 struct mg_connection fc;; 19247 lua_cry(fake_connection(&fc, ctx),; 19248 ret,; 19249 lstate,; 19250 ""lua_background_script"",; 19251 ""start"");; 19252 }; 19253 } else {; 19254 lua_pop(lstate, 1);; 19255 }; 19256 ; 19257 /* determine if there is a ""log()"" function in Lua background script */; 19258 lua_getglobal(lstate, ""log"");; 19259 if (lua_type(lstate, -1) == LUA_TFUNCTION) {; 19260 ctx->lua_bg_log_available = 1;; 19261 }; 19262 lua_pop(lstate, 1);; 19263 ; 19264 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19265 }; 19266#endif; 19267 ; 19268 /* Server starts *now* */; 19269 ctx->start_time = time(NULL);; 19270 ; 19271 /* Server accept loop */; 19272 pfd = ctx->listening_socket_fds;; 19273 while (STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 19274 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19275 pfd[i].fd = ctx->listening_sockets[i].sock;; 19276 pfd[i].events = POLLIN;; 19277 }; 19278 ; 19279 if (mg_poll(pfd,; 19280 ctx->num_listening_sockets,; 19281 SOCKET_TIMEOUT_QUANTUM,; 19282 &(ctx->stop_flag)); 19283 > 0) {; 19284 for (i = 0; i < ctx->num_listening_sockets; i++) {; 19285 /* NOTE(lsm): on QNX, poll() returns POLLRDNORM after the; 19286",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:50750,Usability,simpl,simple,50750,"ostic ignored ""-Wunreachable-code""; 1627 /* For every compiler, either ""sizeof(pthread_t) > sizeof(unsigned long)""; 1628 * or not, so one of the two conditions will be unreachable by construction.; 1629 * Unfortunately the C standard does not define a way to check this at; 1630 * compile time, since the #if preprocessor conditions can not use the; 1631 * sizeof operator as an argument. */; 1632#endif; 1633 ; 1634 if (sizeof(pthread_t) > sizeof(unsigned long)) {; 1635 /* This is the problematic case for CRYPTO_set_id_callback:; 1636 * The OS pthread_t can not be cast to unsigned long. */; 1637 struct mg_workerTLS *tls =; 1638 (struct mg_workerTLS *)pthread_getspecific(sTlsKey);; 1639 if (tls == NULL) {; 1640 /* SSL called from an unknown thread: Create some thread index.; 1641 */; 1642 tls = (struct mg_workerTLS *)mg_malloc(sizeof(struct mg_workerTLS));; 1643 tls->is_master = -2; /* -2 means ""3rd party thread"" */; 1644 tls->thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);; 1645 pthread_setspecific(sTlsKey, tls);; 1646 }; 1647 return tls->thread_idx;; 1648 } else {; 1649 /* pthread_t may be any data type, so a simple cast to unsigned long; 1650 * can rise a warning/error, depending on the platform.; 1651 * Here memcpy is used as an anything-to-anything cast. */; 1652 unsigned long ret = 0;; 1653 pthread_t t = pthread_self();; 1654 memcpy(&ret, &t, sizeof(pthread_t));; 1655 return ret;; 1656 }; 1657 ; 1658#if defined(__clang__); 1659#pragma clang diagnostic pop; 1660#endif; 1661 ; 1662#endif; 1663}; 1664 ; 1665 ; 1666FUNCTION_MAY_BE_UNUSED; 1667static uint64_t; 1668mg_get_current_time_ns(void); 1669{; 1670 struct timespec tsnow;; 1671 clock_gettime(CLOCK_REALTIME, &tsnow);; 1672 return (((uint64_t)tsnow.tv_sec) * 1000000000) + (uint64_t)tsnow.tv_nsec;; 1673}; 1674 ; 1675 ; 1676#if defined(GCC_DIAGNOSTIC); 1677/* Show no warning in case system functions are not used. */; 1678#pragma GCC diagnostic pop; 1679#endif /* defined(GCC_DIAGNOSTIC) */; 1680#if defined(__cla",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:54226,Usability,simpl,simply,54226,"L argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/engine.h>; 1748#include <openssl/err.h>; 1749#include <openssl/opensslv.h>; 1750#include <openssl/pem.h>; 1751#include <openssl/ssl.h>; 1752#include <openssl/tls1.h>; 1753#include <openssl/x509.h>; 1754 ; 1755#if defined(WOLFSSL_VERSION); 1756/* Additional defines for WolfSSL, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767 * the standard memory functions.; 1768 *; 1769 * #define OPENSSL_free free */; 1770#define free free; 1771// disable for boringssl; 1772#define CONF_modules_unload(a) ((void)0); 1773#define ENGINE_cleanup() ((void)0); 1774#endif; 1775 ; 1776/* If OpenSSL headers are included, automatically select the API version */; 1777#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1778#if !defined(OPENSSL_API_3_0); 1779#define OPENSSL_API_3_0; 1780#endif; 1781#define OPENSSL_REMOVE_THREAD_STATE(); 1782#else; 1783#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1784#if !defined(OPENSSL_API_1_1); 1785#define OPENSSL_API_1_1; 1786#endif; 1787#define OPENSSL_REMOVE_THREAD_STATE(); 1788#else; 1789#if !defined(OPENSSL_API_1_0); 1790#define OPENSSL_API_1_0; 1791#endif; 1792#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1793#endif; 1794#endif; 1795 ; 1796 ; 1797#else; 1798/* SSL loaded dynamically from DLL / shared object */; 1799/* Add all prototypes here,",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:172534,Usability,feedback,feedback,172534,"NO));; 5836 }; 5837 }; 5838 exit(EXIT_FAILURE);; 5839 }; 5840 ; 5841 return pid;; 5842}; 5843#endif /* !NO_CGI */; 5844 ; 5845 ; 5846static int; 5847set_non_blocking_mode(SOCKET sock); 5848{; 5849 int flags = fcntl(sock, F_GETFL, 0);; 5850 if (flags < 0) {; 5851 return -1;; 5852 }; 5853 ; 5854 if (fcntl(sock, F_SETFL, (flags | O_NONBLOCK)) < 0) {; 5855 return -1;; 5856 }; 5857 return 0;; 5858}; 5859 ; 5860static int; 5861set_blocking_mode(SOCKET sock); 5862{; 5863 int flags = fcntl(sock, F_GETFL, 0);; 5864 if (flags < 0) {; 5865 return -1;; 5866 }; 5867 ; 5868 if (fcntl(sock, F_SETFL, flags & (~(int)(O_NONBLOCK))) < 0) {; 5869 return -1;; 5870 }; 5871 return 0;; 5872}; 5873#endif /* _WIN32 / else */; 5874 ; 5875/* End of initial operating system specific define block. */; 5876 ; 5877 ; 5878/* Get a random number (independent of C rand function) */; 5879static uint64_t; 5880get_random(void); 5881{; 5882 static uint64_t lfsr = 0; /* Linear feedback shift register */; 5883 static uint64_t lcg = 0; /* Linear congruential generator */; 5884 uint64_t now = mg_get_current_time_ns();; 5885 ; 5886 if (lfsr == 0) {; 5887 /* lfsr will be only 0 if has not been initialized,; 5888 * so this code is called only once. */; 5889 lfsr = mg_get_current_time_ns();; 5890 lcg = mg_get_current_time_ns();; 5891 } else {; 5892 /* Get the next step of both random number generators. */; 5893 lfsr = (lfsr >> 1); 5894 | ((((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 3) ^ (lfsr >> 4)) & 1); 5895 << 63);; 5896 lcg = lcg * 6364136223846793005LL + 1442695040888963407LL;; 5897 }; 5898 ; 5899 /* Combining two pseudo-random number generators and a high resolution; 5900 * part; 5901 * of the current server time will make it hard (impossible?) to guess; 5902 * the; 5903 * next number. */; 5904 return (lfsr ^ lcg ^ now);; 5905}; 5906 ; 5907 ; 5908static int; 5909mg_poll(struct mg_pollfd *pfd,; 5910 unsigned int n,; 5911 int milliseconds,; 5912 const stop_flag_t *stop_flag); 5913{; 5914 /* Call poll, but only fo",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:423452,Usability,simpl,simpler,423452,"n the callback.; 14353 *; 14354 * TODO: What would be the best reaction here?; 14355 * (Note: The reaction may change, if there is a better; 14356 * idea.); 14357 */; 14358 ; 14359 /* For the moment, use option c: We look for a proper file,; 14360 * but since a file request is not always a script resource,; 14361 * the authorization check might be different. */; 14362 interpret_uri(conn,; 14363 path,; 14364 sizeof(path),; 14365 &file.stat,; 14366 &is_found,; 14367 &is_script_resource,; 14368 &is_websocket_request,; 14369 &is_put_or_delete_request,; 14370 &is_template_text_file);; 14371 callback_handler = NULL;; 14372 ; 14373 /* Here we are at a dead end:; 14374 * According to URI matching, a callback should be; 14375 * responsible for handling the request,; 14376 * we called it, but the callback declared itself; 14377 * not responsible.; 14378 * We use a goto here, to get out of this dead end,; 14379 * and continue with the default handling.; 14380 * A goto here is simpler and better to understand; 14381 * than some curious loop. */; 14382 goto no_callback_resource;; 14383 }; 14384 } else {; 14385#if defined(USE_WEBSOCKET); 14386 handle_websocket_request(conn,; 14387 path,; 14388 is_callback_resource,; 14389 subprotocols,; 14390 ws_connect_handler,; 14391 ws_ready_handler,; 14392 ws_data_handler,; 14393 ws_close_handler,; 14394 callback_data);; 14395#endif; 14396 }; 14397 return;; 14398 }; 14399 ; 14400 /* 8. handle websocket requests */; 14401#if defined(USE_WEBSOCKET); 14402 if (is_websocket_request) {; 14403 HTTP1_only;; 14404 if (is_script_resource) {; 14405 ; 14406 if (is_in_script_path(conn, path)) {; 14407 /* Websocket Lua script */; 14408 handle_websocket_request(conn,; 14409 path,; 14410 0 /* Lua Script */,; 14411 NULL,; 14412 NULL,; 14413 NULL,; 14414 NULL,; 14415 NULL,; 14416 conn->phys_ctx->user_data);; 14417 } else {; 14418 /* Script was in an illegal path */; 14419 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14420 }; 14421 } else {; 14422 mg_sen",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:442368,Usability,simpl,simple,442368,"ions; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hostnames, so in most cases the only name will be ""localhost"".; 14934 *; 14935 * So, for now, we use this simple algorithm, that may still return; 14936 * a false positive in bizarre cases.; 14937 */; 14938 int i;; 14939 int portslen = (int)strlen(ports);; 14940 char prevIsNumber = 0;; 14941 ; 14942 for (i = 0; i < portslen; i++) {; 14943 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14944 return 1;; 14945 }; 14946 if (ports[i] >= '0' && ports[i] <= '9') {; 14947 prevIsNumber = 1;; 14948 } else {; 14949 prevIsNumber = 0;; 14950 }; 14951 }; 14952 }; 14953 return 0;; 14954}; 14955 ; 14956 ; 14957static int; 14958set_ports_option(struct mg_context *phys_ctx); 14959{; 14960 const char *list;; 14961 int on = 1;; 14962#if defined(USE_IPV6); 14963 int off = 0;; 14964#endif; 14965 struct vec vec;; 14966 struct socket so, *ptr;; 14967 ; 14968 struct mg_pollfd *pfd;; 14969 union usa usa;; 14970 socklen_t len;; 14971 int ip_version;; 14972 ; 14973 int portsTotal = 0;; 14974 int portsOk = 0;; 14975 ; 14976 const char *opt_txt;; 14977 long opt_listen_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/civetweb_8c_source.html:536159,Usability,clear,clear,536159," save_timeout;; 18020 ; 18021 /* TODO: here, the URI is the http response code */; 18022 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18023 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18024 ; 18025 /* TODO (mid): Define proper return values - maybe return length?; 18026 * For the first test use <0 for error and >0 for OK */; 18027 return (ret == 0) ? -1 : +1;; 18028}; 18029 ; 18030 ; 18031struct mg_connection *; 18032mg_download(const char *host,; 18033 int port,; 18034 int use_ssl,; 18035 char *ebuf,; 18036 size_t ebuf_len,; 18037 const char *fmt,; 18038 ...); 18039{; 18040 struct mg_connection *conn;; 18041 va_list ap;; 18042 int i;; 18043 int reqerr;; 18044 ; 18045 if (ebuf_len > 0) {; 18046 ebuf[0] = '\0';; 18047 }; 18048 ; 18049 va_start(ap, fmt);; 18050 ; 18051 /* open a connection */; 18052 conn = mg_connect_client(host, port, use_ssl, ebuf, ebuf_len);; 18053 ; 18054 if (conn != NULL) {; 18055 i = mg_vprintf(conn, fmt, ap);; 18056 if (i <= 0) {; 18057 mg_snprintf(conn,; 18058 NULL, /* No truncation check for ebuf */; 18059 ebuf,; 18060 ebuf_len,; 18061 ""%s"",; 18062 ""Error sending request"");; 18063 } else {; 18064 /* make sure the buffer is clear */; 18065 conn->data_len = 0;; 18066 get_response(conn, ebuf, ebuf_len, &reqerr);; 18067 ; 18068 /* TODO: here, the URI is the http response code */; 18069 conn->request_info.local_uri = conn->request_info.request_uri;; 18070 }; 18071 }; 18072 ; 18073 /* if an error occurred, close the connection */; 18074 if ((ebuf[0] != '\0') && (conn != NULL)) {; 18075 mg_close_connection(conn);; 18076 conn = NULL;; 18077 }; 18078 ; 18079 va_end(ap);; 18080 return conn;; 18081}; 18082 ; 18083 ; 18084struct websocket_client_thread_data {; 18085 struct mg_connection *conn;; 18086 mg_websocket_data_handler data_handler;; 18087 mg_websocket_close_handler close_handler;; 18088 void *callback_data;; 18089};; 18090 ; 18091 ; 18092#if defined(USE_WEBSOCKET); 18093#if defined(_WIN32); 18094static ",MatchSource.WIKI,doc/v632/civetweb_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html
https://root.cern/doc/v632/classRooAbsCollection.html:13809,Availability,error,error,13809,"&outColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; void setAttribAll (const Text_t *name, bool value=true);  Set given attribute in each element of the collection by calling each elements setAttribute() function. ;  ; bool setCatIndex (const char *name, Int_t newVal=0, bool verbose=false);  Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; bool setCatLabel (const char *name, const char *newVal="""", bool verbose=false);  Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; void setHashTableSize (Int_t number);  Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; void setName (const char *name);  ; bool setRealValue (const char *name, double newVal=0.0, bool verbose=false);  Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ;  ; bool setStringValue (const char *name, const char *newVal="""", bool verbose=false);  Set string value of a RooStringVar stored in set with given name to newVal. ;  ; Storage_t::size_type size () const;  ; RooAbsCollection * snapshot (bool deepCopy=true) const;  Take a snap shot of current collection contents. ;  ; bool snapshot (RooAbsCollection &output, bool deepCopy=true) const;  Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. ;  ; void sort (bool reverse=false);  Sort collection using std::sort and name comparison. ;  ; void sortTopologically ();  Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void takeOwnership ();  ; RooFit",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:16645,Availability,error,error,16645,"egular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; v",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:16734,Availability,error,error,16734,"e of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTi",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:16889,Availability,error,error,16889,";  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t Has",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:17186,Availability,error,error,17186,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *cl",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:21265,Availability,error,error,21265,"is method must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printAddress (std::ostream &os) const;  Print class name of object. ;  ; virtual void printArgs (std::ostream &os) const;  Interface for printing of objec",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:33678,Availability,error,error,33678,"list that is flagged as owning all of its contents, or else on an empty list (which will force the list into that mode).; If you want to pass an argument that is not owned by a std::unique_ptr, you can use RooAbsCollection::addOwned(RooAbsArg&, bool). ; Definition at line 389 of file RooAbsCollection.cxx. ◆ addTyped(). template<class Arg_t > . bool RooAbsCollection::addTyped ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Adds elements of a given RooAbsCollection to the container if they match the specified type. ; This function iterates through the elements of the provided RooAbsCollection and checks if each element matches the specified type. If any element doesn't match the type, it throws an exception.; Template Parameters. Arg_tThe type to match for elements in the collection. Must inherit from RooAbsArg. . Parameters. listThe RooAbsCollection containing elements to be added. ; silentForwarded to the non-typed add function. If true, suppresses error messages when adding elements, e.g. when the collection is a RooArgSet and the element is already in the set. . ReturnsReturns true if all elements could be added, else false.; Exceptions. std::invalid_argumentif an element in the collection doesn't match the specified type. . Definition at line 171 of file RooAbsCollection.h. ◆ allInRange(). bool RooAbsCollection::allInRange ; (; const char * ; rangeSpec); const. Return true if all contained object report to have their value inside the specified range. ; Definition at line 1473 of file RooAbsCollection.cxx. ◆ assert_is_no_temporary(). template<class T > . static void RooAbsCollection::assert_is_no_temporary ; (; T && ; ). inlinestaticprotected . Definition at line 424 of file RooAbsCollection.h. ◆ assign(). void RooAbsCollection::assign ; (; const RooAbsCollection & ; other); const. Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ; Note that this function changes the values of t",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:42629,Availability,error,error,42629,"dObject ; (; const TObject * ; obj); const. inlineoverridevirtual . Find object in the collection, Note: matching by object name, like the find() method. ; Reimplemented from TObject.; Definition at line 217 of file RooAbsCollection.h. ◆ first(). RooAbsArg * RooAbsCollection::first ; (; ); const. inline . Definition at line 314 of file RooAbsCollection.h. ◆ fwdIterator(). RooFIter RooAbsCollection::fwdIterator ; (; ); const. One-time forward iterator. ; NoteUse begin() and end() or range-based for loop instead. . ◆ get(). Storage_t const & RooAbsCollection::get ; (; ); const. inline . Const access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of fil",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:43014,Availability,error,error,43014,"ooAbsCollection::fwdIterator ; (; ); const. One-time forward iterator. ; NoteUse begin() and end() or range-based for loop instead. . ◆ get(). Storage_t const & RooAbsCollection::get ; (; ); const. inline . Const access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cx",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:43957,Availability,error,error,43957,". No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1097 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1629 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:44518,Availability,error,error,44518,"at give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1097 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1629 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in the collection. ; Definition at line 955 of file RooAbsCollection.cxx. ◆ index() [2/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg & ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 332 of file RooAbsCollection.h. ◆ index() [3/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg * ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 326 of file RooAbsCollection.h. ◆ insert(). void RooAbsCollection::insert ; (; RooAbsArg * ; it",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:49570,Availability,error,error,49570,"put content of collection as LaTex table. ; By default a table with two columns is created: the left column contains the name of each variable, the right column the value.; The following optional named arguments can be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1310 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; o",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:49598,Availability,error,error,49598,"put content of collection as LaTex table. ; By default a table with two columns is created: the left column contains the name of each variable, the right column the value.; The following optional named arguments can be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1310 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; o",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:49797,Availability,error,error,49797," be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1310 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; ofs, . Int_t ; ncol, . const char * ; option = ""NEYU"", . Int_t ; sigDigit = 1, . const RooLinkedList & ; siblingLists = RooLinkedList(), . const RooCmdArg * ; formatCmd = nullptr . ); const. Internal implementation ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:58012,Availability,error,error,58012,"oAbsCollection & ; refColl, . RooAbsCollection & ; outColl . ); const. Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ; Returns true only if something went wrong. The complement of this function is getParameters(). Parameters. [in]refCollThe collection to check for common elements. ; [out]outCollOutput collection. . Definition at line 807 of file RooAbsCollection.cxx. ◆ setAttribAll(). void RooAbsCollection::setAttribAll ; (; const Text_t * ; name, . bool ; value = true . ). Set given attribute in each element of the collection by calling each elements setAttribute() function. ; Definition at line 768 of file RooAbsCollection.cxx. ◆ setCatIndex(). bool RooAbsCollection::setCatIndex ; (; const char * ; name, . Int_t ; newVal = 0, . bool ; verbose = false . ). Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given n",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:58351,Availability,error,error,58351,"ction to check for common elements. ; [out]outCollOutput collection. . Definition at line 807 of file RooAbsCollection.cxx. ◆ setAttribAll(). void RooAbsCollection::setAttribAll ; (; const Text_t * ; name, . bool ; value = true . ). Set given attribute in each element of the collection by calling each elements setAttribute() function. ; Definition at line 768 of file RooAbsCollection.cxx. ◆ setCatIndex(). bool RooAbsCollection::setCatIndex ; (; const char * ; name, . Int_t ; newVal = 0, . bool ; verbose = false . ). Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59081,Availability,error,error,59081,"Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or paramet",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59420,Availability,error,error,59420,"ashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::sna",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:10998,Deployability,release,releaseOwnership,10998,"aTex table. ;  ; void printLatex (std::ostream &ofs, Int_t ncol, const char *option=""NEYU"", Int_t sigDigit=1, const RooLinkedList &siblingLists=RooLinkedList(), const RooCmdArg *formatCmd=nullptr) const;  Internal implementation function of printLatex. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Implement multiline printing of collection, one line for each contained object showing the requested content. ;  ; void printName (std::ostream &os) const override;  Return collection name. ;  ; void printTitle (std::ostream &os) const override;  Return collection title. ;  ; void printValue (std::ostream &os) const override;  Print value of collection, i.e. ;  ; Storage_t::const_reverse_iterator rbegin () const;  ; void RecursiveRemove (TObject *obj) override;  If one of the TObject we have a referenced to is deleted, remove the reference. ;  ; void releaseOwnership ();  ; virtual bool remove (const RooAbsArg &var, bool silent=false, bool matchByNameOnly=false);  Remove the specified argument from our list. ;  ; bool remove (const RooAbsCollection &list, bool silent=false, bool matchByNameOnly=false);  Remove each argument in the input list from our list. ;  ; template<class forwardIt > ; void remove (forwardIt rangeBegin, forwardIt rangeEnd, bool silent=false, bool matchByNameOnly=false);  ; virtual void removeAll ();  Remove all arguments from our set, deleting them if we own them. ;  ; Storage_t::const_reverse_iterator rend () const;  ; virtual bool replace (const RooAbsArg &var1, const RooAbsArg &var2);  Replace var1 with var2 and return true for success. ;  ; bool replace (const RooAbsCollection &other);  Replace any args in our set with args of the same name from the other set and return true for success. ;  ; bool replace (RooAbsArg *var1, std::unique_ptr< RooAbsArg > var2);  Replace var1 with var2 and return true for success. ;  ; void reserve (Storage_t::size_type count);  ; RooAbsCollection * s",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:30643,Deployability,release,release,30643,"roxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 409 of file RooAbsCollection.cxx. ◆ addClone() [2/2]. void RooAbsCollection::addClone ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 524 of file RooAbsCollection.cxx. ◆ addOwned() [1/4]. bool RooAbsCollection::addOwned ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . for each element in the source collection. ; The input list can't be an owning collection itself, otherwise the arguments would be owned by two collections.; If you want to transfer arguments from one owning collection to another, you have two options:; std::move the input collection and use RooAbsCollection::addOwned(RooAbsCollection&&, bool) (preferred); release the ownership of the input collection first, using RooAbsCollection::releaseOwnership() . Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 466 of file RooAbsCollection.cxx. ◆ addOwned() [2/4]. bool RooAbsCollection::addOwned ; (; RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add an argument and transfer the ownership to the collection. ; Returns true if successful, or false if the argument could not be added to the collection (e.g. in the RooArgSet case when an argument with the same name is already in the list). This method can only be called on a list that is flagged as owning all of its contents, or else on an empty list (which will force the list into that mode).; If the argument you want to add is owned by a std::unique_ptr, you should prefer RooAbsCollection::addOwned(std::unique_ptr<RooAbsArg>, bool). ; Reimplemented in RooCollectionProxy< RooArgLis",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:30720,Deployability,release,releaseOwnership,30720,"roxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 409 of file RooAbsCollection.cxx. ◆ addClone() [2/2]. void RooAbsCollection::addClone ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 524 of file RooAbsCollection.cxx. ◆ addOwned() [1/4]. bool RooAbsCollection::addOwned ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . for each element in the source collection. ; The input list can't be an owning collection itself, otherwise the arguments would be owned by two collections.; If you want to transfer arguments from one owning collection to another, you have two options:; std::move the input collection and use RooAbsCollection::addOwned(RooAbsCollection&&, bool) (preferred); release the ownership of the input collection first, using RooAbsCollection::releaseOwnership() . Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 466 of file RooAbsCollection.cxx. ◆ addOwned() [2/4]. bool RooAbsCollection::addOwned ; (; RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add an argument and transfer the ownership to the collection. ; Returns true if successful, or false if the argument could not be added to the collection (e.g. in the RooArgSet case when an argument with the same name is already in the list). This method can only be called on a list that is flagged as owning all of its contents, or else on an empty list (which will force the list into that mode).; If the argument you want to add is owned by a std::unique_ptr, you should prefer RooAbsCollection::addOwned(std::unique_ptr<RooAbsArg>, bool). ; Reimplemented in RooCollectionProxy< RooArgLis",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:52392,Deployability,release,releaseOwnership,52392,"implemented from RooPrintable.; Definition at line 1156 of file RooAbsCollection.cxx. ◆ printTitle(). void RooAbsCollection::printTitle ; (; std::ostream & ; os); const. overridevirtual . Return collection title. ; Reimplemented from RooPrintable.; Definition at line 1166 of file RooAbsCollection.cxx. ◆ printValue(). void RooAbsCollection::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of collection, i.e. ; a comma separated list of contained object names ; Reimplemented from RooPrintable.; Definition at line 1208 of file RooAbsCollection.cxx. ◆ rbegin(). Storage_t::const_reverse_iterator RooAbsCollection::rbegin ; (; ); const. inline . Definition at line 284 of file RooAbsCollection.h. ◆ RecursiveRemove(). void RooAbsCollection::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 1518 of file RooAbsCollection.cxx. ◆ releaseOwnership(). void RooAbsCollection::releaseOwnership ; (; ). inline . Definition at line 378 of file RooAbsCollection.h. ◆ remove() [1/3]. bool RooAbsCollection::remove ; (; const RooAbsArg & ; var, . bool ; silent = false, . bool ; matchByNameOnly = false . ). virtual . Remove the specified argument from our list. ; Return false if the specified argument is not found in our list. An exact pointer match is required, not just a match by name. If matchByNameOnly is set, items will be looked up by name. In this case, if the collection also owns the item, it will delete it. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 649 of file RooAbsCollection.cxx. ◆ remove() [2/3]. bool RooAbsCollection::remove ; (; const RooAbsCollection & ; list, . bool ; silent = false, . bool ; matchByNameOnly = false . ). Remove each argument in the input list from our list. ; An exact pointer match is required, not just a match by name. If matchByNam",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:52435,Deployability,release,releaseOwnership,52435,"inition at line 1156 of file RooAbsCollection.cxx. ◆ printTitle(). void RooAbsCollection::printTitle ; (; std::ostream & ; os); const. overridevirtual . Return collection title. ; Reimplemented from RooPrintable.; Definition at line 1166 of file RooAbsCollection.cxx. ◆ printValue(). void RooAbsCollection::printValue ; (; std::ostream & ; os); const. overridevirtual . Print value of collection, i.e. ; a comma separated list of contained object names ; Reimplemented from RooPrintable.; Definition at line 1208 of file RooAbsCollection.cxx. ◆ rbegin(). Storage_t::const_reverse_iterator RooAbsCollection::rbegin ; (; ); const. inline . Definition at line 284 of file RooAbsCollection.h. ◆ RecursiveRemove(). void RooAbsCollection::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 1518 of file RooAbsCollection.cxx. ◆ releaseOwnership(). void RooAbsCollection::releaseOwnership ; (; ). inline . Definition at line 378 of file RooAbsCollection.h. ◆ remove() [1/3]. bool RooAbsCollection::remove ; (; const RooAbsArg & ; var, . bool ; silent = false, . bool ; matchByNameOnly = false . ). virtual . Remove the specified argument from our list. ; Return false if the specified argument is not found in our list. An exact pointer match is required, not just a match by name. If matchByNameOnly is set, items will be looked up by name. In this case, if the collection also owns the item, it will delete it. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 649 of file RooAbsCollection.cxx. ◆ remove() [2/3]. bool RooAbsCollection::remove ; (; const RooAbsCollection & ; list, . bool ; silent = false, . bool ; matchByNameOnly = false . ). Remove each argument in the input list from our list. ; An exact pointer match is required, not just a match by name. If matchByNameOnly is set, items will be looked ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:13815,Integrability,message,messages,13815,"&outColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; void setAttribAll (const Text_t *name, bool value=true);  Set given attribute in each element of the collection by calling each elements setAttribute() function. ;  ; bool setCatIndex (const char *name, Int_t newVal=0, bool verbose=false);  Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; bool setCatLabel (const char *name, const char *newVal="""", bool verbose=false);  Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; void setHashTableSize (Int_t number);  Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; void setName (const char *name);  ; bool setRealValue (const char *name, double newVal=0.0, bool verbose=false);  Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ;  ; bool setStringValue (const char *name, const char *newVal="""", bool verbose=false);  Set string value of a RooStringVar stored in set with given name to newVal. ;  ; Storage_t::size_type size () const;  ; RooAbsCollection * snapshot (bool deepCopy=true) const;  Take a snap shot of current collection contents. ;  ; bool snapshot (RooAbsCollection &output, bool deepCopy=true) const;  Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. ;  ; void sort (bool reverse=false);  Sort collection using std::sort and name comparison. ;  ; void sortTopologically ();  Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void takeOwnership ();  ; RooFit",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:16651,Integrability,message,message,16651,"egular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; v",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:17192,Integrability,message,message,17192,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *cl",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:18125,Integrability,message,message,18125,"al (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:21271,Integrability,message,message,21271,"is method must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printAddress (std::ostream &os) const;  Print class name of object. ;  ; virtual void printArgs (std::ostream &os) const;  Interface for printing of objec",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:21644,Integrability,message,message,21644," Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printAddress (std::ostream &os) const;  Print class name of object. ;  ; virtual void printArgs (std::ostream &os) const;  Interface for printing of object arguments. ;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:33684,Integrability,message,messages,33684,"list that is flagged as owning all of its contents, or else on an empty list (which will force the list into that mode).; If you want to pass an argument that is not owned by a std::unique_ptr, you can use RooAbsCollection::addOwned(RooAbsArg&, bool). ; Definition at line 389 of file RooAbsCollection.cxx. ◆ addTyped(). template<class Arg_t > . bool RooAbsCollection::addTyped ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Adds elements of a given RooAbsCollection to the container if they match the specified type. ; This function iterates through the elements of the provided RooAbsCollection and checks if each element matches the specified type. If any element doesn't match the type, it throws an exception.; Template Parameters. Arg_tThe type to match for elements in the collection. Must inherit from RooAbsArg. . Parameters. listThe RooAbsCollection containing elements to be added. ; silentForwarded to the non-typed add function. If true, suppresses error messages when adding elements, e.g. when the collection is a RooArgSet and the element is already in the set. . ReturnsReturns true if all elements could be added, else false.; Exceptions. std::invalid_argumentif an element in the collection doesn't match the specified type. . Definition at line 171 of file RooAbsCollection.h. ◆ allInRange(). bool RooAbsCollection::allInRange ; (; const char * ; rangeSpec); const. Return true if all contained object report to have their value inside the specified range. ; Definition at line 1473 of file RooAbsCollection.cxx. ◆ assert_is_no_temporary(). template<class T > . static void RooAbsCollection::assert_is_no_temporary ; (; T && ; ). inlinestaticprotected . Definition at line 424 of file RooAbsCollection.h. ◆ assign(). void RooAbsCollection::assign ; (; const RooAbsCollection & ; other); const. Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ; Note that this function changes the values of t",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:35457,Integrability,synchroniz,synchronize,35457,"ign(). void RooAbsCollection::assign ; (; const RooAbsCollection & ; other); const. Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ; Note that this function changes the values of the elements in this collection, but is still marked const as it does not change which elements this collection points to. ; Definition at line 276 of file RooAbsCollection.cxx. ◆ assignFast(). void RooAbsCollection::assignFast ; (; const RooAbsCollection & ; other, . bool ; setValDirty = true . ); const. Functional equivalent of assign() but assumes this and other collection have same layout. ; Also no attributes are copied ; Definition at line 324 of file RooAbsCollection.cxx. ◆ assignValueOnly(). RooAbsCollection & RooAbsCollection::assignValueOnly ; (; const RooAbsCollection & ; other, . bool ; forceIfSizeOne = false . ). Sets the value of any argument in our set that also appears in the other set. ; Parameters. [in]otherCollection holding the arguments to synchronize values with. ; [in]forceIfSizeOneIf set to true and both our collection and the other collection have a size of one, the arguments are always synchronized without checking if they have the same name. . Definition at line 298 of file RooAbsCollection.cxx. ◆ begin() [1/4]. TIterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:35611,Integrability,synchroniz,synchronized,35611," of any argument in our set that also appears in the other set. ; Note that this function changes the values of the elements in this collection, but is still marked const as it does not change which elements this collection points to. ; Definition at line 276 of file RooAbsCollection.cxx. ◆ assignFast(). void RooAbsCollection::assignFast ; (; const RooAbsCollection & ; other, . bool ; setValDirty = true . ); const. Functional equivalent of assign() but assumes this and other collection have same layout. ; Also no attributes are copied ; Definition at line 324 of file RooAbsCollection.cxx. ◆ assignValueOnly(). RooAbsCollection & RooAbsCollection::assignValueOnly ; (; const RooAbsCollection & ; other, . bool ; forceIfSizeOne = false . ). Sets the value of any argument in our set that also appears in the other set. ; Parameters. [in]otherCollection holding the arguments to synchronize values with. ; [in]forceIfSizeOneIf set to true and both our collection and the other collection have a size of one, the arguments are always synchronized without checking if they have the same name. . Definition at line 298 of file RooAbsCollection.cxx. ◆ begin() [1/4]. TIterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsC",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:42635,Integrability,message,messages,42635,"dObject ; (; const TObject * ; obj); const. inlineoverridevirtual . Find object in the collection, Note: matching by object name, like the find() method. ; Reimplemented from TObject.; Definition at line 217 of file RooAbsCollection.h. ◆ first(). RooAbsArg * RooAbsCollection::first ; (; ); const. inline . Definition at line 314 of file RooAbsCollection.h. ◆ fwdIterator(). RooFIter RooAbsCollection::fwdIterator ; (; ); const. One-time forward iterator. ; NoteUse begin() and end() or range-based for loop instead. . ◆ get(). Storage_t const & RooAbsCollection::get ; (; ); const. inline . Const access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of fil",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:43020,Integrability,message,messages,43020,"ooAbsCollection::fwdIterator ; (; ); const. One-time forward iterator. ; NoteUse begin() and end() or range-based for loop instead. . ◆ get(). Storage_t const & RooAbsCollection::get ; (; ); const. inline . Const access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cx",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:43963,Integrability,message,messages,43963,". No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1097 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1629 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:44524,Integrability,message,messages,44524,"at give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1097 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1629 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in the collection. ; Definition at line 955 of file RooAbsCollection.cxx. ◆ index() [2/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg & ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 332 of file RooAbsCollection.h. ◆ index() [3/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg * ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 326 of file RooAbsCollection.h. ◆ insert(). void RooAbsCollection::insert ; (; RooAbsArg * ; it",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:58018,Integrability,message,messages,58018,"oAbsCollection & ; refColl, . RooAbsCollection & ; outColl . ); const. Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ; Returns true only if something went wrong. The complement of this function is getParameters(). Parameters. [in]refCollThe collection to check for common elements. ; [out]outCollOutput collection. . Definition at line 807 of file RooAbsCollection.cxx. ◆ setAttribAll(). void RooAbsCollection::setAttribAll ; (; const Text_t * ; name, . bool ; value = true . ). Set given attribute in each element of the collection by calling each elements setAttribute() function. ; Definition at line 768 of file RooAbsCollection.cxx. ◆ setCatIndex(). bool RooAbsCollection::setCatIndex ; (; const char * ; name, . Int_t ; newVal = 0, . bool ; verbose = false . ). Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given n",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:58357,Integrability,message,messages,58357,"ction to check for common elements. ; [out]outCollOutput collection. . Definition at line 807 of file RooAbsCollection.cxx. ◆ setAttribAll(). void RooAbsCollection::setAttribAll ; (; const Text_t * ; name, . bool ; value = true . ). Set given attribute in each element of the collection by calling each elements setAttribute() function. ; Definition at line 768 of file RooAbsCollection.cxx. ◆ setCatIndex(). bool RooAbsCollection::setCatIndex ; (; const char * ; name, . Int_t ; newVal = 0, . bool ; verbose = false . ). Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59087,Integrability,message,messages,59087,"Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or paramet",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59426,Integrability,message,messages,59426,"ashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::sna",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59910,Integrability,depend,dependents,59910,"tRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned e",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59957,Integrability,depend,dependents,59957,"tRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned e",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:59977,Integrability,depend,dependents,59977,"tRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned e",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60273,Integrability,depend,dependents,60273,"r * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 of file RooAbsCollection.cxx. ◆ sort(). void RooAbsCollection::sort ; (; bool ; reverse = false). Sort collection using std::sort and name comparison. ; Definition at line 1526 of file RooAbsCollection.cxx. ◆ sortTopologic",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60708,Integrability,depend,dependents,60708,"deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 of file RooAbsCollection.cxx. ◆ sort(). void RooAbsCollection::sort ; (; bool ; reverse = false). Sort collection using std::sort and name comparison. ; Definition at line 1526 of file RooAbsCollection.cxx. ◆ sortTopologically(). void RooAbsCollection::sortTopologically ; (; ). Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ; Definition at line 1550 of file RooAbsCollection.cxx. ◆ Streamer(). void RooAbsCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooArgList, RooArgSet, RooCollectionProxy< RooArgList >, and RooCollectionProxy< R",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60757,Integrability,depend,dependents,60757,"deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 of file RooAbsCollection.cxx. ◆ sort(). void RooAbsCollection::sort ; (; bool ; reverse = false). Sort collection using std::sort and name comparison. ; Definition at line 1526 of file RooAbsCollection.cxx. ◆ sortTopologically(). void RooAbsCollection::sortTopologically ; (; ). Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ; Definition at line 1550 of file RooAbsCollection.cxx. ◆ Streamer(). void RooAbsCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooArgList, RooArgSet, RooCollectionProxy< RooArgList >, and RooCollectionProxy< R",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60777,Integrability,depend,dependents,60777,"deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 of file RooAbsCollection.cxx. ◆ sort(). void RooAbsCollection::sort ; (; bool ; reverse = false). Sort collection using std::sort and name comparison. ; Definition at line 1526 of file RooAbsCollection.cxx. ◆ sortTopologically(). void RooAbsCollection::sortTopologically ; (; ). Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ; Definition at line 1550 of file RooAbsCollection.cxx. ◆ Streamer(). void RooAbsCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooArgList, RooArgSet, RooCollectionProxy< RooArgList >, and RooCollectionProxy< R",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60922,Integrability,depend,dependents,60922,"ents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 of file RooAbsCollection.cxx. ◆ sort(). void RooAbsCollection::sort ; (; bool ; reverse = false). Sort collection using std::sort and name comparison. ; Definition at line 1526 of file RooAbsCollection.cxx. ◆ sortTopologically(). void RooAbsCollection::sortTopologically ; (; ). Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ; Definition at line 1550 of file RooAbsCollection.cxx. ◆ Streamer(). void RooAbsCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooArgList, RooArgSet, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >. ◆ StreamerNVirtual(). void RooAbsCollection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 455 of file RooAbsCollecti",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:1469,Modifiability,inherit,inherited,1469,"s ReferenceabstractRooFit » RooFit Core. ; Abstract container object that can hold multiple RooAbsArg objects. ; Collections are ordered and can contain multiple objects of the same name, (but a derived implementation can enforce unique names). The storage of objects is implemented using the container denoted by RooAbsCollection::Storage_t. PyROOT; Some member functions of RooAbsCollection that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooAbsCollection::printLatex. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; params.printLatex(ROOT.RooFit.Sibling(initParams), ROOT.RooFit.Columns(2)); ; # With keyword arguments:; params.printLatex(Sibling=initParams, Columns =2). Definition at line 65 of file RooAbsCollection.h. Classes; struct  RooAbsArgPtrOrDouble;  . Public Types; using const_iterator = Storage_t::const_iterator;  ; using Storage_t = std::vector< RooAbsArg * >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooAbsCollection ();  Default constructor. ;  ;  Ro",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:2107,Modifiability,inherit,inherited,2107,"uments:; params.printLatex(Sibling=initParams, Columns =2). Definition at line 65 of file RooAbsCollection.h. Classes; struct  RooAbsArgPtrOrDouble;  . Public Types; using const_iterator = Storage_t::const_iterator;  ; using Storage_t = std::vector< RooAbsArg * >;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooAbsCollection ();  Default constructor. ;  ;  RooAbsCollection (const char *name);  Empty collection constructor. ;  ;  RooAbsCollection (const RooAbsCollection &other, const char *name="""");  Copy constructor. ;  ;  RooAbsCollection (RooAbsCollection &&other);  Move constructor. ;  ;  ~RooAbsCollection () override;  Destructor. ;  ; virtual bool add (const RooAbsArg &var, bool silent=false);  Add the specified argument to list. ;  ; bool add (const RooAbsCollection &list, bool silent=false);  Add a collection of arguments to this collection by calling add() for each element in the source collection. ;  ; template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:15001,Modifiability,inherit,inherited,15001,"stored in set with given name to newVal. ;  ; Storage_t::size_type size () const;  ; RooAbsCollection * snapshot (bool deepCopy=true) const;  Take a snap shot of current collection contents. ;  ; bool snapshot (RooAbsCollection &output, bool deepCopy=true) const;  Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. ;  ; void sort (bool reverse=false);  Sort collection using std::sort and name comparison. ;  ; void sortTopologically ();  Sort collection topologically: the servers of any RooAbsArg will be before that RooAbsArg in the collection. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void takeOwnership ();  ; RooFit::UniqueId< RooAbsCollection > const & uniqueId () const;  Returns a unique ID that is different for every instantiated RooAbsCollection. ;  ; void useHashMapForFind (bool flag) const;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Op",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:16281,Modifiability,inherit,inheritance,16281,"want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics sys",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:18223,Modifiability,inherit,inherits,18223,"ssage. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:18340,Modifiability,inherit,inherits,18340," ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its p",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:21951,Modifiability,inherit,inherited,21951,"l void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printAddress (std::ostream &os) const;  Print class name of object. ;  ; virtual void printArgs (std::ostream &os) const;  Interface for printing of object arguments. ;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; virtual void printTree (std::ostream &os, TString indent="""") const;  Interface for tree structure printing of object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:23083,Modifiability,inherit,inherited,23083," virtual void printAddress (std::ostream &os) const;  Print class name of object. ;  ; virtual void printArgs (std::ostream &os) const;  Interface for printing of object arguments. ;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; virtual void printTree (std::ostream &os, TString indent="""") const;  Interface for tree structure printing of object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Pro",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:23601,Modifiability,inherit,inherited,23601,";  Interface for tree structure printing of object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int leve",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:24191,Modifiability,inherit,inherited,24191,"tatic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; template<class T > ; static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that o",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:24689,Modifiability,inherit,inherited,24689,"ame ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; template<class T > ; static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that owns its contents. ;  ; TNamed * _structureTag {nullptr};  ! Structure tag ;  ; TNamed * _typedStructureTag {nullptr};  ! Typed structure tag ;  . Private Types; using HashAssistedFind = RooFit::Detail::HashAssistedFind;  . Private Member Functions; void insert (RooAbsArg *);  Insert an element into the owned collections. ;  ; bool replaceImpl (const RooAbsArg &var1, const RooAbsArg &var2);  . Static Private Member Functions; static void throwAddTypedException (TClass *klass, RooAbsArg *arg);  . Private At",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:25929,Modifiability,inherit,inherited,25929," static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that owns its contents. ;  ; TNamed * _structureTag {nullptr};  ! Structure tag ;  ; TNamed * _typedStructureTag {nullptr};  ! Typed structure tag ;  . Private Types; using HashAssistedFind = RooFit::Detail::HashAssistedFind;  . Private Member Functions; void insert (RooAbsArg *);  Insert an element into the owned collections. ;  ; bool replaceImpl (const RooAbsArg &var1, const RooAbsArg &var2);  . Static Private Member Functions; static void throwAddTypedException (TClass *klass, RooAbsArg *arg);  . Private Attributes; std::unique_ptr< HashAssistedFind > _hashAssistedFind;  ! ;  ; std::size_t _sizeThresholdForMapSearch = 100;  ! ;  ; const RooFit::UniqueId< RooAbsCollection > _uniqueId;  . Additional Inherited Members;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsCollection.h>. Inheritance diagram for RooAbsCollection:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ const_iterator. using RooAbsCollection::const_iterator = Storage_t::const_iterator. Definition at line 68 of file RooAbsCollection.h. ◆ HashAssistedFind. using RooAbsCollection::HashAssistedFind = RooFit::Detail::HashAssistedFind. private . Definition at line 445 of file RooAbsCollection.h. ◆ LegacyIterator_t. using RooAbsCollection::LegacyIterator_t = TIteratorToSTLInterface<Storage_t>. protected . Definition at line 401 of file RooAbsCollection.h. ◆ Storage_t. using RooAbsCollection::Storage_t = std::vector<RooAbsArg*>. Definition at line 67 of file RooAbsCollection.h. Constructor & Destructor Documentation. ◆ RooAbsCollection() [1/4]. RooAbsCollection::RooAbsCollection ; (; ). Default constructor. ; Definition at line 117 of f",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:28059,Modifiability,variab,variable,28059,"f file RooAbsCollection.cxx. ◆ ~RooAbsCollection(). RooAbsCollection::~RooAbsCollection ; (; ). override . Destructor. ; Definition at line 175 of file RooAbsCollection.cxx. ◆ RooAbsCollection() [3/4]. RooAbsCollection::RooAbsCollection ; (; const RooAbsCollection & ; other, . const char * ; name = """" . ). Copy constructor. ; Note that a copy of a collection is always non-owning, even the source collection is owning. To create an owning copy of a collection (owning or not), use the snapshot() method. ; Definition at line 140 of file RooAbsCollection.cxx. ◆ RooAbsCollection() [4/4]. RooAbsCollection::RooAbsCollection ; (; RooAbsCollection && ; other). Move constructor. ; Definition at line 160 of file RooAbsCollection.cxx. Member Function Documentation. ◆ add() [1/3]. bool RooAbsCollection::add ; (; const RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add the specified argument to list. ; Returns true if successful, or else false if a variable of the same name is already in the list or the list owns its variables (in this case, try addClone() or addOwned() instead). ; Reimplemented in RooCollectionProxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 436 of file RooAbsCollection.cxx. ◆ add() [2/3]. bool RooAbsCollection::add ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Add a collection of arguments to this collection by calling add() for each element in the source collection. ; Definition at line 151 of file RooAbsCollection.h. ◆ add() [3/3]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::add ; (; Iterator_t ; beginIt, . Iterator_t ; endIt, . bool ; silent = false . ). inline . Definition at line 140 of file RooAbsCollection.h. ◆ add",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:28129,Modifiability,variab,variables,28129,"f file RooAbsCollection.cxx. ◆ ~RooAbsCollection(). RooAbsCollection::~RooAbsCollection ; (; ). override . Destructor. ; Definition at line 175 of file RooAbsCollection.cxx. ◆ RooAbsCollection() [3/4]. RooAbsCollection::RooAbsCollection ; (; const RooAbsCollection & ; other, . const char * ; name = """" . ). Copy constructor. ; Note that a copy of a collection is always non-owning, even the source collection is owning. To create an owning copy of a collection (owning or not), use the snapshot() method. ; Definition at line 140 of file RooAbsCollection.cxx. ◆ RooAbsCollection() [4/4]. RooAbsCollection::RooAbsCollection ; (; RooAbsCollection && ; other). Move constructor. ; Definition at line 160 of file RooAbsCollection.cxx. Member Function Documentation. ◆ add() [1/3]. bool RooAbsCollection::add ; (; const RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add the specified argument to list. ; Returns true if successful, or else false if a variable of the same name is already in the list or the list owns its variables (in this case, try addClone() or addOwned() instead). ; Reimplemented in RooCollectionProxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 436 of file RooAbsCollection.cxx. ◆ add() [2/3]. bool RooAbsCollection::add ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Add a collection of arguments to this collection by calling add() for each element in the source collection. ; Definition at line 151 of file RooAbsCollection.h. ◆ add() [3/3]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::add ; (; Iterator_t ; beginIt, . Iterator_t ; endIt, . bool ; silent = false . ). inline . Definition at line 140 of file RooAbsCollection.h. ◆ add",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:29337,Modifiability,variab,variable,29337," line 436 of file RooAbsCollection.cxx. ◆ add() [2/3]. bool RooAbsCollection::add ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Add a collection of arguments to this collection by calling add() for each element in the source collection. ; Definition at line 151 of file RooAbsCollection.h. ◆ add() [3/3]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::add ; (; Iterator_t ; beginIt, . Iterator_t ; endIt, . bool ; silent = false . ). inline . Definition at line 140 of file RooAbsCollection.h. ◆ addClone() [1/2]. RooAbsArg * RooAbsCollection::addClone ; (; const RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add a clone of the specified argument to list. ; Returns a pointer to the clone if successful, or else zero if a variable of the same name is already in the list or the list does not own its variables (in this case, try add() instead.) Calling addClone() on an empty list forces it to take ownership of all its subsequent variables. ; Reimplemented in RooCollectionProxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 409 of file RooAbsCollection.cxx. ◆ addClone() [2/2]. void RooAbsCollection::addClone ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 524 of file RooAbsCollection.cxx. ◆ addOwned() [1/4]. bool RooAbsCollection::addOwned ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . for each element in the source collection. ; The input list can't be an owning c",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:29415,Modifiability,variab,variables,29415," line 436 of file RooAbsCollection.cxx. ◆ add() [2/3]. bool RooAbsCollection::add ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Add a collection of arguments to this collection by calling add() for each element in the source collection. ; Definition at line 151 of file RooAbsCollection.h. ◆ add() [3/3]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::add ; (; Iterator_t ; beginIt, . Iterator_t ; endIt, . bool ; silent = false . ). inline . Definition at line 140 of file RooAbsCollection.h. ◆ addClone() [1/2]. RooAbsArg * RooAbsCollection::addClone ; (; const RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add a clone of the specified argument to list. ; Returns a pointer to the clone if successful, or else zero if a variable of the same name is already in the list or the list does not own its variables (in this case, try add() instead.) Calling addClone() on an empty list forces it to take ownership of all its subsequent variables. ; Reimplemented in RooCollectionProxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 409 of file RooAbsCollection.cxx. ◆ addClone() [2/2]. void RooAbsCollection::addClone ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 524 of file RooAbsCollection.cxx. ◆ addOwned() [1/4]. bool RooAbsCollection::addOwned ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . for each element in the source collection. ; The input list can't be an owning c",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:29546,Modifiability,variab,variables,29546," . ). inline . Add a collection of arguments to this collection by calling add() for each element in the source collection. ; Definition at line 151 of file RooAbsCollection.h. ◆ add() [3/3]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::add ; (; Iterator_t ; beginIt, . Iterator_t ; endIt, . bool ; silent = false . ). inline . Definition at line 140 of file RooAbsCollection.h. ◆ addClone() [1/2]. RooAbsArg * RooAbsCollection::addClone ; (; const RooAbsArg & ; var, . bool ; silent = false . ). virtual . Add a clone of the specified argument to list. ; Returns a pointer to the clone if successful, or else zero if a variable of the same name is already in the list or the list does not own its variables (in this case, try add() instead.) Calling addClone() on an empty list forces it to take ownership of all its subsequent variables. ; Reimplemented in RooCollectionProxy< RooArgList >, RooCollectionProxy< RooArgSet >, RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 409 of file RooAbsCollection.cxx. ◆ addClone() [2/2]. void RooAbsCollection::addClone ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ; Reimplemented in RooCollectionProxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 524 of file RooAbsCollection.cxx. ◆ addOwned() [1/4]. bool RooAbsCollection::addOwned ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). virtual . for each element in the source collection. ; The input list can't be an owning collection itself, otherwise the arguments would be owned by two collections.; If you want to transfer arguments from one owning collection to a",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:33513,Modifiability,inherit,inherit,33513,"nt with the same name is already in the list), a std::runtime_exception will be thrown, as nobody is owning the argument anymore. This method can only be called on a list that is flagged as owning all of its contents, or else on an empty list (which will force the list into that mode).; If you want to pass an argument that is not owned by a std::unique_ptr, you can use RooAbsCollection::addOwned(RooAbsArg&, bool). ; Definition at line 389 of file RooAbsCollection.cxx. ◆ addTyped(). template<class Arg_t > . bool RooAbsCollection::addTyped ; (; const RooAbsCollection & ; list, . bool ; silent = false . ). inline . Adds elements of a given RooAbsCollection to the container if they match the specified type. ; This function iterates through the elements of the provided RooAbsCollection and checks if each element matches the specified type. If any element doesn't match the type, it throws an exception.; Template Parameters. Arg_tThe type to match for elements in the collection. Must inherit from RooAbsArg. . Parameters. listThe RooAbsCollection containing elements to be added. ; silentForwarded to the non-typed add function. If true, suppresses error messages when adding elements, e.g. when the collection is a RooArgSet and the element is already in the set. . ReturnsReturns true if all elements could be added, else false.; Exceptions. std::invalid_argumentif an element in the collection doesn't match the specified type. . Definition at line 171 of file RooAbsCollection.h. ◆ allInRange(). bool RooAbsCollection::allInRange ; (; const char * ; rangeSpec); const. Return true if all contained object report to have their value inside the specified range. ; Definition at line 1473 of file RooAbsCollection.cxx. ◆ assert_is_no_temporary(). template<class T > . static void RooAbsCollection::assert_is_no_temporary ; (; T && ; ). inlinestaticprotected . Definition at line 424 of file RooAbsCollection.h. ◆ assign(). void RooAbsCollection::assign ; (; const RooAbsCollection & ; other);",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:48727,Modifiability,variab,variable,48727,"nd . ); const. inline . Definition at line 238 of file RooAbsCollection.h. ◆ Print(). void RooAbsCollection::Print ; (; Option_t * ; option = nullptr); const. inlineoverridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 338 of file RooAbsCollection.h. ◆ printClassName(). void RooAbsCollection::printClassName ; (; std::ostream & ; os); const. overridevirtual . Return collection class name. ; Reimplemented from RooPrintable.; Definition at line 1176 of file RooAbsCollection.cxx. ◆ printLatex() [1/2]. RooAbsCollection::printLatex ; (; const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Output content of collection as LaTex table. ; By default a table with two columns is created: the left column contains the name of each variable, the right column the value.; The following optional named arguments can be used to modify the default behavior . Argument Effect . Columns(Int_t ncol) Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed numb",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:49891,Modifiability,variab,variable,49891,"able into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns . Sibling(const RooAbsCollection& other) Define sibling list. The sibling list is assumed to have objects with the same name in the same order. If this is not the case warnings will be printed. If a single sibling list is specified, 3 columns will be output: the (common) name, the value of this list and the value in the sibling list. Multiple sibling lists can be specified by repeating the Sibling() command. . Format(const char* str) Classic format string, provided for backward compatibility . Format() Formatting arguments. . const char* what Controls what is shown. ""N"" adds name, ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error and n specified additional digits (1 is sensible default) . VerbatimName(bool flag) Put variable name in a \verb+ + clause. . OutputFile(const char* fname) Send output to file with given name rather than standard output. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) );; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 1310 of file RooAbsCollection.cxx. ◆ printLatex() [2/2]. void RooAbsCollection::printLatex ; (; std::ostream & ; ofs, . Int_t ; ncol, . const char * ; option = ""NEYU"", . Int_t ; sigDigit = 1, . const RooLinkedList & ; siblingLists = RooLinkedList(), . const RooCmdArg * ; formatCmd = nullptr . ); const. Internal implementation function of printLatex. ; Definition at line 1367 of file RooAbsCollection.cxx. ◆ prin",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:60052,Modifiability,variab,variables,60052,"in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 253 ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:4664,Performance,cache,cache,4664,"; virtual bool addOwned (const RooAbsCollection &list, bool silent=false);  for each element in the source collection. ;  ; virtual bool addOwned (RooAbsArg &var, bool silent=false);  Add an argument and transfer the ownership to the collection. ;  ; bool addOwned (RooAbsCollection &&list, bool silent=false);  Add a collection of arguments to this collection by calling addOwned() for each element in the source collection. ;  ; bool addOwned (std::unique_ptr< RooAbsArg > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; TIterator begin ();  ; RooLinkedListIter begin ();  ; RooFIter begin ();  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &v",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:7792,Performance,perform,performing,7792,"(const char *name) const;  Find object with given name in list. ;  ; RooAbsArg * find (const RooAbsArg &) const;  Find object with given name in list. ;  ; TObject * FindObject (const char *name) const override;  Find object by name in the collection. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object in the collection, Note: matching by object name, like the find() method. ;  ; RooAbsArg * first () const;  ; RooFIter fwdIterator () const R__DEPRECATED(6;  One-time forward iterator. ;  ; Storage_t const & get () const;  Const access to the underlying stl container. ;  ; Int_t getCatIndex (const char *name, Int_t defVal=0, bool verbose=false) const;  Get index value of a RooAbsCategory stored in set with given name. ;  ; const char * getCatLabel (const char *name, const char *defVal="""", bool verbose=false) const;  Get state name of a RooAbsCategory stored in set with given name. ;  ; Int_t getHashTableSize () const;  Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; const char * GetName () const override;  Returns name of object. ;  ; double getRealValue (const char *name, double defVal=0.0, bool verbose=false) const;  Get value of a RooAbsReal stored in set with given name. ;  ; Int_t getSize () const;  Return the number of elements in the collection. ;  ; const char * getStringValue (const char *name, const char *defVal="""", bool verbose=false) const;  Get string value of a RooStringVar stored in set with given name. ;  ; bool hasSameLayout (const RooAbsCollection &other) const;  Check that all entries where the collections overlap have the same name. ;  ; Int_t index (const char *name) const;  Return index of item with given name, or -1 in case it's not in the collection. ;  ; Int_t index (const RooAbsArg &arg) const;  Returns index of given arg, or -1 if arg is not in the collection. ;  ; Int_t index (const RooAbsArg *arg) const;  Returns index of given a",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:13587,Performance,perform,performing,13587,"ommon (const RooAbsCollection &refColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; bool selectCommon (const RooAbsCollection &refColl, RooAbsCollection &outColl) const;  Create a subset of the current collection, consisting only of those elements that are contained as well in the given reference collection. ;  ; void setAttribAll (const Text_t *name, bool value=true);  Set given attribute in each element of the collection by calling each elements setAttribute() function. ;  ; bool setCatIndex (const char *name, Int_t newVal=0, bool verbose=false);  Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; bool setCatLabel (const char *name, const char *newVal="""", bool verbose=false);  Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ;  ; void setHashTableSize (Int_t number);  Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; void setName (const char *name);  ; bool setRealValue (const char *name, double newVal=0.0, bool verbose=false);  Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ;  ; bool setStringValue (const char *name, const char *newVal="""", bool verbose=false);  Set string value of a RooStringVar stored in set with given name to newVal. ;  ; Storage_t::size_type size () const;  ; RooAbsCollection * snapshot (bool deepCopy=true) const;  Take a snap shot of current collection contents. ;  ; bool snapshot (RooAbsCollection &output, bool deepCopy=true) const;  Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. ;  ; void sort (bool reverse=false);  Sort collection using std::sort and name comparison. ;  ; void sortTopologically ();  Sort collection topologicall",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:34546,Performance,cache,cache,34546,"ing elements to be added. ; silentForwarded to the non-typed add function. If true, suppresses error messages when adding elements, e.g. when the collection is a RooArgSet and the element is already in the set. . ReturnsReturns true if all elements could be added, else false.; Exceptions. std::invalid_argumentif an element in the collection doesn't match the specified type. . Definition at line 171 of file RooAbsCollection.h. ◆ allInRange(). bool RooAbsCollection::allInRange ; (; const char * ; rangeSpec); const. Return true if all contained object report to have their value inside the specified range. ; Definition at line 1473 of file RooAbsCollection.cxx. ◆ assert_is_no_temporary(). template<class T > . static void RooAbsCollection::assert_is_no_temporary ; (; T && ; ). inlinestaticprotected . Definition at line 424 of file RooAbsCollection.h. ◆ assign(). void RooAbsCollection::assign ; (; const RooAbsCollection & ; other); const. Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ; Note that this function changes the values of the elements in this collection, but is still marked const as it does not change which elements this collection points to. ; Definition at line 276 of file RooAbsCollection.cxx. ◆ assignFast(). void RooAbsCollection::assignFast ; (; const RooAbsCollection & ; other, . bool ; setValDirty = true . ); const. Functional equivalent of assign() but assumes this and other collection have same layout. ; Also no attributes are copied ; Definition at line 324 of file RooAbsCollection.cxx. ◆ assignValueOnly(). RooAbsCollection & RooAbsCollection::assignValueOnly ; (; const RooAbsCollection & ; other, . bool ; forceIfSizeOne = false . ). Sets the value of any argument in our set that also appears in the other set. ; Parameters. [in]otherCollection holding the arguments to synchronize values with. ; [in]forceIfSizeOneIf set to true and both our collection and the other collection have a size of on",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:43318,Performance,perform,performing,43318,"access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 111 of file RooAbsCollection.h. ◆ GetName(). const char * RooAbsCollection::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbs",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:58659,Performance,perform,performing,58659,"e = true . ). Set given attribute in each element of the collection by calling each elements setAttribute() function. ; Definition at line 768 of file RooAbsCollection.cxx. ◆ setCatIndex(). bool RooAbsCollection::setCatIndex ; (; const char * ; name, . Int_t ; newVal = 0, . bool ; verbose = false . ). Set index value of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1075 of file RooAbsCollection.cxx. ◆ setCatLabel(). bool RooAbsCollection::setCatLabel ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set state name of a RooAbsCategoryLValue stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1032 of file RooAbsCollection.cxx. ◆ setHashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:46866,Safety,avoid,avoid,46866,"roxy< RooArgList >, and RooCollectionProxy< RooArgSet >.; Definition at line 455 of file RooAbsCollection.h. ◆ isOwning(). bool RooAbsCollection::isOwning ; (; ); const. inline . Definition at line 369 of file RooAbsCollection.h. ◆ iterator(). RooLinkedListIter RooAbsCollection::iterator ; (; bool ; dir = kIterForward); const. TIterator-style iteration over contained elements. ; NoteThis iterator is slow. Use begin() and end() or range-based for loop instead. . ◆ makeStructureTag(). void RooAbsCollection::makeStructureTag ; (; ). inlineprotected . Definition at line 417 of file RooAbsCollection.h. ◆ makeTypedStructureTag(). void RooAbsCollection::makeTypedStructureTag ; (; ). inlineprotected . Definition at line 418 of file RooAbsCollection.h. ◆ operator=(). RooAbsCollection & RooAbsCollection::operator= ; (; const RooAbsCollection & ; other). Assign values from the elements in other to our elements. ; WarningThis is not a conventional assignment operator. To avoid confusion, prefer using RooAbsCollection::assign(). ; Definition at line 263 of file RooAbsCollection.cxx. ◆ operator[](). RooAbsArg * RooAbsCollection::operator[] ; (; Storage_t::size_type ; i); const. inline . Definition at line 320 of file RooAbsCollection.h. ◆ overlaps() [1/2]. bool RooAbsCollection::overlaps ; (; const RooAbsCollection & ; otherColl); const. inline . Check if this and other collection have common entries. ; Definition at line 249 of file RooAbsCollection.h. ◆ overlaps() [2/2]. template<typename Iterator_t , typename value_type = typename std::remove_pointer<typename std::iterator_traits<Iterator_t>::value_type>, typename = std::enable_if<std::is_convertible<const value_type*, const RooAbsArg*>::value>> . bool RooAbsCollection::overlaps ; (; Iterator_t ; otherCollBegin, . Iterator_t ; otherCollEnd . ); const. inline . Definition at line 238 of file RooAbsCollection.h. ◆ Print(). void RooAbsCollection::Print ; (; Option_t * ; option = nullptr); const. inlineoverridevirtual . This method",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:62793,Safety,safe,safer,62793,"StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 455 of file RooAbsCollection.h. ◆ structureTag(). TNamed * RooAbsCollection::structureTag ; (; ). inlineprotected . Definition at line 409 of file RooAbsCollection.h. ◆ takeOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 379 of file RooAbsCollection.h. ◆ throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass * ; klass, . RooAbsArg * ; arg . ). staticprivate . Definition at line 1638 of file RooAbsCollection.cxx. ◆ typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 410 of file RooAbsCollection.h. ◆ uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. ◆ useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; bool ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1604 of file RooAbsCollection.cxx. Member Data Documentation. ◆ _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 405 of file RooAbsCollection.h. ◆ _hashAssistedFind. std::unique_ptr<HashAssistedFind> RooAbsCollection::_hashAssistedFind. mutableprivate . ! ; Definition at line 446 of file RooAbsCollection.h. ◆ _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 400 of file RooAbsCollection.h. ◆ _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 404 of file RooAbsCollection.h. ◆ _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a l",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:7291,Security,access,access,7291,"object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; TIterator end () and range-based for loops."") ;  ; RooLinkedListIter end () and range-based for loops."") ;  ; RooFIter end () and range-based for loops."") ;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &otherColl) const;  Check if this and other collection have identically-named contents. ;  ; RooAbsArg * find (const char *name) const;  Find object with given name in list. ;  ; RooAbsArg * find (const RooAbsArg &) const;  Find object with given name in list. ;  ; TObject * FindObject (const char *name) const override;  Find object by name in the collection. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object in the collection, Note: matching by object name, like the find() method. ;  ; RooAbsArg * first () const;  ; RooFIter fwdIterator () const R__DEPRECATED(6;  One-time forward iterator. ;  ; Storage_t const & get () const;  Const access to the underlying stl container. ;  ; Int_t getCatIndex (const char *name, Int_t defVal=0, bool verbose=false) const;  Get index value of a RooAbsCategory stored in set with given name. ;  ; const char * getCatLabel (const char *name, const char *defVal="""", bool verbose=false) const;  Get state name of a RooAbsCategory stored in set with given name. ;  ; Int_t getHashTableSize () const;  Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; const char * GetName () const override;  Returns name of object. ;  ; double getRealValue (const char *name, double defVal=0.0, bool verbose=false) const;  Get value of a RooAbsReal stored in set with given name. ;  ; Int_t getSize () const;  Return the number of elements in the collection. ;  ; const char * getStringValue (const char *name, const char *defVal="""", bool verbose=false) const;  Get string value of a RooStringVar stored in set with given name. ; ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:17854,Security,hash,hash,17854,"(TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:39829,Security,hash,hash-map,39829,"e iteration over contained elements. ; NoteThese iterators are slow. Use begin() and end() or range-based for loop instead. . ◆ DeclFileName(). static const char * RooAbsCollection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 455 of file RooAbsCollection.h. ◆ defaultPrintContents(). Int_t RooAbsCollection::defaultPrintContents ; (; Option_t * ; opt); const. overridevirtual . Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ; In verbose mode also add object address, argument and title ; Reimplemented from RooPrintable.; Definition at line 1189 of file RooAbsCollection.cxx. ◆ deleteList(). void RooAbsCollection::deleteList ; (; ). protected . Delete contents of the list. ; The RooAbsArg destructor ensures clients and servers can be deleted in any order. Also cleans the hash-map for fast lookups if present. ; Definition at line 190 of file RooAbsCollection.cxx. ◆ dump(). void RooAbsCollection::dump ; (; ); const. Base contents dumper for debugging purposes. ; Definition at line 1268 of file RooAbsCollection.cxx. ◆ empty(). bool RooAbsCollection::empty ; (; ); const. inline . Definition at line 296 of file RooAbsCollection.h. ◆ end() [1/4]. TIterator RooAbsCollection::end ; (; ). inline . Definition at line 257 of file RooAbsCollection.h. ◆ end() [2/4]. RooLinkedListIter RooAbsCollection::end ; (; ). inline . Definition at line 265 of file RooAbsCollection.h. ◆ end() [3/4]. RooFIter RooAbsCollection::end ; (; ). inline . Definition at line 272 of file RooAbsCollection.h. ◆ end() [4/4]. const_iterator RooAbsCollection::end ; (; ); const. inline . Definition at line 280 of file RooAbsCollection.h. ◆ equals(). bool RooAbsCollection::equals ; (; const RooAbsCollection & ; otherColl); const. Check if this and other collection have identically-named contents. ; Defini",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:42279,Security,access,access,42279," object with the given name is found. ; Definition at line 937 of file RooAbsCollection.cxx. ◆ FindObject() [1/2]. TObject * RooAbsCollection::FindObject ; (; const char * ; name); const. inlineoverridevirtual . Find object by name in the collection. ; Reimplemented from TObject.; Definition at line 214 of file RooAbsCollection.h. ◆ FindObject() [2/2]. TObject * RooAbsCollection::FindObject ; (; const TObject * ; obj); const. inlineoverridevirtual . Find object in the collection, Note: matching by object name, like the find() method. ; Reimplemented from TObject.; Definition at line 217 of file RooAbsCollection.h. ◆ first(). RooAbsArg * RooAbsCollection::first ; (; ); const. inline . Definition at line 314 of file RooAbsCollection.h. ◆ fwdIterator(). RooFIter RooAbsCollection::fwdIterator ; (; ); const. One-time forward iterator. ; NoteUse begin() and end() or range-based for loop instead. . ◆ get(). Storage_t const & RooAbsCollection::get ; (; ); const. inline . Const access to the underlying stl container. ; Definition at line 116 of file RooAbsCollection.h. ◆ getCatIndex(). Int_t RooAbsCollection::getCatIndex ; (; const char * ; name, . Int_t ; defVal = 0, . bool ; verbose = false . ); const. Get index value of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1054 of file RooAbsCollection.cxx. ◆ getCatLabel(). const char * RooAbsCollection::getCatLabel ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get state name of a RooAbsCategory stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1011 of file RooAbsCollection.cxx. ◆ getHashTableSize(). Int_t RooAbsCollection::getHashTableSize ; (; ); const. inline . Query the size at which the collection will automatically start using an extra l",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:63062,Security,hash,hash,63062,"eOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 379 of file RooAbsCollection.h. ◆ throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass * ; klass, . RooAbsArg * ; arg . ). staticprivate . Definition at line 1638 of file RooAbsCollection.cxx. ◆ typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 410 of file RooAbsCollection.h. ◆ uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. ◆ useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; bool ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1604 of file RooAbsCollection.cxx. Member Data Documentation. ◆ _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 405 of file RooAbsCollection.h. ◆ _hashAssistedFind. std::unique_ptr<HashAssistedFind> RooAbsCollection::_hashAssistedFind. mutableprivate . ! ; Definition at line 446 of file RooAbsCollection.h. ◆ _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 400 of file RooAbsCollection.h. ◆ _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 404 of file RooAbsCollection.h. ◆ _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a list that owns its contents. ; Definition at line 403 of file RooAbsCollection.h. ◆ _sizeThresholdForMapSearch. std::size_t RooAbsCollection::_sizeThresholdForMapSearch = 100. private . ! ; Definition at line 447 of file RooAbsCollection.h. ◆ _structureTag. TNamed*",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:5229,Usability,clear,clear,5229,"rgument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; TIterator begin ();  ; RooLinkedListIter begin ();  ; RooFIter begin ();  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; virtual TObject * create (const char *newname) const =0;  ; TIterator * createIterator (bool dir=kIterForward) const R__DEPRECATED(6;  TIterator-style iteration over contained elements. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For in",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:24454,Usability,clear,clearStructureTags,24454,"jectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Types; using LegacyIterator_t = TIteratorToSTLInterface< Storage_t >;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; virtual bool canBeAdded (const RooAbsArg &arg, bool silent) const =0;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; template<class T > ; static void assert_is_no_temporary (T &&);  . Protected Attributes; bool _allRRV = true;  All contents are RRV. ;  ; Storage_t _list;  Actual object storage. ;  ; TString _name;  Our name. ;  ; bool _ownCont = false;  Flag to identify a list that owns its contents. ;  ; TNamed * _structureTag {nullptr};  ! Structure tag ;  ; TNamed * _typedStructureTag {nullptr};  ! Typed structure tag ;  . Private Types; using HashAssistedFind = RooFit::Detail::HashAssistedFind;  . Private Member Functions; void insert (RooAbsArg *);  Insert an element into the owned ",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:36716,Usability,clear,clear,36716,".cxx. ◆ begin() [1/4]. TIterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:36748,Usability,clear,clear,36748,"Iterator RooAbsCollection::begin ; (; ). ◆ begin() [2/4]. RooLinkedListIter RooAbsCollection::begin ; (; ). ◆ begin() [3/4]. RooFIter RooAbsCollection::begin ; (; ). ◆ begin() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory.",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:36905,Usability,clear,clearStructureTags,36905,"n() [4/4]. const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inlin",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsCollection.html:36950,Usability,clear,clearStructureTags,36950,"ction::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inline . Check if collection contains an a",MatchSource.WIKI,doc/v632/classRooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html
https://root.cern/doc/v632/classRooAbsReal.html:1468,Availability,error,error,1468,"it » RooFit Core. ; Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. ; Implementation of RooAbsReal may be derived, thus no interface is provided to modify the contents. PyROOT; Some member functions of RooAbsReal that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooAbsReal::plotOn, RooAbsReal::createHistogram, RooAbsReal::chi2FitTo, RooAbsReal::createChi2, RooAbsReal::createRunningIntegral and RooAbsReal::createIntegral For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; var.plotOn(frame, ROOT.RooFit.Components(""background"")); ; # With keyword arguments:; var.plotOn(frame, Components=""background""). Definition at line 59 of file RooAbsReal.h. Classes; class  EvalError;  ; class  EvalErrorContext;  Context to temporarily change the error logging mode as long as the context is alive. More...;  ; struct  GlobalSelectComponentRAII;  ; struct  PlotOpt;  ; class  Ref;  A RooAbsReal::Ref can be constructed from a RooAbsReal& or a double that will be implicitly converted to a RooConstVar&. More...;  . Public Types; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; typedef std::map< constRooAbsArg *, std::pair< std::string, std::list< EvalError > > >::const_iterator EvalErrorIter;  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:1513,Availability,alive,alive,1513,"it » RooFit Core. ; Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. ; Implementation of RooAbsReal may be derived, thus no interface is provided to modify the contents. PyROOT; Some member functions of RooAbsReal that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooAbsReal::plotOn, RooAbsReal::createHistogram, RooAbsReal::chi2FitTo, RooAbsReal::createChi2, RooAbsReal::createRunningIntegral and RooAbsReal::createIntegral For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; var.plotOn(frame, ROOT.RooFit.Components(""background"")); ; # With keyword arguments:; var.plotOn(frame, Components=""background""). Definition at line 59 of file RooAbsReal.h. Classes; class  EvalError;  ; class  EvalErrorContext;  Context to temporarily change the error logging mode as long as the context is alive. More...;  ; struct  GlobalSelectComponentRAII;  ; struct  PlotOpt;  ; class  Ref;  A RooAbsReal::Ref can be constructed from a RooAbsReal& or a double that will be implicitly converted to a RooConstVar&. More...;  . Public Types; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; typedef std::map< constRooAbsArg *, std::pair< std::string, std::list< EvalError > > >::const_iterator EvalErrorIter;  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:16257,Availability,error,error,16257,"s parameter uncertainties to an uncertainty estimate for this RooAbsReal. ;  ; TString getTitle (bool appendUnit=false) const;  Return this variable's title string. ;  ; const Text_t * getUnit () const;  ; double getVal (const RooArgSet &normalisationSet) const;  Like getVal(const RooArgSet*), but always requires an argument for normalisation. ;  ; double getVal (const RooArgSet *normalisationSet=nullptr) const;  Evaluate object. ;  ; virtual double getValV (const RooArgSet *normalisationSet=nullptr) const;  Return value of object. ;  ; virtual void gradient (double *) const;  ; virtual bool hasGradient () const;  ; TClass * IsA () const override;  ; virtual bool isBinnedDistribution (const RooArgSet &) const;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const override;  ; virtual bool isOffsetting () const;  ; bool isSelectedComp () const;  If true, the current pdf is a selected component (for use in plotting) ;  ; void logEvalError (const char *message, const char *serverValueString=nullptr) const;  Log evaluation error message. ;  ; virtual double maxVal (Int_t code) const;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; RooAbsMoment * mean (RooRealVar &obs);  ; RooAbsMoment * mean (RooRealVar &obs, const RooArgSet &nset);  ; virtual Int_t minTrialSamples (const RooArgSet &) const;  ; RooAbsMoment * moment (RooRealVar &obs, const RooArgSet &normObs, Int_t order, bool central, bool takeRoot, bool intNormObs);  Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. ;  ; RooAbsMoment * moment (RooRealVar &obs, Int_t order, bool central, bool takeRoot);  Return function representing moment of function of given order. ;  ; virtual double offset () const;  ; bool operator== (const RooAbsArg &other) const override;  Equality operator when comparing to ano",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:36728,Availability,mask,mask,36728,"s);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const Ro",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:42367,Availability,error,error,42367,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:42456,Availability,error,error,42456,"ecord whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:42611,Availability,error,error,42611,"Name () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:42908,Availability,error,error,42908,"ption="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:46992,Availability,error,error,46992,"n object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SaveAs (const char *filename="""", Option_t *option="""") const;  Save this object in the file specified by filename. ;  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption s",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:48495,Availability,error,error,48495,"_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error o",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:48808,Availability,error,error,48808,"; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbo",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:49030,Availability,error,error,49030,"ents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:49090,Availability,error,error,49090,"ents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Versi",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:49226,Availability,error,errors,49226,"given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:49389,Availability,error,error,49389," ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get st",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:49496,Availability,error,error,49496,"Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bo",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:55635,Availability,error,error,55635,"bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:61251,Availability,error,error,61251," = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _evalErrorCount = 0;  ; static std::map< const RooAbsArg *, std::pair< std::string, std::list< EvalError > > > _evalErrorList;  ; static ErrorLoggingMode _evalErrorMode = RooAbsReal::PrintErrors;  ; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsReal.h>. Inheritance diagram for RooAbsReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ EvalErrorIter. typedef std::map<constRooAbsArg*,std::pair<std::string,std::list<EvalError>>>::const_iterator RooAbsReal::EvalErrorIter. Definition at line 347 of file RooAbsReal.h. ◆ value_type. using RooAbsReal::value_type = double. Definition at line 61 of file RooAbsReal.h. Member Enumeration Documentation. ◆ ErrorLoggingMode. enum RooAbsR",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:63606,Availability,error,error,63606,"structor ; Definition at line 180 of file RooAbsReal.cxx. ◆ RooAbsReal() [2/4]. RooAbsReal::RooAbsReal ; (; const char * ; name, . const char * ; title, . const char * ; unit = """" . ). Constructor with unit label. ; Definition at line 186 of file RooAbsReal.cxx. ◆ RooAbsReal() [3/4]. RooAbsReal::RooAbsReal ; (; const char * ; name, . const char * ; title, . double ; minVal, . double ; maxVal, . const char * ; unit = """" . ). Constructor with plot range and unit label. ; Definition at line 197 of file RooAbsReal.cxx. ◆ RooAbsReal() [4/4]. RooAbsReal::RooAbsReal ; (; const RooAbsReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 208 of file RooAbsReal.cxx. ◆ ~RooAbsReal(). RooAbsReal::~RooAbsReal ; (; ). override . Destructor. ; Definition at line 222 of file RooAbsReal.cxx. Member Function Documentation. ◆ _DEBUG_getVal(). double RooAbsReal::_DEBUG_getVal ; (; const RooArgSet * ; normalisationSet); const. private . Debug version of getVal(), which is slow and does error checking. ; Definition at line 4510 of file RooAbsReal.cxx. ◆ analyticalIntegral(). double RooAbsReal::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. virtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented in RooLegacyExpPoly, RooPowerSum, RooGaussModel, RooLandau, RooArgusBG, RooBernstein, RooBifurGauss, RooBreitWigner, RooChebychev, RooChiSquarePdf, RooCrystalBall, RooDstD0BG, RooExponential, RooGamma, RooGaussian, RooGExpModel, RooJohnson, RooKeysPdf, RooLognormal, RooNDKeysPdf, RooNovosibirsk, RooParametricStepFunction, RooPoisson, RooPolynomial, RooUniform, RooAddition, RooBinSamplingPdf, RooConvCoefVar, RooEfficiency, RooHistFunc, RooHistPdf, RooMultiVarGaussian, RooPolyVar, RooProduct, RooTruthModel, RooWrapperPdf, RooFixedProdPdf, RooLegendre, RooNonCentralChiSquar",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:69987,Availability,error,error,69987,"t RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a \( \chi^2 \) fit to given histogram. ; By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession; The following named arguments are supported. Options to control construction of chi2 . Extended(bool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on the fly on all observables. Multiple comma separated range names can be specified. . NumCPU(int num) Parallelize NLL calculation on num CPUs . Optimize(bool flag) Activate constant term optimization (on by default) . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Options to control flow of fit procedur",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:70412,Availability,error,error,70412,"ool flag) Only applicable when fitting a RooAbsPdf. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight. This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events (in RooFit jargon, ""if the pdf can be extended"").; Passing Extended(true) when the the pdf makes no prediction on the expected number of events will result in error messages, and the chi2 will fall back to the total data weight to scale the normalized pdf.; There are cases where the fit must be done in extended mode. This happens for example when you have a RooAddPdf where the coefficients represent component yields. If the fit is not extended, these coefficients will not be well-defined, as the RooAddPdf always normalizes itself. If you pass Extended(false) in such a case, an error will be printed and you'll most likely get garbage results. . Range(const char* name) Fit only data inside range with given name . Range(double lo, double hi) Fit only data inside given range. A range named ""fit"" is created on the fly on all observables. Multiple comma separated range names can be specified. . NumCPU(int num) Parallelize NLL calculation on num CPUs . Optimize(bool flag) Activate constant term optimization (on by default) . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set M",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:71974,Availability,error,errors,71974,"tialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Po",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72094,Availability,error,error,72094,"efault . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72174,Availability,error,error,72174,"lag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72680,Availability,error,error,72680," off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected r",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72767,Availability,error,error,72767," RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected region . Verbose() Verbose output of GOF framework . IntegrateBins() Integrate PDF within each bin. This ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72833,Availability,error,errors,72833,"isable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected region . Verbose() Verbose output of GOF framework . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits. . SumCoefRange() Set the range",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:72939,Availability,error,errors,72939," errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . Definition at line 4181 of file RooAbsReal.cxx. ◆ chi2FitTo() [2/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ; List of possible commands in the cmdList:. Type of CmdArg Effect on \( \chi^2 \) . DataError() Choose between:; RooAbsData::Expected: Expected Poisson error ( \( \sqrt{n_\text{expected}} \) from the PDF).; RooAbsData::SumW2: The observed error from the square root of the sum of weights, i.e., symmetric errors calculated with the standard deviation of a Poisson distribution.; RooAbsData::Poisson: Asymmetric errors from the central 68 % interval around a Poisson distribution with mean \( n_\text{observed} \). If for a given bin \( n_\text{expected} \) is lower than the \( n_\text{observed} \), the lower uncertainty is taken (e.g., the difference between the mean and the 16 % quantile). If \( n_\text{expected} \) is higher than \( n_\text{observed} \), the higher uncertainty is taken (e.g., the difference between the 84 % quantile and the mean).; RooAbsData::Auto (default): RooAbsData::Expected for unweighted data, RooAbsData::SumW2 for weighted data. . Extended() Use expected number of events of an extended p.d.f as normalization . NumCPU() Activate parallel processing feature . Range() Calculate \( \chi^2 \) only in selected region . Verbose() Verbose output of GOF framework . IntegrateBins() Integrate PDF within each bin. This sets the desired precision. Only useful for binned fits. . SumCoefRange() Set the range in which to interpret the coefficients of RooAddPdf components . SplitRange() Fit ranges used in different ca",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:74978,Availability,error,errors,74978,"ter the category. Using Range(""range""), SplitRange() as switches, different ranges could be set like this: myVariable.setRange(""range_pi0"", 135, 210);; myVariable.setRange(""range_gamma"", 50, 210);; . ConditionalObservables(Args_t &&... argsOrArgSet) Define projected observables. Arguments can either be multiple RooRealVar or a single RooArgSet containing them. Definition at line 4235 of file RooAbsReal.cxx. ◆ chi2FitTo() [3/4]. RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:75222,Availability,error,errors,75222,"vables(Args_t &&... argsOrArgSet) Define projected observables. Arguments can either be multiple RooRealVar or a single RooArgSet containing them. Definition at line 4235 of file RooAbsReal.cxx. ◆ chi2FitTo() [3/4]. RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:76299,Availability,error,errors,76299,"tialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y valu",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:76419,Availability,error,error,76419,"efault . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:76499,Availability,error,error,76499,"lag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bo",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:77139,Availability,error,errors,77139,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:77383,Availability,error,errors,77383,"ut completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:78460,Availability,error,errors,78460,"tialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cx",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:78580,Availability,error,error,78580,"efault . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:78660,Availability,error,error,78660,"lag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit steps, off by default . PrintLevel(Int_t level) Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational messages are suppressed as well . Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy th",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:79411,Availability,error,error,79411,"lErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4330 of file RooAbsReal.cxx. ◆ Class(). static TClass * RooAbsReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 558 of file RooAbsReal.h. ◆ clearEvalErrorLog(). void RooAbsReal::clearEvalErrorLog ; (; ). static . Clear the stack of evaluation error messages. ; Definition at line 3622 of file RooAbsReal.cxx. ◆ copyCache(). void RooAbsReal::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value of another RooAbsArg to our cache. ; Warning: This function just copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, and RooRealVar.; Definition at line 3082 of file RooAbsReal.cxx. ◆ createChi2() [1/4]. RooAbsReal::createChi2 ; (; RooDataHist & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) variable from a histogram and this function. ; Parameters. arg1,arg2,arg3,arg",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:82105,Availability,error,errors,82105,"teChi2 ; (; RooDataHist & ; data, . const RooLinkedList & ; cmdList . ). virtual . See alsoRooAbsReal::createChi2(RooDataHist&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ; Parameters. datahist data ; cmdListList with RooCmdArg() from the table . Definition at line 4276 of file RooAbsReal.cxx. ◆ createChi2() [3/4]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createChi2 ; (; RooDataSet & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) from a series of x and y values stored in a dataset. ; The y values can either be the event weights (default), or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined.; The following named arguments are supported. Options to control construction of the \( \chi^2 \) . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. . Definition at line 4352 of file RooAbsReal.cxx. ◆ createChi2() [4/4]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createChi2 ; (; RooDataSet & ; data, . const RooLinkedList & ; cmdList . ). virtual . See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ; Definition at line 4368 of file RooAbsReal.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsReal::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooRealVar fundamental object with our properties. ; The new object will be created without a",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:82397,Availability,error,errors,82397,"; Parameters. datahist data ; cmdListList with RooCmdArg() from the table . Definition at line 4276 of file RooAbsReal.cxx. ◆ createChi2() [3/4]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createChi2 ; (; RooDataSet & ; data, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Create a \( \chi^2 \) from a series of x and y values stored in a dataset. ; The y values can either be the event weights (default), or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined.; The following named arguments are supported. Options to control construction of the \( \chi^2 \) . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. . Definition at line 4352 of file RooAbsReal.cxx. ◆ createChi2() [4/4]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createChi2 ; (; RooDataSet & ; data, . const RooLinkedList & ; cmdList . ). virtual . See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ; Definition at line 4368 of file RooAbsReal.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsReal::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooRealVar fundamental object with our properties. ; The new object will be created without any fit limits. ; Implements RooAbsArg.; Definition at line 3212 of file RooAbsReal.cxx. ◆ createHistogram() [1/3]. RooAbsReal::createHistogram ; (; const char * ; name, . const RooAbsRealLValue & ; xvar, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 =",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:93066,Availability,error,error,93066,"Obs = nullptr . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; Create a new object \( G \) that represents the normalized projection: ; \[; G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; \]. where \( F[x,y,p] \) is the function we represent, and \( \{ p \} \) are the remaining variables (""parameters"").; Parameters. [in]dependentVarsDependent variables over which to normalise, \( \{x\} \). ; [in]projectedVarsVariables to project out, \( \{ y \} \). ; [out]cloneSetWill be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object. The latter will also be returned. The caller takes ownership of this set. ; [in]rangeNameOptional range for projection integrals ; [in]condObsConditional observables, which are not integrated for normalisation, even if they are in dependentVars or projectedVars. . ReturnsA pointer to the newly created object, or zero in case of an error. The caller is responsible for deleting the cloneSet (which includes the returned projection object). ; Definition at line 842 of file RooAbsReal.cxx. ◆ createPlotProjection() [2/2]. const RooAbsReal * RooAbsReal::createPlotProjection ; (; const RooArgSet & ; depVars, . const RooArgSet & ; projVars, . RooArgSet *& ; cloneSet . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; createPlotProjection() ; Definition at line 813 of file RooAbsReal.cxx. ◆ createProfile(). RooFit::OwningPtr< RooAbsReal > RooAbsReal::createProfile ; (; const RooArgSet & ; paramsOfInterest). virtual . Create a RooProfileLL object that eliminates all nuisance parameters in the present function. ; The nuisance parameters are defined as all parameters of the function except the stated paramsOfInterest ; Reimplemented in RooProfileLL.; Definition at line 469 of file RooAbsReal.cxx. ◆ createRunningIntegral() [1/2",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:100335,Availability,error,error,100335,"ChiSquarePdf, RooDstD0BG, RooExponential, RooGamma, RooGaussian, RooGaussModel, RooJohnson, RooLandau, RooLegacyExpPoly, RooLognormal, RooNovosibirsk, RooPoisson, RooPolynomial, RooPowerSum, RooVoigtian, RooAbsCachedPdf, RooAddition, RooAddModel, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooConstraintSum, RooGenericPdf, RooHistFunc, RooHistPdf, RooPolyVar, RooProduct, RooRatio, RooRealSumPdf, RooTruthModel, RooNormalizedPdf, RooHypatia2, RooLegendre, RooFormulaVar, and RooFixedProdPdf.; Definition at line 4419 of file RooAbsReal.cxx. ◆ enableOffsetting(). void RooAbsReal::enableOffsetting ; (; bool ; flag). virtual . Reimplemented in RooAbsTestStatistic, and RooRealMPFE.; Definition at line 4560 of file RooAbsReal.cxx. ◆ evalErrorIter(). RooAbsReal::EvalErrorIter RooAbsReal::evalErrorIter ; (; ). static . Definition at line 308 of file RooAbsReal.cxx. ◆ evalErrorLoggingMode(). RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode ; (; ). static . Return current evaluation error logging mode. ; Definition at line 4378 of file RooAbsReal.cxx. ◆ evaluate(). virtual double RooAbsReal::evaluate ; (; ); const. protectedpure virtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implemented in RooStats::HistFactory::FlexibleInterpVar, RooStats::HistFactory::LinInterpVar, ParamHistFunc, PiecewiseInterpolation, RooStats::HistFactory::RooBarlowBeestonLL, Roo2DKeysPdf, RooArgusBG, RooBernstein, RooBifurGauss, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1, VI2, VI3, VI4 >, RooChebychev, RooChiSquarePdf, RooCrystalBall, RooDstD0BG, RooExponential, RooFunctor1DBinding, RooFunctor1DPdfBinding, RooFunctorBinding, Ro",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:103510,Availability,error,error,103510,"ion, RooNumConvPdf, RooNumRunningInt, RooPolyFunc, RooPolyVar, RooProdPdf, RooProduct, RooProfileLL, RooProjectedPdf, RooPullVar, RooRangeBoolean, RooRatio, RooRealIntegral, RooRealMPFE, RooRealSumFunc, RooRealSumPdf, RooRealVar, RooRecursiveFraction, RooSecondMoment, RooSimultaneous, RooTruthModel, RooWrapperPdf, RooGenProdProj, RooNormalizedPdf, RooFixedProdPdf, RooHypatia2, RooLegendre, RooNonCentralChiSquare, RooSpHarmonic, RooStats::Heaviside, ProgressMonitor, xRooProjectedPdf, and PdfWrapper. ◆ fillDataHist(). RooDataHist * RooAbsReal::fillDataHist ; (; RooDataHist * ; hist, . const RooArgSet * ; normSet, . double ; scaleFactor, . bool ; correctForBinSize = false, . bool ; showProgress = false . ); const. Fill a RooDataHist with values sampled from this function at the bin centers. ; If extendedMode is true, the p.d.f. values is multiplied by the number of expected events in each bin; An optional scaling by a given scaleFactor can be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1152 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result by scaleFactor. Returns a pointer to the input histogram, or zero in case of an error. The input hist",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:104459,Availability,error,error,104459," be performed. Returns a pointer to the input RooDataHist, or zero in case of an error.; If correctForBinSize is true the RooDataHist is filled with the functions density (function value times the bin volume) rather than function value.; If showProgress is true a process indicator is printed on stdout in steps of one percent, which is mostly useful for the sampling of expensive functions such as likelihoods ; Definition at line 1152 of file RooAbsReal.cxx. ◆ fillHistogram(). TH1 * RooAbsReal::fillHistogram ; (; TH1 * ; hist, . const RooArgList & ; plotVars, . double ; scaleFactor = 1, . const RooArgSet * ; projectedVars = nullptr, . bool ; scaleForDensity = true, . const RooArgSet * ; condObs = nullptr, . bool ; setError = true . ); const. Fill the ROOT histogram 'hist' with values sampled from this function at the bin centers. ; Our value is calculated by first integrating out any variables in projectedVars and then scaling the result by scaleFactor. Returns a pointer to the input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input histogram according to the order in which they appear in the input plotVars list. If scaleForDensity is true the histogram is filled with a the functions density rather than the functions value (i.e. the value at the bin center is multiplied with bin volume) ; Definition at line 975 of file RooAbsReal.cxx. ◆ fillTreeBranch(). void RooAbsReal::fillTreeBranch ; (; TTree & ; t). overrideprotectedvirtual . Fill the tree branch that associated with this object with its current value. ; Implements RooAbsArg.; Reimplemented in RooRealVar.; Definition at line 3181 of file RooAbsReal.cxx. ◆ findInnerMostIntegration(). void RooAbsReal::findInnerMostIntegration ; (; const RooArgSet & ; allObs, . RooArgSet & ; innerObs, . const char * ; rangeName . ); const. protected . Utility function for createIntObj() that aids i",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:121271,Availability,error,error,121271,".; Definition at line 377 of file RooAbsReal.h. ◆ isSelectedComp(). bool RooAbsReal::isSelectedComp ; (; ); const. If true, the current pdf is a selected component (for use in plotting) ; Definition at line 3041 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition a",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:121299,Availability,error,errors,121299,"nt pdf is a selected component (for use in plotting) ; Definition at line 3041 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . cons",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:121446,Availability,error,errors,121446,"nt pdf is a selected component (for use in plotting) ; Definition at line 3041 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . cons",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:121915,Availability,error,error,121915,"a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:121997,Availability,error,errors,121997,"oRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of va",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:122161,Availability,error,error,122161,"(; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input paramete",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:122537,Availability,error,error,122537,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2988 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:122597,Availability,error,error,122597,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2988 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:128083,Availability,error,errors,128083,"tralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root ; [in]intNormObsIf true, the moment of the function integrated over all normalization observables is returned. . Definition at line 4110 of file RooAbsReal.cxx. ◆ moment() [2/2]. RooAbsMoment * RooAbsReal::moment ; (; RooRealVar & ; obs, . Int_t ; order, . bool ; central, . bool ; takeRoot . ). Return function representing moment of function of given order. ; Parameters. [in]obsObservable to calculate the moments for ; [in]orderOrder of the moment ; [in]centralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root . Definition at line 4091 of file RooAbsReal.cxx. ◆ numEvalErrorItems(). Int_t RooAbsReal::numEvalErrorItems ; (; ). static . Definition at line 300 of file RooAbsReal.cxx. ◆ numEvalErrors(). Int_t RooAbsReal::numEvalErrors ; (; ). static . Return the number of logged evaluation errors since the last clearing. ; Definition at line 3701 of file RooAbsReal.cxx. ◆ offset(). virtual double RooAbsReal::offset ; (; ); const. inlinevirtual . Reimplemented in RooAbsTestStatistic.; Definition at line 378 of file RooAbsReal.h. ◆ operator==() [1/2]. bool RooAbsReal::operator== ; (; const RooAbsArg & ; other); const. overridevirtual . Equality operator when comparing to another RooAbsArg. ; Only functional when the other arg is a RooAbsReal ; Implements RooAbsArg.; Definition at line 239 of file RooAbsReal.cxx. ◆ operator==() [2/2]. bool RooAbsReal::operator== ; (; double ; value); const. Equality operator comparing to a double. ; Definition at line 228 of file RooAbsReal.cxx. ◆ plotAsymOn(). RooPlot * RooAbsReal::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Definition at line 2284 of file RooAbsReal.cxx. ◆ plotOn() [1/3]. RooAbsReal::plotOn ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:132223,Availability,error,errors,132223,"s given in the set, ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) Override default projection technique (integration). For observables present in given dataset projection of PDF is achieved by constructing an average over all observable values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, const RooAbsData& d) As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging. ProjectionRange(const char* rn) Override default range of projection integrals to a different range specified by given range name. This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per curve. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three state",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:132327,Availability,error,error,132327,"ced use only. ProjWData(const RooAbsData& d) Override default projection technique (integration). For observables present in given dataset projection of PDF is achieved by constructing an average over all observable values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, const RooAbsData& d) As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging. ProjectionRange(const char* rn) Override default range of projection integrals to a different range specified by given range name. This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per curve. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. ShiftToZero(bool flag) Shift entire curv",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:132407,Availability,error,error,132407,"For observables present in given dataset projection of PDF is achieved by constructing an average over all observable values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, const RooAbsData& d) As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging. ProjectionRange(const char* rn) Override default range of projection integrals to a different range specified by given range name. This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per curve. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. ShiftToZero(bool flag) Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \( -\log(L) \) o",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:132528,Availability,error,errors,132528,"able values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, const RooAbsData& d) As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging. ProjectionRange(const char* rn) Override default range of projection integrals to a different range specified by given range name. This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per curve. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. ShiftToZero(bool flag) Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \( -\log(L) \) or \( \chi^2 \) distributions. AddTo(const char* name, double_t wgtSelf, double_t wgtOther) Add constructed project",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:134746,Availability,down,downward,134746,"nst RooArgSet& compSet) As above, but pass a RooArgSet of the components themselves. Plotting control . DrawOption(const char* opt) Select ROOT draw option for resulting TGraph object. Currently supported options are ""F"" (fill), ""L"" (line), and ""P"" (points). NoteOption ""P"" will cause RooFit to plot (and treat) this pdf as if it were data! This is intended for plotting ""corrected data""-type pdfs such as ""data-minus-background"" or unfolded datasets. LineStyle(Int_t style) Select line style by ROOT line style code, default is solid. LineColor(Int_t color) Select line color by ROOT color code, default is blue. LineWidth(Int_t width) Select line with in pixels, default is 3. MarkerStyle(Int_t style) Select the ROOT marker style, default is 21. MarkerColor(Int_t color) Select the ROOT marker color, default is black. MarkerSize(double size) Select the ROOT marker size. FillStyle(Int_t style) Select fill style, default is not filled. If a filled style is selected, also use VLines() to add vertical downward lines at end of curve to ensure proper closure. Add DrawOption(""F"") for filled drawing. . FillColor(Int_t color) Select fill color by ROOT color code. Range(const char* name) Only draw curve in range defined by given name. Range(double lo, double hi) Only draw curve in specified range. VLines() Add vertical lines to y=0 at end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may ",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:136050,Availability,error,error,136050," end points of curve. Precision(double eps) Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision will result in more and more densely spaced curve points. Invisible(bool flag) Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true) Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma' . Details on error band visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1639 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The fun",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:137062,Availability,error,errors,137062," visualization; VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter: See alsoplotOnWithErrorBand(). PyROOT; The RooAbsReal::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented in RooSimultaneous, RooAbsPdf, and RooSimultaneous.; Definition at line 1639 of file RooAbsReal.cxx. ◆ plotOn() [2/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The functions value can be multiplied with an optional scale factor. The interpretation of the scale factor is unique for generic real functions, for PDFs there are various interpretations possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; The default projection behaviour can be overridden by supplying an optional set of dependents to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface to modify the default projection behaviour. ; Reimplemented in RooAbsPdf, and RooSimultaneous.; Definition at line 1931 of file RooAbsReal.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. virtual . Internal back-end function of plotOn() with named arguments. ; Reimplemented in RooAbsPdf, RooSimultaneous, and RooSimultaneous.; Definition at line 1659 of file RooAbsReal.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; RooArgSet * ; selNodes",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:138833,Availability,error,errors,138833,"l.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; RooArgSet * ; selNodes); const. protected . Helper function for plotting of composite p.d.fs. ; Given a set of selected components that should be plotted, find all nodes that (in)directly depend on these selected nodes. Mark all directly and indirectly selected nodes as 'selected' using the selectComp() method ; Definition at line 1466 of file RooAbsReal.cxx. ◆ plotOnWithErrorBand(). RooPlot * RooAbsReal::plotOnWithErrorBand ; (; RooPlot * ; frame, . const RooFitResult & ; fr, . double ; Z, . const RooArgSet * ; params, . const RooLinkedList & ; argList, . bool ; linMethod . ); const. protected . Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ; Parameters. [in]frameRooPlot to plot on ; [in]frThe RooFitResult, where errors can be extracted ; [in]ZThe desired significance (width) of the error band ; [in]paramsIf non-zero, consider only the subset of the parameters in fr for the error evaluation ; [in]argListOptional RooCmdArg that can be applied to a regular plotOn() operation ; [in]linMethodBy default (linMethod=true), a linearized error is shown. . ReturnsThe RooPlot the band was plotted on (for chaining of plotting commands).; The linearized error is calculated as follows: ; \[; \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; \]. where ; \[; F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; \]. with \( f(x) \) the plotted curve and \( \mathrm{d}a \) taken from the fit result, and \( \mathrm{Corr}(a,a') \) = the correlation matrix from the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated us",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:138904,Availability,error,error,138904,"l.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; RooArgSet * ; selNodes); const. protected . Helper function for plotting of composite p.d.fs. ; Given a set of selected components that should be plotted, find all nodes that (in)directly depend on these selected nodes. Mark all directly and indirectly selected nodes as 'selected' using the selectComp() method ; Definition at line 1466 of file RooAbsReal.cxx. ◆ plotOnWithErrorBand(). RooPlot * RooAbsReal::plotOnWithErrorBand ; (; RooPlot * ; frame, . const RooFitResult & ; fr, . double ; Z, . const RooArgSet * ; params, . const RooLinkedList & ; argList, . bool ; linMethod . ); const. protected . Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ; Parameters. [in]frameRooPlot to plot on ; [in]frThe RooFitResult, where errors can be extracted ; [in]ZThe desired significance (width) of the error band ; [in]paramsIf non-zero, consider only the subset of the parameters in fr for the error evaluation ; [in]argListOptional RooCmdArg that can be applied to a regular plotOn() operation ; [in]linMethodBy default (linMethod=true), a linearized error is shown. . ReturnsThe RooPlot the band was plotted on (for chaining of plotting commands).; The linearized error is calculated as follows: ; \[; \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; \]. where ; \[; F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; \]. with \( f(x) \) the plotted curve and \( \mathrm{d}a \) taken from the fit result, and \( \mathrm{Corr}(a,a') \) = the correlation matrix from the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated us",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
https://root.cern/doc/v632/classRooAbsReal.html:138997,Availability,error,error,138997,"l.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; RooArgSet * ; selNodes); const. protected . Helper function for plotting of composite p.d.fs. ; Given a set of selected components that should be plotted, find all nodes that (in)directly depend on these selected nodes. Mark all directly and indirectly selected nodes as 'selected' using the selectComp() method ; Definition at line 1466 of file RooAbsReal.cxx. ◆ plotOnWithErrorBand(). RooPlot * RooAbsReal::plotOnWithErrorBand ; (; RooPlot * ; frame, . const RooFitResult & ; fr, . double ; Z, . const RooArgSet * ; params, . const RooLinkedList & ; argList, . bool ; linMethod . ); const. protected . Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ; Parameters. [in]frameRooPlot to plot on ; [in]frThe RooFitResult, where errors can be extracted ; [in]ZThe desired significance (width) of the error band ; [in]paramsIf non-zero, consider only the subset of the parameters in fr for the error evaluation ; [in]argListOptional RooCmdArg that can be applied to a regular plotOn() operation ; [in]linMethodBy default (linMethod=true), a linearized error is shown. . ReturnsThe RooPlot the band was plotted on (for chaining of plotting commands).; The linearized error is calculated as follows: ; \[; \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; \]. where ; \[; F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; \]. with \( f(x) \) the plotted curve and \( \mathrm{d}a \) taken from the fit result, and \( \mathrm{Corr}(a,a') \) = the correlation matrix from the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated us",MatchSource.WIKI,doc/v632/classRooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html
