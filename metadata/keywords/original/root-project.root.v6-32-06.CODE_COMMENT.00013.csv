id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:265,Availability,mask,mask,265,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:479,Availability,mask,mask,479,/// Stores 8 packed 64-bit integer elements located in a and stores them in; /// memory locations starting at location \a base_addr at packed 32-bit integer; /// indices stored in \a vindex scaled by scale using writemask \a mask (elements; /// whose corresponding mask bit is not set are not written to memory).; ///; /// This intrinsic corresponds to the <c> VPSCATTERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// MEM[addr+63:addr] := a[i+63:i]; /// FI; /// ENDFOR; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h:3,Performance,load,loads,3,// loads with vmovsh:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fp16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:375,Availability,mask,mask,375,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:320,Availability,mask,mask,320,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __B; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __B, and higher 64 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:377,Availability,mask,mask,377,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [16 x bfloat].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element from __W.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:321,Availability,mask,mask,321,"/// Convert Two Packed Single Data to One Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNE2PS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __B; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A or __B. A 0 means element is zero.; /// \returns A 256-bit vector of [16 x bfloat] whose lower 128 bits come from; /// conversion of __B, and higher 128 bits come from conversion of __A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,Availability,mask,mask,312,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __W; /// A 128-bit vector of [8 x bfloat].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,Availability,mask,mask,257,"/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 4-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] whose lower 64 bits come from; /// conversion of __A, and higher 64 bits are 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:312,Availability,mask,mask,312,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __W; /// A 256-bit vector of [8 x bfloat].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element from __W.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:257,Availability,mask,mask,257,/// Convert Packed Single Data to Packed BF16 Data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VCVTNEPS2BF16 </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means conversion of __A. A 0 means element is zero.; /// \returns A 128-bit vector of [8 x bfloat] comes from conversion of __A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,Availability,mask,mask,383,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:383,Availability,mask,mask,383,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \param __B; /// A 128-bit vector of [8 x bfloat].; /// \param __D; /// A 128-bit vector of [4 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 128-bit vector of [4 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:386,Availability,mask,mask,386,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 16-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means __D.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:385,Availability,mask,mask,385,"/// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VDPBF16PS </c> instructions.; ///; /// \param __A; /// A 256-bit vector of [16 x bfloat].; /// \param __B; /// A 256-bit vector of [16 x bfloat].; /// \param __D; /// A 256-bit vector of [8 x float].; /// \param __U; /// A 8-bit mask value specifying what is chosen for each element.; /// A 1 means __A and __B's dot product accumulated with __D. A 0 means 0.; /// \returns A 256-bit vector of [8 x float] comes from Dot Product of; /// __A, __B and __D",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:140,Availability,mask,mask,140,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:193,Availability,mask,mask,193,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:140,Availability,mask,mask,140,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:193,Availability,mask,mask,193,/// Convert Packed BF16 Data to Packed float Data using zeroing mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:222,Availability,mask,mask,222,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:272,Availability,mask,mask,272,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:325,Availability,mask,mask,325,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 128-bit vector of [4 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 4-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [4 x bfloat].; /// \returns A 128-bit vector of [4 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:64,Availability,mask,mask,64,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:222,Availability,mask,mask,222,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:272,Availability,mask,mask,272,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h:325,Availability,mask,mask,325,/// Convert Packed BF16 Data to Packed float Data using merging mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \param __S; /// A 256-bit vector of [8 x float]. Elements are copied from __S when; /// the corresponding mask bit is not set.; /// \param __U; /// A 8-bit mask. Elements are zeroed out when the corresponding mask; /// bit is not set.; /// \param __A; /// A 128-bit vector of [8 x bfloat].; /// \returns A 256-bit vector of [8 x float] come from conversion of __A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlbf16intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:127,Energy Efficiency,charge,charge,127,"/*===------ avx512vlvp2intersectintrin.h - VL VP2INTERSECT intrinsics ------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:1021,Integrability,CONTRACT,CONTRACT,1021,"/*===------ avx512vlvp2intersectintrin.h - VL VP2INTERSECT intrinsics ------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:415,Availability,mask,mask,415,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:467,Availability,mask,mask,467,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x i32].; /// \param __b; /// A 256-bit vector of [8 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x i64].; /// \param __b; /// A 256-bit vector of [4 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:415,Availability,mask,mask,415,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:467,Availability,mask,mask,467,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x i32].; /// \param __b; /// A 128-bit vector of [4 x i32]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x i64].; /// \param __b; /// A 128-bit vector of [2 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vlvp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:128,Energy Efficiency,charge,charge,128,"/*===------- avx512vpintersectintrin.h - VP2INTERSECT intrinsics ------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:1022,Integrability,CONTRACT,CONTRACT,1022,"/*===------- avx512vpintersectintrin.h - VP2INTERSECT intrinsics ------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:471,Availability,mask,mask,471,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between dwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTD </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [16 x i32].; /// \param __b; /// A 512-bit vector of [16 x i32]; /// \param __m0; /// A pointer point to 16-bit mask; /// \param __m1; /// A pointer point to 16-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:34,Availability,mask,mask,34,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:418,Availability,mask,mask,418,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h:470,Availability,mask,mask,470,"/// Store, in an even/odd pair of mask registers, the indicators of the; /// locations of value matches between quadwords in operands __a and __b.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VP2INTERSECTQ </c> instruction.; ///; /// \param __a; /// A 512-bit vector of [8 x i64].; /// \param __b; /// A 512-bit vector of [8 x i64]; /// \param __m0; /// A pointer point to 8-bit mask; /// \param __m1; /// A pointer point to 8-bit mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512vp2intersectintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:92,Integrability,interface,interface,92,/* We need an explicitly signed variant for char. Note that this shouldn't; * appear in the interface though. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:922,Availability,Down,Downward,922,"/// Rounds the values in a 256-bit vector of [4 x double] as specified; /// by the byte operand. The source values are rounded to integer values and; /// returned as 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_round_pd(__m256d V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [4 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:695,Deployability,update,updated,695,"/// Rounds the values in a 256-bit vector of [4 x double] as specified; /// by the byte operand. The source values are rounded to integer values and; /// returned as 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_round_pd(__m256d V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [4 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:901,Availability,Down,Downward,901,"/// Rounds the values stored in a 256-bit vector of [8 x float] as; /// specified by the byte operand. The source values are rounded to integer; /// values and returned as floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_round_ps(__m256 V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [8 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:674,Deployability,update,updated,674,"/// Rounds the values stored in a 256-bit vector of [8 x float] as; /// specified by the byte operand. The source values are rounded to integer; /// values and returned as floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_round_ps(__m256 V, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used. \n; /// 1: The PE field is not updated. \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M. \n; /// 1: Use the current MXCSR setting. \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest. \n; /// 01: Downward (toward negative infinity). \n; /// 10: Upward (toward positive infinity). \n; /// 11: Truncated.; /// \returns A 256-bit vector of [8 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,Availability,down,down,11,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:106,Availability,down,down,106,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:507,Availability,down,down,507,/// Rounds down the values stored in a 256-bit vector of [4 x double].; /// The source values are rounded down to integer values and returned as; /// 64-bit double-precision floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_floor_pd(__m256d V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD </c> instruction.; ///; /// \param V; /// A 256-bit vector of [4 x double].; /// \returns A 256-bit vector of [4 x double] containing the rounded down; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:11,Availability,down,down,11,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:105,Availability,down,down,105,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:478,Availability,down,down,478,/// Rounds down the values stored in a 256-bit vector of [8 x float]. The; /// source values are rounded down to integer values and returned as; /// floating-point values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_floor_ps(__m256 V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS </c> instruction.; ///; /// \param V; /// A 256-bit vector of [8 x float].; /// \returns A 256-bit vector of [8 x float] containing the rounded down values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:19,Performance,Perform,Performs,19,/* Logical */; /// Performs a bitwise AND of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:3,Testability,Log,Logical,3,/* Logical */; /// Performs a bitwise AND of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of two 256-bit vectors of [4 x double], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [4 x double] containing the right source operand.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of two 256-bit vectors of [8 x float], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [8 x float] containing the right source operand.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise XOR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise XOR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:560,Availability,mask,mask,560,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:645,Availability,mask,mask,645,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:710,Availability,mask,mask,710,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:843,Availability,mask,mask,843,"/* Vector Blend */; /// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_blend_pd(__m256d V1, __m256d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double].; /// \param V2; /// A 256-bit vector of [4 x double].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 64-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:534,Availability,mask,mask,534,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:619,Availability,mask,mask,619,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:684,Availability,mask,mask,684,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:817,Availability,mask,mask,817,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the immediate; /// integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_blend_ps(__m256 V1, __m256 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float].; /// \param V2; /// A 256-bit vector of [8 x float].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the; /// destination. When a mask bit is 1, the corresponding 32-bit element in; /// operand \a V2 is copied to the same position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:441,Availability,mask,mask,441,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:542,Availability,mask,mask,542,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:622,Availability,mask,mask,622,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:756,Availability,mask,mask,756,"/// Merges 64-bit double-precision data values stored in either of the; /// two 256-bit vectors of [4 x double], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 191, 127, and 63 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __a is copied to the same; /// position in the destination. When a mask bit is 1, the corresponding; /// 64-bit element in operand \a __b is copied to the same position in the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:438,Availability,mask,mask,438,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:562,Availability,mask,mask,562,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:642,Availability,mask,mask,642,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:771,Availability,mask,mask,771,"/// Merges 32-bit single-precision data values stored in either of the; /// two 256-bit vectors of [8 x float], as specified by the 256-bit vector; /// operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \param __c; /// A 256-bit vector operand, with mask bits 255, 223, 191, 159, 127, 95, 63,; /// and 31 specifying how the values are to be copied. The position of the; /// mask bit corresponds to the most significant bit of a copied value. When; /// a mask bit is 0, the corresponding 32-bit element in operand \a __a is; /// copied to the same position in the destination. When a mask bit is 1, the; /// corresponding 32-bit element in operand \a __b is copied to the same; /// position in the destination.; /// \returns A 256-bit vector of [8 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:864,Availability,mask,mask,864,"/* Vector shuffle */; /// Selects 8 float values from the 256-bit operands of [8 x float], as; /// specified by the immediate value operand.; ///; /// The four selected elements in each operand are copied to the destination; /// according to the bits specified in the immediate operand. The selected; /// elements from the first 256-bit operand are copied to bits [63:0] and; /// bits [191:128] of the destination, and the selected elements from the; /// second 256-bit operand are copied to bits [127:64] and bits [255:192] of; /// the destination. For example, if bits [7:0] of the immediate operand; /// contain a value of 0xFF, the 256-bit destination vector would contain the; /// following values: b[7], b[7], a[7], a[7], b[3], b[3], a[3], a[3].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:1434,Availability,mask,mask,1434,"ied to bits [127:64] and bits [255:192] of; /// the destination. For example, if bits [7:0] of the immediate operand; /// contain a value of 0xFF, the 256-bit destination vector would contain the; /// following values: b[7], b[7], a[7], a[7], b[3], b[3], a[3], a[3].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:2592,Availability,mask,mask,2592,"56_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. \n; /// 11: Bits [127:96] and [255:224] are copied from the selected operand. \n; /// Note: To generate a mask, you can use the \c _MM_SHUFFLE macro.; /// <c>_MM_SHUFFLE(b6, b4, b2, b0)</c> can create an 8-bit mask of the form; /// <c>[b6, b4, b2, b0]</c>.; /// \returns A 256-bit vector of [8 x float] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:2696,Availability,mask,mask,2696,"56_shuffle_ps(__m256 a, __m256 b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPS </c> instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [63:0] and bits [191:128] in the destination,; /// according to the bits specified in the immediate operand.; /// \param b; /// A 256-bit vector of [8 x float]. The four selected elements in this; /// operand are copied to bits [127:64] and bits [255:192] in the; /// destination, according to the bits specified in the immediate operand.; /// \param mask; /// An immediate value containing an 8-bit value specifying which elements to; /// copy from \a a and \a b \n.; /// Bits [3:0] specify the values copied from operand \a a. \n; /// Bits [7:4] specify the values copied from operand \a b. \n; /// The destinations within the 256-bit destination are assigned values as; /// follows, according to the bit value assignments described below: \n; /// Bits [1:0] are used to assign values to bits [31:0] and [159:128] in the; /// destination. \n; /// Bits [3:2] are used to assign values to bits [63:32] and [191:160] in the; /// destination. \n; /// Bits [5:4] are used to assign values to bits [95:64] and [223:192] in the; /// destination. \n; /// Bits [7:6] are used to assign values to bits [127:96] and [255:224] in; /// the destination. \n; /// Bit value assignments: \n; /// 00: Bits [31:0] and [159:128] are copied from the selected operand. \n; /// 01: Bits [63:32] and [191:160] are copied from the selected operand. \n; /// 10: Bits [95:64] and [223:192] are copied from the selected operand. \n; /// 11: Bits [127:96] and [255:224] are copied from the selected operand. \n; /// Note: To generate a mask, you can use the \c _MM_SHUFFLE macro.; /// <c>_MM_SHUFFLE(b6, b4, b2, b0)</c> can create an 8-bit mask of the form; /// <c>[b6, b4, b2, b0]</c>.; /// \returns A 256-bit vector of [8 x float] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:694,Availability,mask,mask,694,"/// Selects four double-precision values from the 256-bit operands of; /// [4 x double], as specified by the immediate value operand.; ///; /// The selected elements from the first 256-bit operand are copied to bits; /// [63:0] and bits [191:128] in the destination, and the selected elements; /// from the second 256-bit operand are copied to bits [127:64] and bits; /// [255:192] in the destination. For example, if bits [3:0] of the immediate; /// operand contain a value of 0xF, the 256-bit destination vector would; /// contain the following values: b[3], a[3], b[1], a[1].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_shuffle_pd(__m256d a, __m256d b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPD </c> instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double].; /// \param b; /// A 256-bit vector of [4 x double].; /// \param mask; /// An immediate value containing 8-bit values specifying which elements to; /// copy from \a a and \a b: \n; /// Bit [0]=0: Bits [63:0] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [0]=1: Bits [127:64] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [1]=0: Bits [63:0] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [1]=1: Bits [127:64] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [2]=0: Bits [191:128] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [2]=1: Bits [255:192] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [3]=0: Bits [191:128] are copied from \a b to bits [255:192] of the; /// destination. \n; /// Bit [3]=1: Bits [255:192] are copied from \a b to bits [255:192] of the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:912,Availability,mask,mask,912,"/// Selects four double-precision values from the 256-bit operands of; /// [4 x double], as specified by the immediate value operand.; ///; /// The selected elements from the first 256-bit operand are copied to bits; /// [63:0] and bits [191:128] in the destination, and the selected elements; /// from the second 256-bit operand are copied to bits [127:64] and bits; /// [255:192] in the destination. For example, if bits [3:0] of the immediate; /// operand contain a value of 0xF, the 256-bit destination vector would; /// contain the following values: b[3], a[3], b[1], a[1].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_shuffle_pd(__m256d a, __m256d b, const int mask);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VSHUFPD </c> instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double].; /// \param b; /// A 256-bit vector of [4 x double].; /// \param mask; /// An immediate value containing 8-bit values specifying which elements to; /// copy from \a a and \a b: \n; /// Bit [0]=0: Bits [63:0] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [0]=1: Bits [127:64] are copied from \a a to bits [63:0] of the; /// destination. \n; /// Bit [1]=0: Bits [63:0] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [1]=1: Bits [127:64] are copied from \a b to bits [127:64] of the; /// destination. \n; /// Bit [2]=0: Bits [191:128] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [2]=1: Bits [255:192] are copied from \a a to bits [191:128] of the; /// destination. \n; /// Bit [3]=0: Bits [191:128] are copied from \a b to bits [255:192] of the; /// destination. \n; /// Bit [3]=1: Bits [255:192] are copied from \a b to bits [255:192] of the; /// destination.; /// \returns A 256-bit vector of [4 x double] containing the shuffled values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:288,Usability,clear,cleared,288,"/// Compares each of the corresponding scalar double-precision values of; /// two 128-bit vectors of [2 x double], using the operation specified by the; /// immediate integer operand.; ///; /// If the result is true, all 64 bits of the destination vector are set;; /// otherwise they are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_cmp_sd(__m128d a, __m128d b, const int c);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCMPSD </c> instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double].; /// \param b; /// A 128-bit vector of [2 x double].; /// \param c; /// An immediate integer operand, with bits [4:0] specifying which comparison; /// operation to use: \n; /// 0x00: Equal (ordered, non-signaling) \n; /// 0x01: Less-than (ordered, signaling) \n; /// 0x02: Less-than-or-equal (ordered, signaling) \n; /// 0x03: Unordered (non-signaling) \n; /// 0x04: Not-equal (unordered, non-signaling) \n; /// 0x05: Not-less-than (unordered, signaling) \n; /// 0x06: Not-less-than-or-equal (unordered, signaling) \n; /// 0x07: Ordered (non-signaling) \n; /// 0x08: Equal (unordered, non-signaling) \n; /// 0x09: Not-greater-than-or-equal (unordered, signaling) \n; /// 0x0A: Not-greater-than (unordered, signaling) \n; /// 0x0B: False (ordered, non-signaling) \n; /// 0x0C: Not-equal (ordered, non-signaling) \n; /// 0x0D: Greater-than-or-equal (ordered, signaling) \n; /// 0x0E: Greater-than (ordered, signaling) \n; /// 0x0F: True (unordered, non-signaling) \n; /// 0x10: Equal (ordered, signaling) \n; /// 0x11: Less-than (ordered, non-signaling) \n; /// 0x12: Less-than-or-equal (ordered, non-signaling) \n; /// 0x13: Unordered (signaling) \n; /// 0x14: Not-equal (unordered, signaling) \n; /// 0x15: Not-less-than (unordered, non-signaling) \n; /// 0x16: Not-less-than-or-equal (unordered, non-signaling) \n; /// 0x17: Ordered (signaling) \n; /// 0x18: Equal (unordered, signaling) \n; /// 0x19: Not-greater-than-or-equal (unordered, non-si",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:270,Usability,clear,cleared,270,"/// Compares each of the corresponding scalar values of two 128-bit; /// vectors of [4 x float], using the operation specified by the immediate; /// integer operand.; ///; /// If the result is true, all 32 bits of the destination vector are set;; /// otherwise they are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_cmp_ss(__m128 a, __m128 b, const int c);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCMPSS </c> instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float].; /// \param b; /// A 128-bit vector of [4 x float].; /// \param c; /// An immediate integer operand, with bits [4:0] specifying which comparison; /// operation to use: \n; /// 0x00: Equal (ordered, non-signaling) \n; /// 0x01: Less-than (ordered, signaling) \n; /// 0x02: Less-than-or-equal (ordered, signaling) \n; /// 0x03: Unordered (non-signaling) \n; /// 0x04: Not-equal (unordered, non-signaling) \n; /// 0x05: Not-less-than (unordered, signaling) \n; /// 0x06: Not-less-than-or-equal (unordered, signaling) \n; /// 0x07: Ordered (non-signaling) \n; /// 0x08: Equal (unordered, non-signaling) \n; /// 0x09: Not-greater-than-or-equal (unordered, signaling) \n; /// 0x0A: Not-greater-than (unordered, signaling) \n; /// 0x0B: False (ordered, non-signaling) \n; /// 0x0C: Not-equal (ordered, non-signaling) \n; /// 0x0D: Greater-than-or-equal (ordered, signaling) \n; /// 0x0E: Greater-than (ordered, signaling) \n; /// 0x0F: True (unordered, non-signaling) \n; /// 0x10: Equal (ordered, signaling) \n; /// 0x11: Less-than (ordered, non-signaling) \n; /// 0x12: Less-than-or-equal (ordered, non-signaling) \n; /// 0x13: Unordered (signaling) \n; /// 0x14: Not-equal (unordered, signaling) \n; /// 0x15: Not-less-than (unordered, non-signaling) \n; /// 0x16: Not-less-than-or-equal (unordered, non-signaling) \n; /// 0x17: Ordered (signaling) \n; /// 0x18: Equal (unordered, signaling) \n; /// 0x19: Not-greater-than-or-equal (unordered, non-signaling) \n; /// 0x1A: ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:580,Modifiability,extend,extended,580,"/// Takes a [8 x i32] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi32(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit vector of [8 x i32].; /// \param N; /// An immediate integer operand with bits [2:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 32 bits of extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:595,Modifiability,extend,extended,595,"/// Takes a [16 x i16] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi16(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [16 x i16].; /// \param N; /// An immediate integer operand with bits [3:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 16 bits of zero extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:591,Modifiability,extend,extended,591,"/// Takes a [32 x i8] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm256_extract_epi8(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [32 x i8].; /// \param N; /// An immediate integer operand with bits [4:0] determining which vector; /// element is extracted and returned.; /// \returns A 32-bit integer containing the extracted 8 bits of zero extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:594,Modifiability,extend,extended,594,"/// Takes a [4 x i64] vector and returns the vector element value; /// indexed by the immediate constant operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// long long _mm256_extract_epi64(__m256i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VEXTRACTF128+COMPOSITE </c>; /// instruction.; ///; /// \param X; /// A 256-bit integer vector of [4 x i64].; /// \param N; /// An immediate integer operand with bits [1:0] determining which vector; /// element is extracted and returned.; /// \returns A 64-bit integer containing the extracted 64 bits of extended; /// packed data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:285,Deployability,update,updated,285,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:78,Performance,perform,perform,78,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:7,Testability,Test,Test,7,"/* Bit Test */; /// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the ZF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:269,Deployability,update,updated,269,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the CF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the CF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:269,Deployability,update,updated,269,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:271,Deployability,update,updated,271,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,Performance,perform,perform,62,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:268,Deployability,update,updated,268,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:270,Deployability,update,updated,270,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,Performance,perform,perform,61,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the CF flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:136,Deployability,update,updated,136,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,Performance,perform,perform,39,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:23,Availability,mask,mask,23,"/* Vector extract sign mask */; /// Extracts the sign bits of double-precision floating point elements; /// in a 256-bit vector of [4 x double] and writes them to the lower order; /// bits of the return value.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVMSKPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing the double-precision; /// floating point values with sign bits to be extracted.; /// \returns The sign bits from the operand, written to bits [3:0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:10,Performance,load,load,10,/* Vector load with broadcast */; /// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 128-bit vector of [4 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:38,Performance,Load,Loads,38,/* Vector load with broadcast */; /// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 128-bit vector of [4 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads a scalar double-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x double] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSD </c> instruction.; ///; /// \param __a; /// The double-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 64-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [8 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads the data from a 128-bit vector of [2 x double] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [2 x double] to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads the data from a 128-bit vector of [4 x float] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [4 x float] to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,Performance,load,load,8,/* SIMD load ops */; /// Loads 4 double-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPD </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing; /// double-precision floating point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:25,Performance,Load,Loads,25,/* SIMD load ops */; /// Loads 4 double-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPD </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing; /// double-precision floating point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 8 single-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPS </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing float values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 4 double-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing double-precision floating; /// point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 8 single-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing single-precision floating; /// point values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from a 32-byte aligned memory; /// location pointed to by \a __p into elements of a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQA </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a 256-bit integer vector containing integer; /// values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:150,Performance,perform,perform,150,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:216,Performance,cache,cache,216,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:203,Availability,mask,mask,203,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:547,Availability,mask,mask,547,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:619,Availability,mask,mask,619,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:635,Availability,mask,mask,635,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:186,Integrability,depend,depending,186,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:15,Performance,load,load,15,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:46,Performance,load,loads,46,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:712,Performance,load,loaded,712,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:850,Performance,load,loaded,850,"/* Conditional load ops */; /// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [2 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [2 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:175,Availability,mask,mask,175,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:537,Availability,mask,mask,537,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:613,Availability,mask,mask,613,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:634,Availability,mask,mask,634,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:158,Integrability,depend,depending,158,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:711,Performance,load,loaded,711,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:844,Performance,load,loaded,844,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:174,Availability,mask,mask,174,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:518,Availability,mask,mask,518,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:590,Availability,mask,mask,590,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:606,Availability,mask,mask,606,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,Integrability,depend,depending,157,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:683,Performance,load,loaded,683,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:820,Performance,load,loaded,820,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:174,Availability,mask,mask,174,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:533,Availability,mask,mask,533,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:606,Availability,mask,mask,606,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:622,Availability,mask,mask,622,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:157,Integrability,depend,depending,157,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,Performance,load,loads,18,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:699,Performance,load,loaded,699,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:836,Performance,load,loaded,836,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:195,Availability,mask,mask,195,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:483,Availability,mask,mask,483,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:548,Availability,mask,mask,548,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:580,Availability,mask,mask,580,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:596,Availability,mask,mask,596,"/* Conditional store ops */; /// Moves single-precision floating point values from a 256-bit vector; /// of [8 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element in the mask vector represents the; /// mask bits. If a mask bit is zero, the corresponding value from vector; /// \a __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [8 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,Availability,mask,mask,152,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:425,Availability,mask,mask,425,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:482,Availability,mask,mask,482,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:509,Availability,mask,mask,509,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:525,Availability,mask,mask,525,"/// Moves double-precision values from a 128-bit vector of [2 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector \a __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [2 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:152,Availability,mask,mask,152,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:443,Availability,mask,mask,443,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:511,Availability,mask,mask,511,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:543,Availability,mask,mask,543,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:559,Availability,mask,mask,559,"/// Moves double-precision values from a 256-bit vector of [4 x double]; /// to a memory location pointed to by \a __p, according to the specified; /// mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element in the mask vector represents; /// the mask bits. If a mask bit is zero, the corresponding value from vector; /// __a is not stored and the corresponding field in the memory location; /// pointed to by \a __p is not changed.; /// \param __a; /// A 256-bit vector of [4 x double] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:166,Availability,mask,mask,166,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:439,Availability,mask,mask,439,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:496,Availability,mask,mask,496,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:523,Availability,mask,mask,523,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:539,Availability,mask,mask,539,"/// Moves single-precision floating point values from a 128-bit vector; /// of [4 x float] to a memory location pointed to by \a __p, according to; /// the specified mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that will receive the float values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each field in the mask vector represents the mask bits. If a mask bit is; /// zero, the corresponding value from vector __a is not stored and the; /// corresponding field in the memory location pointed to by \a __p is not; /// changed.; /// \param __a; /// A 128-bit vector of [4 x float] containing the values to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:3,Performance,Cache,Cacheability,3,"/* Cacheability support ops */; /// Moves integer data from a 256-bit integer vector to a 32-byte; /// aligned memory location. To minimize caching, the data is flagged as; /// non-temporal (unlikely to be used again soon).; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQ </c> instruction.; ///; /// \param __a; /// A pointer to a 32-byte aligned memory location that will receive the; /// integer values.; /// \param __b; /// A 256-bit integer vector containing the values to be moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:1121,Integrability,depend,depending,1121,"/*; Vector insert.; We use macros rather than inlines because we only want to accept; invocations where the immediate M is a constant expression.; */; /// Constructs a new 256-bit vector of [8 x float] by first duplicating; /// a 256-bit vector of [8 x float] given in the first parameter, and then; /// replacing either the upper or the lower 128 bits with the contents of a; /// 128-bit vector of [4 x float] in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256 _mm256_insertf128_ps(__m256 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [8 x float]. This vector is copied to the result; /// first, and then either the upper or the lower 128 bits of the result will; /// be replaced by the contents of \a V2.; /// \param V2; /// A 128-bit vector of [4 x float]. The contents of this parameter are; /// written to either the upper or the lower 128 bits of the result depending; /// on the value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit vector of [8 x float] containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:978,Integrability,depend,depending,978,"/// Constructs a new 256-bit vector of [4 x double] by first duplicating; /// a 256-bit vector of [4 x double] given in the first parameter, and then; /// replacing either the upper or the lower 128 bits with the contents of a; /// 128-bit vector of [2 x double] in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256d _mm256_insertf128_pd(__m256d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit vector of [4 x double]. This vector is copied to the result; /// first, and then either the upper or the lower 128 bits of the result will; /// be replaced by the contents of \a V2.; /// \param V2; /// A 128-bit vector of [2 x double]. The contents of this parameter are; /// written to either the upper or the lower 128 bits of the result depending; /// on the value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit vector of [4 x double] containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:941,Integrability,depend,depending,941,"/// Constructs a new 256-bit integer vector by first duplicating a; /// 256-bit integer vector given in the first parameter, and then replacing; /// either the upper or the lower 128 bits with the contents of a 128-bit; /// integer vector in the second parameter.; ///; /// The immediate integer parameter determines between the upper or the lower; /// 128 bits.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m256i _mm256_insertf128_si256(__m256i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTF128 </c> instruction.; ///; /// \param V1; /// A 256-bit integer vector. This vector is copied to the result first, and; /// then either the upper or the lower 128 bits of the result will be; /// replaced by the contents of \a V2.; /// \param V2; /// A 128-bit integer vector. The contents of this parameter are written to; /// either the upper or the lower 128 bits of the result depending on the; /// value of parameter \a M.; /// \param M; /// An immediate integer. The least significant bit determines how the values; /// from the two parameters are interleaved: \n; /// If bit [0] of \a M is 0, \a V2 are copied to bits [127:0] of the result,; /// and bits [255:128] of \a V1 are copied to bits [255:128] of the; /// result. \n; /// If bit [0] of \a M is 1, \a V2 are copied to bits [255:128] of the; /// result, and bits [127:0] of \a V1 are copied to bits [127:0] of the; /// result.; /// \returns A 256-bit integer vector containing the interleaved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:8,Performance,load,load,8,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:37,Performance,Load,Loads,37,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:315,Performance,load,load,315,/* SIMD load ops (unaligned) */; /// Loads two 128-bit floating-point vectors of [4 x float] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [8 x float] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing 4 consecutive; /// single-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [8 x float] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads two 128-bit floating-point vectors of [2 x double] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [4 x double] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [4 x double] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:284,Performance,load,load,284,/// Loads two 128-bit floating-point vectors of [2 x double] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [4 x double] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [4 x double] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Performance,Load,Loads,4,/// Loads two 128-bit integer vectors from unaligned memory locations and; /// constructs a 256-bit integer vector by concatenating the two 128-bit; /// vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[255:128] of the result. The; /// address of the memory location does not have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[127:0] of the result. The; /// address of the memory location does not have to be aligned.; /// \returns A 256-bit integer vector containing the concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:238,Performance,load,load,238,/// Loads two 128-bit integer vectors from unaligned memory locations and; /// constructs a 256-bit integer vector by concatenating the two 128-bit; /// vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[255:128] of the result. The; /// address of the memory location does not have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[127:0] of the result. The; /// address of the memory location does not have to be aligned.; /// \returns A 256-bit integer vector containing the concatenated result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h:126,Energy Efficiency,charge,charge,126,"/*===--------------- avxvnniintrin.h - VNNI intrinsics --------------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h:1020,Integrability,CONTRACT,CONTRACT,1020,"/*===--------------- avxvnniintrin.h - VNNI intrinsics --------------------===; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxvnniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,Availability,mask,mask,123,"/// Deposit (scatter) low-order bits from the unsigned 32-bit integer \a __X; /// into the 32-bit result, according to the mask in the unsigned 32-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying where to deposit source bits.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:580,Availability,mask,mask,580,"/// Deposit (scatter) low-order bits from the unsigned 32-bit integer \a __X; /// into the 32-bit result, according to the mask in the unsigned 32-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying where to deposit source bits.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,Availability,mask,mask,134,"/// Extract (gather) bits from the unsigned 32-bit integer \a __X into the; /// low-order bits of the 32-bit result, according to the mask in the; /// unsigned 32-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying which source bits to extract.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:591,Availability,mask,mask,591,"/// Extract (gather) bits from the unsigned 32-bit integer \a __X into the; /// low-order bits of the 32-bit result, according to the mask in the; /// unsigned 32-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 31; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 32-bit source value to copy.; /// \param __Y; /// The 32-bit mask specifying which source bits to extract.; /// \returns The 32-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:123,Availability,mask,mask,123,"/// Deposit (scatter) low-order bits from the unsigned 64-bit integer \a __X; /// into the 64-bit result, according to the mask in the unsigned 64-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying where to deposit source bits.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:580,Availability,mask,mask,580,"/// Deposit (scatter) low-order bits from the unsigned 64-bit integer \a __X; /// into the 64-bit result, according to the mask in the unsigned 64-bit; /// integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[m] := __X[i]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PDEP instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying where to deposit source bits.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:134,Availability,mask,mask,134,"/// Extract (gather) bits from the unsigned 64-bit integer \a __X into the; /// low-order bits of the 64-bit result, according to the mask in the; /// unsigned 64-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying which source bits to extract.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h:591,Availability,mask,mask,591,"/// Extract (gather) bits from the unsigned 64-bit integer \a __X into the; /// low-order bits of the 64-bit result, according to the mask in the; /// unsigned 64-bit integer \a __Y. All other bits of the result are zero.; ///; /// \code{.operation}; /// i := 0; /// result := 0; /// FOR m := 0 TO 63; /// IF __Y[m] == 1; /// result[i] := __X[m]; /// i := i + 1; /// ENDIF; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c PEXT instruction.; ///; /// \param __X; /// The 64-bit source value to copy.; /// \param __Y; /// The 64-bit mask specifying which source bits to extract.; /// \returns The 64-bit result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _andn_u32(unsigned int __X, unsigned int __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:292,Usability,clear,cleared,292,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:360,Usability,clear,clearing,360,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see _blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:369,Usability,clear,cleared,369,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:437,Usability,clear,clearing,437,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsi_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned integer whose bits are to be cleared.; /// \returns An unsigned integer containing the result of clearing the bits from; /// the source operand.; /// \see __blsi_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:343,Availability,mask,mask,343,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:412,Availability,mask,mask,412,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see _blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:422,Availability,mask,mask,422,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:491,Availability,mask,mask,491,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _blsmsk_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned integer used to create the mask.; /// \returns An unsigned integer containing the newly created mask.; /// \see __blsmsk_u32",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:281,Usability,clear,cleared,281,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:349,Usability,clear,clearing,349,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see _blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:358,Usability,clear,cleared,358,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:426,Usability,clear,clearing,426,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _bls4_u32(unsigned int __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned integer containing the operand to be cleared.; /// \returns An unsigned integer containing the result of clearing the source; /// operand.; /// \see __blsr_u32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _andn_u64(unsigned long long __X,; /// unsigned long long __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:299,Usability,clear,cleared,299,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:374,Usability,clear,clearing,374,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see _blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:388,Usability,clear,cleared,388,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:463,Usability,clear,clearing,463,/// Clears all bits in the source except for the least significant bit; /// containing a value of 1 and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsi_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSI instruction.; ///; /// \param __X; /// An unsigned 64-bit integer whose bits are to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// bits from the source operand.; /// \see __blsi_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:350,Availability,mask,mask,350,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:426,Availability,mask,mask,426,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see _blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:14,Availability,mask,mask,14,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:441,Availability,mask,mask,441,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:517,Availability,mask,mask,517,"/// Creates a mask whose bits are set to 1, using bit 0 up to and; /// including the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsmsk_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSMSK instruction.; ///; /// \param __X; /// An unsigned 64-bit integer used to create the mask.; /// \returns An unsigned 64-bit integer containing the newly created mask.; /// \see __blsmsk_u64",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:288,Usability,clear,cleared,288,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:363,Usability,clear,clearing,363,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see _blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Usability,Clear,Clears,4,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:377,Usability,clear,cleared,377,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:452,Usability,clear,clearing,452,/// Clears the least significant bit that is set to 1 in the source; /// operand and returns the result.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _blsr_u64(unsigned long long __X);; /// \endcode; ///; /// This intrinsic corresponds to the \c BLSR instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing the operand to be cleared.; /// \returns An unsigned 64-bit integer containing the result of clearing the; /// source operand.; /// \see __blsr_u64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h:628,Availability,error,error,628,"/*===---- builtins.h - Standard header for extra builtins -----------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/; /// Some legacy compilers have builtin definitions in a file named builtins.h.; /// This header file has been added to allow compatibility with code that was; /// written for those compilers. Code may have an include line for this file; /// and to avoid an error an empty file with this name is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h:619,Safety,avoid,avoid,619,"/*===---- builtins.h - Standard header for extra builtins -----------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/; /// Some legacy compilers have builtin definitions in a file named builtins.h.; /// This header file has been added to allow compatibility with code that was; /// written for those compilers. Code may have an include line for this file; /// and to avoid an error an empty file with this name is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h:30,Performance,cache,cache,30,/// Hint to hardware that the cache line that contains \p __P should be demoted; /// from the cache closest to the processor core to a level more distant from; /// the processor core.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CLDEMOTE </c> instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h:94,Performance,cache,cache,94,/// Hint to hardware that the cache line that contains \p __P should be demoted; /// from the cache closest to the processor core to a level more distant from; /// the processor core.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CLDEMOTE </c> instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:34,Performance,cache,cache,34,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:99,Performance,cache,cache,99,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:298,Performance,cache,cache,298,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:30,Performance,cache,cache,30,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:135,Performance,cache,cache,135,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:163,Performance,cache,cache,163,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:373,Performance,cache,cache,373,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h:19,Performance,cache,cache,19,/// Zeroes out the cache line for the address \a __line. This uses a; /// non-temporal store. Calling \c _mm_sfence() afterward might be needed; /// to enforce ordering.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CLZERO instruction.; ///; /// \param __line; /// An address within the cache line to zero out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h:324,Performance,cache,cache,324,/// Zeroes out the cache line for the address \a __line. This uses a; /// non-temporal store. Calling \c _mm_sfence() afterward might be needed; /// to enforce ordering.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CLZERO instruction.; ///; /// \param __line; /// An address within the cache line to zero out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h:34,Safety,detect,detection,34,"/*===---- cpuid.h - X86 cpu model detection --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cpuid.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:282,Security,checksum,checksum,282,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:398,Security,checksum,checksum,398,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:473,Security,checksum,checksum,473,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:283,Security,checksum,checksum,283,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:400,Security,checksum,checksum,400,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:475,Security,checksum,checksum,475,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:59,Security,checksum,checksum,59,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:298,Security,checksum,checksum,298,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:415,Security,checksum,checksum,415,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:490,Security,checksum,checksum,490,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:292,Security,checksum,checksum,292,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:409,Security,checksum,checksum,409,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:484,Security,checksum,checksum,484,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed comparison, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,Performance,perform,performs,92,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst.; /// This intrinsics may only be used in User mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMD </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,Performance,perform,performs,92,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst; /// This intrinsic may only be used in Privileged mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMDS </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:529,Availability,Down,Down,529,"/// Converts a 32-bit single-precision float value to a 16-bit; /// half-precision float value.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned short _cvtss_sh(float a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 32-bit single-precision float value to be converted to a 16-bit; /// half-precision float value.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns The converted 16-bit half-precision float value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:515,Availability,Down,Down,515,"/// Converts a 128-bit vector containing 32-bit float values into a; /// 128-bit vector containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cvtps_ph(__m128 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 128-bit vector containing 32-bit float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing converted 16-bit half-precision float; /// values. The lower 64 bits are used to store the converted 16-bit; /// half-precision floating-point values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h:578,Availability,Down,Down,578,"/// Converts a 256-bit vector of [8 x float] into a 128-bit vector; /// containing 16-bit half-precision float values.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm256_cvtps_ph(__m256 a, const int imm);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VCVTPS2PH </c> instruction.; ///; /// \param a; /// A 256-bit vector containing 32-bit single-precision float values to be; /// converted to 16-bit half-precision float values.; /// \param imm; /// An immediate value controlling rounding using bits [2:0]: \n; /// 000: Nearest \n; /// 001: Down \n; /// 010: Up \n; /// 011: Truncate \n; /// 1XX: Use MXCSR.RC for rounding; /// \returns A 128-bit vector containing the converted 16-bit half-precision; /// float values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/f16cintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/f16cintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:42,Availability,mask,masking,42,/* Default attributes for simple form (no masking). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:26,Usability,simpl,simple,26,/* Default attributes for simple form (no masking). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:30,Availability,mask,masked,30,/* Default attributes for ZMM masked forms. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h:30,Availability,mask,masked,30,/* Default attributes for VLX masked forms. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/gfniintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/gfniintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:12,Performance,Load,Load,12,"/* Circular Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_circ_load_update_D(Word64 dst, Word64 *ptr, UWord32 incr, UWord32 bufsize, UWord32 K); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h:15,Performance,Load,Load,15,"/* Bit Reverse Load */; /* ==========================================================================; Assembly Syntax: Return=instruction(); C Intrinsic Prototype: void Q6_bitrev_load_update_D(Word64 dst, Word64 *ptr, UWord32 Iu4); Instruction Type: InstructionType; Execution Slots: SLOT0123; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_circ_brev_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:102,Availability,mask,mask,102,/* ==========================================================================; Assembly Syntax: Rdd32=mask(Pt4); C Intrinsic Prototype: Word64 Q6_P_mask_p(Byte Pt); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Deployability,toggle,togglebit,101,"/* ==========================================================================; Assembly Syntax: Rd32=togglebit(Rs32,#u5); C Intrinsic Prototype: Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Deployability,toggle,togglebit,101,"/* ==========================================================================; Assembly Syntax: Rd32=togglebit(Rs32,Rt32); C Intrinsic Prototype: Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt); Instruction Type: S_3op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h:101,Availability,mask,mask,101,"/* ==========================================================================; Assembly Syntax: Rd32=mask(#u5,#U5); C Intrinsic Prototype: Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5); Instruction Type: S_2op; Execution Slots: SLOT23; ========================================================================== */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hexagon_protos.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h:62,Safety,predict,prediction,62,/// Provides a hint to the processor to selectively reset the prediction; /// history of the current logical processor specified by a 32-bit integer; /// value \a __eax.; ///; /// This intrinsic corresponds to the <c> HRESET </c> instruction.; ///; /// \code{.operation}; /// IF __eax == 0; /// // nop; /// ELSE; /// FOR i := 0 to 31; /// IF __eax[i]; /// ResetPredictionFeature(i); /// FI; /// ENDFOR; /// FI; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h:101,Testability,log,logical,101,/// Provides a hint to the processor to selectively reset the prediction; /// history of the current logical processor specified by a 32-bit integer; /// value \a __eax.; ///; /// This intrinsic corresponds to the <c> HRESET </c> instruction.; ///; /// \code{.operation}; /// IF __eax == 0; /// // nop; /// ELSE; /// FOR i := 0 to 31; /// IF __eax[i]; /// ResetPredictionFeature(i); /// FI; /// ENDFOR; /// FI; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:44,Energy Efficiency,Power,PowerPC,44,"/*===---- htmintrin.h - Standard header for PowerPC HTM ---------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:7,Safety,abort,abort,7,/* The abort codes below this threshold are reserved for machine use. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:58,Availability,failure,failure,58,/* Helper intrinsics to retry tbegin in case of transient failure. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:35,Availability,avail,available,35,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:167,Availability,avail,available,167,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:151,Usability,Guid,Guide,151,"/* These intrinsics are being made available for compatibility with; the IBM XL compiler. For documentation please see the ""z/OS XL; C/C++ Programming Guide"" publicly available on the web. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h:15,Availability,failure,failure,15,/* Transaction failure diagnostics */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmxlintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:232,Testability,log,logic,232,/* __x86_64__ */; /// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param __A; /// An unsigned 32-bit integer operand.; /// \returns A 32-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see _popcnt32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:271,Testability,log,logic,271,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _popcnt32(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param A; /// An unsigned 32-bit integer operand.; /// \returns A 32-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see __popcntd,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:214,Testability,log,logic,214,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param __A; /// An unsigned 64-bit integer operand.; /// \returns A 64-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see _popcnt64,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:292,Testability,log,logic,292,/// Counts the number of bits in the source operand having a value of 1.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// long long _popcnt64(unsigned long long A);; /// \endcode; ///; /// This intrinsic corresponds to the \c POPCNT instruction or a; /// a sequence of arithmetic and logic ops to calculate it.; ///; /// \param A; /// An unsigned 64-bit integer operand.; /// \returns A 64-bit integer containing the number of bits with value 1 in the; /// source operand.; /// \see __popcntq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:98,Usability,clear,cleared,98,/// Returns the program status and control \c RFLAGS register with the \c VM; /// and \c RF flags cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PUSHFQ + \c POP instruction sequence.; ///; /// \returns The 64-bit value of the RFLAGS register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:117,Usability,clear,cleared,117,/* !__x86_64__ */; /// Returns the program status and control \c EFLAGS register with the \c VM; /// and \c RF flags cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PUSHFD + \c POP instruction sequence.; ///; /// \returns The 32-bit value of the EFLAGS register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:276,Security,checksum,checksum,276,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:392,Security,checksum,checksum,392,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:467,Security,checksum,checksum,467,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:277,Security,checksum,checksum,277,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:394,Security,checksum,checksum,394,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:469,Security,checksum,checksum,469,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:286,Security,checksum,checksum,286,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:403,Security,checksum,checksum,403,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:478,Security,checksum,checksum,478,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,Security,checksum,checksum,53,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:286,Security,checksum,checksum,286,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:403,Security,checksum,checksum,403,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:478,Security,checksum,checksum,478,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:54,Energy Efficiency,monitor,monitoring,54,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:42,Performance,perform,performance,42,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:138,Performance,perform,performance,138,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:311,Performance,perform,performance,311,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:385,Performance,perform,performance,385,/* __x86_64__ */; /// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param __A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see _rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:36,Energy Efficiency,monitor,monitoring,36,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:24,Performance,perform,performance,24,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:120,Performance,perform,performance,120,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:360,Performance,perform,performance,360,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:434,Performance,perform,performance,434,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:43,Performance,load,load,43,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:263,Performance,Load,Load,263,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:473,Performance,load,load,473,/* The structs used below are to force the load/store to be unaligned. This; * is accomplished with the __packed__ attribute. The __may_alias__ prevents; * tbaa metadata from being generated based on the struct and the type of the; * field inside of it.; */; /// Load a 16-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 16-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Performance,Load,Load,4,/// Load a 32-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 32-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:214,Performance,load,load,214,/// Load a 32-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 32-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Performance,Load,Load,4,/// Load a 64-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 64-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:214,Performance,load,load,214,/// Load a 64-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 64-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:37,Availability,avail,available,37,/* Intrinsics inside adcintrin.h are available at all times. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange Add; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange Add; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Increment; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Increment; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Decrement; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Decrement; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked And; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked And; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:102,Testability,Test,Testing,102,/*----------------------------------------------------------------------------*\; |* Bit Counting and Testing; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Or; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Or; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Xor; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Xor; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Safety,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Security,Interlock,Interlocked,85,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:3,Performance,Load,Loads,3,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:142,Performance,load,loaded,142,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:216,Performance,load,loaded,216,"// Loads the contents of a 64-bit model specific register (MSR) specified in; // the ECX register into registers EDX:EAX. The EDX register is loaded with; // the high-order 32 bits of the MSR and the EAX register is loaded with the; // low-order 32 bits. If less than 64 bits are implemented in the MSR being; // read, the values returned to EDX:EAX in unimplemented bit locations are; // undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:124,Energy Efficiency,charge,charge,124,"/*===----------------- keylockerintrin.h - KL Intrinsics -------------------===; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1018,Integrability,CONTRACT,CONTRACT,1018,"/*===----------------- keylockerintrin.h - KL Intrinsics -------------------===; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in; * all copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; * THE SOFTWARE.; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:18,Integrability,wrap,wrapping,18,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Performance,Load,Load,4,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:215,Performance,load,loaded,215,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:321,Performance,load,loaded,321,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:471,Performance,LOAD,LOADIWKEY,471,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:547,Performance,LOAD,LOADKWKEY,547,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:627,Performance,LOAD,LOADIWKEY,627,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:2020,Performance,load,loaded,2020,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:197,Security,encrypt,encryption,197,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:299,Security,integrity,integrity,299,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1132,Security,Encrypt,Encryption,1132,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1187,Security,Encrypt,Encryption,1187,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1243,Security,Integrity,IntegrityKey,1243,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1534,Security,Encrypt,Encryption,1534,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1616,Security,Encrypt,Encryption,1616,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1702,Security,Encrypt,Encryption,1702,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:1802,Security,Integrity,IntegrityKey,1802,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Integrability,Wrap,Wrap,4,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:696,Security,Integrity,Integrity,696,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:724,Security,Encrypt,Encryption,724,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:929,Security,Integrity,Integrity,929,"/// Wrap a 128-bit AES key from __key into a key handle and output in; /// ((__m128i*)__h) to ((__m128i*)__h) + 2 and a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY128 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key[127:0]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 0 // KeyType is AES-128 (value of 0); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[383:0] := WrapKey128(InputKey[127:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Integrity Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Integrability,Wrap,Wrap,4,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:769,Security,Integrity,Integrity,769,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:797,Security,Encrypt,Encryption,797,"/// Wrap a 256-bit AES key from __key_hi:__key_lo into a key handle, then; /// output handle in ((__m128i*)__h) to ((__m128i*)__h) + 3 and; /// a 32-bit value as return.; /// The explicit source operand __htype specifies handle restrictions.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> ENCODEKEY256 </c> instructions.; ///; /// \code{.operation}; /// InputKey[127:0] := __key_lo[127:0]; /// InputKey[255:128] := __key_hi[255:128]; /// KeyMetadata[2:0] := __htype[2:0]; /// KeyMetadata[23:3] := 0 // Reserved for future usage; /// KeyMetadata[27:24] := 1 // KeyType is AES-256 (value of 1); /// KeyMetadata[127:28] := 0 // Reserved for future usage; /// Handle[511:0] := WrapKey256(InputKey[255:0], KeyMetadata[127:0],; /// IWKey.Integrity Key[127:0], IWKey.Encryption Key[255:0]); /// dst[0] := IWKey.NoBackup; /// dst[4:1] := IWKey.KeySource[3:0]; /// dst[31:5] := 0; /// MEM[__h+127:__h] := Handle[127:0] // AAD; /// MEM[__h+255:__h+128] := Handle[255:128] // Tag; /// MEM[__h+383:__h+256] := Handle[383:256] // CipherText[127:0]; /// MEM[__h+511:__h+384] := Handle[511:384] // CipherText[255:128]; /// OF := 0; /// SF := 0; /// ZF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:49,Security,encrypt,encrypt,49,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:49,Security,encrypt,encrypt,49,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESDEC128KL performs 10 rounds of AES to decrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := (HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES128Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:391,Performance,Load,Load,391,"/// The AESDEC128KL performs 10 rounds of AES to decrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := (HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES128Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,Performance,perform,performs,20,"/// The AESDEC256KL performs 10 rounds of AES to decrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h]; /// IllegalHandle := (HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Security,Encrypt,Encrypt,4,"/// Encrypt __idata[0] to __idata[7] using 128-bit AES key indicated by handle; /// at __h and store each resultant block back from __odata to __odata+7. And; /// return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENCWIDE128KL </c> instructions.; ///; /// \code{.operation}; /// Handle := MEM[__h+383:__h]; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF Authentic == 0; /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// FOR i := 0 to 7; /// __odata[i] := AES128Encrypt (__idata[i], UnwrappedKey); /// ENDFOR; /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Security,Encrypt,Encrypt,4,"/// Encrypt __idata[0] to __idata[7] using 256-bit AES key indicated by handle; /// at __h and store each resultant block back from __odata to __odata+7. And; /// return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENCWIDE256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h]; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES512 ); /// IF (IllegalHandle); /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF Authentic == 0; /// ZF := 1; /// FOR i := 0 to 7; /// __odata[i] := 0; /// ENDFOR; /// ELSE; /// FOR i := 0 to 7; /// __odata[i] := AES256Encrypt (__idata[i], UnwrappedKey); /// ENDFOR; /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:552,Integrability,Synchroniz,Synchronized,552,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:270,Modifiability,extend,extended,270,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:362,Modifiability,extend,extended,362,"/// Decrements the LWP programmed value sample event counter. If the result is; /// negative, inserts an event record into the LWP event ring buffer in memory; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPVAL </c> instruction.; ///; /// \param DATA2; /// A 32-bit value is zero-extended and inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h:534,Integrability,Synchroniz,Synchronized,534,"/// Inserts programmed event record into the LWP event ring buffer; /// and advances the ring buffer pointer.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LWPINS </c> instruction.; ///; /// \param DATA2; /// A 64-bit value is inserted into the 64-bit Data2 field.; /// \param DATA1; /// A 32-bit value is inserted into the 32-bit Data1 field.; /// \param FLAGS; /// A 32-bit immediate value is inserted into the 32-bit Flags field.; /// \returns If the ring buffer is full and LWP is running in Synchronized Mode,; /// the event record overwrites the last record in the buffer, the MissedEvents; /// counter in the LWPCB is incremented, the head pointer is not advanced, and; /// 1 is returned. Otherwise 0 is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/lwpintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/lwpintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Usability,Clear,Clears,4,/// Clears the MMX state by setting the state of the x87 stack registers; /// to empty.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> EMMS </c> instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:240,Usability,clear,cleared,240,"/// Right-shifts each 16-bit integer element of the first parameter,; /// which is a 64-bit integer vector of [4 x i16], by the number of bits; /// specified by the second parameter, which is a 64-bit integer.; ///; /// High-order bits are cleared. The 16-bit results are packed into a 64-bit; /// integer vector of [4 x i16].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLW </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [4 x i16].; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector of [4 x i16] containing the right-shifted; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:173,Usability,clear,cleared,173,/// Right-shifts each 16-bit integer element of a 64-bit integer vector; /// of [4 x i16] by the number of bits specified by a 32-bit integer.; ///; /// High-order bits are cleared. The 16-bit results are packed into a 64-bit; /// integer vector of [4 x i16].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLW </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [4 x i16].; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector of [4 x i16] containing the right-shifted; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:240,Usability,clear,cleared,240,"/// Right-shifts each 32-bit integer element of the first parameter,; /// which is a 64-bit integer vector of [2 x i32], by the number of bits; /// specified by the second parameter, which is a 64-bit integer.; ///; /// High-order bits are cleared. The 32-bit results are packed into a 64-bit; /// integer vector of [2 x i32].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLD </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [2 x i32].; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector of [2 x i32] containing the right-shifted; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:173,Usability,clear,cleared,173,/// Right-shifts each 32-bit integer element of a 64-bit integer vector; /// of [2 x i32] by the number of bits specified by a 32-bit integer.; ///; /// High-order bits are cleared. The 32-bit results are packed into a 64-bit; /// integer vector of [2 x i32].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLD </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector of [2 x i32].; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector of [2 x i32] containing the right-shifted; /// values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:159,Usability,clear,cleared,159,/// Right-shifts the first 64-bit integer parameter by the number of bits; /// specified by the second 64-bit integer parameter.; ///; /// High-order bits are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLQ </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \param __count; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \returns A 64-bit integer vector containing the right-shifted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:189,Usability,clear,cleared,189,"/// Right-shifts the first parameter, which is a 64-bit integer, by the; /// number of bits specified by the second parameter, which is a 32-bit; /// integer.; ///; /// High-order bits are cleared.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PSRLQ </c> instruction.; ///; /// \param __m; /// A 64-bit integer vector interpreted as a single 64-bit integer.; /// \param __count; /// A 32-bit integer value.; /// \returns A 64-bit integer vector containing the right-shifted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise AND of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PAND </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,"/// Performs a bitwise NOT of the first 64-bit integer vector, and then; /// performs a bitwise AND of the intermediate result and the second 64-bit; /// integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PANDN </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector. The one's complement of this parameter is used; /// in the bitwise AND.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of the second; /// parameter and the one's complement of the first parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:77,Performance,perform,performs,77,"/// Performs a bitwise NOT of the first 64-bit integer vector, and then; /// performs a bitwise AND of the intermediate result and the second 64-bit; /// integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PANDN </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector. The one's complement of this parameter is used; /// in the bitwise AND.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of the second; /// parameter and the one's complement of the first parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> POR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise OR of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Performance,Perform,Performs,4,/// Performs a bitwise exclusive OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PXOR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise exclusive OR of both; /// parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h:196,Performance,load,load,196,"/* __x86_64__ */; /*; * movdir64b - Move 64 bytes as direct store.; * The destination must be 64 byte aligned, and the store is atomic.; * The source address has no alignment requirement, and the load from; * the source address is not atomic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/movdirintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/movdirintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:27,Energy Efficiency,MONITOR,MONITORX,27,"/*===---- mwaitxintrin.h - MONITORX/MWAITX intrinsics ----------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:52,Energy Efficiency,monitor,monitored,52,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:97,Energy Efficiency,monitor,monitor,97,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:150,Energy Efficiency,monitor,monitored,150,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:305,Energy Efficiency,MONITOR,MONITORX,305,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:376,Energy Efficiency,monitor,monitored,376,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:516,Energy Efficiency,monitor,monitoring,516,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:582,Energy Efficiency,monitor,monitoring,582,/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITORX instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:21,Energy Efficiency,MONITOR,MONITORX,21,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:85,Energy Efficiency,monitor,monitor,85,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:133,Energy Efficiency,monitor,monitored,133,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:394,Energy Efficiency,monitor,monitoring,394,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h:494,Energy Efficiency,monitor,monitoring,494,"/// Used with the \c MONITORX instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAITX instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mwaitxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:93,Availability,error,error,93,/**; * A positive float constant expression. HUGE_VALF evaluates; * to +infinity. Used as an error value returned by the built-in; * math functions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:93,Availability,error,error,93,/**; * A positive double constant expression. HUGE_VAL evaluates; * to +infinity. Used as an error value returned by the built-in; * math functions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:53,Integrability,Synchroniz,Synchronization,53,"// OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; // Flag type and values for barrier, mem_fence, read_mem_fence, write_mem_fence",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to local memory; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct; * ordering of memory operations to global memory; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:74,Testability,test,test,74,"/**; * Subgroups have different requirements on forward progress, so just test; * all the relevant macros.; * CL 3.0 sub-groups ""they are not guaranteed to make independent forward progress""; * KHR subgroups ""Subgroups within a workgroup are independent, make forward progress with respect to each other""; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:7,Performance,Queue,Queue,7,/**; * Queue a memory fence to ensure correct ordering of memory; * operations between work-items of a work-group to; * image memory.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:3,Performance,Optimiz,Optimizations,3,// Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:36,Availability,error,error,36,//cl_khr_fp16; /**; * Complementary error function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Availability,Error,Error,22,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:52,Deployability,integrat,integrating,52,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:52,Integrability,integrat,integrating,52,//cl_khr_fp16; /**; * Error function encountered in integrating the; * normal distribution.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:45,Energy Efficiency,power,power,45,//cl_khr_fp16; /**; * Multiply x by 2 to the power n.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Log,Log,22,//cl_khr_fp16; /**; * Log gamma function. Returns the natural; * logarithm of the absolute value of the gamma; * function. The sign of the gamma function is; * returned in the signp argument of lgamma_r.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:65,Testability,log,logarithm,65,//cl_khr_fp16; /**; * Log gamma function. Returns the natural; * logarithm of the absolute value of the gamma; * function. The sign of the gamma function is; * returned in the signp argument of lgamma_r.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:75,Testability,log,logarithm,75,//defined(__opencl_c_named_address_space_builtins); /**; * Compute natural logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Testability,log,logarithm,39,//cl_khr_fp16; /**; * Compute a base 2 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:40,Testability,log,logarithm,40,//cl_khr_fp16; /**; * Compute a base 10 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Testability,log,logarithm,39,//cl_khr_fp16; /**; * Compute a base e logarithm of (1.0 + x).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:82,Testability,log,logr,82,"//cl_khr_fp16; /**; * Compute the exponent of x, which is the integral; * part of logr | x |.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,//cl_khr_fp16; /**; * Compute x to the power y.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,"//cl_khr_fp16; /**; * Compute x to the power y, where y is an integer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,"//cl_khr_fp16; /**; * Compute x to the power y, where x is >= 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:39,Energy Efficiency,power,power,39,//cl_khr_fp16; /**; * Compute x to the power 1/y.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:23,Testability,log,logarithm,23,/**; * Compute natural logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Testability,log,logarithm,24,/**; * Compute a base 2 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:25,Testability,log,logarithm,25,/**; * Compute a base 10 logarithm.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Energy Efficiency,power,power,24,"/**; * Compute x to the power y, where x is >= 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:75,Availability,error,error,75,/**; * Compute cosine over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:74,Availability,error,error,74,/**; * Compute x / y over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:97,Availability,error,error,97,/**; * Compute the base- e exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:97,Availability,error,error,97,/**; * Compute the base- 2 exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:98,Availability,error,error,98,/**; * Compute the base- 10 exponential of x over an; * implementation-defined range. The maximum error is; * implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:85,Availability,error,error,85,/**; * Compute natural logarithm over an implementationdefined; * range. The maximum error is implementation; * defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:23,Testability,log,logarithm,23,/**; * Compute natural logarithm over an implementationdefined; * range. The maximum error is implementation; * defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:86,Availability,error,error,86,/**; * Compute a base 2 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Testability,log,logarithm,24,/**; * Compute a base 2 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:87,Availability,error,error,87,/**; * Compute a base 10 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:25,Testability,log,logarithm,25,/**; * Compute a base 10 logarithm over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:114,Availability,error,error,114,"/**; * Compute x to the power y, where x is >= 0. The range of; * x and y are implementation-defined. The maximum error; * is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:24,Energy Efficiency,power,power,24,"/**; * Compute x to the power y, where x is >= 0. The range of; * x and y are implementation-defined. The maximum error; * is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:79,Availability,error,error,79,/**; * Compute reciprocal over an implementation-defined; * range. The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:87,Availability,error,error,87,/**; * Compute inverse square root over an implementationdefined; * range. The maximum error is implementationdefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:73,Availability,error,error,73,/**; * Compute sine over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:80,Availability,error,error,80,/**; * Compute square root over an implementation-defined; * range. The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:76,Availability,error,error,76,/**; * Compute tangent over an implementation-defined range.; * The maximum error is implementation-defined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:275,Performance,perform,performed,275,// defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_1_2); /**; * Multiply two 24-bit integer values x and y and add; * the 32-bit integer result to the 32-bit integer z.; * Refer to definition of mul24 to see how the 24-bit; * integer multiplication is performed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:122,Performance,perform,perform,122,"/**; * Multiply two 24-bit integer values x and y. x and y; * are 32-bit integers but only the low 24-bits are used; * to perform the multiplication. mul24 should only; * be used when values in x and y are in the range [-; * 2^23, 2^23-1] if x and y are signed integers and in the; * range [0, 2^24-1] if x and y are unsigned integers. If; * x and y are not in this range, the multiplication; * result is implementation-defined.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:77,Performance,perform,performs,77,"//cl_khr_fp16; /**; * Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and; * performs smooth Hermite interpolation between 0; * and 1when edge0 < x < edge1. This is useful in; * cases where you would want a threshold function; * with a smooth transition.; * This is equivalent to:; * gentype t;; * t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);; * return t * t * (3 - 2 * t);; * Results are undefined if edge0 >= edge1 or if x,; * edge0 or edge1 is a NaN.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:190,Availability,error,error,190,"/**; * Returns a vector in the same direction as p but with a; * length of 1. fast_normalize is computed as:; * p * half_rsqrt (p.x^2 + p.y^2 + ... ); * The result shall be within 8192 ulps error from the; * infinitely precise result of; * if (all(p == 0.0f)); * result = p;; * else; * result = p / sqrt (p.x^2 + p.y^2 + ...);; * with the following exceptions:; * 1) If the sum of squares is greater than FLT_MAX; * then the value of the floating-point values in the; * result vector are undefined.; * 2) If the sum of squares is less than FLT_MIN then; * the implementation may return back p.; * 3) If the device is in ""denorms are flushed to zero""; * mode, individual operand elements with magnitude; * less than sqrt(FLT_MIN) may be flushed to zero; * before proceeding with the calculation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for finite value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for infinity value (+ve or -ve) .; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for a NaN.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for a normal value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,"//cl_khr_fp16; /**; * Test if arguments are ordered. isordered() takes; * arguments x and y, and returns the result; * isequal(x, x) && isequal(y, y).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,"//cl_khr_fp16; /**; * Test if arguments are unordered. isunordered(); * takes arguments x and y, returning non-zero if x or y; * is NaN, and zero otherwise.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Testability,Test,Test,22,//cl_khr_fp16; /**; * Test for sign bit. The scalar version of the function; * returns a 1 if the sign bit in the float is set else returns; * 0. The vector version of the function returns the; * following for each component in floatn: a -1 if the; * sign bit in the float is set else returns 0.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:80,Performance,Load,Load,80,"//cl_khr_fp16; // OpenCL v1.1 s6.11.7, v1.2 s6.12.7, v2.0 s6.13.7 - Vector Data Load and Store Functions; // OpenCL extensions v1.1 s9.6.6, v1.2 s9.5.6, v2.0 s9.4.6 - Vector Data Load and Store Functions for Half Type; /**; * Use generic type gentype to indicate the built-in data types; * char, uchar, short, ushort, int, uint, long, ulong, float,; * double or half.; *; * vloadn return sizeof (gentypen) bytes of data read from address (p + (offset * n)).; *; * vstoren write sizeof (gentypen) bytes given by data to address (p + (offset * n)).; *; * The address computed as (p + (offset * n)) must be; * 8-bit aligned if gentype is char, uchar;; * 16-bit aligned if gentype is short, ushort, half;; * 32-bit aligned if gentype is int, uint, float;; * 64-bit aligned if gentype is long, ulong, double.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:179,Performance,Load,Load,179,"//cl_khr_fp16; // OpenCL v1.1 s6.11.7, v1.2 s6.12.7, v2.0 s6.13.7 - Vector Data Load and Store Functions; // OpenCL extensions v1.1 s9.6.6, v1.2 s9.5.6, v2.0 s9.4.6 - Vector Data Load and Store Functions for Half Type; /**; * Use generic type gentype to indicate the built-in data types; * char, uchar, short, ushort, int, uint, long, ulong, float,; * double or half.; *; * vloadn return sizeof (gentypen) bytes of data read from address (p + (offset * n)).; *; * vstoren write sizeof (gentypen) bytes given by data to address (p + (offset * n)).; *; * The address computed as (p + (offset * n)) must be; * 8-bit aligned if gentype is char, uchar;; * 16-bit aligned if gentype is short, ushort, half;; * 32-bit aligned if gentype is int, uint, float;; * 64-bit aligned if gentype is long, ulong, double.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1491,Deployability,update,updated,1491,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:105,Integrability,Synchroniz,Synchronization,105,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1104,Modifiability,variab,variables,1104,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:783,Performance,queue,queues,783,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1143,Performance,queue,queue,1143,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1287,Performance,queue,queue,1287,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:165,Performance,load,loads,165,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:236,Performance,load,loads,236,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:322,Performance,load,loads,322,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:47,Performance,load,loads,47,/**; * Read memory barrier that orders only; * loads.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1116,Integrability,synchroniz,synchronization,1116,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:322,Performance,Perform,Perform,322,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:418,Performance,perform,performed,418,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1092,Performance,perform,perform,1092,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1181,Performance,perform,performing,1181,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1002,Integrability,synchroniz,synchronization,1002,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Performance,Perform,Perform,22,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:297,Performance,perform,performed,297,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:978,Performance,perform,perform,978,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1067,Performance,perform,performing,1067,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:161,Deployability,release,released,161,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:191,Performance,perform,performed,191,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:72,Performance,cache,cache,72,/**; * Prefetch num_elements * sizeof(gentype); * bytes into the global cache. The prefetch; * instruction is applied to a work-item in a workgroup; * and does not affect the functional; * behavior of the kernel.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:438,Availability,mask,mask,438,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:479,Availability,mask,mask,479,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:606,Availability,mask,mask,606,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:709,Availability,mask,mask,709,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:759,Availability,mask,mask,759,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:995,Availability,mask,mask,995,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1160,Availability,mask,mask,1160,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1229,Availability,mask,mask,1229,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1268,Availability,mask,mask,1268,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1356,Availability,mask,mask,1356,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1418,Availability,mask,mask,1418,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1468,Availability,mask,mask,1468,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1520,Availability,mask,mask,1520,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:1571,Availability,mask,mask,1571,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.12, v1.2 s6.12.12, v2.0 s6.13.12 - Miscellaneous Vector Functions; /**; * The shuffle and shuffle2 built-in functions construct; * a permutation of elements from one or two input; * vectors respectively that are of the same type,; * returning a vector with the same element type as the; * input and length that is the same as the shuffle mask.; * The size of each element in the mask must match the; * size of each element in the result. For shuffle, only; * the ilogb(2m-1) least significant bits of each mask; * element are considered. For shuffle2, only the; * ilogb(2m-1)+1 least significant bits of each mask; * element are considered. Other bits in the mask shall; * be ignored.; * The elements of the input vectors are numbered from; * left to right across one or both of the vectors. For this; * purpose, the number of elements in a vector is given; * by vec_step(gentypem). The shuffle mask operand; * specifies, for each element of the result vector, which; * element of the one or two input vectors the result; * element gets.; * Examples:; * uint4 mask = (uint4)(3, 2,; * 1, 0);; * float4 a;; * float4 r = shuffle(a, mask);; * // r.s0123 = a.wzyx; * uint8 mask = (uint8)(0, 1, 2, 3,; * 4, 5, 6, 7);; * float4 a, b;; * float8 r = shuffle2(a, b, mask);; * // r.s0123 = a.xyzw; * // r.s4567 = b.xyzw; * uint4 mask;; * float8 a;; * float4 b;; * b = shuffle(a, mask);; * Examples that are not valid are:; * uint8 mask;; * short16 a;; * short8 b;; * b = shuffle(a, mask); <- not valid; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:26,Security,Access,Access,26,/**; * Sampler-less Image Access; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:26,Security,Access,Access,26,/**; * Sampler-less Image Access; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:140,Security,access,access,140,"//defined(__opencl_c_read_write_images); // Note: In OpenCL v1.0/1.1/1.2, image argument of image query builtin functions does not have; // access qualifier, which by default assume read_only access qualifier. Image query builtin; // functions with write_only image argument should also be declared.; /**; * Return the image width in pixels.; *; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:192,Security,access,access,192,"//defined(__opencl_c_read_write_images); // Note: In OpenCL v1.0/1.1/1.2, image argument of image query builtin functions does not have; // access qualifier, which by default assume read_only access qualifier. Image query builtin; // functions with write_only image argument should also be declared.; /**; * Return the image width in pixels.; *; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:3,Integrability,Wrap,Wrappers,3,// Wrappers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h:41,Deployability,configurat,configuration,41,"/*===---- pconfigintrin.h - X86 platform configuration ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h:41,Modifiability,config,configuration,41,"/*===---- pconfigintrin.h - X86 platform configuration ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pconfigintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:4,Performance,Load,Loads,4,"/// Loads data from an unaligned memory location to elements in a 128-bit; /// vector.; ///; /// If the address of the data is not 16-byte aligned, the instruction may; /// read two adjacent aligned blocks of memory to retrieve the requested; /// data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 128-bit integer vector containing integer values.; /// \returns A 128-bit vector containing the moved values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:52,Energy Efficiency,monitor,monitored,52,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:97,Energy Efficiency,monitor,monitor,97,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:150,Energy Efficiency,monitor,monitored,150,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:239,Energy Efficiency,MONITOR,MONITOR,239,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:445,Energy Efficiency,MONITOR,MONITOR,445,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:515,Energy Efficiency,monitor,monitored,515,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:655,Energy Efficiency,monitor,monitoring,655,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:721,Energy Efficiency,monitor,monitoring,721,"/// Establishes a linear address memory range to be monitored and puts; /// the processor in the monitor event pending state. Data stored in the; /// monitored address range causes the processor to exit the pending state.; ///; /// The \c MONITOR instruction can be used in kernel mode, and in other modes; /// if MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MONITOR instruction.; ///; /// \param __p; /// The memory range to be monitored. The size of the range is determined by; /// CPUID function 0000_0005h.; /// \param __extensions; /// Optional extensions for the monitoring state.; /// \param __hints; /// Optional hints for the monitoring state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:21,Energy Efficiency,MONITOR,MONITOR,21,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:84,Energy Efficiency,monitor,monitor,84,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:132,Energy Efficiency,monitor,monitored,132,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:530,Energy Efficiency,monitor,monitoring,530,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:630,Energy Efficiency,monitor,monitoring,630,"/// Used with the \c MONITOR instruction to wait while the processor is in; /// the monitor event pending state. Data stored in the monitored address; /// range, or an interrupt, causes the processor to exit the pending state.; ///; /// The \c MWAIT instruction can be used in kernel mode, and in other modes if; /// MSR <c> C001_0015h[MonMwaitUserEn] </c> is set.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c MWAIT instruction.; ///; /// \param __extensions; /// Optional extensions for the monitoring state, which can vary by; /// processor.; /// \param __hints; /// Optional hints for the monitoring state, which can vary by processor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:153,Integrability,depend,dependent,153,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Performance,Load,Loads,4,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:94,Performance,cache,cache,94,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:167,Integrability,depend,dependent,167,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Performance,Load,Loads,4,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:108,Performance,cache,cache,108,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Performance,Load,Loads,4,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:87,Performance,cache,cache,87,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:105,Performance,cache,cache-coherency,105,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:194,Performance,cache,cache,194,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:384,Integrability,depend,dependent,384,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Performance,Load,Loads,4,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:90,Performance,cache,cache,90,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:109,Performance,cache,cache-coherency,109,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:190,Performance,cache,cache,190,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:256,Performance,cache,cache,256,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:321,Performance,perform,performed,321,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically add a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] + __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically and a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] AND __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,Performance,perform,performance,233,"/// Atomically or a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] OR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically xor a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] XOR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically add a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] + __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically and a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] AND __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,Performance,perform,performance,233,"/// Atomically or a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] OR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,Performance,perform,performance,234,"/// Atomically xor a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] XOR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h:43,Deployability,configurat,configuration,43,"/*===---- sgxintrin.h - X86 SGX intrinsics configuration -------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sgxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h:43,Modifiability,config,configuration,43,"/*===---- sgxintrin.h - X86 SGX intrinsics configuration -------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sgxintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sgxintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:52,Energy Efficiency,schedul,scheduling,52,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:44,Integrability,message,message,44,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:163,Integrability,message,message,163,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,Performance,perform,performs,96,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:52,Energy Efficiency,schedul,scheduling,52,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:44,Integrability,message,message,44,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:157,Integrability,message,message,157,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,Performance,perform,performs,96,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:340,Deployability,update,updated,340,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:428,Deployability,update,updated,428,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:211,Integrability,message,message,211,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:433,Deployability,update,updated,433,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1412,Deployability,update,updated,1412,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:60,Integrability,message,message,60,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:231,Integrability,message,message,231,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1163,Integrability,message,message,1163,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:317,Modifiability,variab,variable,317,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1189,Modifiability,variab,variable,1189,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:401,Performance,perform,perform,401,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:667,Performance,perform,performs,667,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:618,Deployability,update,updated,618,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:163,Integrability,message,message,163,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:550,Integrability,message,message,550,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:31,Modifiability,variab,variable,31,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:63,Modifiability,variab,variables,63,"/// Calculates the SHA-1 state variable E from the SHA-1 state variables in; /// the 128-bit vector of [4 x i32] in \a __X, adds that to the next set of; /// four message elements in the 128-bit vector of [4 x i32] in \a __Y, and; /// returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1NEXTE instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing the current SHA-1 state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing the next four elements of the; /// message.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:79,Integrability,message,message,79,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:111,Integrability,message,message,111,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:398,Integrability,message,message,398,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:487,Integrability,message,message,487,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:553,Deployability,update,updated,553,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:68,Integrability,message,message,68,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:105,Integrability,message,message,105,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:478,Integrability,message,message,478,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:455,Deployability,update,updated,455,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:1135,Deployability,update,updated,1135,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:304,Integrability,message,message,304,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:615,Performance,perform,performs,615,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:568,Deployability,update,updated,568,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:81,Integrability,message,message,81,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:113,Integrability,message,message,113,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:402,Integrability,message,message,402,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:491,Integrability,message,message,491,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:557,Deployability,update,updated,557,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:70,Integrability,message,message,70,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:107,Integrability,message,message,107,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:482,Integrability,message,message,482,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Performance,Perform,Performs,4,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:49,Energy Efficiency,schedul,scheduling,49,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:41,Integrability,message,message,41,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:145,Integrability,message,message,145,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,Performance,perform,performs,91,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:49,Energy Efficiency,schedul,scheduling,49,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:41,Integrability,message,message,41,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:144,Integrability,message,message,144,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,Performance,perform,performs,91,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:525,Availability,mask,masks,525,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:330,Deployability,update,updated,330,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:295,Modifiability,variab,variables,295,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4key4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4key4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 1; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4rnds4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:47,Security,encrypt,encryption,47,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4rnds4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,Performance,perform,performs,19,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4rnds4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:47,Security,encrypt,encryption,47,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4rnds4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,Availability,down,down,11,/// Rounds down each element of the 128-bit vector of [4 x float] to an; /// an integer and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ps(__m128 X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float] values to be rounded down.; /// \returns A 128-bit vector of [4 x float] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:424,Availability,down,down,424,/// Rounds down each element of the 128-bit vector of [4 x float] to an; /// an integer and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ps(__m128 X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float] values to be rounded down.; /// \returns A 128-bit vector of [4 x float] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:11,Availability,down,down,11,/// Rounds down each element of the 128-bit vector of [2 x double] to an; /// integer and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_pd(__m128d X);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \returns A 128-bit vector of [2 x double] containing the rounded values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,down,down,172,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds down the lowest element of the second 128-bit vector; /// operand to an integer and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ss(__m128 X, __m128 Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:784,Availability,down,down,784,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds down the lowest element of the second 128-bit vector; /// operand to an integer and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_floor_ss(__m128 X, __m128 Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:163,Availability,down,down,163,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds down the lower element of the second 128-bit vector operand to an; /// integer and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_sd(__m128d X, __m128d Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:777,Availability,down,down,777,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds down the lower element of the second 128-bit vector operand to an; /// integer and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_floor_sd(__m128d X, __m128d Y);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded down to the nearest integer and copied to the corresponding bits; /// of the result.; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:938,Availability,Down,Downward,938,"/// Rounds each element of the 128-bit vector of [4 x float] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ps(__m128 X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:715,Deployability,update,updated,715,"/// Rounds each element of the 128-bit vector of [4 x float] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ps(__m128 X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPS / ROUNDPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1437,Availability,Down,Downward,1437,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds the lowest element of the second 128-bit vector; /// operand to an integer value according to the rounding control specified; /// by the third argument and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ss(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1214,Deployability,update,updated,1214,"/// Copies three upper elements of the first 128-bit vector operand to; /// the corresponding three upper elements of the 128-bit result vector of; /// [4 x float]. Rounds the lowest element of the second 128-bit vector; /// operand to an integer value according to the rounding control specified; /// by the third argument and copies it to the lowest element of the 128-bit; /// result vector of [4 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_round_ss(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSS / ROUNDSS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float]. The values stored in bits [127:32] are; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [4 x float]. The value stored in bits [31:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [4 x float] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:943,Availability,Down,Downward,943,"/// Rounds each element of the 128-bit vector of [2 x double] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_pd(__m128d X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:720,Deployability,update,updated,720,"/// Rounds each element of the 128-bit vector of [2 x double] to an; /// integer value according to the rounding control specified by the second; /// argument and returns the rounded values in a 128-bit vector of; /// [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_pd(__m128d X, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDPD / ROUNDPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the rounded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1430,Availability,Down,Downward,1430,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds the lower element of the second 128-bit vector operand to an; /// integer value according to the rounding control specified by the third; /// argument and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_sd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1207,Deployability,update,updated,1207,"/// Copies the upper element of the first 128-bit vector operand to the; /// corresponding upper element of the 128-bit result vector of [2 x double].; /// Rounds the lower element of the second 128-bit vector operand to an; /// integer value according to the rounding control specified by the third; /// argument and copies it to the lower element of the 128-bit result vector; /// of [2 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_round_sd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VROUNDSD / ROUNDSD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double]. The value stored in bits [127:64] is; /// copied to the corresponding bits of the result.; /// \param Y; /// A 128-bit vector of [2 x double]. The value stored in bits [63:0] is; /// rounded to the nearest integer using the specified rounding control and; /// copied to the corresponding bits of the result.; /// \param M; /// An integer value that specifies the rounding operation. \n; /// Bits [7:4] are reserved. \n; /// Bit [3] is a precision exception value: \n; /// 0: A normal PE exception is used \n; /// 1: The PE field is not updated \n; /// Bit [2] is the rounding control source: \n; /// 0: Use bits [1:0] of \a M \n; /// 1: Use the current MXCSR setting \n; /// Bits [1:0] contain the rounding control definition: \n; /// 00: Nearest \n; /// 01: Downward (toward negative infinity) \n; /// 10: Upward (toward positive infinity) \n; /// 11: Truncated; /// \returns A 128-bit vector of [2 x double] containing the copied and rounded; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:212,Availability,mask,mask,212,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:600,Availability,mask,mask,600,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:685,Availability,mask,mask,685,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:750,Availability,mask,mask,750,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:878,Availability,mask,mask,878,"/* SSE4 Packed Blending Intrinsics. */; /// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_blend_pd(__m128d V1, __m128d V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPD / BLENDPD </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [2 x double].; /// \param V2; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand, with mask bits [1:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 64-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 64-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,Availability,mask,mask,171,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:554,Availability,mask,mask,554,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:639,Availability,mask,mask,639,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:704,Availability,mask,mask,704,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:832,Availability,mask,mask,832,"/// Returns a 128-bit vector of [4 x float] where the values are selected; /// from either the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_blend_ps(__m128 V1, __m128 V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VBLENDPS / BLENDPS </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x float].; /// \param V2; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand, with mask bits [3:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 32-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 32-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:470,Availability,mask,mask,470,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Availability,mask,mask,560,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:640,Availability,mask,mask,640,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:770,Availability,mask,mask,770,"/// Returns a 128-bit vector of [2 x double] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPD / BLENDVPD </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [2 x double].; /// \param __V2; /// A 128-bit vector of [2 x double].; /// \param __M; /// A 128-bit vector operand, with mask bits 127 and 63 specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 64-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 64-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [2 x double] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:171,Availability,mask,mask,171,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:467,Availability,mask,mask,467,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:566,Availability,mask,mask,566,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:646,Availability,mask,mask,646,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:776,Availability,mask,mask,776,"/// Returns a 128-bit vector of [4 x float] where the values are; /// selected from either the first or second operand as specified by the; /// third operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBLENDVPS / BLENDVPS </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [4 x float].; /// \param __V2; /// A 128-bit vector of [4 x float].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 95, 63, and 31 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 32-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 32-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [4 x float] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:464,Availability,mask,mask,464,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:561,Availability,mask,mask,561,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:641,Availability,mask,mask,641,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:770,Availability,mask,mask,770,"/// Returns a 128-bit vector of [16 x i8] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPBLENDVB / PBLENDVB </c> instruction.; ///; /// \param __V1; /// A 128-bit vector of [16 x i8].; /// \param __V2; /// A 128-bit vector of [16 x i8].; /// \param __M; /// A 128-bit vector operand, with mask bits 127, 119, 111...7 specifying; /// how the values are to be copied. The position of the mask bit corresponds; /// to the most significant bit of a copied value. When a mask bit is 0, the; /// corresponding 8-bit element in operand \a __V1 is copied to the same; /// position in the result. When a mask bit is 1, the corresponding 8-bit; /// element in operand \a __V2 is copied to the same position in the result.; /// \returns A 128-bit vector of [16 x i8] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:172,Availability,mask,mask,172,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Availability,mask,mask,557,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:642,Availability,mask,mask,642,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:707,Availability,mask,mask,707,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:835,Availability,mask,mask,835,"/// Returns a 128-bit vector of [8 x i16] where the values are selected; /// from either of the first or second operand as specified by the third; /// operand, the control mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_blend_epi16(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPBLENDW / PBLENDW </c> instruction.; ///; /// \param V1; /// A 128-bit vector of [8 x i16].; /// \param V2; /// A 128-bit vector of [8 x i16].; /// \param M; /// An immediate integer operand, with mask bits [7:0] specifying how the; /// values are to be copied. The position of the mask bit corresponds to the; /// index of a copied value. When a mask bit is 0, the corresponding 16-bit; /// element in operand \a V1 is copied to the same position in the result.; /// When a mask bit is 1, the corresponding 16-bit element in operand \a V2; /// is copied to the same position in the result.; /// \returns A 128-bit vector of [8 x i16] containing the copied values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:727,Availability,Mask,Mask,727,"/* SSE4 Floating Point Dot Product Instructions. */; /// Computes the dot product of the two 128-bit vectors of [4 x float]; /// and returns it in the elements of the 128-bit result vector of; /// [4 x float].; ///; /// The immediate integer operand controls which input elements; /// will contribute to the dot product, and where the final results are; /// returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_dp_ps(__m128 X, __m128 Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VDPPS / DPPS </c> instruction.; ///; /// \param X; /// A 128-bit vector of [4 x float].; /// \param Y; /// A 128-bit vector of [4 x float].; /// \param M; /// An immediate integer operand. Mask bits [7:4] determine which elements; /// of the input vectors are used, with bit [4] corresponding to the lowest; /// element and bit [7] corresponding to the highest element of each [4 x; /// float] vector. If a bit is set, the corresponding elements from the two; /// input vectors are used as an input for dot product; otherwise that input; /// is treated as zero. Bits [3:0] determine which elements of the result; /// will receive a copy of the final dot product, with bit [0] corresponding; /// to the lowest element and bit [3] corresponding to the highest element of; /// each [4 x float] subvector. If a bit is set, the dot product is returned; /// in the corresponding element; otherwise that element is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the dot product.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:681,Availability,Mask,Mask,681,"/// Computes the dot product of the two 128-bit vectors of [2 x double]; /// and returns it in the elements of the 128-bit result vector of; /// [2 x double].; ///; /// The immediate integer operand controls which input; /// elements will contribute to the dot product, and where the final results; /// are returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128d _mm_dp_pd(__m128d X, __m128d Y, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VDPPD / DPPD </c> instruction.; ///; /// \param X; /// A 128-bit vector of [2 x double].; /// \param Y; /// A 128-bit vector of [2 x double].; /// \param M; /// An immediate integer operand. Mask bits [5:4] determine which elements; /// of the input vectors are used, with bit [4] corresponding to the lowest; /// element and bit [5] corresponding to the highest element of each of [2 x; /// double] vector. If a bit is set, the corresponding elements from the two; /// input vectors are used as an input for dot product; otherwise that input; /// is treated as zero. Bits [1:0] determine which elements of the result; /// will receive a copy of the final dot product, with bit [0] corresponding; /// to the lowest element and bit [1] corresponding to the highest element of; /// each [2 x double] vector. If a bit is set, the dot product is returned in; /// the corresponding element; otherwise that element is set to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:18,Performance,Load,Load,18,/* SSE4 Streaming Load Hint Instruction. */; /// Loads integer values from a 128-bit aligned memory location to a; /// 128-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQA / MOVNTDQA </c> instruction.; ///; /// \param __V; /// A pointer to a 128-bit aligned memory location that contains the integer; /// values.; /// \returns A 128-bit integer vector containing the data stored at the; /// specified memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:49,Performance,Load,Loads,49,/* SSE4 Streaming Load Hint Instruction. */; /// Loads integer values from a 128-bit aligned memory location to a; /// 128-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVNTDQA / MOVNTDQA </c> instruction.; ///; /// \param __V; /// A pointer to a 128-bit aligned memory location that contains the integer; /// values.; /// \returns A 128-bit integer vector containing the data stored at the; /// specified memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1182,Usability,clear,cleared,1182," X and inserts an element from the second; /// argument \a Y as selected by the third argument \a N. That result then; /// has elements zeroed out also as selected by the third argument \a N. The; /// resulting 128-bit vector of [4 x float] is then returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_insert_ps(__m128 X, __m128 Y, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTPS </c> instruction.; ///; /// \param X; /// A 128-bit vector source operand of [4 x float]. With the exception of; /// those bits in the result copied from parameter \a Y and zeroed by bits; /// [3:0] of \a N, all bits from this parameter are copied to the result.; /// \param Y; /// A 128-bit vector source operand of [4 x float]. One single-precision; /// floating-point element from this source, as determined by the immediate; /// parameter, is copied to the result.; /// \param N; /// Specifies which bits from operand \a Y will be copied, which bits in the; /// result they will be copied to, and which bits in the result will be; /// cleared. The following assignments are made: \n; /// Bits [7:6] specify the bits to copy from operand \a Y: \n; /// 00: Selects bits [31:0] from operand \a Y. \n; /// 01: Selects bits [63:32] from operand \a Y. \n; /// 10: Selects bits [95:64] from operand \a Y. \n; /// 11: Selects bits [127:96] from operand \a Y. \n; /// Bits [5:4] specify the bits in the result to which the selected bits; /// from operand \a Y are copied: \n; /// 00: Copies the selected bits from \a Y to result bits [31:0]. \n; /// 01: Copies the selected bits from \a Y to result bits [63:32]. \n; /// 10: Copies the selected bits from \a Y to result bits [95:64]. \n; /// 11: Copies the selected bits from \a Y to result bits [127:96]. \n; /// Bits[3:0]: If any of these bits are set, the corresponding result; /// element is cleared.; /// \returns A 128-bit vector of [4 x float] containing the copied; /// single-precision floating point ele",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1984,Usability,clear,cleared,1984," from the second; /// argument \a Y as selected by the third argument \a N. That result then; /// has elements zeroed out also as selected by the third argument \a N. The; /// resulting 128-bit vector of [4 x float] is then returned.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128 _mm_insert_ps(__m128 X, __m128 Y, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VINSERTPS </c> instruction.; ///; /// \param X; /// A 128-bit vector source operand of [4 x float]. With the exception of; /// those bits in the result copied from parameter \a Y and zeroed by bits; /// [3:0] of \a N, all bits from this parameter are copied to the result.; /// \param Y; /// A 128-bit vector source operand of [4 x float]. One single-precision; /// floating-point element from this source, as determined by the immediate; /// parameter, is copied to the result.; /// \param N; /// Specifies which bits from operand \a Y will be copied, which bits in the; /// result they will be copied to, and which bits in the result will be; /// cleared. The following assignments are made: \n; /// Bits [7:6] specify the bits to copy from operand \a Y: \n; /// 00: Selects bits [31:0] from operand \a Y. \n; /// 01: Selects bits [63:32] from operand \a Y. \n; /// 10: Selects bits [95:64] from operand \a Y. \n; /// 11: Selects bits [127:96] from operand \a Y. \n; /// Bits [5:4] specify the bits in the result to which the selected bits; /// from operand \a Y are copied: \n; /// 00: Copies the selected bits from \a Y to result bits [31:0]. \n; /// 01: Copies the selected bits from \a Y to result bits [63:32]. \n; /// 10: Copies the selected bits from \a Y to result bits [95:64]. \n; /// 11: Copies the selected bits from \a Y to result bits [127:96]. \n; /// Bits[3:0]: If any of these bits are set, the corresponding result; /// element is cleared.; /// \returns A 128-bit vector of [4 x float] containing the copied; /// single-precision floating point elements from the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:107,Modifiability,extend,extended,107,"/* __x86_64__ */; /* Extract int from packed integer array at index. This returns the element; * as a zero extended value, so it is unsigned.; */; /// Extracts an 8-bit element from the 128-bit integer vector of; /// [16 x i8], using the immediate value parameter \a N as a selector.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_extract_epi8(__m128i X, const int N);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPEXTRB / PEXTRB </c> instruction.; ///; /// \param X; /// A 128-bit integer vector.; /// \param N; /// An immediate value. Bits [3:0] specify which 8-bit vector element from; /// the argument \a X to extract and copy to the result. \n; /// 0000: Bits [7:0] of parameter \a X are extracted. \n; /// 0001: Bits [15:8] of the parameter \a X are extracted. \n; /// 0010: Bits [23:16] of the parameter \a X are extracted. \n; /// 0011: Bits [31:24] of the parameter \a X are extracted. \n; /// 0100: Bits [39:32] of the parameter \a X are extracted. \n; /// 0101: Bits [47:40] of the parameter \a X are extracted. \n; /// 0110: Bits [55:48] of the parameter \a X are extracted. \n; /// 0111: Bits [63:56] of the parameter \a X are extracted. \n; /// 1000: Bits [71:64] of the parameter \a X are extracted. \n; /// 1001: Bits [79:72] of the parameter \a X are extracted. \n; /// 1010: Bits [87:80] of the parameter \a X are extracted. \n; /// 1011: Bits [95:88] of the parameter \a X are extracted. \n; /// 1100: Bits [103:96] of the parameter \a X are extracted. \n; /// 1101: Bits [111:104] of the parameter \a X are extracted. \n; /// 1110: Bits [119:112] of the parameter \a X are extracted. \n; /// 1111: Bits [127:120] of the parameter \a X are extracted.; /// \returns An unsigned integer, whose lower 8 bits are selected from the; /// 128-bit integer vector parameter and the remaining bits are assigned; /// zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Testability,Test,Tests,52,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:327,Testability,test,tested,327,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:405,Testability,test,test,405,/* SSE4 128-bit Packed Integer Comparisons. */; /// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:278,Testability,test,tested,278,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:356,Testability,test,test,356,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are all ones; FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:300,Testability,test,tested,300,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:378,Testability,test,test,378,/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param __M; /// A 128-bit integer vector containing the bits to be tested.; /// \param __V; /// A 128-bit integer vector selecting which bits to test in operand \a __M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_ones(__m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param V; /// A 128-bit integer vector containing the bits to be tested.; /// \returns TRUE if the bits specified in the operand are all set to 1; FALSE; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:345,Testability,test,tested,345,/// Tests whether the specified bits in a 128-bit integer vector are all; /// ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_ones(__m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param V; /// A 128-bit integer vector containing the bits to be tested.; /// \returns TRUE if the bits specified in the operand are all set to 1; FALSE; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:384,Testability,test,tested,384,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:460,Testability,test,test,460,"/// Tests whether the specified bits in a 128-bit integer vector are; /// neither all zeros nor all ones.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_mix_ones_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are neither all zeros nor all ones;; /// FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:4,Testability,Test,Tests,4,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:358,Testability,test,tested,358,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:434,Testability,test,test,434,"/// Tests whether the specified bits in a 128-bit integer vector are all; /// zeros.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_test_all_zeros(__m128i M, __m128i V);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPTEST / PTEST </c> instruction.; ///; /// \param M; /// A 128-bit integer vector containing the bits to be tested.; /// \param V; /// A 128-bit integer vector selecting which bits to test in operand \a M.; /// \returns TRUE if the specified bits are all zeros; FALSE otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Modifiability,extend,extends,52,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:505,Modifiability,extend,extended,505,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:596,Modifiability,extend,extended,596,/* SSE4 Packed Integer Sign-Extension. */; /// Sign-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBW / PMOVSXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// sign-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:461,Modifiability,extend,extended,461,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:552,Modifiability,extend,extended,552,/// Sign-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBD / PMOVSXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Sign-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXBQ / PMOVSXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:24,Performance,perform,performs,24,"/* This function always performs a signed extension, but __v16qi is a char; which may be signed or unsigned, so use __v16qs. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Sign-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWD / PMOVSXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// sign-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Sign-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXWQ / PMOVSXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Sign-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVSXDQ / PMOVSXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// sign-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:52,Modifiability,extend,extends,52,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:505,Modifiability,extend,extended,505,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:596,Modifiability,extend,extended,596,/* SSE4 Packed Integer Zero-Extension. */; /// Zero-extends each of the lower eight 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 16-bit values and returns them in a; /// 128-bit vector of [8 x i16]. The upper eight elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBW / PMOVZXBW </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower eight 8-bit elements are; /// zero-extended to 16-bit values.; /// \returns A 128-bit vector of [8 x i16] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:461,Modifiability,extend,extended,461,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:552,Modifiability,extend,extended,552,/// Zero-extends each of the lower four 8-bit integer elements of a; /// 128-bit vector of [16 x i8] to 32-bit values and returns them in a; /// 128-bit vector of [4 x i32]. The upper twelve elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBD / PMOVZXBD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower four 8-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Zero-extends each of the lower two 8-bit integer elements of a; /// 128-bit integer vector of [16 x i8] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper fourteen elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXBQ / PMOVZXBQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [16 x i8]. The lower two 8-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:469,Modifiability,extend,extended,469,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:560,Modifiability,extend,extended,560,/// Zero-extends each of the lower four 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 32-bit values and returns them in; /// a 128-bit vector of [4 x i32]. The upper four elements of the input; /// vector are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWD / PMOVZXWD </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower four 16-bit elements are; /// zero-extended to 32-bit values.; /// \returns A 128-bit vector of [4 x i32] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Zero-extends each of the lower two 16-bit integer elements of a; /// 128-bit integer vector of [8 x i16] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper six elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXWQ / PMOVZXWQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [8 x i16]. The lower two 16-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:9,Modifiability,extend,extends,9,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:466,Modifiability,extend,extended,466,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:557,Modifiability,extend,extended,557,/// Zero-extends each of the lower two 32-bit integer elements of a; /// 128-bit integer vector of [4 x i32] to 64-bit values and returns them in; /// a 128-bit vector of [2 x i64]. The upper two elements of the input vector; /// are unused.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPMOVZXDQ / PMOVZXDQ </c> instruction.; ///; /// \param __V; /// A 128-bit vector of [4 x i32]. The lower two 32-bit elements are; /// zero-extended to 64-bit values.; /// \returns A 128-bit vector of [2 x i64] containing the zero-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:275,Availability,mask,mask,275,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1716,Availability,mask,mask,1716,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1798,Availability,mask,mask,1798,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1854,Availability,mask,mask,1854,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2275,Availability,mask,mask,2275,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1995,Modifiability,extend,extended,1995,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2064,Modifiability,extend,extended,2064,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:83,Performance,perform,perform,83,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:863,Performance,perform,perform,863,"/* SSE4.2 Packed Comparison Intrinsics. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extend",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1673,Performance,perform,perform,1673,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2151,Performance,perform,performed,2151,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1652,Availability,mask,mask,1652,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1734,Availability,mask,mask,1734,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1790,Availability,mask,mask,1790,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:802,Performance,perform,perform,802,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The i",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1609,Performance,perform,perform,1609,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:231,Availability,mask,mask,231,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1848,Availability,mask,mask,1848," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1930,Availability,mask,mask,1930," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1986,Availability,mask,mask,1986," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2410,Availability,mask,mask,2410," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2127,Modifiability,extend,extended,2127," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2196,Modifiability,extend,extended,2196," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:995,Performance,perform,perform,995,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1805,Performance,perform,perform,1805," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2283,Performance,perform,performed,2283," the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times). \n; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1828,Availability,mask,mask,1828,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1910,Availability,mask,mask,1910,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1966,Availability,mask,mask,1966,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestri(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:978,Performance,perform,perform,978,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestri(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index le",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1785,Performance,perform,perform,1785,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:252,Availability,mask,mask,252,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1720,Availability,mask,mask,1720," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1802,Availability,mask,mask,1802," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1858,Availability,mask,mask,1858," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1982,Availability,mask,mask,1982," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:101,Performance,perform,perform,101,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:908,Performance,perform,perform,908,"/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading. */; /// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1677,Performance,perform,perform,1677," immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistra(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum; otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,Availability,mask,mask,190,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1607,Availability,mask,mask,1607,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1689,Availability,mask,mask,1689,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1745,Availability,mask,mask,1745,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1866,Availability,mask,mask,1866,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:798,Performance,perform,perform,798,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1564,Performance,perform,perform,1564,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,Availability,mask,mask,204,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1582,Availability,mask,mask,1582,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1664,Availability,mask,mask,1664,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1720,Availability,mask,mask,1720,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1858,Availability,mask,mask,1858,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:773,Performance,perform,perform,773,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1539,Performance,perform,perform,1539,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,Availability,mask,mask,1643,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1725,Availability,mask,mask,1725,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1781,Availability,mask,mask,1781,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:831,Performance,perform,perform,831,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1600,Performance,perform,perform,1600,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1643,Availability,mask,mask,1643,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1725,Availability,mask,mask,1725,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1781,Availability,mask,mask,1781,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:831,Performance,perform,perform,831,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1600,Performance,perform,perform,1600,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:190,Availability,mask,mask,190,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1834,Availability,mask,mask,1834," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1916,Availability,mask,mask,1916," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1972,Availability,mask,mask,1972," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2093,Availability,mask,mask,2093," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1022,Performance,perform,perform,1022,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1791,Performance,perform,perform,1791," bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is zero and the length of the string in; /// \a B is the maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:196,Availability,mask,mask,196,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1792,Availability,mask,mask,1792,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1874,Availability,mask,mask,1874,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1930,Availability,mask,mask,1930,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2060,Availability,mask,mask,2060,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:980,Performance,perform,perform,980,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1749,Performance,perform,perform,1749,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:204,Availability,mask,mask,204,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1761,Availability,mask,mask,1761,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1843,Availability,mask,mask,1843,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1899,Availability,mask,mask,1899,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:2034,Availability,mask,mask,2034,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:949,Performance,perform,perform,949,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1718,Performance,perform,perform,1718,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1819,Availability,mask,mask,1819," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1901,Availability,mask,mask,1901," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1957,Availability,mask,mask,1957," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1007,Performance,perform,perform,1007,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1776,Performance,perform,perform,1776," and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1802,Availability,mask,mask,1802,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1884,Availability,mask,mask,1884,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1940,Availability,mask,mask,1940,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,Performance,perform,perform,39,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:990,Performance,perform,perform,990,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to t",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1759,Performance,perform,perform,1759,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:503,Integrability,interface,interfaces,503,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:640,Integrability,interface,interfaces,640,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:706,Integrability,interface,interfaces,706,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:863,Integrability,interface,interfaces,863,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:1280,Integrability,interface,interfaces,1280,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:21,Modifiability,Variab,Variable,21,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:585,Security,expose,expose,585,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h:1503,Usability,simpl,simple,1503,"/*===---- stdarg.h - Variable argument handling ----------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stdarg.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stdarg.h; * When SM.A builds, __STDARG_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stdarg.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stdarg modules, and SM.B's `export *`; * wouldn't export any stdarg interfaces as expected. However, since stdarg.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdarg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdarg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdatomic.h:273,Availability,error,error,273,"/* If we're hosted, fall back to the system's stdatomic.h. FreeBSD, for; * example, already has a Clang-compatible stdatomic.h header.; *; * Exclude the MSVC path as well as the MSVC header as of the 14.31.30818; * explicitly disallows `stdatomic.h` in the C mode via an `#error`. Fallback; * to the clang resource header until that is fully supported. The; * `stdatomic.h` header requires C++ 23 or newer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdatomic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdatomic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h:41,Performance,perform,performing,41,/* C23 7.20.1 Defines several macros for performing checked integer arithmetic*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdckdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h:438,Integrability,message,message,438,"// Both A and B shall be any integer type other than ""plain"" char, bool, a bit-; // precise integer type, or an enumerated type, and they need not be the same.; // R shall be a modifiable lvalue of any integer type other than ""plain"" char,; // bool, a bit-precise integer type, or an enumerated type. It shouldn't be; // short type, either. Otherwise, it may be unable to hold two the result of; // operating two 'int's.; // A diagnostic message will be produced if A or B are not suitable integer; // types, or if R is not a modifiable lvalue of a suitable integer type or R; // is short type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdckdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdckdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:503,Integrability,interface,interfaces,503,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:640,Integrability,interface,interfaces,640,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:706,Integrability,interface,interfaces,706,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:863,Integrability,interface,interfaces,863,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:1280,Integrability,interface,interfaces,1280,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:585,Security,expose,expose,585,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h:1503,Usability,simpl,simple,1503,"/*===---- stddef.h - Basic type definitions --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * This header is designed to be included multiple times. If any of the __need_; * macros are defined, then only that subset of interfaces are provided. This; * can be useful for POSIX headers that need to not expose all of stddef.h, but; * need to use some of its interfaces. Otherwise this header provides all of; * the expected interfaces.; *; * When clang modules are enabled, this header is a textual header. It ignores; * its header guard so that multiple submodules can export its interfaces.; * Take module SM with submodules A and B, whose headers both include stddef.h; * When SM.A builds, __STDDEF_H will be defined. When SM.B builds, the; * definition from SM.A will leak when building without local submodule; * visibility. stddef.h wouldn't include any of its implementation headers, and; * SM.B wouldn't import any of the stddef modules, and SM.B's `export *`; * wouldn't export any stddef interfaces as expected. However, since stddef.h; * ignores its header guard when building with modules, it all works as; * expected.; *; * When clang modules are not enabled, the header guards can function in the; * normal simple fashion.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stddef.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stddef.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h:79,Security,expose,exposes,79,"/* NB: The C standard requires that these be the same value, but the compiler; exposes separate internal width macros. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h:79,Security,expose,exposes,79,"/* NB: The C standard requires that these be the same value, but the compiler; exposes separate internal width macros. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/stdint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/stdint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:132,Safety,avoid,avoid,132,/*; * Allow additional definitions and implementation-defined values on Apple; * platforms. This is done after #include <math.h> to avoid depcycle conflicts; * between libcxx and darwin in C++ modules builds.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:3,Testability,log,log,3,// log,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:3,Testability,log,logb,3,// logb,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tgmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:87,Usability,clear,clears,87,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:512,Usability,Clear,Clear,512,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:802,Usability,clear,cleared,802,"/// Copies the 8-bit integers from a 128-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSHUFB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [6:4] Reserved. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 128-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:86,Usability,clear,clears,86,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:508,Usability,Clear,Clear,508,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:768,Usability,clear,cleared,768,"/// Copies the 8-bit integers from a 64-bit integer vector to the; /// destination or clears 8-bit values in the destination, as specified by; /// the second source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSHUFB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination:; /// Bit 7: \n; /// 1: Clear the corresponding byte in the destination. \n; /// 0: Copy the selected source byte to the corresponding byte in the; /// destination. \n; /// Bits [3:0] select the source byte to be copied.; /// \returns A 64-bit integer vector containing the copied or cleared values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,Performance,perform,perform,56,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:494,Usability,clear,clear,494,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:495,Usability,clear,clear,495,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the doubleword in the second source is; /// positive, copy the corresponding word from the first source to the; /// destination. If the doubleword in the second source is zero, clear the; /// corresponding word in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control doublewords corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:513,Usability,clear,clear,513,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the doubleword in the second source is; /// positive, copy the corresponding word from the first source to the; /// destination. If the doubleword in the second source is zero, clear the; /// corresponding word in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control doublewords corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,Performance,perform,perform,56,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:494,Usability,clear,clear,494,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNW instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:495,Usability,clear,clear,495,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNW instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,Performance,perform,perform,57,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding doubleword in the first source, and; /// write that value to the destination. If the doubleword in the second; /// source is positive, copy the corresponding doubleword from the first; /// source to the destination. If the doubleword in the second source is; /// zero, clear the corresponding doubleword in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGND instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing two control doublewords corresponding; /// to positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:530,Usability,clear,clear,530,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding doubleword in the first source, and; /// write that value to the destination. If the doubleword in the second; /// source is positive, copy the corresponding doubleword from the first; /// source to the destination. If the doubleword in the second source is; /// zero, clear the corresponding doubleword in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGND instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing two control doublewords corresponding; /// to positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:44,Performance,load,load,44,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:147,Performance,load,loads,147,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:243,Performance,load,load,243,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:298,Safety,abort,abort,298,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:42,Performance,load,load,42,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:120,Performance,load,load,120,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:203,Performance,load,load,203,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:367,Safety,abort,abort,367,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:446,Performance,load,loads,446,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:382,Safety,abort,abort,382,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:440,Safety,abort,abort,440,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:211,Testability,log,logical,211,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:4,Usability,Clear,Clears,4,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:441,Performance,load,loads,441,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:377,Safety,abort,abort,377,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:435,Safety,abort,abort,435,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:206,Testability,log,logical,206,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:181,Testability,log,logical,181,"/// Get the current value of the user interrupt flag (UIF). Can be executed; /// regardless of CPL and inside a transactional region. Can be executed only; /// if CR4.UINT = 1, the logical processor is in 64-bit mode, and software is; /// not executing inside an enclave; otherwise, it causes an invalid-opcode; /// exception.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> TESTUI </c> instruction.; ///; /// \returns The current value of the user interrupt flag (UIF).; ///; /// \code{.operation}; /// CF := UIF; /// ZF := 0; /// AF := 0; /// OF := 0; /// PF := 0; /// SF := 0; /// dst := CF; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:414,Testability,TEST,TESTUI,414,"/// Get the current value of the user interrupt flag (UIF). Can be executed; /// regardless of CPL and inside a transactional region. Can be executed only; /// if CR4.UINT = 1, the logical processor is in 64-bit mode, and software is; /// not executing inside an enclave; otherwise, it causes an invalid-opcode; /// exception.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> TESTUI </c> instruction.; ///; /// \returns The current value of the user interrupt flag (UIF).; ///; /// \code{.operation}; /// CF := UIF; /// ZF := 0; /// AF := 0; /// OF := 0; /// PF := 0; /// SF := 0; /// dst := CF; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:1005,Deployability,release,release,1005,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:1238,Deployability,release,release,1238,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:327,Performance,perform,performed,327,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:314,Security,access,accesses,314,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:105,Testability,log,logical,105,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:144,Integrability,depend,depend,144,"/* It is a bit strange for a header to play with the visibility of the; symbols it declares, but this matches gcc's behavior and some programs; depend on it */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:12,Performance,cache,cache,12,/* unwinder cache (private fields for the unwinder's use) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:15,Integrability,rout,routine,15,/* personality routine */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:23,Performance,cache,cache,23,/* propagation barrier cache (valid after phase 1) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:11,Performance,cache,cache,11,/* cleanup cache (preserved over cleanup) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:15,Performance,cache,cache,15,/* personality cache (for personality's benefit) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h:37,Availability,avail,available,37,/* DWARF EH functions; currently not available on Darwin/ARM */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/unwind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/unwind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/varargs.h:22,Modifiability,Variab,Variable,22,"/*===---- varargs.h - Variable argument handling -------------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/varargs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/varargs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/velintrin.h:10,Availability,mask,mask,10,// Vector mask registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/velintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/velintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:39,Modifiability,portab,portable,39,"/*===---- wasm_simd128.h - WebAssembly portable SIMD intrinsics ------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:21,Security,access,access,21,// UB-free unaligned access copied from xmmintrin.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:21,Security,access,access,21,// UB-free unaligned access copied from xmmintrin.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h:81,Modifiability,extend,extended,81,"// When in 64-bit target, the 32-bit operands generate a 32-bit result,; // zero-extended to a 64-bit result in the destination general-purpose,; // It means ""mov x %ebx"" will clobber the higher 32 bits of rbx, so we; // should preserve the 64-bit register rbx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/x86gprintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:143,Performance,Load,Loads,143,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:153,Performance,cache,cache,153,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:509,Performance,cache,cache,509,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h:683,Security,access,access,683,"/* FIXME: We have to #define this because ""sel"" must be a constant integer, and; Sema doesn't do any form of constant propagation yet. */; /// Loads one cache line of data from the specified address to a location; /// closer to the processor.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _mm_prefetch(const void *a, const int sel);; /// \endcode; ///; /// This intrinsic corresponds to the <c> PREFETCHNTA </c> instruction.; ///; /// \param a; /// A pointer to a memory location containing a cache line of data.; /// \param sel; /// A predefined integer constant specifying the type of prefetch; /// operation: \n; /// _MM_HINT_NTA: Move data using the non-temporal access (NTA) hint. The; /// PREFETCHNTA instruction will be generated. \n; /// _MM_HINT_T0: Move data using the T0 hint. The PREFETCHT0 instruction will; /// be generated. \n; /// _MM_HINT_T1: Move data using the T1 hint. The PREFETCHT1 instruction will; /// be generated. \n; /// _MM_HINT_T2: Move data using the T2 hint. The PREFETCHT2 instruction will; /// be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,Availability,mask,mask,129,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:219,Availability,mask,mask,219,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:288,Availability,mask,mask,288,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:493,Availability,mask,mask,493,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:729,Availability,mask,mask,729,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:107,Integrability,depend,depends,107,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Performance,Perform,Performs,4,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:129,Availability,mask,mask,129,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:219,Availability,mask,mask,219,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:288,Availability,mask,mask,288,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:493,Availability,mask,mask,493,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:731,Availability,mask,mask,731,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:107,Integrability,depend,depends,107,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Performance,Perform,Performs,4,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:46,Modifiability,variab,variables,46,"/*===---- cuda_builtin_vars.h - CUDA built-in variables ---------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:37,Modifiability,variab,variables,37,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:168,Modifiability,variab,variable,168,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:147,Security,access,accesses,147,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:56,Modifiability,variab,variable,56,"// Make sure nobody can create instances of the special variable types. nvcc; // also disallows taking address of special variables, so we disable address-of; // operator as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:122,Modifiability,variab,variables,122,"// Make sure nobody can create instances of the special variable types. nvcc; // also disallows taking address of special variables, so we disable address-of; // operator as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:257,Safety,avoid,avoid,257,"// For OpenMP we work around some old system headers that have non-conforming; // `isinf(float)` and `isnan(float)` implementations that return an `int`. We do; // this by providing two versions of these functions, differing only in the; // return type. To avoid conflicting definitions we disable implicit base; // function generation. That means we will end up with two specializations, one; // per type, but only one has a base function defined by the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:221,Safety,avoid,avoid,221,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:418,Safety,avoid,avoid,418,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:143,Availability,avail,available,143,"// For inscrutable reasons, __finite(), the double-precision version of; // __finitef, does not exist when compiling for MacOS. __isfinited is available; // everywhere and is just as good.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:121,Availability,avail,available,121,"// This header defines __muldc3, __mulsc3, __divdc3, and __divsc3. These are; // libgcc functions that clang assumes are available when compiling c99 complex; // operations. (These implementations come from libc++, and have been modified; // to work with CUDA and OpenMP target offloading [in C and C++ mode].)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:26,Availability,avail,available,26,// To make the algorithms available for C and C++ in CUDA and OpenMP we select; // different but equivalent function versions. TODO: For OpenMP we currently; // select the native builtins as the overload support for templates is lacking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h:65,Availability,avail,available,65,"// Rather than pulling in std::max from algorithm everytime, use available ::max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_complex_builtins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:70,Integrability,wrap,wrappers,70,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:214,Integrability,wrap,wrappers,214,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:137,Safety,avoid,avoid,137,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:194,Performance,optimiz,optimized,194,"// CUDA_VERSION >= 9020; // CUDA no longer provides inline assembly (or bitcode) implementation of these; // functions, so we have to reimplment them. The implementation is naive and is; // not optimized for performance.; // Helper function to convert N-bit boolean subfields into all-0 or all-1.; // E.g. __bool2mask(0x01000100,8) -> 0xff00ff00; // __bool2mask(0x00010000,16) -> 0xffff0000",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:208,Performance,perform,performance,208,"// CUDA_VERSION >= 9020; // CUDA no longer provides inline assembly (or bitcode) implementation of these; // functions, so we have to reimplment them. The implementation is naive and is; // not optimized for performance.; // Helper function to convert N-bit boolean subfields into all-0 or all-1.; // E.g. __bool2mask(0x01000100,8) -> 0xff00ff00; // __bool2mask(0x00010000,16) -> 0xffff0000",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:237,Availability,mask,mask,237,// Based on ITEM 23 in AIM-239: http://dspace.mit.edu/handle/1721.1/6086; // (a & b) + (a | b) = a + b = (a ^ b) + 2 * (a & b) =>; // (a + b) / 2 = ((a ^ b) >> 1) + (a & b); // To operate on multiple sub-elements we need to make sure to mask out bits; // that crossed over into adjacent elements during the shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:64,Integrability,wrap,wrappers,64,"/*===--- __clang_cuda_intrinsics.h - Device-side CUDA intrinsic wrappers ---===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:32,Availability,down,down,32,"// sm_30 intrinsics: __shfl_{up,down,xor}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:34,Availability,mask,mask,34,"// We use 0 rather than 31 as our mask, because shfl.up applies to lanes >=; // maxLane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:26,Availability,avail,available,26,// __shfl_sync_* variants available in CUDA-9,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:34,Availability,mask,mask,34,"// We use 0 rather than 31 as our mask, because shfl.up applies to lanes >=; // maxLane.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:80,Performance,load,load,80,"// We can assume that ptr is aligned at least to char2's alignment, but the; // load will assume that ptr is aligned to char2's alignment. This is only; // safe if alignof(c2) <= alignof(char2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:156,Safety,safe,safe,156,"// We can assume that ptr is aligned at least to char2's alignment, but the; // load will assume that ptr is aligned to char2's alignment. This is only; // safe if alignof(c2) <= alignof(char2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:275,Availability,avail,available,275,"// TODO: it appears to provide compiler with some sort of a hint. We do not; // know what exactly it is supposed to do. However, CUDA headers suggest that; // just passing through __ptr should not affect correctness. They do so on; // pre-sm80 GPUs where this builtin is not available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:70,Integrability,wrap,wrappers,70,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:214,Integrability,wrap,wrappers,214,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:137,Safety,avoid,avoid,137,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h:128,Integrability,depend,depends,128,// libdevice provides fast low precision and slow full-recision implementations; // for some functions. Which one gets selected depends on; // __CLANG_CUDA_APPROX_TRANSCENDENTALS__ which gets defined by clang if; // -ffast-math or -fgpu-approx-transcendentals are in effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:748,Deployability,pipeline,pipeline,748,"/*===---- __clang_cuda_runtime_wrapper.h - CUDA runtime support -------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * WARNING: This header is intended to be directly -include'd by; * the compiler and is not supposed to be included by users.; *; * CUDA headers are implemented in a way that currently makes it; * impossible for user code to #include directly when compiling with; * Clang. They present different view of CUDA-supplied functions; * depending on where in NVCC's compilation pipeline the headers are; * included. Neither of these modes provides function definitions with; * correct attributes, so we use preprocessor to force the headers; * into a form that Clang can use.; *; * Similarly to NVCC which -include's cuda_runtime.h, Clang -include's; * this file during every CUDA compilation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:707,Integrability,depend,depending,707,"/*===---- __clang_cuda_runtime_wrapper.h - CUDA runtime support -------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /*; * WARNING: This header is intended to be directly -include'd by; * the compiler and is not supposed to be included by users.; *; * CUDA headers are implemented in a way that currently makes it; * impossible for user code to #include directly when compiling with; * Clang. They present different view of CUDA-supplied functions; * depending on where in NVCC's compilation pipeline the headers are; * included. Neither of these modes provides function definitions with; * correct attributes, so we use preprocessor to force the headers; * into a form that Clang can use.; *; * Similarly to NVCC which -include's cuda_runtime.h, Clang -include's; * this file during every CUDA compilation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:89,Integrability,depend,depend,89,"// Define __CUDACC__ early as libstdc++ standard headers with GNU extensions; // enabled depend on it to avoid using __float128, which is unsupported in; // CUDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:105,Safety,avoid,avoid,105,"// Define __CUDACC__ early as libstdc++ standard headers with GNU extensions; // enabled depend on it to avoid using __float128, which is unsupported in; // CUDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:36,Safety,avoid,avoid,36,// Include some standard headers to avoid CUDA headers including them; // while some required macros (like __THROW) are in a weird state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:43,Availability,avail,available,43,// Make largest subset of device functions available during host; // compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:109,Modifiability,variab,variables,109,// No need for device_launch_parameters.h as __clang_cuda_builtin_vars.h above; // has taken care of builtin variables declared in the file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:55,Testability,stub,stubs,55,// Disables definitions of device-side runtime support stubs in; // cuda_device_runtime_api.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:175,Usability,simpl,simple,175,"// math_functions.hpp expects this host function be defined on MacOS, but it; // ends up not being there because of the games we play here. Just define it; // ourselves; it's simple enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:3,Integrability,Wrap,Wrappers,3,"// Wrappers for many device-side standard library functions, incl. math; // functions, became compiler builtins in CUDA-9 and have been removed from the; // CUDA headers. Clang now provides its own implementation of the wrappers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:220,Integrability,wrap,wrappers,220,"// Wrappers for many device-side standard library functions, incl. math; // functions, became compiler builtins in CUDA-9 and have been removed from the; // CUDA headers. Clang now provides its own implementation of the wrappers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:222,Safety,detect,detect,222,"// CUDA 8.0.41 relies on __USE_FAST_MATH__ and __CUDA_PREC_DIV's values.; // Previous versions used to check whether they are defined or not.; // CU_DEVICE_INVALID macro is only defined in 8.0.41, so we use it; // here to detect the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:45,Availability,avail,available,45,// Pull in host-only functions that are only available when neither; // __CUDACC__ nor __CUDABE__ are defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:196,Performance,optimiz,optimizer,196,"// Don't include sm_30_intrinsics.h and sm_32_intrinsics.h. These define the; // __shfl and __ldg intrinsics using inline (volatile) asm, but we want to; // define them using builtins so that the optimizer can reason about and across; // these instructions. In particular, using intrinsics for ldg gets us the; // [addr+imm] addressing mode, which, although it doesn't actually exist in the; // hardware, seems to generate faster machine code because ptxas can more easily; // reason about our code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:104,Integrability,wrap,wrapper,104,// CUDA-9 omits device-side definitions of some math functions if it sees; // include guard from math.h wrapper from libstdc++. We have to undo the header; // guard temporarily to get the definitions we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:139,Usability,undo,undo,139,// CUDA-9 omits device-side definitions of some math functions if it sees; // include guard from math.h wrapper from libstdc++. We have to undo the header; // guard temporarily to get the definitions we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:19,Usability,undo,undo,19,// We also need to undo another guard that checks for libc++ 3.8+,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:145,Integrability,depend,depend,145,// __clang_cuda_texture_intrinsics.h must be included first in order to provide; // implementation for __nv_tex_surf_handler that CUDA's headers depend on.; // The implementation requires c++11 and only works with CUDA-9 or newer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:170,Availability,error,error,170,"// Textures in CUDA-8 and older are not supported by clang.There's no; // convenient way to intercept texture use in these versions, so we can't; // produce a meaningful error. The source code that attempts to use textures; // will continue to fail as it does now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:87,Integrability,interoperab,interoperability,87,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:163,Integrability,wrap,wrappers,163,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:78,Usability,guid,guide-to-interoperability,78,// Device-side CUDA system calls.; // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#system-calls; // We need these declarations and wrappers for device-side; // malloc/free/printf calls to work without relying on; // -fcuda-disable-target-call-checks option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:139,Testability,assert,assert,139,// __assertfail() used to have a `noreturn` attribute. Unfortunately that; // contributed to triggering the longstanding bug in ptxas when assert was used; // in sufficiently convoluted code. See; // https://bugs.llvm.org/show_bug.cgi?id=27738 for the details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:25,Testability,assert,assert,25,// In order for standard assert() macro on linux to work we need to; // provide device-side __assert_fail(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:76,Deployability,configurat,configuration,76,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:76,Modifiability,config,configuration,76,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:51,Security,access,access,51,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:26,Usability,undo,undocumented,26,"// CUDA runtime uses this undocumented function to access kernel launch; // configuration. The declaration is in crt/device_functions.h but that file; // includes a lot of other stuff we don't want. Instead, we'll provide our own; // declaration for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:140,Safety,avoid,avoid,140,// Put all functions into anonymous namespace so they have internal linkage.; // The device-only function here must be internal in order to avoid ODR; // violations in case they are used from the files compiled with; // -fgpu-rdc. E.g. a library and an app using it may be built with a different; // version of this header file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:28,Security,hash,hash,28,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:270,Security,hash,hash,270,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:400,Security,hash,hashing,400,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:453,Security,hash,hash,453,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:646,Security,hash,hash,646,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:440,Testability,test,test,440,"// First, we need a perfect hash function and a few constexpr helper functions; // for converting a string literal into a numeric value which can be used to; // parametrize a template. We can not use string literals for that as that would; // require C++20.; //; // The hash function was generated with 'gperf' and then manually converted into; // its constexpr equivalent.; //; // NOTE: the perfect hashing scheme comes with inherent self-test. If the hash; // function has a collision for any of the texture operations, the compilation; // will fail due to an attempt to redefine a tag with the same value. If the; // header compiles, then the hash function is good enough for the job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:34,Availability,avail,available,34,"// Same, but for sparse ops. Only available on sm_60+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:101,Modifiability,inherit,inherit,101,"// CUDA headers have some 'legacy' texture oprerations that duplicate; // functionality. So, we just inherit it, instead of refining a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:285,Performance,optimiz,optimize,285,"// texture<> objects get magically converted into a texture reference. However,; // there's no way to convert them to cudaTextureObject_t on C++ level. So, we; // cheat a bit and use inline assembly to do it. It costs us an extra register; // and a move, but that is easy for ptxas to optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:48,Integrability,depend,dependent,48,"// The value returned by fpclassify is platform dependent, therefore it is not; // supported by hipRTC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:257,Safety,avoid,avoid,257,"// For OpenMP we work around some old system headers that have non-conforming; // `isinf(float)` and `isnan(float)` implementations that return an `int`. We do; // this by providing two versions of these functions, differing only in the; // return type. To avoid conflicting definitions we disable implicit base; // function generation. That means we will end up with two specializations, one; // per type, but only one has a base function defined by the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:221,Safety,avoid,avoid,221,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:418,Safety,avoid,avoid,418,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:20,Availability,avail,available,20,// decltype is only available in C++11 and above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:120,Availability,error,error,120,// namespace __hip; // __HIP_OVERLOAD1 is used to resolve function calls with integer argument to; // avoid compilation error due to ambibuity. e.g. floor(5) is resolved with; // floor(double).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:102,Safety,avoid,avoid,102,// namespace __hip; // __HIP_OVERLOAD1 is used to resolve function calls with integer argument to; // avoid compilation error due to ambibuity. e.g. floor(5) is resolved with; // floor(double).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:122,Availability,error,error,122,"// __HIP_OVERLOAD2 is used to resolve function calls with mixed float/double; // or integer argument to avoid compilation error due to ambibuity. e.g.; // max(5.0f, 6.0) is resolved with max(double, double).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:104,Safety,avoid,avoid,104,"// __HIP_OVERLOAD2 is used to resolve function calls with mixed float/double; // or integer argument to avoid compilation error due to ambibuity. e.g.; // max(5.0f, 6.0) is resolved with max(double, double).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h:43,Deployability,release,releases,43,"// Deprecated, should be removed when rocm releases using it are no longer; // relevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_libdevice_declares.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:133,Integrability,depend,depends,133,// Device library provides fast low precision and slow full-recision; // implementations for some functions. Which one gets selected depends on; // __CLANG_GPU_APPROX_TRANSCENDENTALS__ which gets defined by clang if; // -ffast-math or -fgpu-approx-transcendentals are in effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h:116,Testability,log,log,116,"// TODO: we could use Ahmes multiplication; // and the Miller & Brown algorithm; // for linear recurrences to get O(log n) steps, but it's unclear if; // it'd be beneficial in this case. Placeholder until OCML adds; // support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:35,Security,encrypt,encryption,35,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:592,Security,encrypt,encrypted,592,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:36,Security,encrypt,encryption,36,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:597,Security,encrypt,encrypted,597,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs a single round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDEC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Performance,Perform,Performs,4,"/// Performs the final round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDECLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:34,Security,encrypt,encryption,34,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:535,Security,encrypt,encryption,535,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:619,Security,encrypt,encryption,619,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:677,Security,encrypt,encryption,677,"/// Generates a round key for AES encryption, operating on 128-bit data; /// specified in the first source operand and using an 8-bit round constant; /// specified by the second source operand, and writes the result to the; /// destination.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_aeskeygenassist_si128(__m128i C, const int R);; /// \endcode; ///; /// This intrinsic corresponds to the <c> AESKEYGENASSIST </c> instruction.; ///; /// \param C; /// A 128-bit integer vector that is used to generate the AES encryption key.; /// \param R; /// An 8-bit round constant used to generate the AES encryption key.; /// \returns A 128-bit round key for AES encryption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:142,Availability,error,error,142,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:124,Safety,avoid,avoid,124,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h:142,Availability,error,error,142,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h:124,Safety,avoid,avoid,124,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/shared_ptr_base.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h:85,Testability,log,log,85,//===----------------------------------------------------------------------===//; // log builtins; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hlsl/hlsl_intrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard assert.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h:31,Testability,assert,assert,31,"//===-- Wrapper for C standard assert.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/assert.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard ctype.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,Availability,redundant,redundantly,58,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,Safety,redund,redundantly,58,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard inttypes.h declarations on the GPU ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/inttypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard stdio.h declarations on the GPU ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdio.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard stdlib.h declarations on the GPU -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/stdlib.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard string.h declarations on the GPU -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/string.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h:8,Integrability,Wrap,Wrapper,8,"//===-- Wrapper for C standard time.h declarations on the GPU -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/time.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h:35,Integrability,wrap,wrapper,35,"/*===-- complex --- OpenMP complex wrapper for target regions --------- c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h:437,Usability,simpl,simplified,437,"//===------------------------- __complex_cmath.h --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // std::complex header copied from the libcxx source and simplified for use in; // OpenMP target offload regions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h:3,Testability,log,log,3,// log,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/complex_cmath.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:790,Availability,error,errors,790,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:933,Integrability,depend,dependence,933,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:803,Safety,avoid,avoids,803,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h:38,Integrability,wrap,wrapper,38,"/*===---- time.h - OpenMP time header wrapper ------------------------ c ---===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/time.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- bmiintrin.h - Implementation of BMI2 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:24,Availability,mask,mask,24,/* The pop-count of the mask gives the number of the bits from; source to process. This is also needed to shift bits from the; source into the correct position for the result. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:49,Availability,mask,mask,49,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:73,Availability,mask,mask,73,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:58,Usability,clear,clearing,58,/* The loop is for the number of '1' bits in the mask and clearing; each mask bit as it is processed. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:10,Availability,mask,mask,10,/* if the mask is constant and selects 8 bits or less we can use; the Power8 Bit permute instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:20,Availability,mask,mask,20,"/* Also if the pext mask is constant, then the popcount is; constant, we can evaluate the following loop at compile; time and use a constant bit permute vector. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:188,Availability,mask,mask,188,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:119,Safety,avoid,avoids,119,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:215,Testability,test,test,215,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:175,Usability,clear,clearing,175,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:32,Integrability,depend,depend,32,/* these 32-bit implementations depend on 64-bit pdep/pext; which depend on _ARCH_PWR7. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:66,Integrability,depend,depend,66,/* these 32-bit implementations depend on 64-bit pdep/pext; which depend on _ARCH_PWR7. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- bmiintrin.h - Implementation of BMI intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmiintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:185,Energy Efficiency,Power,PowerPC,185,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:517,Energy Efficiency,POWER,POWER,517,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:600,Energy Efficiency,Power,PowerISA,600,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:777,Energy Efficiency,efficient,efficiently,777,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:658,Modifiability,portab,portable,658,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:761,Performance,perform,performed,761,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:830,Performance,optimiz,optimized,830,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:687,Security,access,access,687,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE2 intrinsics mainly handles __m128i and __m128d type,; PowerPC VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE2 scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE2 scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we do the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:26,Testability,log,logically,26,/* Pre-rotate __A left 3 (logically right 1) elements. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:82,Availability,mask,mask,82,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 2-bit mask from the most significant bits of the DPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 2-bit mask from the most significant bits of the DPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:108,Performance,load,load,108,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:101,Safety,avoid,avoid,101,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:75,Availability,mask,mask,75,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Return a mask created from the most significant bit of each 8-bit; element in A. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Return a mask created from the most significant bit of each 8-bit; element in A. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:367,Performance,perform,performed,367,"/* Note: vec_sum2s could be used here, but on little-endian, vector; shifts are added that are not needed for this use-case.; A vector shift to correctly position the 32-bit integer results; (currently at [0] and [2]) to [1] and [3] would then need to be; swapped back again since the desired results are two 64-bit; integers ([1]|[0] and [3]|[2]). Thus, no shift is performed. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block flush. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:29,Performance,load,load,29,/* Use light weight sync for load to load ordering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:37,Performance,load,load,37,/* Use light weight sync for load to load ordering. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h:62,Energy Efficiency,Power,PowerPC,62,"/*===---- immintrin.h - Implementation of Intel intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/immintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:123,Energy Efficiency,Power,PowerPC,123,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:377,Energy Efficiency,Power,PowerPC,377,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:473,Energy Efficiency,efficient,efficient,473,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:704,Energy Efficiency,efficient,efficient,704,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:690,Modifiability,portab,portable,690,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since PowerPC target doesn't support native 64-bit vector type, we; typedef __m64 to 64-bit unsigned long long in MMX intrinsics, which; works well for _si64 and some _pi32 operations. For _pi16 and _pi8 operations, it's better to transfer __m64 into; 128-bit PowerPC vector first. Power8 introduced direct register; move instructions which helps for more efficient implementation. It's user's responsibility to determine if the results of such port; are acceptable or further changes are needed. Please note that much; code using Intel intrinsics CAN BE REWRITTEN in more portable and; efficient standard C or GNU C extensions with 64-bit scalar; operations, or 128-bit SSE/Altivec operations, which are more; recommended. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:20,Energy Efficiency,Power,PowerPC,20,/* nothing to do on PowerPC. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h:20,Energy Efficiency,Power,PowerPC,20,/* nothing to do on PowerPC. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h:12,Integrability,depend,depend,12,/* We can't depend on <stdlib.h> since the prototype of posix_memalign; may not be visible. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/mm_malloc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- nmmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/nmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- pmmintrin.h - Implementation of SSE3 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- pmmintrin.h - Implementation of SSE3 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:463,Energy Efficiency,Power,PowerPC,463,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:884,Energy Efficiency,schedul,schedule,884,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:964,Energy Efficiency,monitor,monitor,964,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:1034,Energy Efficiency,Power,PowerISA,1034,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:927,Performance,latency,latency,927,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:909,Safety,avoid,avoid,909,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:61,Energy Efficiency,Power,PowerPC,61,"/*===---- smmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. NOTE: This is NOT a complete implementation of the SSE4 intrinsics! */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:451,Usability,Guid,Guide,451,"/*===---- smmintrin.h - Implementation of SSE4 intrinsics on PowerPC -------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. NOTE: This is NOT a complete implementation of the SSE4 intrinsics! */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:366,Modifiability,portab,portable,366,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:387,Performance,optimiz,optimized,387,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64/powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:108,Energy Efficiency,schedul,schedule,108,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:54,Modifiability,variab,variable,54,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:136,Modifiability,variab,variable,136,"/* Insert an artificial ""read/write"" reference to the variable; read below, to ensure the compiler does not schedule; a read/use of the variable before the FPSCR is modified, above.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:105,Energy Efficiency,schedul,schedule,105,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h:48,Modifiability,variab,variable,48,"/* Insert an artificial ""read"" reference to the variable written; above, to ensure the compiler does not schedule the computation; of the value after the manipulation of the FPSCR, below.; This can be removed if and when GCC PR102783 is fixed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/smmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:62,Energy Efficiency,Power,PowerPC,62,"/*===---- tmmintrin.h - Implementation of SSSE3 intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- tmmintrin.h - Implementation of SSSE3 intrinsics on PowerPC ------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:356,Modifiability,portab,portable,356,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:377,Performance,optimiz,optimized,377,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le. It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary. Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/tmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h:66,Energy Efficiency,Power,PowerPC,66,"/*===--- x86gprintrin.h - Implementation of X86 GPR intrinsics on PowerPC --===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86gprintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- x86intrin.h - Implementation of X86 intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:358,Modifiability,portab,portable,358,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:379,Performance,optimiz,optimized,379,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h:33,Usability,simpl,simplify,33,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/x86intrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:60,Energy Efficiency,Power,PowerPC,60,"/*===---- xmmintrin.h - Implementation of SSE intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:451,Usability,Guid,Guide,451,"/*===---- xmmintrin.h - Implementation of SSE intrinsics on PowerPC --------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; /* Implemented from the specification included in the Intel C++ Compiler; User Guide and Reference, version 9.0. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:170,Energy Efficiency,Power,PowerPC,170,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:502,Energy Efficiency,POWER,POWER,502,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:585,Energy Efficiency,Power,PowerISA,585,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:761,Energy Efficiency,efficient,efficiently,761,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:643,Modifiability,portab,portable,643,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:745,Performance,perform,performed,745,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:814,Performance,optimiz,optimized,814,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:672,Security,access,access,672,"/* This header file is to help porting code using Intel intrinsics; explicitly from x86_64 to powerpc64/powerpc64le. Since X86 SSE intrinsics mainly handles __m128 type, PowerPC; VMX/VSX ISA is a good match for vector float SIMD operations.; However scalar float operations in vector (XMM) registers require; the POWER8 VSX ISA (2.07) level. There are differences for data; format and placement of float scalars in the vector register, which; require extra steps to match SSE scalar float semantics on POWER. It should be noted that there's much difference between X86_64's; MXSCR and PowerISA's FPSCR/VSCR registers. It's recommended to use; portable <fenv.h> instead of access MXSCR directly. Most SSE scalar float intrinsic operations can be performed more; efficiently as C language float scalar operations or optimized to; use vector SIMD operations. We recommend this for new applications. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); results. So to insure we don't generate spurious exceptions; (from the upper double values) we splat the lower double; before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower double); * results. So to insure we don't generate spurious exceptions; * (from the upper double values) we splat the lower double; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower float); * results. So to insure we don't generate spurious exceptions; * (from the upper float values) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VSX does not allow partial (for just lower float); * results. So to insure we don't generate spurious exceptions; * (from the upper float values) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we to the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:3,Energy Efficiency,Power,PowerISA,3,/* PowerISA VMX does not allow partial (for just element 0); * results. So to insure we don't generate spurious exceptions; * (from the upper elements) we splat the lower float; * before we do the operation. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:11,Energy Efficiency,Power,PowerPC,11,/* Current PowerPC will ignores the hint parameters. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:82,Availability,mask,mask,82,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 4-bit mask from the most significant bits of the SPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:36,Energy Efficiency,Power,PowerISA,36,/* Intrinsic functions that require PowerISA 2.07 minimum. */; /* Creates a 4-bit mask from the most significant bits of the SPFP values. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:153,Usability,clear,cleared,153,/* Compute the sum of the absolute differences of the unsigned 8-bit; values in A and B. Return the value in the lower 16-bit word; the; upper words are cleared. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:63,Performance,cache,caches,63,/* Stores the data in A to the address P without polluting the caches. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:16,Performance,cache,cache,16,/* Use the data cache block touch for store transient. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:433,Deployability,release,release,433,"/* On power8 and later processors we can depend on Program Priority; (PRI) and associated ""very low"" PPI setting. Since we don't know; what PPI this thread is running at we: 1) save the current PRI; from the PPR SPR into a local GRP, 2) set the PRI to ""very low*; via the special or 31,31,31 encoding. 3) issue an ""isync"" to; insure the PRI change takes effect before we execute any more; instructions.; Now we can execute a lwsync (release barrier) while we execute; this thread at ""very low"" PRI. Finally we restore the original; PRI and continue execution. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:41,Integrability,depend,depend,41,"/* On power8 and later processors we can depend on Program Priority; (PRI) and associated ""very low"" PPI setting. Since we don't know; what PPI this thread is running at we: 1) save the current PRI; from the PPR SPR into a local GRP, 2) set the PRI to ""very low*; via the special or 31,31,31 encoding. 3) issue an ""isync"" to; insure the PRI change takes effect before we execute any more; instructions.; Now we can execute a lwsync (release barrier) while we execute; this thread at ""very low"" PRI. Finally we restore the original; PRI and continue execution. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h:89,Integrability,depend,depend,89,/* For older processor where we may not even have Program Priority; controls we can only depend on Heavy Weight Sync. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/xmmintrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp:4,Availability,avail,availability,4,// 'availability' attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/CommentToXML.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:21,Integrability,message,message,21,// Implicit property message sends are not 'implicit'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:84,Integrability,message,message,84,"// No need to do a handleReference for the objc method, because there will; // be a message expr as part of PseudoObjectExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:25,Integrability,depend,dependent,25,// FIXME: Try to resolve dependent field references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:207,Testability,test,tests,207,// Visit implicit @synthesize property implementations first as their; // location is reported at the name of the @implementation block. This; // serves no purpose other than to simplify the FileCheck-based tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:178,Usability,simpl,simplify,178,// Visit implicit @synthesize property implementations first as their; // location is reported at the name of the @implementation block. This; // serves no purpose other than to simplify the FileCheck-based tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:247,Integrability,interface,interface,247,"// For synthesized ivars, use the location of its name in the; // corresponding @synthesize. If there isn't one, use the containing; // @implementation's location, rather than the property's location,; // otherwise the header file containing the @interface will have different; // indexing contents based on whether the @implementation was present or; // not in the translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:39,Integrability,depend,dependent,39,"// FIXME: Ignore a class template in a dependent context, these are not; // linked properly with their redeclarations, ending up with duplicate; // USRs.; // See comment ""Friend templates are visible in fairly strange ways."" in; // SemaTemplate.cpp which precedes code that prevents the friend template; // from becoming visible from the enclosing context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp:55,Availability,avail,available,55,// Fallback to primary template if no instantiation is available yet (e.g.; // the type doesn't need to be complete).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexingContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp:124,Testability,test,test,124,"/// \returns true if \c D is in a subclass of 'XCTestCase', returns void, has; /// no parameters, and its name starts with 'test'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexSymbol.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:346,Modifiability,inherit,inherited,346,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:176,Safety,Avoid,Avoiding,176,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:84,Usability,clear,clear,84,"// The relations we have to `Parent` do not apply to our template arguments,; // so clear them while visiting the args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:27,Integrability,Rout,Routines,27,"//===- USRGeneration.cpp - Routines for USR generation --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:205,Availability,error,error,205,//===----------------------------------------------------------------------===//; // USR generation.; //===----------------------------------------------------------------------===//; /// \returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:38,Integrability,protocol,protocol,38,/// Generate a USR for an Objective-C protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:3,Modifiability,Variab,Variables,3,// Variables always have simple names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:25,Usability,simpl,simple,25,// Variables always have simple names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:162,Availability,avail,available,162,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:34,Integrability,interface,interface,34,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:146,Integrability,interface,interface,146,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:162,Availability,avail,available,162,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:34,Integrability,interface,interface,34,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:146,Integrability,interface,interface,146,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:104,Testability,log,logic,104,"// This method mangles in USR information for types. It can possibly; // just reuse the naming-mangling logic used by codegen, although the; // requirements for USRs might not be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:16,Integrability,depend,dependent,16,// FIXME: Visit dependent template names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:3,Usability,Simpl,Simple,3,// Simple name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:417,Performance,perform,performs,417,"//===------ CodeCompletion.cpp - Code Completion for ClangRepl -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the classes which performs code completion at the REPL.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:53,Integrability,interface,interfaces,53,"/// The class CompletionContextHandler contains four interfaces, each of; /// which handles one type of completion result.; /// Its derived classes are used to create concrete handlers based on; /// \c CodeCompletionContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:246,Modifiability,variab,variable,246,"// Load all external decls into current context. Under the hood, it calls; // ExternalSource::completeVisibleDeclsMap, which make all decls on the redecl; // chain visible.; //; // This is crucial to code completion on dot members, since a bound variable; // before ""."" would be otherwise treated out-of-scope.; //; // clang-repl> Foo f1;; // clang-repl> f1.<tab>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:3,Performance,Load,Load,3,"// Load all external decls into current context. Under the hood, it calls; // ExternalSource::completeVisibleDeclsMap, which make all decls on the redecl; // chain visible.; //; // This is crucial to code completion on dot members, since a bound variable; // before ""."" would be otherwise treated out-of-scope.; //; // clang-repl> Foo f1;; // clang-repl> f1.<tab>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:9,Availability,error,error,9,"// if an error happens, it usually means the decl has already been; // imported or the decl is a result of a failed import. But in our; // case, every import is fresh each time code completion is; // triggered. So Import usually doesn't fail. If it does, it just means; // the related decl can't be used in code completion and we can safely; // drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:334,Safety,safe,safely,334,"// if an error happens, it usually means the decl has already been; // imported or the decl is a result of a failed import. But in our; // case, every import is fresh each time code completion is; // triggered. So Import usually doesn't fail. If it does, it just means; // the related decl can't be used in code completion and we can safely; // drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:38,Deployability,release,release,38,"// we don't want the AU destructor to release the memory buffer that MB; // owns twice, because MB handles its resource on its own.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp:420,Performance,perform,performs,420,"//===--- IncrementalExecutor.cpp - Incremental Execution --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h:420,Performance,perform,performs,420,"//===--- IncrementalExecutor.h - Incremental Execution ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:419,Performance,perform,performs,419,"//===--------- IncrementalParser.cpp - Incremental Compilation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:390,Availability,alive,alive,390,/// A custom action enabling the incremental processing functionality.; ///; /// The usual \p FrontendAction expects one call to ExecuteAction and once it; /// sees a call to \p EndSourceFile it deletes some of the important objects; /// such as \p Preprocessor and \p Sema assuming no further input will come.; ///; /// \p IncrementalAction ensures it keep its underlying action's objects alive; /// as long as the \p IncrementalParser needs them.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:97,Availability,alive,alive,97,// Do not terminate after processing the input. This allows us to keep various; // clang objects alive and to incrementally grow the current TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:52,Availability,error,error,52,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:7,Integrability,Wrap,WrappedAction,7,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Performance,Load,LoadedID,2,/*LoadedID=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:2,Performance,Load,LoadedOffset,2,/*LoadedOffset=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:420,Performance,perform,performs,420,"//===--- IncrementalParser.h - Incremental Compilation ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:22,Performance,perform,performing,22,/// Compiler instance performing the incremental compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:103,Availability,alive,alive,103,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:56,Performance,cache,cached,56,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:40,Performance,cache,cache,40,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:50,Safety,avoid,avoids,50,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:424,Performance,perform,performs,424,"//===------ Interpreter.cpp - Incremental Compilation and Execution -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the component which performs incremental code; // compilation and execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:94,Testability,test,test,94,// FIXME: Figure out how to unify with namespace init_convenience from; // tools/clang-import-test/clang-import-test.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:112,Testability,test,test,112,// FIXME: Figure out how to unify with namespace init_convenience from; // tools/clang-import-test/clang-import-test.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:96,Availability,error,error,96,/// Retrieves the clang CC1 specific flags out of the compilation's jobs.; /// \returns NULL on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:40,Integrability,wrap,wrapped,40,// Register the support for object-file-wrapped Clang modules.; // FIXME: Clang should register these container operations automatically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:9,Usability,clear,clear,9,"// Don't clear the AST before backend codegen since we do codegen multiple; // times, reusing the same AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:55,Availability,avail,availability,55,// FIXME: This is a ugly hack. Undo command checks its availability by looking; // at the size of the PTU list. However we have parsed something in the; // beginning of the REPL so we have to mark them as 'Irrevocable'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:31,Usability,Undo,Undo,31,// FIXME: This is a ugly hack. Undo command checks its availability by looking; // at the size of the PTU list. However we have parsed something in the; // beginning of the REPL so we have to mark them as 'Irrevocable'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:3,Safety,avoid,avoid,3,// avoid writing fat binary to disk using an in-memory virtual file system,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:39,Energy Efficiency,reduce,reduce,39,// Force cast these types to uint64 to reduce the number of overloads of; // `__clang_Interpreter_SetValueNoAlloc`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:56,Deployability,canary,canary,56,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:141,Deployability,canary,canary,141,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:41,Security,validat,validating,41,"// Check whether the storage is valid by validating the canary bits.; // If someone accidentally write some invalid bits in the storage, the canary; // will be changed first, and `IsAlive` will return false then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp:18,Deployability,canary,canary,18,// These are some canary bits that are used for protecting the storage been; // damaged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Interpreter/Value.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Value.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:565,Availability,down,down,565,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:546,Energy Efficiency,reduce,reduces,546,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:7,Integrability,Depend,DependencyDirectivesScanner,7,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:408,Integrability,interface,interface,408,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:648,Testability,log,logic,648,"//===- DependencyDirectivesScanner.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the interface for scanning header and source files to get the; /// minimum necessary preprocessor directives for evaluating includes. It; /// reduces the source down to #define, #include, #import, @import, and any; /// conditional preprocessor logic that contains one of those.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:12,Energy Efficiency,efficient,efficient,12,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:47,Safety,detect,detect,47,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:86,Availability,error,error,86,/// Lex the provided source and emit the directive tokens.; ///; /// \returns True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:65,Performance,perform,performing,65,/// Returns the spelling of a string literal or identifier after performing; /// any processing needed to handle \c clang::Token::NeedsCleaning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:186,Usability,clear,cleared,186,"/// Keeps track of the tokens for the currently lexed directive. Once a; /// directive is fully lexed and ""committed"" then the tokens get appended to; /// \p Tokens and \p CurDirToks is cleared for the next directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:39,Modifiability,extend,extend,39,// String and character literals don't extend past the end of the line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:37,Safety,avoid,avoid,37,// Iterate over strings correctly to avoid comments and newlines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:66,Energy Efficiency,allocate,allocated,66,// Use a new scanner instance since the tokens will be inside the allocated; // string. We should already have captured all the relevant tokens in the; // current scanner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:4,Usability,Clear,Clear,4,"/// Clear Scanner's CurDirToks before returning, in case we didn't push a; /// new directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:130,Integrability,depend,dependency,130,"// A \p tok::hashhash at this location is passed by the preprocessor to the; // parser to interpret, like any other token. So for dependency scanning; // skip it like a normal token not affecting the preprocessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:13,Security,hash,hashhash,13,"// A \p tok::hashhash at this location is passed by the preprocessor to the; // parser to interpret, like any other token. So for dependency scanning; // skip it like a normal token not affecting the preprocessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:52,Testability,test,testing,52,// Add a space separator where it is convenient for testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:418,Integrability,interface,interface,418,"//===--- HeaderMap.cpp - A file that acts like dir of symlinks ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the HeaderMap interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:4,Security,Hash,HashHMapKey,4,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:43,Security,hash,hash,43,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:119,Security,hash,hash,119,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:135,Security,hash,hash,135,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:151,Usability,simpl,simple,151,"/// HashHMapKey - This is the 'well known' hash function required by the file; /// format, used to look up keys in the hash table. The hash table uses simple; /// linear probing based on this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:452,Availability,error,error,452,"//===----------------------------------------------------------------------===//; // Verification and Construction; //===----------------------------------------------------------------------===//; /// HeaderMap::Create - This attempts to load the specified file as a header; /// map. If it doesn't look like a HeaderMap, it gives up and returns null.; /// If it looks like a HeaderMap but is obviously corrupted, it puts a reason; /// into the string error argument and returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:239,Performance,load,load,239,"//===----------------------------------------------------------------------===//; // Verification and Construction; //===----------------------------------------------------------------------===//; /// HeaderMap::Create - This attempts to load the specified file as a header; /// map. If it doesn't look like a HeaderMap, it gives up and returns null.; /// If it looks like a HeaderMap but is obviously corrupted, it puts a reason; /// into the string error argument and returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:47,Energy Efficiency,power,power,47,"// Check the number of buckets. It should be a power of two, and there; // should be enough space in the file for all of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:37,Security,hash,hash,37,"/// getBucket - Return the specified hash table bucket from the header map,; /// bswap'ing its fields as appropriate. If the bucket number is not valid,; /// this return a bucket with an empty key (0).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:3,Performance,Load,Load,3,"// Load the values, bswapping as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:22,Security,hash,hash,22,// Linearly probe the hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:3,Security,Hash,Hash,3,"// Hash miss.; // See if the key matches. If not, probe on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:33,Security,hash,hash,33,"// If so, we have a match in the hash table. Construct the destination; // path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:441,Integrability,interface,interfaces,441,"//===- HeaderSearch.cpp - Resolve Header File Locations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DirectoryLookup and HeaderSearch interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:18,Usability,clear,clear,18,//LookupFileCache.clear();,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:42,Performance,load,load,42,"// The ModuleMap maybe a nullptr, when we load a cached C++ module without; // *.modulemap file. In this case, just return an empty string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:49,Performance,cache,cached,49,"// The ModuleMap maybe a nullptr, when we load a cached C++ module without; // *.modulemap file. In this case, just return an empty string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:197,Safety,avoid,avoid,197,"// The separator of C++20 modules partitions (':') is not good for file; // systems, here clang and gcc choose '-' by default since it is not a; // valid character of C++ indentifiers. So we could avoid conflicts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:130,Availability,failure,failure,130,// If we have the same ModuleCachePath and PrebuiltModulePath pointing; // to the same folder we should not cache the file lookup failure as it; // may be currently building an implicit module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:108,Performance,cache,cache,108,// If we have the same ModuleCachePath and PrebuiltModulePath pointing; // to the same folder we should not cache the file lookup failure as it; // may be currently building an implicit module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:29,Performance,cache,cache,29,"// If we don't have a module cache path or aren't supposed to use one, we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:170,Safety,safe,safe,170,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:297,Safety,avoid,avoid,297,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:36,Security,hash,hash,36,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:161,Security,hash,hash,161,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:430,Integrability,depend,dependencies,430,"// The facility for ""private modules"" -- adjacent, optional module maps named; // module.private.modulemap that are supposed to define private submodules --; // may have different flavors of names: FooPrivate, Foo_Private and Foo.Private.; //; // Foo.Private is now deprecated in favor of Foo_Private. Users of FooPrivate; // should also rename to Foo_Private. Representing private as submodules; // could force building unwanted dependencies into the parent module and cause; // dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:480,Integrability,depend,dependency,480,"// The facility for ""private modules"" -- adjacent, optional module maps named; // module.private.modulemap that are supposed to define private submodules --; // may have different flavors of names: FooPrivate, Foo_Private and Foo.Private.; //; // Foo.Private is now deprecated in favor of Foo_Private. Users of FooPrivate; // should also rename to Foo_Private. Representing private as submodules; // could force building unwanted dependencies into the parent module and cause; // dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:60,Availability,avail,available,60,"// Look through the various header search paths to load any available module; // maps, searching for a module map that describes this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:51,Performance,load,load,51,"// Look through the various header search paths to load any available module; // maps, searching for a module map that describes this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:69,Availability,avail,available,69,// We just loaded a module map file; check whether the module is; // available now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:11,Performance,load,loaded,11,// We just loaded a module map file; check whether the module is; // available now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:14,Performance,load,loaded,14,"// If we just loaded a module map file, look for the module again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:20,Performance,perform,performed,20,"// If we've already performed the exhaustive search for module maps in this; // search directory, don't do it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load all module maps in the immediate subdirectories of this search; // directory if ModuleName was from @import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:55,Performance,load,load,55,"// If we have a module map that might map this header, load it and; // check whether we'll have a suggestion for a module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:24,Availability,error,errors,24,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:77,Integrability,message,message,77,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:183,Testability,log,logic,183,// Header maps need to be marked as used whenever the filename matches.; // The case where the target file **exists** is handled by callee of this; // function as part of the regular logic that applies to include search paths.; // The case where the target file **does not exist** is handled here:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:470,Security,access,access,470,"// Note: as an egregious but useful hack we use the real path here, because; // frameworks moving between top-level frameworks to embedded frameworks tend; // to be symlinked, and we base the logical structure of modules on the; // physical layout. In particular, we need to deal with crazy includes like; //; // #include <Foo/Frameworks/Bar.framework/Headers/Wibble.h>; //; // where 'Bar' used to be embedded in 'Foo', is now a top-level framework; // which one should access with, e.g.,; //; // #include <Bar/Wibble.h>; //; // Similar issues occur when a top-level framework has moved into an; // embedded framework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:192,Testability,log,logical,192,"// Note: as an egregious but useful hack we use the real path here, because; // frameworks moving between top-level frameworks to embedded frameworks tend; // to be symlinked, and we base the logical structure of modules on the; // physical layout. In particular, we need to deal with crazy includes like; //; // #include <Foo/Frameworks/Bar.framework/Headers/Wibble.h>; //; // where 'Bar' used to be embedded in 'Foo', is now a top-level framework; // which one should access with, e.g.,; //; // #include <Bar/Wibble.h>; //; // Similar issues occur when a top-level framework has moved into an; // embedded framework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,cache,cache,10,"// If the cache entry was unresolved, populate it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Safety,Detect,Detect,3,"// Detect different types of framework style paths:; //; // ...Foo.framework/{Headers,PrivateHeaders}; // ...Foo.framework/Versions/{A,Current}/{Headers,PrivateHeaders}; // ...Foo.framework/Frameworks/Nested.framework/{Headers,PrivateHeaders}; // ...<other variations with 'Versions' like in the above path>; //; // and some other variations among these lines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:178,Integrability,depend,dependency,178,"// Headers in Foo.framework/Headers should not include headers; // from Foo.framework/PrivateHeaders, since this violates public/private; // API boundaries and can cause modular dependency cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:100,Availability,failure,failure,100,"/// LookupFile - Given a ""foo"" or \<foo> reference, look up the indicated file,; /// return null on failure. isAngled indicates whether the file reference is; /// for system \#include's or not (i.e. using <> instead of """"). Includers, if; /// non-empty, indicates where the \#including file(s) are, in case a relative; /// search is needed. Microsoft mode will pass all \#including files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:19,Performance,cache,cache,19,"// FIXME: We don't cache the result of getFileInfo across the call to; // getFileAndSuggestModule, because it's a reference to an element of; // a container that could be reallocated across this call.; //; // If we have no includer, that means we're processing a #include; // from a module build. We should treat this as a system header if we're; // building a [system] module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Cache,Cache,3,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:28,Performance,perform,performed,28,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:116,Performance,optimiz,optimization,116,"// Cache all of the lookups performed by this method. Many headers are; // multiply included, and the ""pragma once"" optimization prevents them from; // being relex/pp'd, but they would still have to search through a; // (potentially huge) series of SearchDirs to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:83,Safety,avoid,avoid,83,// Handle cold misses of user includes in the presence of many header; // maps. We avoid searching perhaps thousands of header maps by; // jumping directly to the correct one or jumping beyond all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Cache,Cache,3,// Cache subframework.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:401,Performance,cache,cached,401,"// Modules with builtins are special; multiple modules use builtins as; // modular headers, example:; //; // module stddef { header ""stddef.h"" export * }; //; // After module map parsing, this expands to:; //; // module stddef {; // header ""/path_to_builtin_dirs/stddef.h""; // textual ""stddef.h""; // }; //; // It's common that libc++ and system modules will both define such; // submodules. Make sure cached results for a builtin header won't; // prevent other builtin modules from potentially entering the builtin; // header. Note that builtins are header guarded and the decision to; // actually enter them is postponed to the controlling macros logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:648,Testability,log,logic,648,"// Modules with builtins are special; multiple modules use builtins as; // modular headers, example:; //; // module stddef { header ""stddef.h"" export * }; //; // After module map parsing, this expands to:; //; // module stddef {; // header ""/path_to_builtin_dirs/stddef.h""; // textual ""stddef.h""; // }; //; // It's common that libc++ and system modules will both define such; // submodules. Make sure cached results for a builtin header won't; // prevent other builtin modules from potentially entering the builtin; // header. Note that builtins are header guarded and the decision to; // actually enter them is postponed to the controlling macros logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:37,Integrability,wrap,wrapped,37,"// Next, check to see if the file is wrapped with #ifndef guards. If so, and; // if the macro that guards it is defined, we know the #include has no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load the module map file in this directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:54,Modifiability,inherit,inherit,54,// Success. All of the directories we stepped through inherit this module; // map file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:98,Integrability,depend,dependency,98,"// If this module specifies [no_undeclared_includes], we cannot find any; // file that's in a non-dependency module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,"// Load this framework module. If that succeeds, find the suggested module; // for this header, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:184,Availability,down,down,184,"// FIXME: This can find a module not part of ModuleName, which is; // important so that we're consistent about whether this header; // corresponds to a module. Possibly we should lock down framework modules; // so that this is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:15,Testability,assert,assert,15,// FIXME: This assert can fail if there's a race between the above check; // and the removal of the directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:31,Performance,load,loaded,31,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:80,Performance,load,loaded,80,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:117,Performance,load,load,117,"// Check whether we've already loaded this module map, and mark it as being; // loaded in case we recursively try to load it from itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a corresponding private module map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load module maps for each of the header search directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:50,Performance,load,load,50,"// Search each of the "".framework"" directories to load them as modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load this framework module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file for the search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load module map files for immediate subdirectories of this; // search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Performance,Load,Load,3,// Load module maps for each of the header search directories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:10,Performance,load,load,10,// Try to load a module map file for the search directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:138,Deployability,update,updates,138,"// Checks whether `Dir` is a strict path prefix of `File`. If so and that's; // the longest prefix we've seen so for it, returns true and updates the; // `BestPrefixLength` accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:64,Performance,perform,performing,64,"/// Add the specified path to the specified group list, without performing any; /// sysroot remapping.; /// Returns true if the path exists, false if it was ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:27,Modifiability,config,configure,27,// Add dirs specified via 'configure --with-c-include-dirs'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:48,Testability,log,logic,48,// NB: This code path is going away. All of the logic is moving into the; // driver which has the information necessary to do target-specific; // selections of default include paths. Each target which moves there will be; // exempted from this logic in ShouldAddDefaultIncludePaths() until we can; // delete the entire pile of code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:244,Testability,log,logic,244,// NB: This code path is going away. All of the logic is moving into the; // driver which has the information necessary to do target-specific; // selections of default include paths. Each target which moves there will be; // exempted from this logic in ShouldAddDefaultIncludePaths() until we can; // delete the entire pile of code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:39,Testability,log,logic,39,// NOTE: some additional header search logic is handled in the driver for; // Darwin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:182,Deployability,update,update,182,"/// If there are duplicate directory entries in the specified search list,; /// remove the later (dead) ones. Returns the number of non-system headers; /// removed, which is used to update NumAngled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:424,Integrability,interface,interfaces,424,"//===- Lexer.cpp - C Language Family Lexer --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Lexer and Token interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:255,Integrability,rout,routine,255,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:544,Integrability,wrap,wrapper,544,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:725,Integrability,interface,interface,725,"/// Create_PragmaLexer: Lexer constructor - Create a new lexer object for; /// _Pragma expansion. This has a variety of magic semantics that this method; /// sets up. It returns a new'd Lexer that must be delete'd when done.; ///; /// On entrance to this routine, TokStartLoc is a macro location which has a; /// spelling loc that indicates the bytes to be lexed for the token and an; /// expansion location that indicates where all lexed tokens should be; /// ""expanded from"".; ///; /// TODO: It would really be nice to make _Pragma just be a wrapper around a; /// normal lexer that remaps tokens as they fly by. This would require making; /// Preprocessor::Lex virtual. Given that, we could just dump in a magic lexer; /// interface that could handle this stuff. This would pull GetMappedTokenLoc; /// out of the critical path of the lexer!; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:14,Performance,load,load,14,// Try to the load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:163,Energy Efficiency,allocate,allocate,163,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The actual length of the token is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:538,Safety,avoid,avoiding,538,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The actual length of the token is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:41,Testability,test,testing,41,// NOTE: this has to be checked *before* testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:40,Testability,test,testing,40,// NOTE: this can be checked even after testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:81,Availability,failure,failure,81,"/// Relex the token at the specified location.; /// \returns true if there was a failure, false on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:47,Testability,log,logical,47,// LexStart should point at first character of logical line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:108,Availability,avail,available,108,"// Figure out which directive this is. Since we're lexing raw tokens,; // we don't have an identifier table available. Instead, just look at; // the raw identifier to recognize and categorize preprocessor directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,Usability,simpl,simple,141,"// The usual case is that tokens don't contain anything interesting. Skip; // over the uninteresting characters. If a token only consists of simple; // chars, this method is extremely fast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:109,Integrability,rout,routine,109,"/// Computes the source location just past the end of the; /// token at this source location.; ///; /// This routine can be used to produce a source location that; /// points just past the end of the token referenced by \p Loc, and; /// is generally used when a diagnostic needs to point just after a; /// token where it expected something different that it received. If; /// the returned source location would not be meaningful (e.g., if; /// it points into a macro), this routine returns an invalid; /// source location.; ///; /// \param Offset an offset from the end of the token, where the source; /// location should refer to. The default offset (0) produces a source; /// location pointing just past the end of the token; an offset of 1 produces; /// a source location pointing to the last character in the token, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:474,Integrability,rout,routine,474,"/// Computes the source location just past the end of the; /// token at this source location.; ///; /// This routine can be used to produce a source location that; /// points just past the end of the token referenced by \p Loc, and; /// is generally used when a diagnostic needs to point just after a; /// token where it expected something different that it received. If; /// the returned source location would not be meaningful (e.g., if; /// it points into a macro), this routine returns an invalid; /// source location.; ///; /// \param Offset an offset from the end of the token, where the source; /// location should refer to. The default offset (0) produces a source; /// location pointing just past the end of the token; an offset of 1 produces; /// a source location pointing to the last character in the token, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:14,Performance,load,load,14,// Try to the load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:332,Performance,perform,perform,332,"//===----------------------------------------------------------------------===//; // Diagnostics forwarding code.; //===----------------------------------------------------------------------===//; /// GetMappedTokenLoc - If lexing out of a 'mapped buffer', where we pretend the; /// lexer buffer was all expanded at a single point, perform the mapping.; /// This is currently only used for _Pragma implementation, so it is the slow; /// path of the hot getSourceLocation method. Do not allow it to be inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:48,Usability,simpl,simple,48,"// In the normal case, we're just lexing from a simple file buffer, return; // the file id from FileLoc with the offset specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:742,Deployability,update,updated,742,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:799,Deployability,update,updated,799,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:295,Integrability,depend,depending,295,"/// getCharAndSizeSlow - Peek a single 'character' from the specified buffer,; /// get its size, and return it. This is tricky in several cases:; /// 1. If currently at the start of a trigraph, we warn about the trigraph,; /// then either return the trigraph (skipping 3 chars) or the '?',; /// depending on whether trigraphs are enabled or not.; /// 2. If this is an escaped newline (potentially with whitespace between; /// the backslash and newline), implicitly skip the newline and return; /// the char after it.; ///; /// This handles the slow/uncommon case of the getCharAndSize method. Here we; /// know that we can accumulate into Size, and that we have already incremented; /// Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlowNoWarn (below) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:246,Deployability,update,updated,246,"/// getCharAndSizeSlowNoWarn - Handle the slow/uncommon case of the; /// getCharAndSizeNoWarn method. Here we know that we can accumulate into Size,; /// and that we have already incremented Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlow (above) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:297,Deployability,update,updated,297,"/// getCharAndSizeSlowNoWarn - Handle the slow/uncommon case of the; /// getCharAndSizeNoWarn method. Here we know that we can accumulate into Size,; /// and that we have already incremented Ptr by Size bytes.; ///; /// NOTE: When this method is updated, getCharAndSizeSlow (above) should; /// be updated to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:199,Integrability,Rout,Routine,199,//===----------------------------------------------------------------------===//; // Helper methods for lexing.; //===----------------------------------------------------------------------===//; /// Routine that indiscriminately sets the offset into the source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Modifiability,extend,extends,166,"// To mitigate https://github.com/llvm/llvm-project/issues/54732,; // we allow ""Mathematical Notation Characters"" in identifiers.; // This is a proposed profile that extends the XID_Start/XID_continue; // with mathematical symbols, superscipts and subscripts digits; // found in some production software.; // https://www.unicode.org/L2/L2022/22230-math-profile.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Testability,LOG,LOGICAL,3,// LOGICAL AND,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Availability,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part.; // Carry on as if the codepoint was valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Safety,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part.; // Carry on as if the codepoint was valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Availability,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part. Carry on as if the codepoint was; // valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,Safety,recover,recovery,136,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part. Carry on as if the codepoint was; // valid for recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:37,Deployability,update,update,37,"// Fill in Result.IdentifierInfo and update the token kind,; // looking up the identifier in the identifier table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:235,Usability,simpl,simple,235,"// Skip the code-completion char and all immediate identifier characters.; // This ensures we get consistent behavior when completing at any point in; // an identifier (i.e. at the start, in the middle, at the end). Note that; // only simple cases (i.e. [a-zA-Z0-9_]) are supported to keep the code; // simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:303,Usability,simpl,simpler,303,"// Skip the code-completion char and all immediate identifier characters.; // This ensures we get consistent behavior when completing at any point in; // an identifier (i.e. at the start, in the middle, at the end). Note that; // only simple cases (i.e. [a-zA-Z0-9_]) are supported to keep the code; // simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of the token as well as the BufferPtr instance var.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:179,Performance,perform,performed,179,"// This function doesn't use getAndAdvanceChar because C++0x [lex.pptoken]p3:; // Between the initial and final double quote characters of the raw string,; // any transformations performed in phases 1 and 2 (trigraphs,; // universal-character-names, and line splicing) are reverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:83,Deployability,Update,Update,83,/// SkipWhitespace - Efficiently skip over a series of whitespace characters.; /// Update BufferPtr to point to the next non-whitespace character and return.; ///; /// This method forms a token and returns true if KeepWhitespaceMode is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:21,Energy Efficiency,Efficient,Efficiently,21,/// SkipWhitespace - Efficiently skip over a series of whitespace characters.; /// Update BufferPtr to point to the next non-whitespace character and return.; ///; /// This method forms a token and returns true if KeepWhitespaceMode is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:27,Energy Efficiency,efficient,efficiently,27,// Skip consecutive spaces efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:132,Deployability,update,update,132,"/// We have just read the // characters from input. Skip until we find the; /// newline character that terminates the comment. Then update BufferPtr and; /// return.; ///; /// If we're in KeepCommentMode or any CommentHandler has inserted; /// some tokens, this will store the first token and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:174,Performance,optimiz,optimize,174,"// Scan over the body of the comment. The common case, when scanning, is that; // the comment contains normal ascii characters with nothing interesting in; // them. As such, optimize for this case with the inner loop.; //; // This loop terminates with CurPtr pointing at the newline (or end of buffer); // character that ends the line comment.; // C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:511,Safety,avoid,avoid,511,"// Scan over the body of the comment. The common case, when scanning, is that; // the comment contains normal ascii characters with nothing interesting in; // them. As such, optimize for this case with the inner loop.; //; // This loop terminates with CurPtr pointing at the newline (or end of buffer); // character that ends the line comment.; // C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:127,Safety,avoid,avoid,127,"// Otherwise, this is a hard case. Fall back on getAndAdvanceChar to; // properly decode the character. Read it in raw mode to avoid emitting; // diagnostics about things like trigraphs. If we see an escaped newline,; // we'll handle it below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:150,Performance,optimiz,optimization,150,"// Scan one character past where we should, looking for a '/' character. Once; // we find it, check to see if it was preceded by a *. This common; // optimization helps people who like to put a lot of * characters in their; // comments.; // The first character we get with newlines and trigraphs skipped to handle; // the degenerate /*/ case below correctly if the * has an escaped newline; // after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Safety,avoid,avoid,166,"// C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:39,Safety,avoid,avoid,39,// If there is a code-completion point avoid the fast scan because it; // doesn't check for '\0'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,Energy Efficiency,efficient,efficiently,141,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,Safety,safe,safe,166,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:44,Modifiability,variab,variable,44,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:12,Performance,Cache,Cache,12,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:105,Availability,error,error,105,"// Issue diagnostics for unterminated #if and missing newline.; // If we are in a #if directive, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:156,Availability,error,error,156,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:171,Availability,recover,recover,171,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:171,Safety,recover,recover,171,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:114,Integrability,depend,depends,114,"// We do not offer misspelled character names suggestions here; // as the set of what would be a valid suggestion depends on context,; // and we should not make invalid suggestions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,Availability,recover,recover,112,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,Safety,recover,recover,112,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:291,Integrability,interface,interface,291,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:88,Performance,perform,performance,88,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:41,Usability,simpl,simple,41,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:353,Usability,clear,cleared,353,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:44,Modifiability,variab,variable,44,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:12,Performance,Cache,Cache,12,// CurPtr - Cache BufferPtr in an automatic variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:19,Performance,perform,performing,19,// Check if we are performing code completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:139,Safety,avoid,avoid,139,"// KeepWhitespaceMode; // We know the lexer hasn't changed, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:65,Energy Efficiency,efficient,efficiently,65,"// If the next token is obviously a // or /* */ comment, skip it efficiently; // too (without going through the big switch stmt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:106,Safety,avoid,avoid,106,"// We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:203,Energy Efficiency,efficient,efficiently,203,"// There is a token to return.; // It is common for the tokens immediately after a // comment to be; // whitespace (indentation for the next line). Instead of going through; // the big switch, handle it efficiently now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:138,Safety,avoid,avoid,138,"// There is a token to return.; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,Availability,recover,recover,97,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,Safety,recover,recover,97,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:58,Safety,avoid,avoid,58,// Suggest adding a space between the '<=' and the '>' to avoid a; // change in semantics if this turns up in C++ <=17 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,Availability,recover,recover,78,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,Safety,recover,recover,78,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,Safety,avoid,avoid,129,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:131,Safety,avoid,avoid,131,"// We're pretending the character didn't exist, so just try again with; // this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:3,Deployability,Update,Update,3,// Update the location of token as well as BufferPtr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:54,Security,hash,hash,54,// Read something other than a preprocessor directive hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:477,Integrability,interface,interfaces,477,"//===--- LiteralSupport.cpp - Code to parse and process literals ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the NumericLiteralParser, CharLiteralParser, and; // StringLiteralParser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:61,Availability,mask,mask,61,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:97,Integrability,depend,depending,97,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Deployability,Update,Update,3,// Update the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:8,Integrability,rout,routine,8,"// This routine assumes that the range begin/end matches the regex for integer; // and FP constants (specifically, the 'pp-number' regex), and assumes that; // the byte at ""*end"" is both valid and not part of the regex. Because of; // this, it doesn't have to check for 'overscan' in various places.; // Note: For HLSL, the end token is allowed to be '.' which would be in the; // 'pp-number' regex. This is required to support vector swizzles on numeric; // constants (i.e. 1.xx or 1.5f.rrr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:98,Safety,avoid,avoid,98,"// CUDA host and device may have different _Float16 support, therefore; // allows f16 literals to avoid false alarm.; // When we compile for OpenMP target offloading on NVPTX, f16 suffix; // should also be supported.; // ToDo: more precise check for CUDA.; // TODO: AMDGPU might also support it in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for integer constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:3,Availability,Error,Error,3,// Error for floating constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:36,Availability,error,error,36,"// If we reached here, there was an error or a ud-suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:13,Availability,error,error,13,// Report an error if there are any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:102,Availability,error,error,102,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:175,Safety,detect,detects,175,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:56,Safety,avoid,avoid,56,"/// Determine whether a suffix is a valid ud-suffix. We avoid treating reserved; /// suffixes as ud-suffixes, because the diagnostic experience is better if we; /// treat it as an invalid suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:10,Usability,simpl,simple,10,// Handle simple binary numbers 0b01010,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:9,Usability,simpl,simple,9,"// Done, simple octal number like 01234; // If we have some other non-octal digit that *is* a decimal digit, see if; // this is part of a floating point number like 094.123 or 09e1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:216,Safety,avoid,avoids,216,"// Fast path: Compute a conservative bound on the maximum number of; // bits per digit in this radix. If we can't possibly overflow a; // uint64 based on that bound then do the simple conversion to; // integer. This avoids the expensive overflow checking below, and; // handles the common cases that matter (small decimal integers and; // hex/octal values which don't overflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:177,Usability,simpl,simple,177,"// Fast path: Compute a conservative bound on the maximum number of; // bits per digit in this radix. If we can't possibly overflow a; // uint64 based on that bound then do the simple conversion to; // integer. This avoids the expensive overflow checking below, and; // handles the common cases that matter (small decimal integers and; // hex/octal values which don't overflow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:54,Usability,Simpl,Simply,54,// This will truncate the value to Val's input width. Simply check; // for overflow by comparing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:285,Usability,simpl,simplicity,285,"// Number of bits needed for decimal literal is; // ceil(NumDigits * log2(10)) Integral part; // + Scale Fractional part; // + ceil(Exponent * log2(10)) Exponent; // --------------------------------------------------; // ceil((NumDigits + Exponent) * log2(10)) + Scale; //; // But for simplicity in handling integers, we can round up log2(10) to 4,; // making:; // 4 * (NumDigits + Exponent) + Scale; //; // Number of digits needed for hexadecimal literal is; // 4 * NumDigits Integral part; // + Scale Fractional part; // + Exponent Exponent; // --------------------------------------------------; // (4 * NumDigits) + Scale + Exponent",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:584,Usability,simpl,simple-escape-sequence,584,"/// \verbatim; /// user-defined-character-literal: [C++11 lex.ext]; /// character-literal ud-suffix; /// ud-suffix:; /// identifier; /// character-literal: [C++11 lex.ccon]; /// ' c-char-sequence '; /// u' c-char-sequence '; /// U' c-char-sequence '; /// L' c-char-sequence '; /// u8' c-char-sequence ' [C++1z lex.ccon]; /// c-char-sequence:; /// c-char; /// c-char-sequence c-char; /// c-char:; /// any member of the source character set except the single-quote ',; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// escape-sequence:; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name: [C++11 lex.charset]; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:672,Usability,simpl,simple-escape-sequence,672,"/// \verbatim; /// user-defined-character-literal: [C++11 lex.ext]; /// character-literal ud-suffix; /// ud-suffix:; /// identifier; /// character-literal: [C++11 lex.ccon]; /// ' c-char-sequence '; /// u' c-char-sequence '; /// U' c-char-sequence '; /// L' c-char-sequence '; /// u8' c-char-sequence ' [C++1z lex.ccon]; /// c-char-sequence:; /// c-char; /// c-char-sequence c-char; /// c-char:; /// any member of the source character set except the single-quote ',; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// escape-sequence:; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name: [C++11 lex.charset]; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:74,Usability,simpl,simply,74,"// If we see bad encoding for unprefixed character literals, warn and; // simply copy the byte values, for compatibility with gcc and; // older versions of clang.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:46,Modifiability,extend,extend,46,"// If this is a single narrow character, sign extend it (e.g. '\xFF' is ""-1""); // if 'char' is signed for this target (C99 6.4.4.4p10). Note that multiple; // character constants are not sign extended in the this implementation:; // '\xFF\xFF' = 65536 and '\x0\xFF' = 255, which matches GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:192,Modifiability,extend,extended,192,"// If this is a single narrow character, sign extend it (e.g. '\xFF' is ""-1""); // if 'char' is signed for this target (C99 6.4.4.4p10). Note that multiple; // character constants are not sign extended in the this implementation:; // '\xFF\xFF' = 65536 and '\x0\xFF' = 255, which matches GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:1106,Usability,simpl,simple-escape-sequence,1106,"/// \verbatim; /// string-literal: [C++0x lex.string]; /// encoding-prefix "" [s-char-sequence] ""; /// encoding-prefix R raw-string; /// encoding-prefix:; /// u8; /// u; /// U; /// L; /// s-char-sequence:; /// s-char; /// s-char-sequence s-char; /// s-char:; /// any member of the source character set except the double-quote "",; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// raw-string:; /// "" d-char-sequence ( r-char-sequence ) d-char-sequence ""; /// r-char-sequence:; /// r-char; /// r-char-sequence r-char; /// r-char:; /// any member of the source character set, except a right parenthesis ); /// followed by the initial d-char-sequence (which may be empty); /// followed by a double quote "".; /// d-char-sequence:; /// d-char; /// d-char-sequence d-char; /// d-char:; /// any member of the basic source character set except:; /// space, the left parenthesis (, the right parenthesis ),; /// the backslash \, and the control characters representing horizontal; /// tab, vertical tab, form feed, and newline.; /// escape-sequence: [C++0x lex.ccon]; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name:; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:1194,Usability,simpl,simple-escape-sequence,1194,"/// \verbatim; /// string-literal: [C++0x lex.string]; /// encoding-prefix "" [s-char-sequence] ""; /// encoding-prefix R raw-string; /// encoding-prefix:; /// u8; /// u; /// U; /// L; /// s-char-sequence:; /// s-char; /// s-char-sequence s-char; /// s-char:; /// any member of the source character set except the double-quote "",; /// backslash \, or new-line character; /// escape-sequence; /// universal-character-name; /// raw-string:; /// "" d-char-sequence ( r-char-sequence ) d-char-sequence ""; /// r-char-sequence:; /// r-char; /// r-char-sequence r-char; /// r-char:; /// any member of the source character set, except a right parenthesis ); /// followed by the initial d-char-sequence (which may be empty); /// followed by a double quote "".; /// d-char-sequence:; /// d-char; /// d-char-sequence d-char; /// d-char:; /// any member of the basic source character set except:; /// space, the left parenthesis (, the right parenthesis ),; /// the backslash \, and the control characters representing horizontal; /// tab, vertical tab, form feed, and newline.; /// escape-sequence: [C++0x lex.ccon]; /// simple-escape-sequence; /// octal-escape-sequence; /// hexadecimal-escape-sequence; /// simple-escape-sequence:; /// one of \' \"" \? \\ \a \b \f \n \r \t \v; /// octal-escape-sequence:; /// \ octal-digit; /// \ octal-digit octal-digit; /// \ octal-digit octal-digit octal-digit; /// hexadecimal-escape-sequence:; /// \x hexadecimal-digit; /// hexadecimal-escape-sequence hexadecimal-digit; /// universal-character-name:; /// \u hex-quad; /// \U hex-quad hex-quad; /// hex-quad:; /// hex-digit hex-digit hex-digit hex-digit; /// \endverbatim; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:90,Availability,error,error,90,"// The literal token may have come from an invalid source location (e.g. due; // to a PCH error), in which case the token length will be 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:58,Performance,load,loading,58,// The file may have come from PCH and then changed after loading the; // PCH; Fail gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:58,Performance,load,loading,58,// The file may have come from PCH and then changed after loading the; // PCH; Fail gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:143,Performance,Perform,Performs,143,"/// This function copies from Fragment, which is a sequence of bytes; /// within Tok's contents (which begin at TokBegin) into ResultPtr.; /// Performs widening for multi-byte characters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:71,Usability,simpl,simply,71,"// If we see bad encoding for unprefixed string literals, warn and; // simply copy the byte values, for compatibility with gcc and older; // versions of clang.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:25,Usability,simpl,simply,25,// Step over non-escapes simply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:56,Safety,avoid,avoid,56,"/// Determine whether a suffix is a valid ud-suffix. We avoid treating reserved; /// suffixes as ud-suffixes, because the diagnostic experience is better if we; /// treat it as an invalid suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:418,Integrability,interface,interface,418,"//===--- MacroArgs.cpp - Formal argument info for Macros ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MacroArgs interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate memory for a MacroArgs object with the lexer tokens at the end,; // and construct the MacroArgs object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:9,Usability,clear,clear,9,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:37,Usability,clear,clear,37,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:56,Usability,Clear,Clearing,56,"// Don't clear PreExpArgTokens, just clear the entries. Clearing the entries; // would deallocate the element vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:3,Deployability,Release,Release,3,// Release the memory for the object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:191,Deployability,install,installed,191,"// Include the EOF.; // Otherwise, we have to pre-expand this argument, populating Result. To do; // this, we set up a fake TokenLexer to lex from the unexpanded argument; // list. With this installed, we lex expanded tokens until we hit the EOF; // token at the end of the unexp list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:90,Safety,avoid,avoid,90,"// Otherwise, just append the token. Do some gymnastics to get the token; // in place and avoid copies where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:120,Availability,error,error,120,"// Count the number of consecutive \ characters. If even, then they are; // just escaped backslashes, otherwise it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:12,Availability,error,errors,12,// Diagnose errors for things like: #define F(X) #X / F(\),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp:418,Integrability,interface,interface,418,"//===- MacroInfo.cpp - Information about #defined identifiers -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MacroInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:66,Usability,simpl,simple,66,// The lack of 'framework' keyword in a module declaration it's a simple; // mistake we can diagnose when the header exists within the proper; // framework style path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:5,Security,Sanitiz,Sanitize,5,"/// ""Sanitize"" a filename so that it can be used as an identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:99,Security,sanitiz,sanitized,99,"// If we don't already have something with the form of an identifier,; // create a buffer with the sanitized name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:6,Availability,error,errors,6,// No errors for indirect modules. This may be a bit of a problem for modules; // with no source files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:10,Availability,avail,available,10,// Prefer available modules.; // FIXME: Considering whether the module is available rather than merely; // importable is non-hermetic and can result in surprising behavior for; // prebuilt modules. Consider only checking for importability here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:74,Availability,avail,available,74,// Prefer available modules.; // FIXME: Considering whether the module is available rather than merely; // importable is non-hermetic and can result in surprising behavior for; // prebuilt modules. Consider only checking for importability here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:32,Availability,avail,available,32,"// When no requesting module is available, the caller is looking if a; // header is part a module by only looking into the module map. This is; // done by warn_uncovered_module_header checks; don't consider textual; // headers part of it in this mode, otherwise we get misleading warnings; // that a umbrella header is not including a textual header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:170,Usability,simpl,simplify,170,// Note: Here the `IsExplicit` parameter refers to the semantics in clang; // modules. All the non-explicit submodules in clang modules will be exported; // too. Here we simplify the implementation by using the concept.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:7,Integrability,interface,interface,7,// The interface for this implementation must exist and be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:59,Performance,load,loaded,59,// The interface for this implementation must exist and be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:34,Performance,Load,Load,34,"// We haven't looked here before. Load a module map, if there is; // one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:85,Performance,load,load,85,"// FIXME: If there's no umbrella header, we could probably scan the; // framework to load *everything*. But, it's not clear that this is a good; // idea.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:118,Usability,clear,clear,118,"// FIXME: If there's no umbrella header, we could probably scan the; // framework to load *everything*. But, it's not clear that this is a good; // idea.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:76,Integrability,wrap,wrap,76,"// If there is a builtin counterpart to this file, add it now so it can; // wrap the system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,Integrability,inject,inject,97,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,Security,inject,inject,97,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:75,Performance,Perform,Perform,75,// We don't have stat information or can't defer looking this file up.; // Perform the lookup now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:21,Testability,log,logically,21,// This operation is logically const; we're just changing how we represent; // the header information for this file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,Availability,redundant,redundant,249,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,Safety,redund,redundant,249,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:15,Availability,error,error,15,/// Whether an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:215,Testability,assert,assert,215,"/// Whether a module uses the 'requires excluded' hack to mark its; /// contents as 'textual'.; ///; /// On older Darwin SDK versions, 'requires excluded' is used to mark the; /// contents of the Darwin.C.excluded (assert.h) and Tcl.Private modules as; /// non-modular headers. For backwards compatibility, we continue to; /// support this idiom for just these modules, and map the headers to; /// 'textual' to match the original intent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:98,Testability,log,logic,98,"/// Private modules are canonicalized as Foo_Private. Clang provides extra; /// module map search logic to find the appropriate private module when PCH; /// is used with implicit module maps. Warn when private modules are written; /// in other ways (FooPrivate and Foo.Private), providing notes and fixits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:120,Availability,error,error,120,"/// Parse a module-id.; ///; /// module-id:; /// identifier; /// identifier '.' module-id; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:112,Testability,log,logic,112,"// namespace; /// Private modules are canonicalized as Foo_Private. Clang provides extra; /// module map search logic to find the appropriate private module when PCH; /// is used with implicit module maps. Warn when private modules are written; /// in other ways (FooPrivate and Foo.Private), providing notes and fixits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:114,Performance,load,loaded,114,"// We might see a (re)definition of a module that we already have a; // definition for in four cases:; // - If we loaded one definition from an AST file and we've just found a; // corresponding definition in a module map file, or",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:62,Performance,load,loaded,62,// - If we're building a (preprocessed) module and we've just loaded the; // module map file from which it was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:85,Availability,error,error,85,"// Private modules named as FooPrivate, Foo.Private or similar are likely a; // user error; provide warnings, notes and fixits to direct users to use; // Foo_Private instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:550,Testability,assert,assert,550,"/// Whether to add the requirement \p Feature to the module \p M.; ///; /// This preserves backwards compatibility for two hacks in the Darwin system; /// module map files:; ///; /// 1. The use of 'requires excluded' to make headers non-modular, which; /// should really be mapped to 'textual' now that we have this feature. We; /// drop the 'excluded' requirement, and set \p IsRequiresExcludedHack to; /// true. Later, this bit will be used to map all the headers inside this; /// module to 'textual'.; ///; /// This affects Darwin.C.excluded (for assert.h) and Tcl.Private.; ///; /// 2. Removes a bogus cplusplus requirement from IOKit.avc. This requirement; /// was never correct and causes issues now that we check it, so drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:45,Integrability,depend,depend,45,// Sort header paths so that the pcm doesn't depend on iteration order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:12,Deployability,configurat,configuration,12,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:12,Modifiability,config,configuration,12,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:112,Modifiability,config,config-macro-list,112,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:141,Modifiability,config,config-macro-list,141,"/// Parse a configuration macro declaration.; ///; /// module-declaration:; /// 'config_macros' attributes[opt] config-macro-list?; ///; /// config-macro-list:; /// identifier (',' identifier)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:35,Deployability,configurat,configuration,35,// Only top-level modules can have configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:35,Modifiability,config,configuration,35,// Only top-level modules can have configuration macros.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:13,Integrability,message,message,13,// Parse the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:234,Availability,error,error,234,"/// Parse optional attributes.; ///; /// attributes:; /// attribute attributes; /// attribute; ///; /// attribute:; /// [ identifier ]; ///; /// \param Attrs Will be filled in with the parsed attributes.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:431,Integrability,interface,interface,431,"//===--- PPCaching.cpp - Handle caching lexed tokens ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements pieces of the Preprocessor interface that manage the; // caching of lexed tokens.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:7,Testability,assert,assert,7,// The assert in EnterCachingLexMode should prevent this from happening.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:3,Performance,Cache,Cache,3,// Cache the lexed token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:7,Performance,cache,cached,7,// All cached tokens were consumed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:83,Performance,cache,cache,83,"// The caching layer sits on top of all the other lexers, so it's incorrect; // to cache tokens while inside a nested lex action. The cached tokens would; // be retained after returning to the enclosing lex action and, at best,; // would appear at the wrong position in the token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:134,Performance,cache,cached,134,"// The caching layer sits on top of all the other lexers, so it's incorrect; // to cache tokens while inside a nested lex action. The cached tokens would; // be retained after returning to the enclosing lex action and, at best,; // would appear at the wrong position in the token stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:29,Performance,cache,cached,29,// Start from the end of the cached tokens list and look for the token; // that is the beginning of the annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:15,Performance,cache,cached,15,// Replace the cached tokens with the single annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp:24,Performance,cache,cached,24,// There's currently no cached token...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPCaching.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:147,Security,secur,security-features-in-the-crt,147,// list from:; // * https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html; // * https://docs.microsoft.com/en-us/cpp/c-runtime-library/security-features-in-the-crt?view=msvc-160; // * man 7 feature_test_macros; // The list must be sorted for correct binary search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:31,Testability,test,test,31,// C++ defines various feature-test macros starting with __cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:274,Modifiability,portab,portability,274,"// Return true if we want to issue a diagnostic by default if we; // encounter this name in a #include with the wrong case. For now,; // this includes the standard C and C++ headers, Posix headers,; // and Boost headers. Improper case for these #includes is a; // potential portability issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:72,Availability,recover,recovery,72,// Allow #defining |and| and friends for Microsoft compatibility or; // recovery when legacy C headers are included in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:72,Safety,recover,recovery,72,// Allow #defining |and| and friends for Microsoft compatibility or; // recovery when legacy C headers are included in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error if defining ""defined"": C99 6.10.8/4, C++ [cpp.predefined]p4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Deployability,configurat,configuration,58,"// We do not want to warn on some patterns widely used in configuration; // scripts. This requires analyzing next tokens, so do not issue warnings; // now, only inform caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Modifiability,config,configuration,58,"// We do not want to warn on some patterns widely used in configuration; // scripts. This requires analyzing next tokens, so do not issue warnings; // now, only inform caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:12,Security,validat,validate,12,"/// Lex and validate a macro name, which occurs after a; /// \#define or \#undef.; ///; /// This sets the token kind to eod and discards the rest of the macro line if; /// the macro name is invalid.; ///; /// \param MacroNameTok Token that is expected to be a macro name.; /// \param isDefineUndef Context in which macro is used.; /// \param ShadowFlag Points to a flag that is set if macro shadows a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:34,Integrability,depend,depending,34,"// In SkippingRangeStateTy we are depending on SkipExcludedConditionalBlock(); // not getting called recursively by storing the RecordedSkippedRanges; // DenseMap lookup pointer (field SkipRangePtr). SkippingRangeStateTy expects; // that RecordedSkippedRanges won't get modified and SkipRangePtr won't be; // invalidated. If this changes and there is a need to call; // SkipExcludedConditionalBlock() recursively, SkippingRangeStateTy should; // change to do a second lookup in endLexPass function instead of reusing the; // lookup pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:20,Performance,cache,caches,20,/// Keeps track and caches skipped ranges and also retrieves a prior skipped; /// range if the same block is re-visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:48,Availability,error,error,48,"// If this is the end of the buffer, we have an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:17,Availability,error,errors,17,"// We don't emit errors for unterminated conditionals here,; // Lexer::LexEndOfFile can do that properly.; // Just return and let the caller lex after this #include.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:88,Safety,safe,safe,88,"// If the first letter isn't i or e, it isn't intesting to us. We know that; // this is safe in the face of spelling differences, because there is no way; // to spell an i/e in a strange way that is another letter. Skipping this; // allows us to avoid looking up the identifier info for #define/#undef and; // other common directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:246,Safety,avoid,avoid,246,"// If the first letter isn't i or e, it isn't intesting to us. We know that; // this is safe in the face of spelling differences, because there is no way; // to spell an i/e in a strange way that is another letter. Skipping this; // allows us to avoid looking up the identifier info for #define/#undef and; // other common directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:25,Testability,assert,asserts,25,// Silence warning in no-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #else with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,error,error,53,"// If the macro name token is tok::eod, there was an error that was; // already reported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:85,Availability,error,error,85,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Safety,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:109,Usability,resume,resume,109,// The last skipped range isn't actually skipped yet if it's truncated; // by the end of the preamble; we'll resume parsing after the preamble.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:132,Performance,load,load,132,"// We want to find all possible modules that might contain this header, so; // search all enclosing directories for module maps and load them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:179,Usability,clear,clear,179,"// It's in a private header; we can't #include it.; // FIXME: If there's a public header in some module that re-exports it,; // then we could suggest including that, but it's not clear that's the; // expected way to make this entity visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:17,Security,access,accessible,17,"// If this is an accessible, non-textual header of M's top-level module; // that transitively includes the given location and makes the; // corresponding module visible, this is the thing to #include.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:88,Security,expose,expose,88,"// If the header is includable and has an include guard, assume the; // intended way to expose its contents is by #include, not by importing a; // module that transitively includes it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Performance,optimiz,optimization,58,"// We are about to read a token. For the multiple-include optimization FA to; // work, we have to remember if we had read any tokens *before* this; // pp-directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:70,Performance,optimiz,optimization,70,"// Ignore the null directive with regards to the multiple-include; // optimization, i.e. allow the null directive to appear outside of the; // include guard and still enable the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:195,Performance,optimiz,optimization,195,"// Ignore the null directive with regards to the multiple-include; // optimization, i.e. allow the null directive to appear outside of the; // include guard and still enable the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:16,Availability,Error,Error,16,// C99 6.10.5 - Error Directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Testability,assert,assert,43,//isExtension = true; // FIXME: implement #assert,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:122,Performance,perform,perform,122,"// If the second token is a hashhash token, then we need to translate it to; // unknown so the token lexer doesn't try to perform token pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:28,Security,hash,hashhash,28,"// If the second token is a hashhash token, then we need to translate it to; // unknown so the token lexer doesn't try to perform token pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:25,Usability,simpl,simple,25,"// Verify that we have a simple digit-sequence, and compute the value. This; // is always a simple digit string computed in decimal, so we do this manually; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:92,Usability,simpl,simple,92,"// Verify that we have a simple digit-sequence, and compute the value. This; // is always a simple digit string computed in decimal, so we do this manually; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Security,Validat,Validate,3,// Validate the number and convert it to an unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Security,validat,validate,13,"// Parse and validate the string, converting it into a unique ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:290,Modifiability,rewrite,rewrites,290,"// Take the file kind of the file containing the #line directive. #line; // directives are often used for generated sources from the same codebase, so; // the new file should generally be classified the same way as the current; // file. This is visible in GCC's pre-processed output, which rewrites #line; // to GNU line markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:36,Security,validat,validate,36,/// ReadLineMarkerFlags - Parse and validate any flags at the end of a GNU line; /// marker directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Security,Validat,Validate,3,// Validate the number and convert it to an unsigned. GNU does not have a; // line # limit other than it fit in 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Security,validat,validate,13,"// Parse and validate the string, converting it into a unique ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:37,Deployability,install,installed,37,"// If the preprocessor has callbacks installed, notify them of the #line; // change. This is used so that the line marker comes out in -E mode for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:58,Availability,error,error,58,/// HandleUserDiagnosticDirective - Handle a #warning or #error directive.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Availability,error,error,43,"// If the macro is not defined, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:43,Availability,error,error,43,"// If the macro is not defined, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:151,Safety,avoid,avoid,151,"// If these non-separator path components differ by more than just case,; // then we may be looking at symlinked paths. Bail on this diagnostic to; // avoid noisy false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:162,Integrability,rout,routine,162,"/// HandleIncludeDirective - The ""\#include"" tokens have just been read, read; /// the file to be included from the lexer, then include it! This is a common; /// routine with functionality shared between \#include, \#include_next and; /// \#import. LookupFrom is set when this is a \#include_next directive, it; /// specifies the file to start searching from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:117,Security,Hash,HashLoc,117,"/// Handle either a #include-like directive or an import declaration that names; /// a header file.; ///; /// \param HashLoc The location of the '#' token for an include, or; /// SourceLocation() for an import declaration.; /// \param IncludeTok The include / include_next / import token.; /// \param FilenameTok The header-name token.; /// \param EndLoc The location at which any imported macros become visible.; /// \param LookupFrom For #include_next, the starting directory for the; /// directory lookup.; /// \param LookupFromFile For #include_next, the starting file for the directory; /// lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:51,Security,audit,audit,51,// Complain about attempts to #include files in an audit pragma.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:812,Safety,avoid,avoids,812,"// Should we enter the source file? Set to Skip if either the source file is; // known to have no effect beyond its effect on module visibility -- that is,; // if it's got an include guard that is already defined, set to Import if it; // is a modular header we've already built and should import.; // For C++20 Modules; // [cpp.include]/7 If the header identified by the header-name denotes an; // importable header, it is implementation-defined whether the #include; // preprocessing directive is instead replaced by an import directive.; // For this implementation, the translation is permitted when we are parsing; // the Global Module Fragment, and not otherwise (the cases where it would be; // valid to replace an include with an import are highly constrained once in; // named module purview; this choice avoids considerable complexity in; // determining valid cases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,Usability,usab,usable,11,// Maybe a usable Header Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,Usability,usab,usable,11,// Maybe a usable clang header module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:140,Performance,load,loadModule,140,"// If this include corresponds to a module but that module is; // unavailable, diagnose the situation and bail out.; // FIXME: Remove this; loadModule does the same check (but produces; // slightly worse diagnostics).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:99,Performance,load,loadModule,99,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:124,Safety,avoid,avoid,124,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:22,Security,access,access,22,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Performance,Load,Load,3,// Load the module to import its macros. We'll make the declarations; // visible when the parser gets here.; // FIXME: Pass SuggestedModule in here rather than converting it to a path; // and making the module loader convert it back again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:210,Performance,load,loader,210,// Load the module to import its macros. We'll make the declarations; // visible when the parser gets here.; // FIXME: Pass SuggestedModule in here rather than converting it to a path; // and making the module loader convert it back again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:8,Deployability,configurat,configuration,8,"// On a configuration mismatch, enter the header textually. We still know; // that it's part of the corresponding module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:8,Modifiability,config,configuration,8,"// On a configuration mismatch, enter the header textually. We still know; // that it's part of the corresponding module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,Availability,error,error,13,// We hit an error processing the import. Bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:310,Availability,error,errors,310,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:318,Safety,avoid,avoid,318,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:272,Integrability,depend,depending,272,"// -Wnonportable-include-path is designed to diagnose includes using; // case even on systems with a case-insensitive file system.; // On Windows, RealPathName always starts with an upper-case drive; // letter for absolute paths, but Name might start with either; // case depending on if `cd c:\foo` or `cd C:\foo` was used in the shell.; // (""foo"" will always have on-disk case, no matter which case was; // used in the cd command). To not emit this warning solely for; // the drive letter, whose case is dependent on if `cd` is used; // with upper- or lower-case drive letters, always consider the; // given drive letter case as correct for the purpose of this warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:506,Integrability,depend,dependent,506,"// -Wnonportable-include-path is designed to diagnose includes using; // case even on systems with a case-insensitive file system.; // On Windows, RealPathName always starts with an upper-case drive; // letter for absolute paths, but Name might start with either; // case depending on if `cd c:\foo` or `cd C:\foo` was used in the shell.; // (""foo"" will always have on-disk case, no matter which case was; // used in the cd command). To not emit this warning solely for; // the drive letter, whose case is dependent on if `cd` is used; // with upper- or lower-case drive letters, always consider the; // given drive letter case as correct for the purpose of this warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:185,Availability,error,error,185,"// The Microsoft #import directive takes a type library and generates header; // files from it, and includes those. This is beyond the scope of what clang; // does, so we ignore it and error out. However, #import can optionally have; // trailing attributes that span multiple lines. We're going to eat those; // so we can continue processing from there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:82,Availability,error,error,82,"// This directive should only occur in the predefines buffer. If not, emit an; // error and reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:420,Availability,error,error,420,"//===----------------------------------------------------------------------===//; // Preprocessor Macro Directive Handling.; //===----------------------------------------------------------------------===//; /// ReadMacroParameterList - The ( starting a parameter list of a macro; /// definition has just been read. Lex the rest of the parameters and the; /// closing ), updating MI with what we learn. Return true if an error occurs; /// parsing the param list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:395,Usability,learn,learn,395,"//===----------------------------------------------------------------------===//; // Preprocessor Macro Directive Handling.; //===----------------------------------------------------------------------===//; /// ReadMacroParameterList - The ( starting a parameter list of a macro; /// definition has just been read. Lex the rest of the parameters and the; /// closing ), updating MI with what we learn. Return true if an error occurs; /// parsing the param list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:161,Performance,perform,performs,161,"// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the; // entire line) of the macro's tokens and adds them to MacroInfo, and while; // doing so performs certain validity checks including (but not limited to):; // - # (stringization) is followed by a macro parameter; //; // Returns a nullptr if an invalid sequence of tokens is encountered or returns; // a pointer to a MacroInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:51,Availability,error,errors,51,// Ensure we consume the rest of the macro body if errors occur.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:46,Usability,Clear,Clear,46,// This is a normal token with leading space. Clear the leading space; // marker on the first token to get proper expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:47,Availability,down,down,47,// Read the first token after the arg list for down below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:31,Usability,simpl,simple,31,"// Object-like macros are very simple, just read their body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:44,Availability,error,error,44,"// If we're already within a VAOPT, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:76,Testability,assert,assert,76,"// If we're in MS compatibility mode and the macro being defined is the; // assert macro, implicitly add a macro definition for static_assert to work; // around their broken assert.h header file in C. Only do so if there isn't; // already a static_assert macro defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:174,Testability,assert,assert,174,"// If we're in MS compatibility mode and the macro being defined is the; // assert macro, implicitly add a macro definition for static_assert to work; // around their broken assert.h header file in C. Only do so if there isn't; // already a static_assert macro defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Availability,Error,Error,3,"// Error reading macro name? If so, diagnostic already issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Availability,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:85,Availability,error,error,85,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,Safety,recover,recovery,53,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:129,Performance,optimiz,optimization,129,"// If this condition is equivalent to #ifndef X, and if this is the first; // directive seen, handle it for the multiple-include optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #else with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:57,Availability,error,error,57,"// If this is a #elif with a #else before it, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:649,Testability,test,testing,649,"//===--- PPExpressions.cpp - Preprocessor Expression Evaluation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor::EvaluateDirectiveExpression method,; // which parses and evaluates integer constant expressions for #if directives.; //; //===----------------------------------------------------------------------===//; //; // FIXME: implement testing for #assert's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:662,Testability,assert,assert,662,"//===--- PPExpressions.cpp - Preprocessor Expression Evaluation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor::EvaluateDirectiveExpression method,; // which parses and evaluates integer constant expressions for #if directives.; //; //===----------------------------------------------------------------------===//; //; // FIXME: implement testing for #assert's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:144,Usability,simpl,simple,144,"/// DefinedTracker - This struct is used while parsing expressions to keep track; /// of whether !defined(X) has been seen.; ///; /// With this simple scheme, we handle the basic forms:; /// !defined(X) and !defined X; /// but we also trivially handle (silly) stuff like:; /// !!!defined(X) and +!defined(X) and !+!+!defined(X) and !(defined(X)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:52,Availability,error,error,52,"// If we don't have a pp-identifier now, this is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:522,Security,threat,threat,522,"// [cpp.cond]p4:; // Prior to evaluation, macro invocations in the list of preprocessing; // tokens that will become the controlling constant expression are replaced; // (except for those macro names modified by the 'defined' unary operator),; // just as in normal text. If the token 'defined' is generated as a result; // of this replacement process or use of the 'defined' unary operator does; // not match one of the two specified forms prior to macro replacement, the; // behavior is undefined.; // This isn't an idle threat, consider this program:; // #define FOO; // #define BAR defined(FOO); // #if BAR; // ...; // #else; // ...; // #endif; // clang and gcc will pick the #if branch while Visual Studio will take the; // #else branch. Emit a warning about this undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:145,Availability,error,error,145,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:418,Safety,avoid,avoid,418,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:136,Usability,simpl,simple,136,"// If this identifier isn't 'defined' or one of the special; // preprocessor keywords and it wasn't macro expanded, it turns; // into a simple 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Safety,Detect,Detect,3,"// Detect overflow based on whether the value is signed. If signed; // and if the value is too large, emit a warning ""integer constant is so; // large that it is unsigned"" e.g. on 12345678901234567890 where intmax_t; // is 64-bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:18,Testability,assert,assert,18,// FIXME: Handle #assert,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:284,Safety,avoid,avoid,284,"/// EvaluateDirectiveSubExpr - Evaluate the subexpression whose first token is; /// PeekTok, and whose precedence is PeekPrec. This returns the result in LHS.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation, such as division by zero warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:41,Availability,error,error,41,"// If this token isn't valid, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:41,Availability,error,error,41,"// If this token isn't valid, report the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:458,Testability,log,logical-OR-expression,458,"// Decide whether to include the next binop in this subexpression. For; // example, when parsing x+y*z and looking at '*', we want to recursively; // handle y*z as a single subexpression. We do this because the precedence; // of * is higher than that of +. The only strange case we have to handle; // here is for the ?: operator, where the precedence is actually lower than; // the LHS of the '?'. The grammar rule is:; //; // conditional-expression ::=; // logical-OR-expression ? expression : conditional-expression; // where 'expression' is actually comma-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Testability,Log,Logical,3,// Logical || does not do UACs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Testability,Log,Logical,3,// Logical && does not do UACs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:9,Availability,error,error,9,"// Parse error, skip the rest of the macro line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:81,Availability,error,error,81,// We cannot trust the source range from the value because there was a; // parse error. Track the range manually -- the end of the directive is the; // end of the condition range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:9,Availability,error,error,9,"// Parse error, skip the rest of the macro line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:431,Integrability,interface,interface,431,"//===--- PPLexerChange.cpp - Handle changing lexers in the preprocessor ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements pieces of the Preprocessor interface that manage the; // current lexer stack.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:584,Energy Efficiency,allocate,allocated,584,"/// EnterTokenStream - Add a ""macro"" context to the top of the include stack,; /// which will cause the lexer to start returning the specified tokens.; ///; /// If DisableMacroExpansion is true, tokens lexed from the token stream will; /// not be subject to further macro expansion. Otherwise, these tokens will; /// be re-macro-expanded when/if expansion is enabled.; ///; /// If OwnsTokens is false, this method assumes that the specified stream of; /// tokens has a permanent owner somewhere, so they do not need to be copied.; /// If it is true, it assumes the array of tokens is allocated with new[] and; /// must be freed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:48,Performance,cache,cached,48,"// We're entering tokens into the middle of our cached token stream. We; // can't represent that, so just insert the tokens into the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:36,Performance,cache,cached,36,// New tokens are at the end of the cached token sequnece; insert the; // token stream underneath the caching lexer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:37,Security,access,access,37,// Find the relative path that would access this header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Availability,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Safety,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:169,Performance,load,loaded,169,"// If we're at the end of generating a preamble, we should record the; // unterminated \#pragma clang assume_nonnull so we can restore it later; // when the preamble is loaded into the main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Availability,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Safety,Recover,Recover,3,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:13,Performance,cache,cache,13,// Delete or cache the now-dead macro expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:13,Performance,cache,cache,13,// Delete or cache the now-dead macro expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:82,Integrability,interface,interface,82,"// Otherwise, we only need module macros if we're actually compiling a module; // interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:17,Security,expose,exposed,17,// This macro is exposed to the rest of this compilation as a; // ModuleMacro; we don't need to track its MacroDirective any more.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Safety,Avoid,Avoid,3,// Avoid assertion in appendMacroDirective.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:9,Testability,assert,assertion,9,// Avoid assertion in appendMacroDirective.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:149,Performance,load,loaded,149,"// shouldIgnoreMacro() in ASTWriter also stops at macros from the; // predefines buffer in module builds. However, in module builds, modules; // are loaded completely before predefines are processed, so StoredMD; // will be nullptr for them when they're loaded. StoredMD should only be; // non-nullptr for builtins read from a pch file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:254,Performance,load,loaded,254,"// shouldIgnoreMacro() in ASTWriter also stops at macros from the; // predefines buffer in module builds. However, in module builds, modules; // are loaded completely before predefines are processed, so StoredMD; // will be nullptr for them when they're loaded. StoredMD should only be; // non-nullptr for builtins read from a pch file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:60,Deployability,update,update,60,"// If the information about this identifier is out of date, update it from; // the external source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,Safety,safe,safe,53,"// If this is an object-like macro invocation, it is safe to trivially expand; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,Safety,safe,safe,53,"// If this is a function-like macro invocation, it's safe to trivially expand; // as long as the identifier is not a macro argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:17,Testability,test,tests,17,// Do some quick tests for rejection cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:174,Performance,optimiz,optimization,174,"// If this is a macro expansion in the ""#if !defined(x)"" line for the file,; // then the macro could expand to different things in other contexts, we need; // to disable the optimization in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:137,Modifiability,portab,portable,137,"// Remember that we are now parsing the arguments to a macro invocation.; // Preprocessor directives used inside macro arguments are not portable, and; // this enables the warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:19,Availability,error,error,19,"// If there was an error parsing the arguments, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:197,Performance,queue,queue,197,"// We can have macro expansion inside a conditional directive while; // reading the function macro arguments. To ensure, in that case, that; // MacroExpands callbacks still happen in source order, queue this; // callback to have it happen after the function macro callback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Deployability,Update,Update,3,// Update the tokens location to include both its expansion and physical; // locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:58,Usability,simpl,simple,58,"// Once it is known that the brackets are matched, only a simple count of the; // braces is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:163,Deployability,update,updated,163,"// Set to true when a macro separator token is found inside a braced list.; // If true, the fixed argument spans multiple old arguments and ParenHints; // will be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:242,Availability,error,error,242,"/// ReadFunctionLikeMacroArgs - After reading ""MACRO"" and knowing that the next; /// token is the '(' of the macro, this method is invoked to read all of the; /// actual arguments specified for the macro invocation. This returns null on; /// error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:45,Safety,avoid,avoids,45,"// Read arguments as unexpanded tokens. This avoids issues, e.g., where; // an argument value in a macro could expand to ',' or '(' or ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:145,Safety,avoid,avoid,145,// ArgTokens - Build up a list of tokens that make up each argument. Each; // argument is separated by an EOF token. Use a SmallVector so we can avoid; // heap allocations in the common case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:45,Safety,avoid,avoids,45,"// Read arguments as unexpanded tokens. This avoids issues, e.g., where; // an argument value in a macro could expand to ',' or '(' or ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:135,Testability,test,test,135,"// In Microsoft-compatibility mode, single commas from nested macro; // expansions should not be considered as argument separators. We test; // for this with the IgnoredComma token flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:82,Availability,error,error,82,"// If this is not a variadic macro, and too many args were specified, emit; // an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:82,Availability,error,error,82,"// If this is not a variadic macro, and too many args were specified, emit; // an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Availability,Recover,Recover,3,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Safety,Recover,Recover,3,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:23,Availability,error,error,23,"// Otherwise, emit the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:155,Performance,cache,cache,155,/// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:230,Performance,cache,cache,230,/// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:86,Deployability,update,update,86,// Go through all the TokenLexers whose 'Tokens' pointer points in the; // buffer and update the pointers to the (potential) new buffer array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:11,Performance,cache,cached,11,// Pop the cached macro expanded tokens from the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:44,Availability,error,error,44,"// If the use of an extension results in an error diagnostic, extensions are; // effectively unavailable, so just return false here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:14,Modifiability,inherit,inherit,14,"// Because we inherit the feature list from HasFeature, this string switch; // must be less restrictive than HasFeature's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:46,Integrability,message,message,46,// Save '(' location for possible missing ')' message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:197,Availability,down,down,197,"// Passing this to LookupFile forces header search to check whether the found; // file belongs to a module. Skipping that check could incorrectly mark; // modular header as textual, causing issues down the line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:63,Availability,error,errors,63,// Provide a dummy '0' value on output stream to elide further errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:77,Usability,Simpl,Simply,77,// Don't provide even a dummy value if the eod or eof marker is; // reached. Simply provide a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:108,Availability,avail,available,108,/// Helper function to return the IdentifierInfo structure of a Token; /// or generate a diagnostic if none available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:232,Availability,down,down,232,"// One wrinkle here is that GCC expands __LINE__ to location of the *end* of; // a macro expansion. This doesn't matter for object-like macros, but; // can matter for a function-like macro that expands to contain __LINE__.; // Skip down through expansion points until we find a file loc for the; // end of the expansion history.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:25,Usability,simpl,simple,25,// __LINE__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:34,Usability,simpl,simple,34,// __INCLUDE_LEVEL__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:36,Usability,simpl,simple,36,// __FLT_EVAL_METHOD__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:28,Usability,simpl,simple,28,// __COUNTER__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:102,Safety,detect,detecting,102,// Likewise for some builtin preprocessor macros.; // FIXME: This is inconsistent; we usually suggest detecting; // builtin macros via #ifdef. Don't add more cases here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:72,Availability,avail,available,72,"// It is possible to receive a scope token. Read the ""::"", if it is; // available, and the subsequent identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:61,Availability,recover,recover,61,// We're expecting '__identifier' '(' identifier ')'. Try to recover; // if the parens are missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:61,Safety,recover,recover,61,// We're expecting '__identifier' '(' identifier ')'. Try to recover; // if the parens are missing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,Availability,recover,recover,59,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,Safety,recover,recover,59,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:434,Integrability,interface,interfaces,434,"//===- Pragma.cpp - Pragma registration and handling ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PragmaHandler/PragmaTable interfaces and implements; // pragma related methods of the Preprocessor class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:464,Availability,failure,failure,464,"//===----------------------------------------------------------------------===//; // PragmaNamespace Implementation.; //===----------------------------------------------------------------------===//; /// FindHandler - Check to see if there is already a handler for the; /// specified name. If not, return the handler for the null identifier if it; /// exists, otherwise return null. If IgnoreNull is true (the default) then; /// the null handler isn't returned on failure to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Deployability,Release,Release,3,// Release ownership back to the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:22,Availability,down,down,22,"// Otherwise, pass it down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:882,Energy Efficiency,consumption,consumption,882,"// C11 6.10.3.4/3:; // all pragma unary operator expressions within [a completely; // macro-replaced preprocessing token sequence] are [...] processed [after; // rescanning is complete]; //; // This means that we execute _Pragma operators in two cases:; //; // 1) on token sequences that would otherwise be produced as the output of; // phase 4 of preprocessing, and; // 2) on token sequences formed as the macro-replaced token sequence of a; // macro argument; //; // Case #2 appears to be a wording bug: only _Pragmas that would survive to; // the end of phase 4 should actually be executed. Discussion on the WG14; // mailing list suggests that a _Pragma operator is notionally checked early,; // but only pragmas that survive to the end of phase 4 should be executed.; //; // In Case #2, we check the syntax now, but then put the tokens back into the; // token stream for later consumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:112,Energy Efficiency,consumption,consumption,112,"// During macro pre-expansion, check the syntax now but put the tokens back; // into the token stream for later consumption. Same as Handle_Pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:141,Availability,error,errors,141,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:134,Safety,avoid,avoids,134,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:49,Integrability,depend,dependency,49,"/// HandlePragmaDependency - Handle \#pragma GCC dependency ""foo"" blah.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:56,Availability,error,error,56,"// If the next token wasn't a header-name, diagnose the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:77,Availability,error,error,77,"// If GetIncludeFilenameSpelling set the start ptr to null, there was an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Integrability,depend,depends,42,"// If this file is older than the file it depends on, emit a diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:32,Integrability,message,message,32,// Lex tokens at the end of the message and include them in the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:64,Integrability,message,message,64,// Lex tokens at the end of the message and include them in the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Performance,Load,Load,3,// Load the extracted text as a preprocessed module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:51,Availability,down,down,51,"// If this is specified to be in a namespace, step down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:95,Availability,error,error,95,"// If there is already a pragma handler with the name of this namespace,; // we either have an error (directive with the same name as a namespace) or; // we already have the namespace to insert into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:198,Availability,error,error,198,"/// RemovePragmaHandler - Remove the specific pragma handler from the; /// preprocessor. If \arg Namespace is non-null, then it should be the; /// namespace that \arg Handler was added to. It is an error to remove; /// a handler that has not been registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:51,Availability,down,down,51,"// If this is specified to be in a namespace, step down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:61,Usability,usab,usable,61,"/// PragmaPoisonHandler - ""\#pragma poison x"" marks x as not usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:172,Safety,avoid,avoid,172,"/// ""\#pragma warning(...)"". MSVC's diagnostics do not map cleanly to clang's; /// diagnostics, so we don't really implement this pragma. We parse it and; /// ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:90,Availability,error,error,90,"// Parse things like:; // warning(push, 1); // warning(pop); // warning(disable : 1 2 3 ; error : 4 5 6 ; suppress : 7 8 9)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:168,Safety,avoid,avoid,168,"/// ""\#pragma execution_character_set(...)"". MSVC supports this pragma only; /// for ""UTF-8"". We parse it and ignore it if UTF-8 is provided and warn; /// otherwise to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:446,Availability,error,error,446,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:65,Integrability,message,message,65,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:128,Integrability,message,message,128,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:204,Integrability,message,message,204,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:494,Integrability,message,message,494,"/// PragmaMessageHandler - Handle the microsoft and gcc \#pragma message; /// extension. The syntax is:; /// \code; /// #pragma message(string); /// \endcode; /// OR, in GCC mode:; /// \code; /// #pragma message string; /// \endcode; /// string is a string, which is fully macro expanded, and permits string; /// concatenation, embedded escape characters, etc... See MSDN for more details.; /// Also handles \#pragma GCC warning and \#pragma GCC error which take the same; /// form as \#pragma message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:31,Integrability,message,message,31,// We have a MSVC style pragma message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:30,Integrability,message,message,30,"// We have a GCC style pragma message, and we just read the string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:14,Integrability,message,message,14,// Output the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Performance,load,load,39,"// If we have a non-empty module path, load the named module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:78,Performance,load,loaded,78,// Find the module we're entering. We require that a module map for it; // be loaded or implicitly loadable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:99,Performance,load,loadable,99,// Find the module we're entering. We require that a module map for it; // be loaded or implicitly loadable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:23,Availability,avail,available,23,"// If the module isn't available, it doesn't make sense to enter it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:37,Performance,load,load,37,/// Handle the clang \#pragma module load extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Performance,Load,Load,3,"// Load the module, don't make it visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:36,Security,audit,audit,36,// The start location of the active audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Security,audit,audit,42,// Complain about attempts to re-enter an audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Security,audit,audit,39,// Complain about attempts to leave an audit that doesn't exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:36,Security,audit,audit,36,// The start location of the active audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,Security,audit,audit,42,// Complain about attempts to re-enter an audit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:39,Security,audit,audit,39,// Complain about attempts to leave an audit that doesn't exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:202,Safety,avoid,avoid,202,"/// ""\#pragma managed""; /// ""\#pragma managed(...)""; /// ""\#pragma unmanaged""; /// MSVC ignores this pragma when not compiling using /clr, which clang doesn't; /// support. We parse it and ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:69,Integrability,message,message,69,/// This handles parsing pragmas that take a macro name and optional message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:115,Integrability,Message,Message,115,"/// ""\#pragma clang deprecated(...)""; ///; /// The syntax is; /// \code; /// #pragma clang deprecate(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:132,Integrability,Message,Message,132,"/// ""\#pragma clang restrict_expansion(...)""; ///; /// The syntax is; /// \code; /// #pragma clang restrict_expansion(MACRO_NAME [, Message]); /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:43,Deployability,Install,Install,43,// namespace; /// RegisterBuiltinPragmas - Install the standard preprocessor pragmas:; /// \#pragma GCC poison/system_header/dependency and \#pragma once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:125,Integrability,depend,dependency,125,// namespace; /// RegisterBuiltinPragmas - Install the standard preprocessor pragmas:; /// \#pragma GCC poison/system_header/dependency and \#pragma once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Safety,Safe,Safe,3,// Safe Buffers pragmas,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:20,Modifiability,plugin,plugins,20,// Pragmas added by plugins,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:142,Safety,avoid,avoid,142,/// Returns true if the preprocessed entity that \arg PPEI iterator; /// points to is coming from the file \arg FID.; ///; /// Can be used to avoid implicit deserializations of preallocated; /// preprocessed entities if we only care about entities of a specific file; /// and not from files \#included in the range given at; /// \see getPreprocessedEntitiesInRange.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:24,Performance,load,loaded,24,// Check if range spans loaded entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:16,Performance,load,loaded,16,// Range spands loaded and local entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:17,Performance,load,loaded,17,/// Retrieve the loaded preprocessed entity at the given index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:13,Performance,load,load,13,// Failed to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:421,Integrability,interface,interface,421,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:722,Integrability,depend,dependency-file,722,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:797,Integrability,Message,Messages,797,"//===- Preprocessor.cpp - C Language Family Preprocessor Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Preprocessor interface.; //; //===----------------------------------------------------------------------===//; //; // Options to support:; // -H - Print the name of each header file used.; // -d[DNI] - Dump various things.; // -fworking-directory - #line's with preprocessor's working dir.; // -fpreprocessed; // -dependency-file,-M,-MM,-MF,-MG,-MP,-MT,-MQ,-MD,-MMD; // -W*; // -w; //; // Messages to emit:; // ""Multiple include guards may be useful for:\n""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:45,Performance,load,loaded,45,"// As the language options may have not been loaded yet (when; // deserializing an ASTUnit), adding keywords to the identifier table is; // deferred to Preprocessor::Initialize().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:12,Performance,cache,cached,12,"// Free any cached macro expanders.; // This populates MacroArgCache, so all TokenLexers need to be destroyed; // before the code below that frees up the MacroArgCache list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:12,Performance,cache,cached,12,// Free any cached MacroArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Performance,Load,Load,3,// Load the actual file's contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:186,Safety,avoid,avoided,186,/// getSpelling - This method is used to get the spelling of a token into a; /// SmallVector. Note that the returned StringRef may not point to the; /// supplied buffer if a copy can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:41,Testability,test,testing,41,// NOTE: this has to be checked *before* testing for an IdentifierInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Performance,load,loaded,20,"// If MainFileID is loaded it means we loaded an AST file, no need to enter; // a main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:39,Performance,load,loaded,39,"// If MainFileID is loaded it means we loaded an AST file, no need to enter; // a main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:109,Availability,error,error,109,"// Lookup and save the FileID for the through header. If it isn't found; // in the search path, it's a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:327,Availability,error,error,327,"/// Skip tokens until after the #include of the through header or; /// until after a #pragma hdrstop is seen. Tokens in the predefines file; /// and the main file may be skipped. If the end of the predefines file; /// is reached, skipping continues into the main file. If the end of the; /// main file is reached, it's a fatal error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:310,Deployability,install,install,310,"//===----------------------------------------------------------------------===//; // Lexer Event Handling.; //===----------------------------------------------------------------------===//; /// LookUpIdentifierInfo - Given a tok::raw_identifier token, look up the; /// identifier information for the token and install it into the token,; /// updating the token kind accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Deployability,Update,Update,3,"// Update the token info (identifier info and appropriate token kind).; // FIXME: the raw_identifier may contain leading whitespace which is removed; // from the cleaned identifier token. The SourceLocation should be updated to; // refer to the non-whitespace character. For instance, the text ""\\\nB"" (a; // line continuation before 'B') is parsed as a single tok::raw_identifier and; // is cleaned to tok::identifier ""B"". After cleaning the token's length is; // still 3 and the SourceLocation refers to the location of the backslash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:217,Deployability,update,updated,217,"// Update the token info (identifier info and appropriate token kind).; // FIXME: the raw_identifier may contain leading whitespace which is removed; // from the cleaned identifier token. The SourceLocation should be updated to; // refer to the non-whitespace character. For instance, the text ""\\\nB"" (a; // line continuation before 'B') is parsed as a single tok::raw_identifier and; // is cleaned to tok::identifier ""B"". After cleaning the token's length is; // still 3 and the SourceLocation refers to the location of the backslash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:60,Deployability,update,update,60,"// If the information about this identifier is out of date, update it from; // the external source.; // We have to treat __VA_ARGS__ in a special way, since it gets; // serialized with isPoisoned = true, but our preprocessor may have; // unpoisoned it if we're defining a C99 macro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:99,Availability,error,error,99,"// If this identifier was poisoned, and if it was not produced from a macro; // expansion, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,Safety,avoid,avoid,59,"// If this is an extension token, diagnose its use.; // We avoid diagnosing tokens that originate from macro definitions.; // FIXME: This warning is disabled in cases where it shouldn't be,; // like ""#define TY typeof"", ""TY(1) x"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,Safety,avoid,avoids,59,// We loop here until a lex function returns a token; this avoids recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:33,Safety,avoid,avoid,33,// Set IdenfitierInfo to null to avoid confusing code that handles both; // identifiers and completion tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Deployability,Update,Update,3,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:158,Deployability,Update,Update,158,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:252,Deployability,update,updates,252,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:317,Integrability,depend,depends,317,"// Update StdCXXImportSeqState to track our position within a C++20 import-seq; // if this token is being produced as a result of phase 4 of translation.; // Update TrackGMFState to decide if we are currently in a Global Module; // Fragment. GMF state updates should precede StdCXXImportSeq ones, since GMF state; // depends on the prevailing StdCXXImportSeq state in two cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,Integrability,inject,injected,17,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,Security,inject,injected,17,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:238,Availability,failure,failure,238,"/// Lex a header-name token (including one formed from header-name-tokens if; /// \p AllowConcatenation is \c true).; ///; /// \param FilenameTok Filled in with the next token. On success, this will; /// be either a header_name token. On failure, it will be whatever other; /// token was found instead.; /// \param AllowMacroExpansion If \c true, allow the header name to be formed; /// by macro expansion (concatenating tokens as necessary if the first; /// token is a '<').; /// \return \c true if we reached EOD or EOF while looking for a > token in; /// a concatenated header name and diagnosed it. \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:139,Usability,clear,clear,139,// Consume tokens until we find a '>'.; // FIXME: A header-name could be formed starting or ending with an; // alternative token. It's not clear whether that's ill-formed in all; // cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:14,Availability,error,error,14,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Availability,recover,recovery,20,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,Safety,recover,recovery,20,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a holding buffer for a sequence of tokens and introduce it into; // the token stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:102,Performance,cache,cache,102,// Enter the header-name token into the token stream; a Lex action cannot; // both return a token and cache tokens (doing so would corrupt the token; // cache if the call to Lex comes from CachingLex / PeekAhead).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:153,Performance,cache,cache,153,// Enter the header-name token into the token stream; a Lex action cannot; // both return a token and cache tokens (doing so would corrupt the token; // cache if the call to Lex comes from CachingLex / PeekAhead).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:2,Security,Hash,HashLoc,2,/*HashLoc*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:192,Performance,perform,performing,192,"// Under the standard C++ Modules, the dot is just part of the module name,; // and not a real hierarchy separator. Flatten such module names now.; //; // FIXME: Is this the right level to be performing this transformation?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:22,Performance,load,load,22,// We don't/shouldn't load the standard c++20 modules when preprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:28,Safety,Safe,SafeBufferOptOutMap,28,// Try to find a region in `SafeBufferOptOutMap` where `Loc` is in:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:6,Testability,test,test,6,// To test if the start location of the found region precedes `Loc`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp:436,Integrability,interface,interfaces,436,"//===- PreprocessorLexer.cpp - C Language Family Lexer --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the PreprocessorLexer and Token interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessorLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:422,Integrability,interface,interface,422,"//===--- ScratchBuffer.cpp - Scratch space for forming tokens -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScratchBuffer interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:108,Modifiability,extend,extended,108,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:29,Performance,cache,cache,29,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:3,Usability,Clear,Clear,3,// Clear out the source line cache if it's already been computed.; // FIXME: Allow this to be incrementally extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp:107,Energy Efficiency,allocate,allocate,107,"// Only pay attention to the requested length if it is larger than our default; // page size. If it is, we allocate an entire chunk for it. This is to; // support gigantic tokens, which almost certainly won't happen. :)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ScratchBuffer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:54,Safety,Avoid,Avoidance,54,"//===--- TokenConcatenation.cpp - Token Concatenation Avoidance -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenConcatenation class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:36,Safety,Avoid,AvoidConcat,36,// These tokens have custom code in AvoidConcat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:71,Safety,avoid,avoiding,71,"/// GetFirstChar - Get the first character of the token \arg Tok,; /// avoiding calls to getSpelling where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:3,Safety,Avoid,Avoid,3,"// Avoid spelling identifiers, the most common form of token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:4,Safety,Avoid,AvoidConcat,4,"/// AvoidConcat - If printing PrevTok immediately followed by Tok would cause; /// the two individual tokens to be lexed as a single token, return true; /// (which causes a space to be printed between them). This allows the output; /// of -E mode to be lexed to the same token stream as lexing the input; /// directly would.; ///; /// This code must conservatively return true if it doesn't want to be 100%; /// accurate. This will cause the output to include extra space characters,; /// but the resulting output won't have incorrect concatenations going on.; /// Examples include "".."", which we print with a space between, because we; /// don't want to track enough to tell ""x.."" from ""..."".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:81,Safety,avoid,avoid,81,// Language keyword or named operator.; // Look up information on when we should avoid concatenation with prevtok.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:37,Safety,avoid,avoid,37,"// If the next token is '=' or '==', avoid concatenation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:112,Safety,avoid,avoid,112,"// Otherwise, this is a narrow character or string. If the *identifier*; // is a literal 'L', 'u8', 'u' or 'U', avoid pasting L ""foo"" -> L""foo"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:419,Integrability,interface,interface,419,"//===- TokenLexer.cpp - Lex from a token stream ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenLexer interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:205,Safety,avoid,avoid,205,// Reserve a source location entry chunk for the length of the macro; // definition. Tokens that get lexed directly from the definition will; // have their locations pointing inside this chunk. This is to avoid; // creating separate source location entries for each token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:14,Availability,avail,available,14,// Is a comma available to be removed?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:103,Performance,perform,perform,103,// FIXME: Should we keep track within VCtx that we did or didnot; // encounter pasting - and only then perform this loop.; // Perform token pasting (concatenation) prior to stringization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:126,Performance,Perform,Perform,126,// FIXME: Should we keep track within VCtx that we did or didnot; // encounter pasting - and only then perform this loop.; // Perform token pasting (concatenation) prior to stringization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:148,Deployability,install,install,148,"// Loop through 'Tokens', expanding them into ResultToks. Keep; // track of whether we change anything. If not, no need to keep them. If so,; // we install the newly expanded sequence as the new 'Tokens' list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:191,Performance,perform,perform,191,"// If we are about to process a token that is either an argument to; // __VA_OPT__ or its closing rparen, then:; // 1) If the token is the closing rparen that exits us out of __VA_OPT__,; // perform any necessary stringification or placemarker processing,; // and/or skip to the next token.; // 2) else if macro was invoked without variadic arguments skip this; // token.; // 3) else (macro was invoked with variadic arguments) process the token; // normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:156,Security,hash,hashhash,156,"// Current token is the closing r_paren which marks the end of the; // __VA_OPT__ invocation, so handle any place-marker pasting (if; // empty) by removing hashhash either before (if exists) or after. And; // also stringify the entire contents if VAOPT was preceded by a hash,; // but do so only after any token concatenation that needs to occur; // within the contents of VAOPT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:271,Security,hash,hash,271,"// Current token is the closing r_paren which marks the end of the; // __VA_OPT__ invocation, so handle any place-marker pasting (if; // empty) by removing hashhash either before (if exists) or after. And; // also stringify the entire contents if VAOPT was preceded by a hash,; // but do so only after any token concatenation that needs to occur; // within the contents of VAOPT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:145,Security,hash,hashhash,145,"// Treat VAOPT as a placemarker token. Eat either the '##' before the; // RHS/VAOPT (if one exists, suggesting that the LHS (if any) to that; // hashhash was not a placemarker) or the '##'; // after VAOPT, but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:22,Security,hash,hashhash,22,// Skip the following hashhash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:156,Safety,avoid,avoid,156,"// If there's a ## before the __VA_OPT__, we might have discovered; // that the __VA_OPT__ begins with a placeholder. We delay action on; // that to now to avoid messing up our stashed count of tokens before; // __VA_OPT__.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:19,Usability,simpl,simple,19,// Else handle the simple argument case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:70,Safety,avoid,avoids,70,// Only preexpand the argument if it could possibly need it. This; // avoids some work in common cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:208,Testability,test,test,208,"// In Microsoft-compatibility mode, we follow MSVC's preprocessing; // behavior by not considering single commas from nested macro; // expansions as argument separators. Set a flag on the token so we can; // test for this later when the macro expansion is processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:78,Safety,avoid,avoid,78,"// If the '##' came from expanding an argument, turn it into 'unknown'; // to avoid pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:137,Availability,error,error,137,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:121,Safety,avoid,avoid,121,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:64,Usability,learn,learned,64,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:78,Safety,avoid,avoid,78,"// If the '##' came from expanding an argument, turn it into 'unknown'; // to avoid pasting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:195,Energy Efficiency,reduce,reduces,195,// Do not remove the paste operator if it is the one before __VA_OPT__; // (and we are still processing tokens within VA_OPT). We handle the case; // of removing the paste operator if __VA_OPT__ reduces to the notional; // placemarker above when we encounter the closing paren of VA_OPT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:24,Deployability,install,install,24,"// If anything changed, install this as the new Tokens list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:46,Performance,cache,cache,46,// The tokens will be added to Preprocessor's cache and will be removed; // when this TokenLexer finishes lexing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:20,Performance,cache,cache,20,"// The preprocessor cache of macro expanded tokens owns these tokens,not us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:57,Modifiability,inherit,inherit,57,"// If this is the first token of the expanded result, we inherit spacing; // properties later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:61,Availability,error,error,61,"// If this identifier was poisoned and from a paste, emit an error. This; // won't be handled by Preprocessor::HandleIdentifier because this is coming; // from a macro expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,Availability,recover,recovery,54,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,Safety,recover,recovery,54,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for the result token. This is guaranteed to be enough for; // the two tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:58,Safety,Avoid,Avoid,58,// Common paste case: identifier+identifier = identifier. Avoid creating; // a lexer and other overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:74,Availability,error,error,74,"// If pasting the two tokens didn't form a full new token, this is an; // error. This occurs with ""x ## +"" and other stuff. Return with LHSTok; // unmodified and with RHS as the next token to lex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:76,Availability,error,error,76,// Test for the Microsoft extension of /##/ turning into // here on the; // error path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:3,Testability,Test,Test,3,// Test for the Microsoft extension of /##/ turning into // here on the; // error path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:19,Availability,error,error,19,// Do not emit the error when preprocessing assembler code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Availability,down,downgrade,42,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:73,Availability,error,error,73,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:115,Availability,error,error,115,"// If we're in microsoft extensions mode, downgrade this from a hard; // error to an extension that defaults to an error. This allows; // disabling it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:6,Availability,error,error,6,// An error has occurred so exit loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:29,Safety,avoid,avoid,29,// Turn ## into 'unknown' to avoid # ## # from looking like a paste; // operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:392,Deployability,update,updated,392,"/// Finds the tokens that are consecutive (from the same FileID); /// creates a single SLocEntry, and assigns SourceLocations to each token that; /// point to that SLocEntry. e.g for; /// assert(foo == bar);; /// There will be a single SLocEntry for the ""foo == bar"" chunk and locations; /// for the 'foo', '==', 'bar' tokens will point inside that chunk.; ///; /// \arg begin_tokens will be updated to a position past all the found; /// consecutive tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:188,Testability,assert,assert,188,"/// Finds the tokens that are consecutive (from the same FileID); /// creates a single SLocEntry, and assigns SourceLocations to each token that; /// point to that SLocEntry. e.g for; /// assert(foo == bar);; /// There will be a single SLocEntry for the ""foo == bar"" chunk and locations; /// for the 'foo', '==', 'bar' tokens will point inside that chunk.; ///; /// \arg begin_tokens will be updated to a position past all the found; /// consecutive tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:105,Safety,avoid,avoid,105,// The maximum distance between two consecutive tokens in a partition.; // This is an important trick to avoid using too much SourceLocation address; // space!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:135,Performance,optimiz,optimized,135,"// Partition the tokens by their FileID.; // This is a hot function, and calling getFileID can be expensive, the; // implementation is optimized by reducing the number of getFileID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Availability,recover,recovery,42,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:276,Energy Efficiency,allocate,allocates,276,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,Safety,recover,recovery,42,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:223,Safety,safe,safe,223,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:28,Deployability,update,updates,28,/// Creates SLocEntries and updates the locations of macro argument; /// tokens to their new expanded locations.; ///; /// \param ArgIdSpellLoc the location of the macro argument id inside the macro; /// definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,Availability,recover,recovers,147,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,Safety,recover,recovers,147,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:80,Energy Efficiency,allocate,allocate,80,// Do the equivalent of PP.getSpelling(Tok) except for the parts that would; // allocate memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:106,Integrability,interface,interface,106,"// namespace; //===----------------------------------------------------------------------===//; // Public interface to the file; //===----------------------------------------------------------------------===//; /// ParseAST - Parse the entire file specified, notifying the ASTConsumer as; /// the file is parsed. This inserts the parsed decls into the translation unit; /// held by Ctx.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Availability,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:3,Safety,Recover,Recover,3,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:139,Availability,error,error,139,"// If we got a null return and something *was* parsed, ignore it. This; // is due to a top-level semicolon, an action override, or a parse error; // skipping something.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:154,Availability,reliab,reliable,154,"// Finalize the template instantiation observer chain.; // FIXME: This (and init.) should be done in the Sema class, but because; // Sema does not have a reliable ""Finalize"" function (it has a; // destructor, but it is not guaranteed to be called (""-disable-free"")).; // So, do the initialization above and do the finalization here:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:140,Availability,error,errors,140,"// If we gave up at the completion point, the initializer list was; // likely truncated, so don't eat more tokens. We'll hit some extra; // errors, but they should be ignored in code completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:25,Availability,error,error,25,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:62,Availability,recover,recover,62,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:62,Safety,recover,recover,62,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of default argument' token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the original token position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:3,Availability,Error,Error,3,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:9,Availability,recover,recovery,9,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:9,Safety,recover,recovery,9,// Error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,Availability,recover,recover,22,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,Safety,recover,recover,22,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class which calls ParseLexedAttribute, after setting up the; /// scope appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:20,Availability,error,error,20,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:51,Performance,cache,cached,51,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:88,Performance,cache,cached,88,"// Due to a parsing error, we either went over the cached tokens or; // there are still cached tokens left, so we skip the leftover tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:264,Availability,error,error,264,/// Consume tokens and store them in the passed token container until; /// we've passed the try keyword and constructor initializers and have consumed; /// the opening brace of the function body. The opening brace will be consumed; /// if and only if there was no error.; ///; /// \return True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:297,Availability,error,error,297,/// Consume tokens and store them in the passed token container until; /// we've passed the try keyword and constructor initializers and have consumed; /// the opening brace of the function body. The opening brace will be consumed; /// if and only if there was no error.; ///; /// \return True on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:12,Availability,reliab,reliably,12,"// We can't reliably skip over a mem-initializer-id, because it could be; // a template-id involving not-yet-declared names. Given:; //; // S ( ) : a < b < c > ( e ); //; // 'e' might be an initializer or part of a template argument, depending; // on whether 'b' is a template.; // Track whether we might be inside a template argument. We can give; // significantly better diagnostics if we know that we're not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:234,Integrability,depend,depending,234,"// We can't reliably skip over a mem-initializer-id, because it could be; // a template-id involving not-yet-declared names. Given:; //; // S ( ) : a < b < c > ( e ); //; // 'e' might be an initializer or part of a template argument, depending; // on whether 'b' is a template.; // Track whether we might be inside a template argument. We can give; // significantly better diagnostics if we know that we're not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:270,Usability,clear,clear,270,"// We may be inside a template argument list. Grab up to the start of the; // next parenthesized initializer or braced-init-list. This *might* be the; // initializer, or it might be a subexpression in the template argument; // list.; // FIXME: Count angle brackets, and clear MightBeTemplateArgument; // if all angles are closed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,Availability,recover,recover,119,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,Safety,recover,recover,119,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:192,Safety,avoid,avoid,192,"// Number of possible unclosed <s we've seen so far. These might be templates,; // and might not, but if there were none of them (or we know for sure that; // we're within a template), we can avoid a tentative parse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:33,Performance,perform,perform,33,"// If we might be in a template, perform a tentative parse to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:57,Performance,perform,performed,57,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:157,Performance,perform,perform,157,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:33,Usability,undo,undo,33,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:390,Availability,down,downstream,390,"// Okay, we found a ']' or '}' or ')', which we think should be balanced.; // Since the user wasn't looking for this token (if they were, it would; // already be handled), this isn't balanced. If there is a LHS token at a; // higher level, we will assume that this matches the unbalanced token; // and return it. Otherwise, this is a spurious RHS token, which we; // consume and pass on to downstream code to diagnose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:443,Integrability,interface,interfaces,443,"//===--- ParseDecl.cpp - Declaration Parsing --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Declaration portions of the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:1386,Availability,error,error,1386,"/// ParseGNUAttributes - Parse a non-empty attributes list.; ///; /// [GNU] attributes:; /// attribute; /// attributes attribute; ///; /// [GNU] attribute:; /// '__attribute__' '(' '(' attribute-list ')' ')'; ///; /// [GNU] attribute-list:; /// attrib; /// attribute_list ',' attrib; ///; /// [GNU] attrib:; /// empty; /// attrib-name; /// attrib-name '(' identifier ')'; /// attrib-name '(' identifier ',' nonempty-expr-list ')'; /// attrib-name '(' argument-expression-list [C99 6.5.2] ')'; ///; /// [GNU] attrib-name:; /// identifier; /// typespec; /// typequal; /// storageclass; ///; /// Whether an attribute takes an 'identifier' is determined by the; /// attrib-name. GCC's behavior here is not worth imitating:; ///; /// * In C mode, if the attribute argument list starts with an identifier; /// followed by a ',' or an ')', and the identifier doesn't resolve to; /// a type, it is parsed as an identifier. If the attribute actually; /// wanted an expression, it's out of luck (but it turns out that no; /// attributes work that way, because C constant expressions are very; /// limited).; /// * In C++ mode, if the attribute argument list starts with an identifier,; /// and the attribute *wants* an identifier, it is parsed as an identifier.; /// At block scope, any additional tokens between the identifier and the; /// ',' or ')' are ignored, otherwise they produce a parse error.; ///; /// We follow the C++ model, but don't allow junk after the identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:11,Modifiability,parameteriz,parameterized,11,"// Handle ""parameterized"" attributes",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:105,Availability,error,error,105,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:222,Performance,perform,performed,222,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,Availability,error,errors,35,// Ensure typos get diagnosed when errors were encountered while parsing the; // expression list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,Availability,avail,available,27,// General case. Parse all available expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:29,Modifiability,parameteriz,parameterized,29,"/// Parse the arguments to a parameterized GNU attribute or; /// a C++11 attribute in ""gnu"" namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:16,Security,Access,AccessorNames,16,// indices into AccessorNames,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:13,Security,access,accessor,13,// Parse the accessor specifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:37,Security,access,accessor,37,// Stop if this doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:40,Security,access,accessor,40,// Handle the mistake of forgetting the accessor kind by skipping; // this accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Security,access,accessor,75,// Handle the mistake of forgetting the accessor kind by skipping; // this accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:41,Security,access,accessor,41,"// Otherwise, complain about the unknown accessor kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,Security,access,accessor,54,// Try to keep parsing unless it doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Security,access,accessors,21,// Just drop invalid accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:31,Security,access,accessor,31,"// Complain about the repeated accessor, ignore it, and keep parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Security,access,accessors,19,// Keep processing accessors until we run out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Modifiability,extend,extended-decl-modifier-seq,43,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:87,Modifiability,extend,extended-decl-modifier-seq,87,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:120,Modifiability,extend,extended-decl-modifier,120,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:153,Modifiability,extend,extended-decl-modifier,153,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:176,Modifiability,extend,extended-decl-modifier-seq,176,/// [MS] decl-specifier:; /// __declspec ( extended-decl-modifier-seq ); ///; /// [MS] extended-decl-modifier-seq:; /// extended-decl-modifier[opt]; /// extended-decl-modifier extended-decl-modifier-seq,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:52,Usability,simpl,simple-integer,52,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:72,Usability,simpl,simple-integer,72,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:91,Usability,simpl,simple-integer,91,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Usability,simpl,simple-integer,111,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:130,Usability,simpl,simple-integer,130,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:150,Usability,simpl,simple-integer,150,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:169,Usability,simpl,simple-integer,169,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:188,Usability,simpl,simple-integer,188,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:208,Usability,simpl,simple-integer,208,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:227,Usability,simpl,simple-integer,227,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:246,Usability,simpl,simple-integer,246,/// Parse a version number.; ///; /// version:; /// simple-integer; /// simple-integer '.' simple-integer; /// simple-integer '_' simple-integer; /// simple-integer '.' simple-integer '.' simple-integer; /// simple-integer '_' simple-integer '_' simple-integer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:31,Availability,avail,availability,31,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:66,Availability,avail,availability-attribute,66,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Availability,avail,availability,96,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:182,Integrability,message,message,182,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:544,Integrability,message,message,544,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:559,Integrability,message,message,559,"/// Parse the contents of the ""availability"" attribute.; ///; /// availability-attribute:; /// 'availability' '(' platform ',' opt-strict version-arg-list,; /// opt-replacement, opt-message')'; ///; /// platform:; /// identifier; ///; /// opt-strict:; /// 'strict' ','; ///; /// version-arg-list:; /// version-arg; /// version-arg ',' version-arg-list; ///; /// version-arg:; /// 'introduced' '=' version; /// 'deprecated' '=' version; /// 'obsoleted' = version; /// 'unavailable'; /// opt-replacement:; /// 'replacement' '=' <string>; /// opt-message:; /// 'message' '=' <string>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Availability,avail,availability,10,/*Source='availability attribute'*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Availability,avail,availability,21,// The 'unavailable' availability cannot be combined with any other; // availability changes. Make sure that hasn't happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:72,Availability,avail,availability,72,// The 'unavailable' availability cannot be combined with any other; // availability changes. Make sure that hasn't happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:17,Availability,avail,availability,17,// Clear out the availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Usability,Clear,Clear,3,// Clear out the availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:227,Modifiability,variab,variable,227,"// Usually, `__attribute__((attrib)) class Foo {} var` means that attribute; // applies to var, not the type Foo.; // As an exception to the rule, __declspec(align(...)) before the; // class-key affects the type instead of the variable.; // Also, Microsoft-style [attributes] seem to affect the type instead of the; // variable.; // This function moves attributes that should apply to the type off DS to Attrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:319,Modifiability,variab,variable,319,"// Usually, `__attribute__((attrib)) class Foo {} var` means that attribute; // applies to var, not the type Foo.; // As an exception to the rule, __declspec(align(...)) before the; // class-key affects the type instead of the variable.; // Also, Microsoft-style [attributes] seem to affect the type instead of the; // variable.; // This function moves attributes that should apply to the type off DS to Attrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:319,Usability,simpl,simple-declaration,319,"/// ParseDeclaration - Parse a full 'declaration', which consists of; /// declaration-specifiers, some number of declarators, and a semicolon.; /// 'Context' should be a DeclaratorContext value. This returns the; /// location of the semicolon in DeclEnd.; ///; /// declaration: [C99 6.7]; /// block-declaration ->; /// simple-declaration; /// others [FIXME]; /// [C++] template-declaration; /// [C++] namespace-definition; /// [C++] using-directive; /// [C++] using-declaration; /// [C++11/C11] static_assert-declaration; /// others... [FIXME]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,Integrability,rout,routine,8,"// This routine returns a DeclGroup, if the thing we parsed only contains a; // single decl, convert it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:306,Energy Efficiency,allocate,allocate-directive,306,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:4,Usability,simpl,simple-declaration,4,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:691,Usability,simpl,simple-declaration,691,"/// simple-declaration: [C99 6.7: declaration] [C++ 7p1: dcl.dcl]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [C++11] attribute-specifier-seq decl-specifier-seq[opt]; /// init-declarator-list ';'; ///[C90/C++]init-declarator-list ';' [TODO]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///; /// for-range-declaration: [C++11 6.5p1: stmt.ranged]; /// attribute-specifier-seq[opt] type-specifier-seq declarator; ///; /// If RequireSemi is false, this does not check for a ';' at the end of the; /// declaration. If it is true, it checks for and eats it.; ///; /// If FRI is non-null, we might be parsing a for-range-declaration instead; /// of a simple-declaration. If we find that we are, we also parse the; /// for-range-initializer, and place it here.; ///; /// DeclSpecStart is used when decl-specifiers are parsed before parsing; /// the Declaration. The SourceLocation for this Decl is set to; /// DeclSpecStart if DeclSpecStart is non-null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:137,Integrability,interface,interface,137,"// 'inline namespace' at the start of a line is almost certainly; // a good place to pick back up parsing, except in an Objective-C; // @interface context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:130,Integrability,interface,interface,130,"// 'namespace' at the start of a line is almost certainly a good; // place to pick back up parsing, except in an Objective-C; // @interface context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:93,Availability,error,error,93,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:220,Availability,recover,recover,220,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:220,Safety,recover,recover,220,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:182,Modifiability,extend,extended,182,// Look at the next token to make sure that this isn't a function; // declaration. We have to check this because __attribute__ might be the; // start of a function definition in GCC-extended K&R C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:211,Modifiability,variab,variable,211,"// C++0x [stmt.iter]p1: Check if we have a for-range-declarator. If so, we; // must parse and analyze the for-range-initializer before the declaration is; // analyzed.; //; // Handle the Objective-C for-in loop variable similarly, although we; // don't need to parse the container in advance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';') or an; // error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,Availability,recover,recover,196,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,Safety,recover,recover,196,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Availability,error,error,111,"/// Parse an optional simple-asm-expr and attributes, and attach them to a; /// declarator. Returns true on an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:22,Usability,simpl,simple-asm-expr,22,"/// Parse an optional simple-asm-expr and attributes, and attach them to a; /// declarator. Returns true on an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,Usability,simpl,simple-asm-expr,8,"// If a simple-asm-expr is present, parse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:342,Usability,simpl,simple-asm-expr,342,"/// Parse 'declaration' after parsing 'declaration-specifiers; /// declarator'. This method parses the remainder of the declaration; /// (including any attributes or initializer, among other things) and; /// finalizes the declaration.; ///; /// init-declarator: [C99 6.7]; /// declarator; /// declarator '=' initializer; /// [GNU] declarator simple-asm-expr[opt] attributes[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] '=' initializer; /// [C++] declarator initializer[opt]; ///; /// [C++] initializer:; /// [C++] '=' initializer-clause; /// [C++] '(' expression-list ')'; /// [C++0x] '=' 'default' [TODO]; /// [C++0x] '=' 'delete'; /// [C++0x] braced-init-list; ///; /// According to the standard grammar, =default and =delete are function; /// definitions, but that definitely doesn't fit with the parser here.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:401,Usability,simpl,simple-asm-expr,401,"/// Parse 'declaration' after parsing 'declaration-specifiers; /// declarator'. This method parses the remainder of the declaration; /// (including any attributes or initializer, among other things) and; /// finalizes the declaration.; ///; /// init-declarator: [C99 6.7]; /// declarator; /// declarator '=' initializer; /// [GNU] declarator simple-asm-expr[opt] attributes[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] '=' initializer; /// [C++] declarator initializer[opt]; ///; /// [C++] initializer:; /// [C++] '=' initializer-clause; /// [C++] '(' expression-list ')'; /// [C++0x] '=' 'default' [TODO]; /// [C++0x] '=' 'delete'; /// [C++0x] braced-init-list; ///; /// According to the standard grammar, =default and =delete are function; /// definitions, but that definitely doesn't fit with the parser here.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:37,Modifiability,variab,variable,37,// FIXME: This check should be for a variable template instantiation only.; // Check that this is a valid instantiation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Availability,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:110,Availability,error,errors,110,"// We are trying to stop parser from looking for ';' in this for; // statement, therefore preventing spurious errors to be issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Availability,error,error,95,"// ParseExpressionList can sometimes succeed even when ThisDecl is not; // VarDecl. This is an error and it is reported in a call to; // Actions.ActOnInitializerError(). However, we call; // ProduceConstructorSignatureHelp only on VarDecls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Security,Validat,Validate,3,// Validate declspec for type-name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:361,Usability,simpl,simple-declaration,361,"/// isValidAfterIdentifierInDeclaratorAfterDeclSpec - Return true if the; /// specified token is valid after the identifier in a declarator which; /// immediately follows the declspec. For example, these things are valid:; ///; /// int x [ 4]; // direct-declarator; /// int x ( int y); // direct-declarator; /// int(int x ) // direct-declarator; /// int x ; // simple-declaration; /// int x = 17; // init-declarator-list; /// int x , y; // init-declarator-list; /// int x __asm__ (""foo""); // init-declarator-list; /// int x : 4; // struct-declarator; /// int x { 5}; // C++'0x unified initializers; ///; /// This is not, because 'x' does not immediately follow the declspec (though; /// ')' happens to be valid anyway).; /// int (x); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,Availability,recover,recovers,408,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,Safety,recover,recovers,408,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:587,Availability,error,error,587,"// If we see an identifier that is not a type name, we normally would; // parse it as the identifier being declared. However, when a typename; // is typo'd or the definition is not included, this will incorrectly; // parse the typename as the identifier name and fall over misparsing; // later parts of the diagnostic.; //; // As such, we try to do some look-ahead in cases where this would; // otherwise be an ""implicit-int"" case to see if this is invalid. For; // example: ""static foo_t x = 4;"" In this case, if we parsed foo_t as; // an identifier with implicit int, we'd get a parse error because the; // next token is obviously invalid for a type. Parse these as a case; // with an invalid type specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,error,error,73,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:113,Availability,recover,recovery,113,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:113,Safety,recover,recovery,113,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:82,Safety,avoid,avoid,82,"// If this token is valid for implicit int, e.g. ""static x = 4"", then; // we just avoid eating the identifier, so it will be parsed as the; // identifier in the declarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Availability,recover,recover,103,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:140,Integrability,depend,dependent,140,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Safety,recover,recover,103,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:74,Availability,error,error,74,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Availability,recover,recover,95,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,Safety,recover,recover,95,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:129,Availability,error,error,129,"// static x(4); // 'x' is not a type; // x(int n); // 'x' is not a type; // x (*p)[]; // 'x' is a type; //; // Since we're in an error case, we can afford to perform a tentative; // parse to determine which case we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:158,Performance,perform,perform,158,"// static x(4); // 'x' is not a type; // x(int n); // 'x' is not a type; // x (*p)[]; // 'x' is a type; //; // Since we're in an error case, we can afford to perform a tentative; // parse to determine which case we're in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,Modifiability,variab,variable,21,// This looks like a variable or function declaration. The type is; // probably missing. We're done parsing decl-specifiers.; // But only if we are not in a function prototype scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Availability,recover,recover,96,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Safety,recover,recover,96,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:67,Availability,error,error,67,"// Otherwise, the action had no suggestion for us. Mark this as an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:90,Availability,error,error,90,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Integrability,inject,inject,15,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,Integrability,message,messages,96,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,avoid,avoid,75,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Security,inject,inject,15,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:273,Availability,error,error,273,"/// Determine whether we're looking at something that might be a declarator; /// in a simple-declaration. If it can't possibly be a declarator, maybe; /// diagnose a missing semicolon after a prior tag definition in the decl; /// specifier.; ///; /// \return \c true if an error occurred and this can't be any kind of; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:86,Usability,simpl,simple-declaration,86,"/// Determine whether we're looking at something that might be a declarator; /// in a simple-declaration. If it can't possibly be a declarator, maybe; /// diagnose a missing semicolon after a prior tag definition in the decl; /// specifier.; ///; /// \return \c true if an error occurred and this can't be any kind of; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:123,Usability,simpl,simple-declaration,123,"// If we have a type expressed as a template-id, this cannot be a; // declarator-id (such a type cannot be redeclared in a simple-declaration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:61,Usability,simpl,simple-declaration,61,"// These tokens cannot come after the declarator-id in a; // simple-declaration, and are likely to come after a type-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:159,Availability,error,error,159,"// If the declarator-id has a scope specifier, it must redeclare a; // previously-declared entity. If that's a type (and this is not a; // typedef), that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Availability,recover,recover,10,"// Try to recover from the typo, by dropping the tag definition and parsing; // the problematic tokens as a type.; //; // FIXME: Split the DeclSpec into pieces for the standalone; // declaration and pieces for the following declaration, instead; // of assuming that all the other pieces attach to new declaration,; // and call ParsedFreeStandingDeclSpec as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Safety,recover,recover,10,"// Try to recover from the typo, by dropping the tag definition and parsing; // the problematic tokens as a type.; //; // FIXME: Split the DeclSpec into pieces for the standalone; // declaration and pieces for the following declaration, instead; // of assuming that all the other pieces attach to new declaration,; // and call ParsedFreeStandingDeclSpec as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:97,Availability,error,error,97,"// If we are in a operator context, convert it back into a type specifier; // context for better error handling later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Security,access,access,18,// Turn off usual access checking for template specializations and; // instantiations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Availability,recover,recover,30,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Safety,recover,recover,30,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,Availability,error,error,73,"// ::foo::bar; // C++ scope specifier. Annotate and loop, or bail out on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,Integrability,inject,injected-class-name,209,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,Security,inject,injected-class-name,209,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - `return type`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:150,Availability,error,errors,150,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:242,Availability,recover,recover,242,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:242,Safety,recover,recover,242,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template; // explicit instantiation and explicit specialization:; // - `return type`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:111,Availability,error,error,111,"// If this is not a typedef name, don't parse it as part of the declspec,; // it must be an implicit int or an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:119,Usability,guid,guide,119,"// Likewise, if this is a context where the identifier could be a template; // name, check whether this is a deduction guide declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:62,Integrability,protocol,protocol,62,// The identifier; // Objective-C supports type arguments and protocol references; // following an Objective-C object or object pointer; // type. Handle either one of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:173,Deployability,update,update,173,"// Any of the following tokens are likely the start of the user; // forgetting 'auto' or 'decltype(auto)', so diagnose.; // Note: if updating this list, please make sure we update; // isCXXDeclarationSpecifier's check for IsPlaceholderSpecifier to have; // a matching list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Safety,avoid,avoid,64,"// C++ for OpenCL does not allow virtual function qualifier, to avoid; // function pointers restricted in OpenCL v2.0 s6.9.a.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:14,Availability,error,error,14,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Availability,recover,recovery,20,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Safety,recover,recovery,20,// For better error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Availability,redundant,redundant,18,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Safety,redund,redundant,18,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,Security,access,access,10,// OpenCL access qualifiers:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:12,Availability,error,error,12,// After an error the next token can be an annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';'); // or an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Deployability,Install,Install,3,// Install the declarator into the current TagDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:40,Safety,avoid,avoid,40,// Skip to end of block or statement to avoid ext-warning on extra ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:133,Modifiability,extend,extend,133,// C++11 [temp.explicit]p12:; // The usual access controls do not apply to names used to specify; // explicit instantiations.; // We extend this to also cover explicit specializations. Note that; // we don't suppress if this turns out to be an elaborated type; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Security,access,access,43,// C++11 [temp.explicit]p12:; // The usual access controls do not apply to names used to specify; // explicit instantiations.; // We extend this to also cover explicit specializations. Note that; // we don't suppress if this turns out to be an elaborated type; // specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:791,Usability,clear,clear,791,"// This might be an enum-base or part of some unrelated enclosing context.; //; // 'enum E : base' is permitted in two circumstances:; //; // 1) As a defining-type-specifier, when followed by '{'.; // 2) As the sole constituent of a complete declaration -- when DS is empty; // and the next token is ';'.; //; // The restriction to defining-type-specifiers is important to allow parsing; // a ? new enum E : int{}; // _Generic(a, enum E : int{}); // properly.; //; // One additional consideration applies:; //; // C++ [dcl.enum]p1:; // A ':' following ""enum nested-name-specifier[opt] identifier"" within; // the decl-specifier-seq of a member-declaration is parsed as part of; // an enum-base.; //; // Other language modes supporting enumerations with fixed underlying types; // do not have clear rules on this, so we disambiguate to determine whether; // the tokens form a bit-field width or an enum-base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:118,Availability,error,error,118,"// Outside C++11, do not interpret the tokens as an enum-base if they do; // not make sense as one. In C++11, it's an error if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Availability,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,Safety,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Integrability,depend,dependent,19,// This enum has a dependent nested-name-specifier. Handle it as a; // dependent tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:71,Integrability,depend,dependent,71,// This enum has a dependent nested-name-specifier. Handle it as a; // dependent tag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Deployability,Install,Install,3,// Install the enumerator constant into EnumDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,Availability,avail,availability,28,// Now handle enum constant availability diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,Availability,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,Safety,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Integrability,protocol,protocol,20,"// GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:192,Integrability,depend,dependent,192,/// isDeclarationSpecifier() - Return true if the current token is part of a; /// declaration specifier.; ///; /// \param AllowImplicitTypename whether this is a context where T::type [T; /// dependent] can appear.; /// \param DisambiguatingWithExpression True to indicate that the purpose of; /// this check is to disambiguate between an expression and a declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:202,Integrability,message,message,202,"// If we're in Objective-C and we have an Objective-C class type followed; // by an identifier and then either ':' or ']', in a place where an; // expression is permitted, then this is probably a class message send; // missing the initial '['. In this case, we won't consider this to be; // the start of a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,Integrability,protocol,protocol,20,"// GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Usability,guid,guide,30,// C(X) -> ... is a deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,error,65,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Availability,recover,recovery,75,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,recover,recovery,75,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:56,Availability,error,errors,56,"// We parse rvalue refs in C++03, because otherwise the errors are scary.; // But we must not parse them in conversion-type-ids and new-type-ids, since; // those can be legitimately followed by a && operator.; // (The same thing can in theory happen after a trailing-return-type, but; // since those are a C++11 feature, there is no rejects-valid issue there.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:312,Modifiability,extend,extended,312,"/// ParseDeclaratorInternal - Parse a C or C++ declarator. The direct-declarator; /// is parsed by the function passed to it. Pass null, and the direct-declarator; /// isn't parsed at all, making this function effectively parse the C++; /// ptr-operator production.; ///; /// If the grammar of this construct is extended, matching changes must also be; /// made to TryParseDeclarator and MightBeDeclarator, and possibly to; /// isConstructorDeclarator.; ///; /// declarator: [C99 6.7.5] [C++ 8p4, dcl.decl]; /// [C] pointer[opt] direct-declarator; /// [C++] direct-declarator; /// [C++] ptr-operator declarator; ///; /// pointer: [C99 6.7.5]; /// '*' type-qualifier-list[opt]; /// '*' type-qualifier-list[opt] pointer; ///; /// ptr-operator:; /// '*' cv-qualifier-seq[opt]; /// '&'; /// [C++0x] '&&'; /// [GNU] '&' restrict[opt] attributes[opt]; /// [GNU?] '&&' restrict[opt] attributes[opt]; /// '::'[opt] nested-name-specifier '*' cv-qualifier-seq[opt]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:139,Integrability,message,messages,139,"// When correcting from misplaced brackets before the identifier, the location; // is saved inside the declarator so that other diagnostic messages can use; // them. This extracts and returns that location, or returns the provided; // location if a stored location does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:1588,Usability,simpl,simple-declaration,1588,"/// ParseDirectDeclarator; /// direct-declarator: [C99 6.7.5]; /// [C99] identifier; /// '(' declarator ')'; /// [GNU] '(' attributes declarator ')'; /// [C90] direct-declarator '[' constant-expression[opt] ']'; /// [C99] direct-declarator '[' type-qual-list[opt] assignment-expr[opt] ']'; /// [C99] direct-declarator '[' 'static' type-qual-list[opt] assign-expr ']'; /// [C99] direct-declarator '[' type-qual-list 'static' assignment-expr ']'; /// [C99] direct-declarator '[' type-qual-list[opt] '*' ']'; /// [C++11] direct-declarator '[' constant-expression[opt] ']'; /// attribute-specifier-seq[opt]; /// direct-declarator '(' parameter-type-list ')'; /// direct-declarator '(' identifier-list[opt] ')'; /// [GNU] direct-declarator '(' parameter-forward-declarations; /// parameter-type-list[opt] ')'; /// [C++] direct-declarator '(' parameter-declaration-clause ')'; /// cv-qualifier-seq[opt] exception-specification[opt]; /// [C++11] direct-declarator '(' parameter-declaration-clause ')'; /// attribute-specifier-seq[opt] cv-qualifier-seq[opt]; /// ref-qualifier[opt] exception-specification[opt]; /// [C++] declarator-id; /// [C++11] declarator-id attribute-specifier-seq[opt]; ///; /// declarator-id: [C++ 8]; /// '...'[opt] id-expression; /// '::'[opt] nested-name-specifier[opt] type-name; ///; /// id-expression: [C++ 5.1]; /// unqualified-id; /// qualified-id; ///; /// unqualified-id: [C++ 5.1]; /// identifier; /// operator-function-id; /// conversion-function-id; /// '~' class-name; /// template-id; ///; /// C++17 adds the following, which we also handle here:; ///; /// simple-declaration:; /// <decl-spec> '[' identifier-list ']' brace-or-equal-initializer ';'; ///; /// Note, any additional constructs added here may need corresponding changes; /// in isConstructorDeclarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Availability,Recover,Recover,44,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Safety,Recover,Recover,44,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,error,65,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Availability,recover,recovery,75,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,Safety,recover,recovery,75,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Deployability,update,update,30,// Parsed the unqualified-id; update range information and move along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,// The most likely error is that the ';' was forgotten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,"// If there was an error parsing parenthesized declarator, declarator; // scope may have been entered before. Don't do it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,Usability,simpl,simple,27,"// This could be something simple like ""int"" (in which case the declarator; // portion is empty), if an abstract-declarator is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:65,Availability,error,errors,65,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Safety,Detect,Detect,18,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:36,Usability,simpl,simple,36,"// Identifier lists follow a really simple grammar: the identifiers can; // be followed *only* by a "", identifier"" or "")"". However, K&R; // identifier lists are really rare in the brave new modern world, and; // it is very common for someone to typo a type in a non-K&R style; // list. If we are presented with something like: ""void foo(intptr x,; // float y)"", we don't want to start parsing the function declarator as; // though it is a K&R style declarator just because intptr is an; // invalid type.; //; // To handle this, we check to see if the token after the first; // identifier is a "","" or "")"". Only then do we parse it as an; // identifier list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,Energy Efficiency,efficient,efficient,15,// Maintain an efficient lookup of params we have seen so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:43,Availability,error,error,43,"// If this isn't an identifier, report the error and skip until ')'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,Testability,test,test,30,"// Reject 'typedef int y; int test(x, y)', but continue parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the maximum function scope depth.; // See https://bugs.llvm.org/show_bug.cgi?id=19607; // Note Sema::ActOnParamDeclarator calls ParmVarDecl::setScopeInfo with; // getFunctionPrototypeDepth() - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:28,Availability,error,error,28,"// Completely missing, emit error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,Availability,recover,recover,157,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,Safety,recover,recover,157,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,Availability,recover,recovery,626,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,Safety,recover,recovery,626,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:39,Performance,cache,cache,39,"// If we're inside a class definition, cache the tokens; // corresponding to the default argument. We'll actually parse; // them when we see the end of the class definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:363,Integrability,depend,depending,363,"// Note, in C89, this production uses the constant-expr production instead; // of assignment-expr. The only difference is that assignment-expr allows; // things like '=' and '*='. Sema rejects these in C89 mode because they; // are not i-c-e's, so we don't need to distinguish between the two here.; // Parse the constant-expression or assignment-expression now (depending; // on dialect).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,Availability,error,error,19,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:60,Availability,recover,recover,60,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:60,Safety,recover,recover,60,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,Availability,error,error,103,"// Something went wrong parsing the brackets, in which case,; // ParseBracketDeclarator has emitted an error, and we don't need to emit; // one here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:29,Availability,error,error,29,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,Integrability,message,message,35,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,Availability,error,error,54,// There could be leftover tokens (e.g. because of an error).; // Skip through until we reach the 'end of directive' token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:447,Integrability,interface,interfaces,447,"//===--- ParseDeclCXX.cpp - C++ Declaration Parsing -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the C++ Declaration portions of the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,Availability,recover,recovery,62,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,Safety,recover,recovery,62,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:45,Usability,simpl,simply,45,// The caller is what called check -- we are simply calling; // the close for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:37,Availability,error,error,37,// Template parameters are always an error here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:148,Availability,error,errors,148,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:348,Usability,simpl,simple-template-id,348,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:49,Availability,recover,recovering,49,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:135,Integrability,depend,depends,135,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:49,Safety,recover,recovering,49,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,Availability,recover,recover,27,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,Safety,recover,recover,27,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:39,Testability,assert,assertion,39,// Save the token name used for static assertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:44,Usability,simpl,simple,44,// Parse the expression; // C++11 [dcl.type.simple]p4:; // The operand of the decltype specifier is an unevaluated operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:21,Availability,error,error,21,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:110,Performance,cache,cache,110,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:190,Usability,resume,resume,190,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:286,Integrability,depend,depending,286,"/// ParseBaseTypeSpecifier - Parse a C++ base-type-specifier which is either a; /// class name or decltype-specifier. Note that we only check that the result; /// names a type; semantic analysis will need to verify that the type names a; /// class. The result is either a type or null, depending on whether a type; /// name was found.; ///; /// base-type-specifier: [C++11 class.derived]; /// class-or-decltype; /// class-or-decltype: [C++11 class.derived]; /// nested-name-specifier[opt] class-name; /// decltype-specifier; /// class-name: [C++ class.name]; /// identifier; /// simple-template-id; ///; /// In C++98, instead of base-type-specifier, we have:; ///; /// ::[opt] nested-name-specifier[opt] class-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:579,Usability,simpl,simple-template-id,579,"/// ParseBaseTypeSpecifier - Parse a C++ base-type-specifier which is either a; /// class name or decltype-specifier. Note that we only check that the result; /// names a type; semantic analysis will need to verify that the type names a; /// class. The result is either a type or null, depending on whether a type; /// name was found.; ///; /// base-type-specifier: [C++11 class.derived]; /// class-or-decltype; /// class-or-decltype: [C++11 class.derived]; /// nested-name-specifier[opt] class-name; /// decltype-specifier; /// class-name: [C++ class.name]; /// identifier; /// simple-template-id; ///; /// In C++98, instead of base-type-specifier, we have:; ///; /// ::[opt] nested-name-specifier[opt] class-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:59,Availability,error,error,59,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:65,Availability,recover,recovery,65,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:65,Safety,recover,recovery,65,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:30,Availability,error,error,30,// Fall through to produce an error below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:523,Availability,error,error,523,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:556,Availability,error,error,556,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:826,Availability,error,error,826,"// struct foo {...} constinit x;; // As shown above, type qualifiers and storage class specifiers absolutely; // can occur after class specifiers according to the grammar. However,; // almost no one actually writes code like this. If we see one of these,; // it is much more likely that someone missed a semi colon and the; // type/storage class specifier we're seeing is part of the *next*; // intended declaration, as in:; //; // struct foo { ... }; // typedef int X;; //; // We'd really like to emit a missing semicolon error instead of emitting; // an error on the 'int' saying that you can't have two type specifiers in; // the same declaration of X. Because of this, we look ahead past this; // token to see if it's a type specifier. If so, we know the code is; // otherwise invalid, so we can produce the expected semi error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:566,Usability,simpl,simple-template-id,566,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:838,Usability,simpl,simple-template-id,838,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:1119,Usability,simpl,simple-template-id,1119,"/// ParseClassSpecifier - Parse a C++ class-specifier [C++ class] or; /// elaborated-type-specifier [C++ dcl.type.elab]; we can't tell which; /// until we reach the start of a definition or see a token that; /// cannot start a definition.; ///; /// class-specifier: [C++ class]; /// class-head '{' member-specification[opt] '}'; /// class-head '{' member-specification[opt] '}' attributes[opt]; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; /// [GNU] class-key attributes[opt] identifier[opt] base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier; /// identifier base-clause[opt]; /// [GNU] class-key attributes[opt] nested-name-specifier[opt]; /// simple-template-id base-clause[opt]; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// elaborated-type-specifier: [C++ dcl.type.elab]; /// class-key ::[opt] nested-name-specifier[opt] identifier; /// class-key ::[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; ///; /// Note that the C++ class-specifier and elaborated-type-specifier,; /// together, subsume the C99 struct-or-union-specifier:; ///; /// struct-or-union-specifier: [C99 6.7.2.1]; /// struct-or-union identifier[opt] '{' struct-contents '}'; /// struct-or-union identifier; /// [GNU] struct-or-union attributes[opt] identifier[opt] '{' struct-contents; /// '}' attributes[opt]; /// [GNU] struct-or-union attributes[opt] identifier; /// struct-or-union:; /// 'struct'; /// 'union'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:93,Integrability,depend,dependent,93,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:51,Security,access,access,51,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:253,Security,access,access,253,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:155,Usability,simpl,simple-template-id,155,// C++20 [temp.class.spec] 13.7.5/10; // The usual access checking rules do not apply to non-dependent names; // used to specify template arguments of the simple-template-id of the; // partial specialization.; // C++20 [temp.spec] 13.9/6:; // The usual access checking rules do not apply to names in a declaration; // of an explicit instantiation or explicit specialization...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Modifiability,inherit,inheritance,9,// Parse inheritance specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:46,Modifiability,inherit,inheritance,46,// Allow attributes to precede or succeed the inheritance specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:269,Usability,undo,undo,269,"// HACK: MSVC doesn't consider _Atomic to be a keyword and its STL; // implementation for VS2013 uses _Atomic as an identifier for one of the; // classes in <atomic>. When we are parsing 'struct _Atomic', don't consider; // '_Atomic' to be a keyword. We are careful to undo this so that clang can; // use '_Atomic' in its own header files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Usability,simpl,simple-template-id,38,// Parse the (optional) class name or simple-template-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:60,Deployability,update,update,60,// Try to resolve the template name to a type template. May update Kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:123,Availability,error,error,123,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:129,Integrability,message,message,129,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:28,Usability,simpl,simple-template-id,28,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:583,Safety,detect,detect,583,"// There are four options here.; // - If we are in a trailing return type, this is always just a reference,; // and we must not try to parse a definition. For instance,; // [] () -> struct S { };; // does not define a type.; // - If we have 'struct foo {...', 'struct foo :...',; // 'struct foo final :' or 'struct foo final {', then this is a definition.; // - If we have 'struct foo;', then this is either a forward declaration; // or a friend declaration, which have to be treated differently.; // - Otherwise we have something like 'struct foo xyz', a reference.; //; // We also detect these erroneous cases to provide better diagnostic for; // C++11 attributes parsing.; // - attributes follow class name:; // struct foo [[]] {};; // - attributes appear before or after 'final':; // struct foo [[]] final [[]] {};; //; // However, in type-specifier-seq's, things look like declarations but are; // just references, e.g.; // new struct s;; // or; // &T::operator struct s;; // For these, DSC is DeclSpecContext::DSC_type_specifier or; // DeclSpecContext::DSC_alias_declaration.; // If there are attributes after class name, parse them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:64,Availability,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:64,Safety,recover,recover,64,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:177,Modifiability,variab,variable,177,"// If we are parsing a definition and stop at a base-clause, continue on; // until the semicolon. Continuing from the comma will just trick us into; // thinking we are seeing a variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:204,Availability,error,error,204,"// Friend template-ids are treated as references unless; // they have template headers, in which case they're ill-formed; // (FIXME: ""template <class T> friend class A<T>::B<int>;"").; // We diagnose this error in ActOnClassTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:14,Availability,down,down,14,"// Don't pass down template parameter lists if this is just a tag; // reference. For example, we don't need the template parameters here:; // template <class T> class A *makeA(T t);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:33,Integrability,depend,dependent,33,"// If ActOnTag said the type was dependent, try again with the; // less common call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:209,Availability,error,error,209,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:215,Availability,recover,recovery,215,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:344,Availability,recover,recover,344,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:215,Safety,recover,recovery,215,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:344,Safety,recover,recover,344,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:115,Availability,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:115,Safety,recover,recovers,115,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:411,Security,access,access-specifier,411,"/// ParseBaseSpecifier - Parse a C++ base-specifier. A base-specifier is; /// one entry in the base class list of a class specifier, for example:; /// class foo : public bar, virtual private baz {; /// 'public bar' and 'virtual private baz' are each base-specifiers.; ///; /// base-specifier: [C++ class.derived]; /// attribute-specifier-seq[opt] base-type-specifier; /// attribute-specifier-seq[opt] 'virtual' access-specifier[opt]; /// base-type-specifier; /// attribute-specifier-seq[opt] access-specifier 'virtual'[opt]; /// base-type-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:492,Security,access,access-specifier,492,"/// ParseBaseSpecifier - Parse a C++ base-specifier. A base-specifier is; /// one entry in the base class list of a class specifier, for example:; /// class foo : public bar, virtual private baz {; /// 'public bar' and 'virtual private baz' are each base-specifiers.; ///; /// base-specifier: [C++ class.derived]; /// attribute-specifier-seq[opt] base-type-specifier; /// attribute-specifier-seq[opt] 'virtual' access-specifier[opt]; /// base-type-specifier; /// attribute-specifier-seq[opt] access-specifier 'virtual'[opt]; /// base-type-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:23,Security,access,access,23,// Parse an (optional) access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:71,Security,access,access,71,"// Parse the 'virtual' keyword (again!), in case it came after the; // access specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:81,Security,access,access-specifier,81,/// getAccessSpecifierIfPresent - Determine whether the next token is; /// a C++ access-specifier.; ///; /// access-specifier: [C++ class.derived]; /// 'private'; /// 'protected'; /// 'public',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:109,Security,access,access-specifier,109,/// getAccessSpecifierIfPresent - Determine whether the next token is; /// a C++ access-specifier.; ///; /// access-specifier: [C++ class.derived]; /// 'private'; /// 'protected'; /// 'public',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:8,Usability,simpl,simple-asm-expr,8,"// If a simple-asm-expr is present, parse it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:130,Availability,error,errors,130,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:140,Availability,error,error,140,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:146,Availability,recover,recovery,146,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:146,Safety,recover,recovery,146,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Security,Access,Access,3,// Access declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Availability,recover,recover,9,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Safety,recover,recover,9,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:18,Security,access,access,18,// Turn off usual access checking for templates explicit specialization; // and instantiation.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:147,Security,access,access,147,// Turn off usual access checking for templates explicit specialization; // and instantiation.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:51,Security,access,access,51,// C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Recover,Recover,3,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,Availability,error,error,16,// Diagnose the error and pretend there is no in-class initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Availability,Error,Error,3,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Availability,recover,recovery,9,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,Safety,recover,recovery,9,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:46,Performance,cache,cache,46,// The initializer was deferred; parse it and cache the tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Safety,Avoid,Avoid,3,// Avoid later warnings about a class member of incomplete type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';'); // or an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:80,Safety,detect,detect,80,"/// ParseCXXMemberInitializer - Parse the brace-or-equal-initializer.; /// Also detect and reject any attempted defaulted/deleted function definition.; /// The location of the '=', if any, will be placed in EqualLoc.; ///; /// This does not check for a pure-specifier; that's handled elsewhere.; ///; /// brace-or-equal-initializer:; /// '=' initializer-expression; /// braced-init-list; ///; /// initializer-clause:; /// assignment-expression; /// braced-init-list; ///; /// defaulted/deleted function-definition:; /// '=' 'default'; /// '=' 'delete'; ///; /// Prior to C++0x, the assignment-expression in an initializer-clause must; /// be a constant-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:44,Security,access,access,44,// FIXME: We don't accept GNU attributes on access specifiers in OpenCL mode; // yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Security,access,access,26,// Current token is a C++ access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:70,Security,access,access,70,// The Microsoft extension __interface does not permit non-public; // access specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:149,Security,access,access-specifier,149,/// ParseCXXMemberSpecification - Parse the class definition.; ///; /// member-specification:; /// member-declaration member-specification[opt]; /// access-specifier ':' member-specification[opt]; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Availability,Error,ErrorType,2,/*ErrorType=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:24,Usability,simpl,simple-template-id,24,// base-clause can have simple-template-id; 'template' can't be there,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:7,Availability,recover,recovering,7,// Try recovering from missing { after base-clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:7,Safety,recover,recovering,7,// Try recovering from missing { after base-clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Availability,recover,recover,38,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,Safety,recover,recover,38,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:15,Performance,cache,cache,15,// Consume and cache the starting token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Performance,Cache,Cache,3,// Cache the tokens for the exception-specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,Availability,recover,recovery,74,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,Safety,recover,recovery,74,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:99,Integrability,rout,routine,99,"/// Pop the top class of the stack of classes that are; /// currently being parsed.; ///; /// This routine should be called when we have finished parsing the; /// definition of a class, but have not yet popped the Scope; /// associated with the class's definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:57,Performance,perform,perform,57,"// The victim is a nested class, but we will not need to perform; // any processing after the definition of this class since it has; // no members whose handling was delayed. Therefore, we can just; // remove this nested class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,Availability,recover,recover,161,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,Safety,recover,recover,161,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:116,Performance,cache,cached,116,"// If the attribute is named `directive`, we can consume its argument list; // and push the tokens from it into the cached token stream for a new OpenMP; // pragma directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:133,Availability,error,error,133,"// The attribute was allowed to have arguments, but none were provided; // even though the attribute parsed successfully. This is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:16,Availability,error,error,16,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Availability,recover,recovered,26,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Safety,recover,recovered,26,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:371,Availability,error,errors,371,"// Since none of C++'s keywords match [a-f]+, accepting just tok::l_brace,; // tok::r_brace, tok::minus, tok::identifier (think C000) and; // tok::numeric_constant (0000) should be enough. But the spelling of the; // uuid argument is checked later anyways, so there's no harm in accepting; // almost anything here.; // cl is very strict about whitespace in this form and errors out if any; // is present, so check the space flags on the tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,Security,access,access,26,// Current token is a C++ access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2382,Testability,log,logical-AND-expression,2382,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2453,Testability,log,logical-AND-expression,2453,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2515,Testability,log,logical-OR-expression,2515,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2556,Testability,log,logical-AND-expression,2556,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2584,Testability,log,logical-OR-expression,2584,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2611,Testability,log,logical-AND-expression,2611,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2686,Testability,log,logical-OR-expression,2686,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2713,Testability,log,logical-OR-expression,2713,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2788,Testability,log,logical-OR-expression,2788,"///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relational-expression; ///; /// AND-expression: [C99 6.5.10]; /// equality-expression; /// AND-expression '&' equality-expression; ///; /// exclusive-OR-expression: [C99 6.5.11]; /// AND-expression; /// exclusive-OR-expression '^' AND-expression; ///; /// inclusive-OR-expression: [C99 6.5.12]; /// exclusive-OR-expression; /// inclusive-OR-expression '|' exclusive-OR-expression; ///; /// logical-AND-expression: [C99 6.5.13]; /// inclusive-OR-expression; /// logical-AND-expression '&&' inclusive-OR-expression; ///; /// logical-OR-expression: [C99 6.5.14]; /// logical-AND-expression; /// logical-OR-expression '||' logical-AND-expression; ///; /// conditional-expression: [C99 6.5.15]; /// logical-OR-expression; /// logical-OR-expression '?' expression ':' conditional-expression; /// [GNU] logical-OR-expression '?' ':' conditional-expression; /// [C++] the third operand is an assignment-expression; ///; /// assignment-expression: [C99 6.5.16]; /// conditional-expression; /// unary-expression assignment-operator assignment-expression; /// [C++] throw-expression [C++ 15]; ///; /// assignment-operator: one of; /// = *= /= %= += -= <<= >>= &= ^= |=; ///; /// expression: [C99 6.5.17]; /// assignment-expression ...[opt]; /// expression ',' assignment-expression ...[opt]; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:4,Usability,Simpl,Simple,4,"/// Simple precedence-based parser for binary/ternary operators.; ///; /// Note: we diverge from the C99 grammar when parsing the assignment-expression; /// production. C99 specifies that the LHS of an assignment operator should be; /// parsed as a unary-expression, but consistency dictates that it be a; /// conditional-expession. In practice, the important thing here is that the; /// LHS of an assignment has to be an l-value, which productions between; /// unary-expression and conditional-expression don't produce. Because we want; /// consistency, we parse the LHS as a conditional-expression, then check for; /// l-value-ness in semantic analysis stages.; ///; /// \verbatim; /// pm-expression: [C++ 5.5]; /// cast-expression; /// pm-expression '.*' cast-expression; /// pm-expression '->*' cast-expression; ///; /// multiplicative-expression: [C99 6.5.5]; /// Note: in C++, apply pm-expression instead of cast-expression; /// cast-expression; /// multiplicative-expression '*' cast-expression; /// multiplicative-expression '/' cast-expression; /// multiplicative-expression '%' cast-expression; ///; /// additive-expression: [C99 6.5.6]; /// multiplicative-expression; /// additive-expression '+' multiplicative-expression; /// additive-expression '-' multiplicative-expression; ///; /// shift-expression: [C99 6.5.7]; /// additive-expression; /// shift-expression '<<' additive-expression; /// shift-expression '>>' additive-expression; ///; /// compare-expression: [C++20 expr.spaceship]; /// shift-expression; /// compare-expression '<=>' shift-expression; ///; /// relational-expression: [C99 6.5.8]; /// compare-expression; /// relational-expression '<' compare-expression; /// relational-expression '>' compare-expression; /// relational-expression '<=' compare-expression; /// relational-expression '>=' compare-expression; ///; /// equality-expression: [C99 6.5.9]; /// relational-expression; /// equality-expression '==' relational-expression; /// equality-expression '!=' relationa",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:9,Integrability,rout,routine,9,"/// This routine is called when the '@' is seen and consumed.; /// Current token is an Identifier and is not a 'try'. This; /// routine is necessary to disambiguate \@try-statement from,; /// for example, \@encode-expression.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:128,Integrability,rout,routine,128,"/// This routine is called when the '@' is seen and consumed.; /// Current token is an Identifier and is not a 'try'. This; /// routine is necessary to disambiguate \@try-statement from,; /// for example, \@encode-expression.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:9,Integrability,rout,routine,9,/// This routine is called when a leading '__extension__' is seen and; /// consumed. This is necessary because the token gets consumed in the; /// process of disambiguating between an expression and a declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:64,Integrability,message,message,64,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:183,Integrability,message,message,183,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:296,Integrability,message,message,296,"/// Parse an assignment expression where part of an Objective-C message; /// send has already been parsed.; ///; /// In this case \p LBracLoc indicates the location of the '[' of the message; /// send, and either \p ReceiverName or \p ReceiverExpr is non-null indicating; /// the receiver of the message.; ///; /// Since this handles full assignment-expression's, it handles postfix; /// expressions and other binary operators for these expressions as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:114,Testability,log,logical-or-expression,114,/// Parse a constraint-expression.; ///; /// \verbatim; /// constraint-expression: C++2a[temp.constr.decl]p1; /// logical-or-expression; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Testability,log,logical-and-expression,30,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:121,Testability,log,logical-and-expression,121,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:185,Testability,log,logical-and-expression,185,/// \brief Parse a constraint-logical-and-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-and-expression:; /// primary-expression; /// constraint-logical-and-expression '&&' primary-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:94,Testability,log,logical,94,"// Use InclusiveOr, the precedence just after '&&' to not parse the; // next arguments to the logical and.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Testability,log,logical-or-expression,30,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:120,Testability,log,logical-or-expression,120,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Testability,log,logical-and-expression,159,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:198,Testability,log,logical-or-expression,198,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:241,Testability,log,logical-and-expression,241,/// \brief Parse a constraint-logical-or-expression.; ///; /// \verbatim; /// C++2a[temp.constr.decl]p1; /// constraint-logical-or-expression:; /// constraint-logical-and-expression; /// constraint-logical-or-expression '||'; /// constraint-logical-and-expression; ///; /// \endverbatim,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:55,Availability,error,error,55,"// Consume the operator, saving the operator token for error reporting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:84,Integrability,message,message,84,"// In Objective-C++, alternative operator tokens can be used as keyword args; // in message expressions. Unconsume the token so that it can reinterpreted; // as an identifier in ParseObjCMessageExpressionBody. i.e., we support:; // [foo meth:0 and:0];; // [foo not_eq];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:37,Availability,error,error,37,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:43,Availability,recover,recovery,43,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:43,Safety,recover,recovery,43,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:41,Testability,log,logical-OR-expression,41,"// Handle this production specially:; // logical-OR-expression '?' expression ':' conditional-expression; // In particular, the RHS of the '?' is 'expression', not; // 'logical-OR-expression' as we might expect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:169,Testability,log,logical-OR-expression,169,"// Handle this production specially:; // logical-OR-expression '?' expression ':' conditional-expression; // In particular, the RHS of the '?' is 'expression', not; // 'logical-OR-expression' as we might expect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:62,Testability,log,logical-OR-expression,62,"// Special case handling of ""X ? Y : Z"" where Y is empty:; // logical-OR-expression '?' ':' conditional-expression [GNU]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,Error,Errors,10,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from parsing the RHS, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:87,Availability,error,errors,87,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from parsing the RHS, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,Error,Errors,10,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from ParseRHSOfBinaryExpression, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:87,Availability,error,errors,87,"// FIXME: Errors generated by the delayed typo correction should be; // printed before errors from ParseRHSOfBinaryExpression, not after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:50,Performance,perform,performed,50,"// In this case, ActOnBinOp or ActOnConditionalOp performed the; // CorrectDelayedTyposInExpr check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2419,Integrability,message,message-expr,2419,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2502,Integrability,protocol,protocol,2502,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2615,Usability,simpl,simple-type-specifier,2615,"/; /// unary-operator: one of; /// '&' '*' '+' '-' '~' '!'; /// [GNU] '__extension__' '__real' '__imag'; ///; /// primary-expression: [C99 6.5.1]; /// [C99] identifier; /// [C++] id-expression; /// constant; /// string-literal; /// [C++] boolean-literal [C++ 2.13.5]; /// [C++11] 'nullptr' [C++11 2.14.7]; /// [C++11] user-defined-literal; /// '(' expression ')'; /// [C11] generic-selection; /// [C++2a] requires-expression; /// '__func__' [C99 6.4.2.2]; /// [GNU] '__FUNCTION__'; /// [MS] '__FUNCDNAME__'; /// [MS] 'L__FUNCTION__'; /// [MS] '__FUNCSIG__'; /// [MS] 'L__FUNCSIG__'; /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:2691,Usability,simpl,simple-type-specifier,2691," /// [GNU] '__PRETTY_FUNCTION__'; /// [GNU] '(' compound-statement ')'; /// [GNU] '__builtin_va_arg' '(' assignment-expression ',' type-name ')'; /// [GNU] '__builtin_offsetof' '(' type-name ',' offsetof-member-designator')'; /// [GNU] '__builtin_choose_expr' '(' assign-expr ',' assign-expr ','; /// assign-expr ')'; /// [GNU] '__builtin_FILE' '(' ')'; /// [CLANG] '__builtin_FILE_NAME' '(' ')'; /// [GNU] '__builtin_FUNCTION' '(' ')'; /// [MS] '__builtin_FUNCSIG' '(' ')'; /// [GNU] '__builtin_LINE' '(' ')'; /// [CLANG] '__builtin_COLUMN' '(' ')'; /// [GNU] '__builtin_source_location' '(' ')'; /// [GNU] '__builtin_types_compatible_p' '(' type-name ',' type-name ')'; /// [GNU] '__null'; /// [OBJC] '[' objc-message-expr ']'; /// [OBJC] '\@selector' '(' objc-selector-arg ')'; /// [OBJC] '\@protocol' '(' identifier ')'; /// [OBJC] '\@encode' '(' type-name ')'; /// [OBJC] objc-string-literal; /// [C++] simple-type-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] simple-type-specifier braced-init-list [C++11 5.2.3]; /// [C++] typename-specifier '(' expression-list[opt] ')' [C++ 5.2.3]; /// [C++11] typename-specifier braced-init-list [C++11 5.2.3]; /// [C++] 'const_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'dynamic_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'reinterpret_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'static_cast' '<' type-name '>' '(' expression ')' [C++ 5.2p1]; /// [C++] 'typeid' '(' expression ')' [C++ 5.2p1]; /// [C++] 'typeid' '(' type-id ')' [C++ 5.2p1]; /// [C++] 'this' [C++ 9.3.2]; /// [G++] unary-type-trait '(' type-id ')'; /// [G++] binary-type-trait '(' type-id ',' type-id ')' [TODO]; /// [EMBT] array-type-trait '(' type-id ',' integer ')'; /// [clang] '^' block-literal; ///; /// constant: [C99 6.4.4]; /// integer-constant; /// floating-constant; /// enumeration-constant -> identifier; /// character-constant; ///; /// id-expression: [C++ 5.1]; /// unqualified-id; /// qu",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:166,Usability,simpl,simplify,166,"// This handles all of cast-expression, unary-expression, postfix-expression,; // and primary-expression. We handle them together like this for efficiency; // and to simplify handling of an expression starting with a '(' token: which; // may be one of a parenthesized expression, cast-expression, compound literal; // expression, or statement expression.; //; // If the parsed tokens consist of a primary-expression, the cases below; // break out of the switch; at the end we call ParsePostfixExpressionSuffix; // to handle the postfix expression suffixes. Cases that cannot be followed; // by postfix exprs should set AllowSuffix to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:3,Safety,Avoid,Avoid,3,// Avoid the unnecessary parse-time lookup in the common case; // where the syntax forbids a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:65,Deployability,update,update,65,"// If we find that this is in fact the name of a type trait,; // update the token kind in place and parse again to treat it as; // the appropriate kind of type trait.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:192,Integrability,message,message,192,"// In an Objective-C method, if we have ""super"" followed by an identifier,; // the token sequence is ill-formed. However, if there's a ':' or ']' after; // that identifier, this is probably a message send with a missing open; // bracket. Treat it as such.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Availability,Recover,Recovery,171,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:122,Integrability,message,message,122,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:228,Performance,perform,performing,228,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Safety,Recover,Recovery,171,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,Availability,down,down,21,// Make sure to pass down the right value for isAddressOfOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:91,Availability,error,error,91,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:97,Availability,recover,recovery,97,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:97,Safety,recover,recovery,97,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:28,Usability,simpl,simple-type-specifier,28,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:23,Usability,simpl,simple-type-specifier,23,// postfix-expression: simple-type-specifier '(' expression-list[opt] ')'; // simple-type-specifier braced-init-list; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:78,Usability,simpl,simple-type-specifier,78,// postfix-expression: simple-type-specifier '(' expression-list[opt] ')'; // simple-type-specifier braced-init-list; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:44,Integrability,message,message,44,"// C++11 lambda expressions and Objective-C message sends both start with a; // square bracket. There are three possibilities here:; // we have a valid lambda expression, we have an invalid lambda; // expression, or we have something that doesn't appear to be a lambda.; // If we're in the last case, we fall back to ParseObjCMessageExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:27,Integrability,message,message,27,// We assume Objective-C++ message expressions are not; // primary-expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:126,Availability,error,error,126,"// Check to see whether Res is a function designator only. If it is and we; // are compiling for OpenCL, we need to return an error as this implies; // that the address of the function is being taken, which is illegal in CL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:80,Availability,error,error,80,// FIXME: Don't parse a primary-expression suffix if we encountered a parse; // error already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:77,Integrability,message,message,77,"// If we see identifier: after an expression, and we're not already in a; // message send, then this is probably a message send with a missing; // opening bracket '['.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:115,Integrability,message,message,115,"// If we see identifier: after an expression, and we're not already in a; // message send, then this is probably a message send with a missing; // opening bracket '['.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,Integrability,message,message,30,// Fall through; this isn't a message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:427,Availability,recover,recover,427,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:285,Integrability,message,message,285,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:427,Safety,recover,recover,427,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:140,Performance,cache,cache,140,"// Handle OpenACC first, since 'AllowOpenACCArraySections' is only enabled; // when actively parsing a 'var' in a 'var-list' during clause/'cache'; // parsing, so it is the most specific, and best allows us to handle; // OpenACC and OpenMP at the same time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,Availability,error,error,16,// There was an error closing the brackets,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:16,Availability,error,error,16,"// If we got an error when parsing expression list, we don't call; // the CodeCompleteCall handler inside the parser. So call it here; // to make sure we get overload suggestions even when we are in the; // middle of a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:106,Safety,avoid,avoid,106,"// If there were delayed typos in the LHS or ArgExprs, call SkipUntil; // instead of PT.consumeClose() to avoid emitting extra diagnostics for; // the unmatched l_paren.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:21,Performance,perform,perform,21,"// Clang will try to perform expression based completion as a; // fallback, which is confusing in case of member references. So we; // stop here without any completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:32,Security,access,access,32,// Code completion for a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:311,Integrability,message,message,311,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:46,Security,access,access,46,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:158,Security,access,access,158,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:51,Availability,error,error,51,// FIXME: This loop leaks the index expressions on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:636,Integrability,bridg,bridged-cast-expression,636,"/// ParseParenExpression - This parses the unit that starts with a '(' token,; /// based on what is allowed by ExprType. The actual thing parsed is returned; /// in ExprType. If stopIfCastExpr is true, it will only return the parsed type,; /// not the parsed cast-expression.; ///; /// \verbatim; /// primary-expression: [C99 6.5.1]; /// '(' expression ')'; /// [GNU] '(' compound-statement ')' (if !ParenExprOnly); /// postfix-expression: [C99 6.5.2]; /// '(' type-name ')' '{' initializer-list '}'; /// '(' type-name ')' '{' initializer-list ',' '}'; /// cast-expression: [C99 6.5.4]; /// '(' type-name ')' cast-expression; /// [ARC] bridged-cast-expression; /// [ARC] bridged-cast-expression:; /// (__bridge type-name) cast-expression; /// (__bridge_transfer type-name) cast-expression; /// (__bridge_retained type-name) cast-expression; /// fold-expression: [C++1z]; /// '(' cast-expression fold-operator '...' ')'; /// '(' '...' fold-operator cast-expression ')'; /// '(' cast-expression fold-operator '...'; /// fold-operator cast-expression ')'; /// [OPENMP] Array shaping operation; /// '(' '[' expression ']' { '[' expression ']' } cast-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:671,Integrability,bridg,bridged-cast-expression,671,"/// ParseParenExpression - This parses the unit that starts with a '(' token,; /// based on what is allowed by ExprType. The actual thing parsed is returned; /// in ExprType. If stopIfCastExpr is true, it will only return the parsed type,; /// not the parsed cast-expression.; ///; /// \verbatim; /// primary-expression: [C99 6.5.1]; /// '(' expression ')'; /// [GNU] '(' compound-statement ')' (if !ParenExprOnly); /// postfix-expression: [C99 6.5.2]; /// '(' type-name ')' '{' initializer-list '}'; /// '(' type-name ')' '{' initializer-list ',' '}'; /// cast-expression: [C99 6.5.4]; /// '(' type-name ')' cast-expression; /// [ARC] bridged-cast-expression; /// [ARC] bridged-cast-expression:; /// (__bridge type-name) cast-expression; /// (__bridge_transfer type-name) cast-expression; /// (__bridge_retained type-name) cast-expression; /// fold-expression: [C++1z]; /// '(' cast-expression fold-operator '...' ')'; /// '(' '...' fold-operator cast-expression ')'; /// '(' cast-expression fold-operator '...'; /// fold-operator cast-expression ')'; /// [OPENMP] Array shaping operation; /// '(' '[' expression ']' { '[' expression ']' } cast-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:19,Integrability,bridg,bridge,19,// Diagnose use of bridge casts in non-arc mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:105,Availability,error,error,105,// None of these cases should fall through with an invalid Result; // unless they've already reported an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:45,Modifiability,Variab,Variables,45,"// Find the nearest non-record decl context. Variables declared in a; // statement expression behave as if they were declared in the enclosing; // function, block, or other code construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Availability,Recover,Recover,159,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:108,Integrability,message,message,108,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Safety,Recover,Recover,159,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:12,Performance,perform,performed,12,// After we performed the cast we can check for postfix-expr pieces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:105,Availability,error,error,105,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:222,Performance,perform,performed,222,"// There's nothing to suggest in here as we parsed a full expression.; // Instead fail and propagate the error since caller might have something; // the suggest, e.g. signature help in function call. Note that this is; // performed before pushing the \p Expr, so that signature help can report; // current argument correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:35,Availability,error,errors,35,// Ensure typos get diagnosed when errors were encountered while parsing the; // expression list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:34,Usability,simpl,simple,34,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:143,Usability,simpl,simple-expression-list,143,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:199,Usability,simpl,simple-expression-list,199,"/// ParseSimpleExpressionList - A simple comma-separated list of expressions,; /// used for misc language extensions.; ///; /// \verbatim; /// simple-expression-list:; /// assignment-expression; /// simple-expression-list , assignment-expression; /// \endverbatim",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:178,Modifiability,variab,variable,178,"// Enter a scope to hold everything within the block. This includes the; // argument decls, decls within the compound expression, etc. This also; // allows determining whether a variable reference inside the block is; // within or outside of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:19,Availability,error,error,19,"// If there was an error parsing the arguments, they may have; // tried to use ^(x+y) which requires an argument list. Just; // skip the whole block literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:13,Availability,avail,availability,13,"/// Validate availability spec list, emitting diagnostics if necessary. Returns; /// true if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:4,Security,Validat,Validate,4,"/// Validate availability spec list, emitting diagnostics if necessary. Returns; /// true if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:95,Availability,error,error,95,"// Rule out multiple version specs referring to the same platform.; // For example, we emit an error for:; // @available(macos 10.10, macos 10.11, *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:111,Availability,avail,available,111,"// Rule out multiple version specs referring to the same platform.; // For example, we emit an error for:; // @available(macos 10.10, macos 10.11, *)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:10,Availability,avail,availability,10,/// Parse availability query specification.; ///; /// availability-spec:; /// '*'; /// identifier version-tuple,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:54,Availability,avail,availability-spec,54,/// Parse availability query specification.; ///; /// availability-spec:; /// '*'; /// identifier version-tuple,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:11,Availability,avail,available,11,// Eat the available or __builtin_available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Deployability,Update,Update,3,// Update token information to reflect their change in token type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1016,Availability,error,errors,1016,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1823,Availability,error,error,1823,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1829,Availability,recover,recovery,1829,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:2150,Availability,error,error,2150,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:191,Integrability,rout,routine,191,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1829,Safety,recover,recovery,1829,"that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nested-name-specifier, if any.; ///; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; ///; /// \returns true if there was an error parsing a scope specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:754,Security,access,access,754,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:849,Security,access,accessed,849,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:938,Security,access,access,938,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:499,Usability,simpl,simple-template-id,499,"/// Parse global scope or nested-name-specifier if present.; ///; /// Parses a C++ global scope specifier ('::') or nested-name-specifier (which; /// may be preceded by '::'). Note that this routine will not parse ::new or; /// ::delete; it will just leave them in the token stream.; ///; /// '::'[opt] nested-name-specifier; /// '::'; ///; /// nested-name-specifier:; /// type-name '::'; /// namespace-name '::'; /// nested-name-specifier identifier '::'; /// nested-name-specifier 'template'[opt] simple-template-id '::'; ///; ///; /// \param SS the scope specifier that will be set to the parsed; /// nested-name-specifier (or empty); ///; /// \param ObjectType if this nested-name-specifier is being parsed following; /// the ""."" or ""->"" of a member access expression, this parameter provides the; /// type of the object whose members are being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we will be entering into the context of; /// the nested-name-specifier after parsing it.; ///; /// \param MayBePseudoDestructor When non-NULL, points to a flag that; /// indicates whether this nested-name-specifier may be part of a; /// pseudo-destructor name. In this case, the flag will be set false; /// if we don't actually end up parsing a destructor name. Moreover,; /// if we do end up determining that we are parsing a destructor name,; /// the last component of the nested-name-specifier is not parsed as; /// part of the scope specifier.; ///; /// \param IsTypename If \c true, this nested-name-specifier is known to be; /// part of a type name. This is used to improve error recovery.; ///; /// \param LastII When non-NULL, points to an IdentifierInfo* that will be; /// filled in with the leading identifier in the last component of the; /// nest",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:166,Testability,assert,assertion,166,// Include code completion token into the range of the scope otherwise; // when we try to annotate the scope tokens the dangling code completion; // token will cause assertion in; // Preprocessor::AnnotatePreviousCachedTokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:254,Usability,clear,clear,254,"// C++ [basic.lookup.classref]p5:; // If the qualified-id has the form; //; // ::class-name-or-namespace-name::...; //; // the class-name-or-namespace-name is looked up in global scope as a; // class-name or namespace-name.; //; // To implement this, we clear out the object type as soon as we've; // seen a leading '::' or part of a nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Usability,simpl,simple-template-id,68,"// nested-name-specifier:; // nested-name-specifier 'template'[opt] simple-template-id '::'; // Parse the optional 'template' keyword, then make sure we have; // 'identifier <' after it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:82,Usability,simpl,simple-template-id,82,"// We don't need to actually parse the unqualified-id in this case,; // because a simple-template-id cannot start with 'operator', but; // go ahead and parse it anyway for consistency with the case where; // we already annotated the template-id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:163,Integrability,depend,dependent,163,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:93,Usability,simpl,simple-template-id,93,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Availability,Recover,Recover,68,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Safety,Recover,Recover,68,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,Availability,error,error,71,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:138,Availability,recover,recover,138,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:138,Safety,recover,recover,138,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:149,Availability,error,error,149,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Availability,recover,recovery,155,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Safety,recover,recovery,155,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Availability,error,errors,13,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Integrability,depend,dependent,46,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:229,Integrability,depend,dependent,229,"// We have something like t::getAs<T>, where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:592,Availability,error,error,592,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:677,Availability,error,error,677,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:944,Availability,error,errors,944,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:724,Usability,simpl,simplify,724,"/// ParseCXXIdExpression - Handle id-expression.; ///; /// id-expression:; /// unqualified-id; /// qualified-id; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' identifier; /// '::' operator-function-id; /// '::' template-id; ///; /// NOTE: The standard specifies that, for qualified-id, the parser does not; /// expect:; ///; /// '::' conversion-function-id; /// '::' '~' class-name; ///; /// This may cause a slight inconsistency on diagnostics:; ///; /// class C {};; /// namespace A {}; /// void f() {; /// :: A :: ~ C(); // Some Sema error about using destructor with a; /// // namespace.; /// :: ~ C(); // Some Parser error like 'unexpected ~'.; /// }; ///; /// We simplify the parser a bit and make it work like:; ///; /// qualified-id:; /// '::'[opt] nested-name-specifier 'template'[opt] unqualified-id; /// '::' unqualified-id; ///; /// That way Sema can handle and report similar errors for namespaces and the; /// global scope.; ///; /// The isAddressOfOperand parameter indicates that this id-expression is a; /// direct operand of the address-of operator. This is, besides member contexts,; /// the only place where a qualified-id naming a non-static class member may; /// appear.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:569,Usability,simpl,simple-capture,569,"/// ParseLambdaExpression - Parse a C++11 lambda expression.; ///; /// lambda-expression:; /// lambda-introducer lambda-declarator compound-statement; /// lambda-introducer '<' template-parameter-list '>'; /// requires-clause[opt] lambda-declarator compound-statement; ///; /// lambda-introducer:; /// '[' lambda-capture[opt] ']'; ///; /// lambda-capture:; /// capture-default; /// capture-list; /// capture-default ',' capture-list; ///; /// capture-default:; /// '&'; /// '='; ///; /// capture-list:; /// capture; /// capture-list ',' capture; ///; /// capture:; /// simple-capture; /// init-capture [C++1y]; ///; /// simple-capture:; /// identifier; /// '&' identifier; /// 'this'; ///; /// init-capture: [C++1y]; /// identifier initializer; /// '&' identifier initializer; ///; /// lambda-declarator:; /// lambda-specifiers [C++23]; /// '(' parameter-declaration-clause ')' lambda-specifiers; /// requires-clause[opt]; ///; /// lambda-specifiers:; /// decl-specifier-seq[opt] noexcept-specifier[opt]; /// attribute-specifier-seq[opt] trailing-return-type[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:620,Usability,simpl,simple-capture,620,"/// ParseLambdaExpression - Parse a C++11 lambda expression.; ///; /// lambda-expression:; /// lambda-introducer lambda-declarator compound-statement; /// lambda-introducer '<' template-parameter-list '>'; /// requires-clause[opt] lambda-declarator compound-statement; ///; /// lambda-introducer:; /// '[' lambda-capture[opt] ']'; ///; /// lambda-capture:; /// capture-default; /// capture-list; /// capture-default ',' capture-list; ///; /// capture-default:; /// '&'; /// '='; ///; /// capture-list:; /// capture; /// capture-list ',' capture; ///; /// capture:; /// simple-capture; /// init-capture [C++1y]; ///; /// simple-capture:; /// identifier; /// '&' identifier; /// 'this'; ///; /// init-capture: [C++1y]; /// identifier initializer; /// '&' identifier initializer; ///; /// lambda-declarator:; /// lambda-specifiers [C++23]; /// '(' parameter-declaration-clause ')' lambda-specifiers; /// requires-clause[opt]; ///; /// lambda-specifiers:; /// decl-specifier-seq[opt] noexcept-specifier[opt]; /// attribute-specifier-seq[opt] trailing-return-type[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:34,Integrability,message,message,34,// If lookahead indicates an ObjC message send...; // [identifier identifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:57,Integrability,message,message,57,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:200,Integrability,message,message,200,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:241,Integrability,rout,routines,241,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:39,Integrability,message,message,39,"// Not a lambda-introducer, might be a message send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,Availability,recover,recover,524,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,Safety,recover,recover,524,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Performance,Perform,Perform,3,// Perform some irreversible action if this is a non-tentative parse;; // otherwise note that our actions were incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:123,Integrability,message,message,123,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:182,Integrability,message,message,182,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:212,Performance,perform,perform,212,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:90,Integrability,message,message,90,"// If we're in Objective-C++ and we have a bare '[', then this is more; // likely to be a message receiver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:175,Availability,error,error,175,"// We have a lone ""&"" or ""="" which is either a misplaced capture-default; // or the start of a capture (in the ""&"" case) with the rest of the; // capture missing. Both are an error but a misplaced capture-default; // is more likely if we don't already have a capture default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:65,Usability,clear,clears,65,"// Each lambda init-capture forms its own full expression, which clears; // Actions.MaybeODRUseExprs. So create an expression evaluation context; // to save the necessary state, and restore it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:164,Integrability,message,message,164,"// We're disambiguating this:; //; // [..., x = expr; //; // We need to find the end of the following expression in order to; // determine whether this is an Obj-C message send's receiver, a; // C99 designator, or a lambda init-capture.; //; // Parse the expression to find where it ends, and annotate it back; // onto the tokens. We would have parsed this expression the same way; // in either case: both the RHS of an init-capture and the RHS of an; // assignment expression are parsed as an initializer-clause, and in; // neither case can anything be added to the scope between the '[' and; // here.; //; // FIXME: This is horrible. Adding a mechanism to skip an expression; // would be much cleaner.; // FIXME: If there is a ',' before the next ']' or ':', we can skip to; // that instead. (And if we see a ':' with no matching '?', we can; // classify this as an Obj-C message send.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:874,Integrability,message,message,874,"// We're disambiguating this:; //; // [..., x = expr; //; // We need to find the end of the following expression in order to; // determine whether this is an Obj-C message send's receiver, a; // C99 designator, or a lambda init-capture.; //; // Parse the expression to find where it ends, and annotate it back; // onto the tokens. We would have parsed this expression the same way; // in either case: both the RHS of an init-capture and the RHS of an; // assignment expression are parsed as an initializer-clause, and in; // neither case can anything be added to the scope between the '[' and; // here.; //; // FIXME: This is horrible. Adding a mechanism to skip an expression; // would be much cleaner.; // FIXME: If there is a ',' before the next ']' or ':', we can skip to; // that instead. (And if we see a ':' with no matching '?', we can; // classify this as an Obj-C message send.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Integrability,message,message,22,// Check if this is a message send before we act on a possible init-capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Integrability,message,message,22,// This can only be a message send. We're done with disambiguation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:8,Performance,perform,performs,8,"// This performs any lvalue-to-rvalue conversions if necessary, which; // can affect what gets captured in the containing decl-context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:122,Availability,error,error,122,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:181,Availability,recover,recover,181,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:181,Safety,recover,recover,181,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:64,Deployability,update,update,64,"// Parse mutable-opt and/or constexpr-opt or consteval-opt, and update; // the DeclEndLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:7,Availability,error,error,7,// For error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Integrability,message,messages,13,// For error messages,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:85,Availability,error,error,85,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:109,Availability,recover,recover,109,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:109,Safety,recover,recover,109,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:2,Security,Access,AccessSpecifier,2,/*AccessSpecifier=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:100,Modifiability,polymorphi,polymorphic,100,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:263,Modifiability,polymorphi,polymorphic,263,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:541,Testability,log,logic,541,"// C++0x [expr.typeid]p3:; // When typeid is applied to an expression other than an lvalue of a; // polymorphic class type [...] The expression is an unevaluated; // operand (Clause 5).; //; // Note that we can't tell whether the expression is an lvalue of a; // polymorphic class type until after we've parsed the expression; we; // speculatively assume the subexpression is unevaluated, and fix it up; // later.; //; // We enter the unevaluated context before trying to determine whether we; // have a type-id, because the tentative parse logic will try to resolve; // names, and must treat them as unevaluated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:991,Integrability,depend,dependent,991,"/// Parse a C++ pseudo-destructor expression after the base,; /// . or -> operator, and nested-name-specifier have already been; /// parsed. We're handling this fragment of the grammar:; ///; /// postfix-expression: [C++2a expr.post]; /// postfix-expression . template[opt] id-expression; /// postfix-expression -> template[opt] id-expression; ///; /// id-expression:; /// qualified-id; /// unqualified-id; ///; /// qualified-id:; /// nested-name-specifier template[opt] unqualified-id; ///; /// nested-name-specifier:; /// type-name ::; /// decltype-specifier :: FIXME: not implemented, but probably only; /// allowed in C++ grammar by accident; /// nested-name-specifier identifier ::; /// nested-name-specifier template[opt] simple-template-id ::; /// [...]; ///; /// unqualified-id:; /// ~ type-name; /// ~ decltype-specifier; /// [...]; ///; /// ... where the all but the last component of the nested-name-specifier; /// has already been parsed, and the base expression is not of a non-dependent; /// class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:728,Usability,simpl,simple-template-id,728,"/// Parse a C++ pseudo-destructor expression after the base,; /// . or -> operator, and nested-name-specifier have already been; /// parsed. We're handling this fragment of the grammar:; ///; /// postfix-expression: [C++2a expr.post]; /// postfix-expression . template[opt] id-expression; /// postfix-expression -> template[opt] id-expression; ///; /// id-expression:; /// qualified-id; /// unqualified-id; ///; /// qualified-id:; /// nested-name-specifier template[opt] unqualified-id; ///; /// nested-name-specifier:; /// type-name ::; /// decltype-specifier :: FIXME: not implemented, but probably only; /// allowed in C++ grammar by accident; /// nested-name-specifier identifier ::; /// nested-name-specifier template[opt] simple-template-id ::; /// [...]; ///; /// unqualified-id:; /// ~ type-name; /// ~ decltype-specifier; /// [...]; ///; /// ... where the all but the last component of the nested-name-specifier; /// has already been parsed, and the base expression is not of a non-dependent; /// class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:86,Usability,simpl,simple-template-id,86,"// If the last component of the (optional) nested-name-specifier is; // template[opt] simple-template-id, it has already been annotated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:324,Usability,simpl,simple-type-specifier,324,"/// ParseCXXTypeConstructExpression - Parse construction of a specified type.; /// Can be interpreted either as function-style casting (""int(x)""); /// or class type construction (""ClassType(x,y,z)""); /// or creation of a value-initialized type (""int()"").; /// See [C++ 5.2.3].; ///; /// postfix-expression: [C++ 5.2p1]; /// simple-type-specifier '(' expression-list[opt] ')'; /// [C++0x] simple-type-specifier braced-init-list; /// typename-specifier '(' expression-list[opt] ')'; /// [C++0x] typename-specifier braced-init-list; ///; /// In C++1z onwards, the type specifier can also be a template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:388,Usability,simpl,simple-type-specifier,388,"/// ParseCXXTypeConstructExpression - Parse construction of a specified type.; /// Can be interpreted either as function-style casting (""int(x)""); /// or class type construction (""ClassType(x,y,z)""); /// or creation of a value-initialized type (""int()"").; /// See [C++ 5.2.3].; ///; /// postfix-expression: [C++ 5.2p1]; /// simple-type-specifier '(' expression-list[opt] ')'; /// [C++0x] simple-type-specifier braced-init-list; /// typename-specifier '(' expression-list[opt] ')'; /// [C++0x] typename-specifier braced-init-list; ///; /// In C++1z onwards, the type specifier can also be a template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1000,Availability,error,error,1000,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1012,Availability,recover,recovered,1012,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1012,Safety,recover,recovered,1012,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:434,Usability,simpl,simple-asm-expr,434,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Usability,simpl,simple-asm-expr,3,// simple-asm-expr[opt],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:50,Modifiability,variab,variable,50,// This was probably an attempt to initialize the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:48,Usability,Simpl,Simple,48,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,Usability,simpl,simple-type-specifier,155,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:188,Usability,simpl,simple-type-specifier,188,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:311,Usability,simpl,simple-template-id,311,/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.; /// This should only be called when the current token is known to be part of; /// simple-type-specifier.; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template' simple-template-id [TODO]; /// char; /// wchar_t; /// bool; /// short; /// int; /// long; /// signed; /// unsigned; /// float; /// double; /// void; /// [GNU] typeof-specifier; /// [C++0x] auto [TODO]; ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:860,Availability,error,errors,860,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1574,Availability,error,error,1574,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1357,Deployability,update,updated,1357,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:96,Integrability,rout,routine,96,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:304,Integrability,rout,routine,304,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1437,Integrability,rout,routine,1437,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1505,Performance,perform,performing,1505,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:622,Security,access,access,622,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:696,Security,access,accessed,696,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:782,Security,access,access,782,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,Integrability,inject,injected-class-name,16,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,Security,inject,injected-class-name,16,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,Availability,error,errors,13,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Integrability,depend,dependent,46,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:231,Integrability,depend,dependent,231,"// We have something like t->getAs<T>(), where getAs is a; // member of an unknown specialization. However, this will only; // parse correctly as a template, so suggest the keyword 'template'; // before 'getAs' and treat this as a dependent template name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:113,Integrability,rout,routine,113,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1116,Security,access,access,1116,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1190,Security,access,accessed,1190,"/// Parse an operator-function-id or conversion-function-id as part; /// of a C++ unqualified-id.; ///; /// This routine is responsible only for parsing the operator-function-id or; /// conversion-function-id; it does not handle template arguments in any way.; ///; /// \code; /// operator-function-id: [C++ 13.5]; /// 'operator' operator; ///; /// operator: one of; /// new delete new[] delete[]; /// + - * / % ^ & | ~; /// ! = < > += -= *= /= %=; /// ^= &= |= << >> >>= <<= == !=; /// <= >= && || ++ -- , ->* ->; /// () [] <=>; ///; /// conversion-function-id: [C++ 12.3.2]; /// operator conversion-type-id; ///; /// conversion-type-id:; /// type-specifier-seq conversion-declarator[opt]; ///; /// conversion-declarator:; /// ptr-operator conversion-declarator[opt]; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:38,Performance,perform,perform,38,"// We're past translation phase 6, so perform string literal concatenation; // before checking for """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:794,Availability,error,errors,794,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:553,Security,access,access,553,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:627,Security,access,accessed,627,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:716,Security,access,access,716,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1223,Usability,guid,guide,1223,"/// Parse a C++ unqualified-id (or a C identifier), which describes the; /// name of an entity.; ///; /// \code; /// unqualified-id: [C++ expr.prim.general]; /// identifier; /// operator-function-id; /// conversion-function-id; /// [C++0x] literal-operator-id [TODO]; /// ~ class-name; /// template-id; ///; /// \endcode; ///; /// \param SS The nested-name-specifier that preceded this unqualified-id. If; /// non-empty, then we are parsing the unqualified-id of a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors if this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; /// When true, diagnostics for missing 'template' keyword will be supressed.; ///; /// \param EnteringContext whether we are entering the scope of the; /// nested-name-specifier.; ///; /// \param AllowDestructorName whether we allow parsing of a destructor name.; ///; /// \param AllowConstructorName whether we allow parsing a constructor name.; ///; /// \param AllowDeductionGuide whether we allow parsing a deduction guide name.; ///; /// \param Result on a successful parse, contains the parsed unqualified-id.; ///; /// \returns true if parsing fails, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:53,Usability,guid,guide,53,// We have parsed a template-name naming a deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,Availability,recover,recover,87,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,Safety,recover,recover,87,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,Availability,recover,recover,378,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,Safety,recover,recover,378,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,Availability,recover,recovery,148,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,Safety,recover,recovery,148,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:157,Testability,log,logic,157,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:47,Usability,simpl,simple-template-id,47,// Parse the class-name (or template-name in a simple-template-id).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:71,Energy Efficiency,allocate,allocate,71,"/// ParseCXXNewExpression - Parse a C++ new-expression. New is used to allocate; /// memory in a typesafe manner and call constructors.; ///; /// This method is called to parse the new expression after the optional :: has; /// been already parsed. If the :: was present, ""UseGlobal"" is true and ""Start""; /// is its location. Otherwise, ""Start"" is the location of the 'new' token.; ///; /// new-expression:; /// '::'[opt] 'new' new-placement[opt] new-type-id; /// new-initializer[opt]; /// '::'[opt] 'new' new-placement[opt] '(' type-id ')'; /// new-initializer[opt]; ///; /// new-placement:; /// '(' expression-list ')'; ///; /// new-type-id:; /// type-specifier-seq new-declarator[opt]; /// [GNU] attributes type-specifier-seq new-declarator[opt]; ///; /// new-declarator:; /// ptr-operator new-declarator[opt]; /// direct-new-declarator; ///; /// new-initializer:; /// '(' expression-list[opt] ')'; /// [C++0x] braced-init-list; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:65,Integrability,wrap,wrapping,65,// Consume 'new'; // A '(' now can be a new-placement or the '(' wrapping the type-id in the; // second form of new-expression. It can't be a new-type-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:22,Usability,simpl,simplified,22,"// A new-type-id is a simplified type-id, where essentially the; // direct-declarator is replaced by a direct-new-declarator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Availability,Recover,Recover,3,// Recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Safety,Recover,Recover,3,// Recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:97,Energy Efficiency,allocate,allocated,97,"/// ParseCXXDeleteExpression - Parse a C++ delete-expression. Delete is used; /// to free memory allocated by new.; ///; /// This method is called to parse the 'delete' expression after the optional; /// '::' has been already parsed. If the '::' was present, ""UseGlobal"" is true; /// and ""Start"" is its location. Otherwise, ""Start"" is the location of the; /// 'delete' token.; ///; /// delete-expression:; /// '::'[opt] 'delete' cast-expression; /// '::'[opt] 'delete' '[' ']' cast-expression",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:658,Usability,simpl,simple-requirement,658,/// ParseRequiresExpression - Parse a C++2a requires-expression.; /// C++2a [expr.prim.req]p1; /// A requires-expression provides a concise way to express requirements on; /// template arguments. A requirement is one that can be checked by name; /// lookup (6.4) or by checking properties of types and expressions.; ///; /// requires-expression:; /// 'requires' requirement-parameter-list[opt] requirement-body; ///; /// requirement-parameter-list:; /// '(' parameter-declaration-clause[opt] ')'; ///; /// requirement-body:; /// '{' requirement-seq '}'; ///; /// requirement-seq:; /// requirement; /// requirement-seq requirement; ///; /// requirement:; /// simple-requirement; /// type-requirement; /// compound-requirement; /// nested-requirement,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:67,Integrability,Depend,Dependent,67,// Create a separate diagnostic pool for RequiresExprBodyDecl.; // Dependent diagnostics are attached to this Decl and non-depenedent; // diagnostics are surfaced after this parse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:59,Usability,simpl,simple-requirement,59,// requires (...) {; // ^ - a requires expression as a; // simple-requirement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:102,Usability,simpl,simple,102,// This might be 'typename T::value_type;' (a type requirement) or; // 'typename T::value_type{};' (a simple requirement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Usability,Simpl,Simple,3,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:45,Usability,simpl,simple,45,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:57,Usability,simpl,simple-requirement,57,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:45,Safety,avoid,avoid,45,// Don't emit an empty requires expr here to avoid confusing the user with; // other diagnostics quoting an empty requires expression they never; // wrote.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:603,Performance,cache,cached,603,"// We need to disambiguate a very ugly part of the C++ syntax:; //; // (T())x; - type-id; // (T())*x; - type-id; // (T())/x; - expression; // (T()); - expression; //; // The bad news is that we cannot use the specialized tentative parser, since; // it can only verify that the thing inside the parens can be parsed as; // type-id, it is not useful for determining the context past the parens.; //; // The good news is that the parser can disambiguate this part without; // making any unnecessary Action calls.; //; // It uses a scheme similar to parsing inline methods. The parenthesized; // tokens are cached, the context that follows is determined (possibly by; // parsing a cast-expression), and then we re-introduce the cached tokens; // into the token stream and parse them appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:724,Performance,cache,cached,724,"// We need to disambiguate a very ugly part of the C++ syntax:; //; // (T())x; - type-id; // (T())*x; - type-id; // (T())/x; - expression; // (T()); - expression; //; // The bad news is that we cannot use the specialized tentative parser, since; // it can only verify that the thing inside the parens can be parsed as; // type-id, it is not useful for determining the context past the parens.; //; // The good news is that the parser can disambiguate this part without; // making any unnecessary Action calls.; //; // It uses a scheme similar to parsing inline methods. The parenthesized; // tokens are cached, the context that follows is determined (possibly by; // parsing a cast-expression), and then we re-introduce the cached tokens; // into the token stream and parse them appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:41,Performance,cache,cached,41,// The current token should go after the cached tokens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,Performance,cache,cached,46,// Drop the current token and bring the first cached one. It's the same token; // as when we entered this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:416,Testability,log,logic,416,"//===--- ParseHLSL.cpp - HLSL-specific parsing support --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the parsing logic for HLSL language features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:24,Modifiability,variab,variable,24,"// Only allow function, variable, record decls inside HLSLBuffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:113,Safety,avoid,avoid,113,// FIXME: HLSLSemantic is shared for Semantic and resource binding which is; // confusing. Need a better name to avoid misunderstanding. Issue; // https://github.com/llvm/llvm-project/issues/57882,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:24,Availability,error,error,24,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:96,Availability,recover,recover,96,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:96,Safety,recover,recover,96,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:103,Integrability,message,message-send,103,// Can't be a lambda-expression. Treat it as a designator.; // FIXME: Should we disambiguate against a message-send?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:1024,Integrability,message,message-args,1024,"/// ParseInitializerWithPotentialDesignator - Parse the 'initializer' production; /// checking to see if the token stream starts with a designator.; ///; /// C99:; ///; /// designation:; /// designator-list '='; /// [GNU] array-designator; /// [GNU] identifier ':'; ///; /// designator-list:; /// designator; /// designator-list designator; ///; /// designator:; /// array-designator; /// '.' identifier; ///; /// array-designator:; /// '[' constant-expression ']'; /// [GNU] '[' constant-expression '...' constant-expression ']'; ///; /// C++20:; ///; /// designated-initializer-list:; /// designated-initializer-clause; /// designated-initializer-list ',' designated-initializer-clause; ///; /// designated-initializer-clause:; /// designator brace-or-equal-initializer; ///; /// designator:; /// '.' identifier; ///; /// We allow the C99 syntax extensions in C++20, but do not allow the C++20; /// extension (a braced-init-list after the designator with no '=') in C99.; ///; /// NOTE: [OBC] allows '[ objc-receiver objc-message-args ]' as an; /// initializer (because it is an expression). We need to consider this case; /// when parsing array designators.; ///; /// \p CodeCompleteCB is called with Designation parsed so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:89,Integrability,message,message,89,"// Desig - This is initialized when we see our first designator. We may have; // an objc message send with no designator, so we don't want to create this; // eagerly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:58,Integrability,message,message,58,// We must have either an array designator now or an objc message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:269,Integrability,message,message,269,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:292,Integrability,message,message-expr,292,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:359,Integrability,message,message,359,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:495,Integrability,message,message,495,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:616,Integrability,message,message,616,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:59,Integrability,message,message,59,"// If Objective-C is enabled and this is a typename (class message; // send) or send to 'super', parse this as a message send; // expression. We handle C++ and C separately, since C++ requires; // much more complicated parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:113,Integrability,message,message,113,"// If Objective-C is enabled and this is a typename (class message; // send) or send to 'super', parse this as a message send; // expression. We handle C++ and C separately, since C++ requires; // much more complicated parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:47,Integrability,message,message,47,"// If the receiver was a type, we have a class message; parse; // the rest of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:80,Integrability,message,message,80,"// If the receiver was an expression, we still don't know; // whether we have a message send or an array designator; just; // adopt the expression for further analysis below.; // FIXME: potentially-potentially evaluated expression above?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:26,Integrability,message,message,26,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:75,Integrability,message,message,75,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:124,Integrability,message,message,124,// Three cases. This is a message send to a type: [type foo]; // This is a message send to super: [super foo]; // This is a message sent to an expr: [super.bar foo],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:28,Integrability,protocol,protocol,28,// Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:99,Integrability,message,message,99,// Fall through; we'll just parse the expression and; // (possibly) treat this like an Objective-C message send; // later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:268,Security,validat,validate,268,"// Parse the index expression, if we haven't already gotten one; // above (which can only happen in Objective-C++).; // Note that we parse this as an assignment expression, not a constant; // expression (allowing *=, =, etc) to handle the objc case. Sema needs; // to validate that the expression is a constant.; // FIXME: We also need to tell Sema that we're in a; // potentially-potentially evaluated context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:110,Integrability,message,message,110,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:147,Integrability,message,message,147,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:184,Integrability,message,message,184,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:205,Integrability,message,message,205,"// Okay, we're done with the designator sequence. We know that there must be; // at least one designator, because the only case we can get into this method; // without a designator is when we have an objc message send. That case is; // handled and returned from above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:230,Availability,error,error,230,"// We read some number of designators and found something that isn't an = or; // an initializer. If we have exactly one array designator, this; // is the GNU 'designation: array-designator' extension. Otherwise, it is a; // parse error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:30,Availability,recover,recover,30,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:48,Availability,error,error,48,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:309,Availability,error,error,309,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:333,Availability,recover,recover,333,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:441,Availability,error,error,441,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:30,Safety,recover,recover,30,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:333,Safety,recover,recover,333,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:6,Availability,error,error,6,// an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:443,Integrability,interface,interface,443,"//===--- ParseObjC.cpp - Objective C Parsing ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Objective-C portions of the Parser interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:239,Integrability,protocol,protocol-definition,239,/// ParseObjCAtDirectives - Handle parts of the external-declaration production:; /// external-declaration: [C99 6.9]; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] '@' 'end',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:14,Integrability,interface,interface,14,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,interface,interface-attributes,41,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,interface,interface,78,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:107,Integrability,interface,interface,107,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:138,Integrability,interface,interface,138,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:159,Integrability,interface,interface,159,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:242,Integrability,protocol,protocol-refs,242,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:311,Integrability,interface,interface-decl-list,311,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:365,Integrability,interface,interface,365,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:386,Integrability,interface,interface,386,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:472,Integrability,protocol,protocol-refs,472,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:501,Integrability,interface,interface-decl-list,501,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:624,Integrability,interface,interface-attributes,624,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:286,Modifiability,variab,variables,286,"///; /// objc-interface:; /// objc-class-interface-attributes[opt] objc-class-interface; /// objc-category-interface; ///; /// objc-class-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// objc-superclass[opt] objc-protocol-refs[opt]; /// objc-class-instance-variables[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-category-interface:; /// '@' 'interface' identifier objc-type-parameter-list[opt]; /// '(' identifier[opt] ')' objc-protocol-refs[opt]; /// objc-interface-decl-list; /// @end; ///; /// objc-superclass:; /// ':' identifier objc-type-arguments[opt]; ///; /// objc-class-interface-attributes:; /// __attribute__((visibility(""default""))); /// __attribute__((visibility(""hidden""))); /// __attribute__((deprecated)); /// __attribute__((unavailable)); /// __attribute__((objc_exception)) - used by NSException on 64-bit; /// __attribute__((objc_root_class)); ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,Integrability,interface,interface,8,"// the ""interface"" identifier; // Code completion after '@interface'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Integrability,interface,interface,58,"// the ""interface"" identifier; // Code completion after '@interface'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,Integrability,protocol,protocol-refs,46,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:114,Integrability,Protocol,ProtocolIdents,114,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:150,Integrability,protocol,protocol,150,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:52,Availability,error,error,52,"// For ObjC2, the category name is optional (not an error).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:34,Integrability,protocol,protocol,34,"// Next, we need to check for any protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Integrability,interface,interface,17,// Parse a class interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,protocol,protocol,40,// Type arguments for the superclass or protocol conformances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:34,Integrability,protocol,protocol,34,"// Next, we need to check for any protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,Integrability,protocol,protocols,25,// We already parsed the protocols named when we thought we had a; // type parameter list. Translate them into actual protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:118,Integrability,protocol,protocol,118,// We already parsed the protocols named when we thought we had a; // type parameter list. Translate them into actual protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:95,Integrability,protocol,protocol,95,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:130,Integrability,protocol,protocol,130,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:576,Integrability,protocol,protocolIdents,576,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:674,Integrability,protocol,protocol,674,"/// Parse an Objective-C type parameter list, if present, or capture; /// the locations of the protocol identifiers for a list of protocol; /// references.; ///; /// objc-type-parameter-list:; /// '<' objc-type-parameter (',' objc-type-parameter)* '>'; ///; /// objc-type-parameter:; /// objc-type-parameter-variance? identifier objc-type-parameter-bound[opt]; ///; /// objc-type-parameter-bound:; /// ':' type-name; ///; /// objc-type-parameter-variance:; /// '__covariant'; /// '__contravariant'; ///; /// \param lAngleLoc The location of the starting '<'.; ///; /// \param protocolIdents Will capture the list of identifiers, if the; /// angle brackets contain a list of protocol references rather than a; /// type parameter list.; ///; /// \param rAngleLoc The location of the ending '>'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:33,Integrability,protocol,protocol,33,"// Local function to ""flush"" the protocol identifiers, turning them into; // type parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:75,Integrability,protocol,protocol,75,"// Once we've seen a variance specific , we know this is not a; // list of protocol references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,protocol,protocol,78,"// Up until now, we have been queuing up parameters because they; // might be protocol references. Turn them into parameters now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:26,Integrability,protocol,protocol,26,"// FIXME: If these aren't protocol references, we'll need different; // completions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Availability,recover,recovery,17,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,Safety,recover,recovery,17,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Integrability,protocol,protocol,58,"// Once we've seen a bound, we know this is not a list of protocol; // references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:78,Integrability,protocol,protocol,78,"// Up until now, we have been queuing up parameters because they; // might be protocol references. Turn them into parameters now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:28,Integrability,protocol,protocol,28,"// If this could still be a protocol list, just capture the identifier.; // We don't want to turn it into a parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:238,Integrability,protocol,protocol-refs,238,// A type parameter list must be followed by either a ':' (indicating the; // presence of a superclass) or a '(' (indicating that this is a category; // or extension). This disambiguates between an objc-type-parameter-list; // and a objc-protocol-refs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:117,Integrability,protocol,protocol,117,// Returning null indicates that we don't have a type parameter list.; // The results the caller needs to handle the protocol references are; // captured in the reference parameters already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:59,Integrability,protocol,protocol,59,// We have a type parameter list that looks like a list of protocol; // references. Turn that parameter list into type parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:99,Integrability,protocol,protocol,99,// Clear out the angle locations; they're used by the caller to indicate; // whether there are any protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Usability,Clear,Clear,3,// Clear out the angle locations; they're used by the caller to indicate; // whether there are any protocol references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,interface,interface-decl-list,9,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,interface,interface-decl-list,51,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:108,Integrability,interface,interface-decl-list,108,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:170,Integrability,interface,interface-decl-list,170,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:222,Integrability,interface,interface-decl-list,222,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:264,Integrability,interface,interface-decl-list,264,/// objc-interface-decl-list:; /// empty; /// objc-interface-decl-list objc-property-decl [OBJC2]; /// objc-interface-decl-list objc-method-requirement [OBJC2]; /// objc-interface-decl-list objc-method-proto ';'; /// objc-interface-decl-list declaration; /// objc-interface-decl-list ';'; ///; /// objc-method-requirement: [OBJC2]; /// @required; /// @optional; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:32,Availability,error,error,32,// We didn't find a semi and we error'ed out. Skip until a ';' or '@'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,interface,interface,41,// Code completion within an Objective-C interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:144,Integrability,interface,interfaces,144,"// Since we call ParseDeclarationOrFunctionDefinition() instead of; // ParseExternalDeclaration() below (so that this doesn't parse nested; // @interfaces), this needs to duplicate some code from the latter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Integrability,interface,interface,30,"// If we see something like '@interface' that's only allowed at the top; // level, bail out as if we saw an '@end'. We'll diagnose this below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:130,Availability,error,errors,130,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,protocol,protocol,42,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:206,Integrability,interface,interface,206,"// FIXME: If someone forgets an @end on a protocol, this loop will; // continue to eat up tons of stuff and spew lots of nonsense errors. It; // would probably be better to bail out if we saw an @class or @interface; // or something like that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:25,Integrability,protocol,protocols,25,// This is only valid on protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Deployability,Install,Install,3,// Install the property declarator into interfaceDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,interface,interfaceDecl,40,// Install the property declarator into interfaceDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:177,Availability,error,error,177,"// We break out of the big loop in 3 cases: when we see @end or when we see; // top-level ObjC keyword or EOF. In the former case, eat the @end. In the; // later cases, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,interface,interface,51,// Insert collected methods declarations into the @interface object.; // This passes in an invalid SourceLocation for AtEndLoc when EOF is hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,Availability,redundant,redundant,13,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,Safety,redund,redundant,13,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:38,Integrability,rout,routine,38,/// ParseObjCTypeQualifierList - This routine parses the objective-c's type; /// qualifier list and builds their bitmask representation in the input; /// argument.; ///; /// objc-type-qualifiers:; /// objc-type-qualifier; /// objc-type-qualifiers objc-type-qualifier; ///; /// objc-type-qualifier:; /// 'in'; /// 'out'; /// 'inout'; /// 'oneway'; /// 'bycopy'; /// 'byref'; /// 'nonnull'; /// 'nullable'; /// 'null_unspecified'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Availability,redundant,redundant,19,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Safety,redund,redundant,19,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,Availability,error,error,89,"// Otherwise, we found *something*, but didn't get a ')' in the right; // place. Emit an error then return what we have as the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-refs,9,/// objc-protocol-refs:; /// '<' identifier-list '>'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:23,Integrability,protocol,protocols,23,// Convert the list of protocols identifiers into a list of protocol decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:60,Integrability,protocol,protocol,60,// Convert the list of protocols identifiers into a list of protocol decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,Integrability,protocol,protocol,40,"/// Parse Objective-C type arguments or protocol qualifiers.; ///; /// objc-type-arguments:; /// '<' type-name '...'[opt] (',' type-name '...'[opt])* '>'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:114,Integrability,protocol,protocols,114,"// Whether all of the elements we've parsed thus far are single; // identifiers, which might be types or might be protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,Integrability,protocol,protocols,89,"// If we parsed an identifier list, semantic analysis sorts out; // whether it refers to protocols or to type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:168,Integrability,protocol,protocol,168,"// We parsed an identifier list but stumbled into non single identifiers, this; // means we might (a) check that what we already parsed is a legitimate type; // (not a protocol or unknown type) and (b) parse the remaining ones, which; // must all be type args.; // Convert the identifiers into type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,protocol,protocols,42,// Diagnose the mix between type args and protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Integrability,protocol,protocol,103,"// An Objective-C object pointer followed by type arguments; // can then be followed again by a set of protocol references, e.g.,; // \c NSArray<NSView><NSTextDelegate>",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:115,Integrability,protocol,protocol,115,"// If we aren't consuming the last token, the prior '>' is still hanging; // there. Consume it before we parse the protocol qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:28,Integrability,protocol,protocol,28,// Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:24,Modifiability,variab,variables,24,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,Modifiability,variab,variable-decl-list,58,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:110,Modifiability,variab,variable-decl-list,110,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:175,Modifiability,variab,variable-decl,175,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:221,Modifiability,variab,variable-decl-list,221,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:280,Modifiability,variab,variable-decl-list,280,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:313,Modifiability,variab,variable-decl,313,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:350,Modifiability,variab,variable-decl-list,350,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:414,Modifiability,variab,variable-decl-list,414,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:558,Modifiability,variab,variable-decl,558,/// objc-class-instance-variables:; /// '{' objc-instance-variable-decl-list[opt] '}'; ///; /// objc-instance-variable-decl-list:; /// objc-visibility-spec; /// objc-instance-variable-decl ';'; /// ';'; /// objc-instance-variable-decl-list objc-visibility-spec; /// objc-instance-variable-decl-list objc-instance-variable-decl ';'; /// objc-instance-variable-decl-list static_assert-declaration; /// objc-instance-variable-decl-list ';'; ///; /// objc-visibility-spec:; /// @private; /// @protected; /// @public; /// @package [OBJC2]; ///; /// objc-instance-variable-decl:; /// struct-declaration; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:60,Modifiability,variab,variables,60,"// While we still have something to read, read the instance variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:55,Modifiability,variab,variable-decl,55,// Each iteration of this loop reads one objc-instance-variable-decl.; // Check for extraneous top-level semicolon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:165,Modifiability,variab,variables,165,// This needs to duplicate a small amount of code from; // ParseStructUnionBody() for things that should work in both; // C struct and in Objective-C class instance variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Deployability,Install,Install,3,// Install the declarator into the interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:35,Integrability,interface,interface,35,// Install the declarator into the interface decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-declaration,9,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:41,Integrability,protocol,protocol-definition,41,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:71,Integrability,protocol,protocol-forward-reference,71,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:113,Integrability,protocol,protocol-definition,113,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:141,Integrability,protocol,protocol,141,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:171,Integrability,protocol,protocol-refs,171,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:200,Integrability,interface,interface-decl-list,200,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:246,Integrability,protocol,protocol-forward-reference,246,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:281,Integrability,protocol,protocol,281,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:323,Integrability,protocol,protocol,323,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:371,Integrability,protocol,protocol,371,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:410,Integrability,interface,interface-decl-list,410,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:499,Integrability,protocol,protocol-refs,499,"/// objc-protocol-declaration:; /// objc-protocol-definition; /// objc-protocol-forward-reference; ///; /// objc-protocol-definition:; /// \@protocol identifier; /// objc-protocol-refs[opt]; /// objc-interface-decl-list; /// \@end; ///; /// objc-protocol-forward-reference:; /// \@protocol identifier-list ';'; ///; /// ""\@protocol identifier ;"" should be resolved as ""\@protocol; /// identifier-list ;"": objc-interface-decl-list may not start with a; /// semicolon in the first alternative if objc-protocol-refs are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:8,Integrability,protocol,protocol,8,"// the ""protocol"" identifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,Integrability,protocol,protocol,11,"// missing protocol name.; // Save the protocol name, then consume it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:39,Integrability,protocol,protocol,39,"// missing protocol name.; // Save the protocol name, then consume it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Integrability,protocol,protocol,30,// forward declaration of one protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:43,Integrability,protocol,protocol,43,"// Last, and definitely not least, parse a protocol declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:232,Modifiability,variab,variables,232,/// objc-implementation:; /// objc-class-implementation-prologue; /// objc-category-implementation-prologue; ///; /// objc-class-implementation-prologue:; /// @implementation identifier objc-superclass[opt]; /// objc-class-instance-variables[opt]; ///; /// objc-category-implementation-prologue:; /// @implementation identifier ( identifier ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:47,Integrability,protocol,protocol,47,// Neither a type parameter list nor a list of protocol references is; // permitted here. Parse and diagnose them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Availability,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Safety,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Availability,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,Safety,recover,recover,30,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:23,Performance,cache,cached,23,/// Clear and free the cached objc methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:4,Usability,Clear,Clear,4,/// Clear and free the cached objc methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,synchroniz,synchronized-statement,9,/// objc-synchronized-statement:; /// @synchronized '(' expression ')' compound-statement; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:39,Integrability,synchroniz,synchronized,39,/// objc-synchronized-statement:; /// @synchronized '(' expression ')' compound-statement; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:11,Integrability,synchroniz,synchronized,11,// consume synchronized,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:14,Integrability,synchroniz,synchronized,14,// Check the @synchronized operand now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:36,Availability,error,error,36,"// If there was a semantic or parse error earlier with the; // operand, fail now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:609,Availability,error,error,609,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:43,Integrability,message,message,43,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:72,Integrability,rout,routine,72,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:105,Integrability,message,message,105,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:198,Integrability,rout,routine,198,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:857,Usability,simpl,simple-type-specifier,857,"/// Parse the receiver of an Objective-C++ message send.; ///; /// This routine parses the receiver of a message send in; /// Objective-C++ either as a type or as an expression. Note that this; /// routine must not be called to parse a send to 'super', since it; /// has no way to return such a result.; ///; /// \param IsExpr Whether the receiver was parsed as an expression.; ///; /// \param TypeOrExpr If the receiver was parsed as an expression (\c; /// IsExpr is true), the parsed expression. If the receiver was parsed; /// as a type (\c IsExpr is false), the parsed type.; ///; /// \returns True if an error occurred during parsing or semantic; /// analysis, in which case the arguments do not have valid; /// values. Otherwise, returns false for a successful parse.; ///; /// objc-receiver: [C++]; /// 'super' [not parsed here]; /// expression; /// simple-type-specifier; /// typename-specifier",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:120,Availability,recover,recovery,120,"// objc-receiver:; // expression; // Make sure any typos in the receiver are corrected or diagnosed, so that; // proper recovery can happen. FIXME: Perhaps filter the corrected expr to; // only the things that are valid ObjC receivers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:120,Safety,recover,recovery,120,"// objc-receiver:; // expression; // Make sure any typos in the receiver are corrected or diagnosed, so that; // proper recovery can happen. FIXME: Perhaps filter the corrected expr to; // only the things that are valid ObjC receivers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:45,Usability,simpl,simple-type-specifier,45,// objc-receiver:; // typename-specifier; // simple-type-specifier; // expression (that starts with one of the above),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:175,Usability,simpl,simple-type-specifier,175,"// If we see an opening parentheses at this point, we are; // actually parsing an expression that starts with a; // function-style cast, e.g.,; //; // postfix-expression:; // simple-type-specifier ( expression-list [opt] ); // typename-specifier ( expression-list [opt] ); //; // Parse the remainder of this case, then the (optional); // postfix-expression suffix, followed by the (optional); // right-hand side of the binary expression. We have an; // instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,Integrability,message,message,19,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:148,Integrability,message,message,148,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:37,Usability,simpl,simple-type-specifier,37,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:81,Integrability,message,message,81,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:158,Integrability,rout,routine,158,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:210,Integrability,message,message-send,210,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:127,Safety,avoid,avoid,127,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Usability,simpl,simplified,103,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,message,message-expr,9,/// objc-message-expr:; /// '[' objc-receiver objc-message-args ']'; ///; /// objc-receiver: [C]; /// 'super'; /// expression; /// class-name; /// type-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,Integrability,message,message-args,51,/// objc-message-expr:; /// '[' objc-receiver objc-message-args ']'; ///; /// objc-receiver: [C]; /// 'super'; /// expression; /// class-name; /// type-name; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,Integrability,protocol,protocol,46,// the type name; // Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:42,Integrability,message,message,42,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:103,Integrability,rout,routine,103,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:141,Integrability,message,messages,141,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:192,Integrability,message,messages,192,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:633,Integrability,message,message,633,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:686,Integrability,message,message,686,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:751,Integrability,message,message,751,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:832,Integrability,message,message-args,832,"/// Parse the remainder of an Objective-C message following the; /// '[' objc-receiver.; ///; /// This routine handles sends to super, class messages (sent to a; /// class name), and instance messages (sent to an object), and the; /// target is represented by \p SuperLoc, \p ReceiverType, or \p; /// ReceiverExpr, respectively. Only one of these parameters may have; /// a valid value.; ///; /// \param LBracLoc The location of the opening '['.; ///; /// \param SuperLoc If this is a send to 'super', the location of the; /// 'super' keyword that indicates a send to the superclass.; ///; /// \param ReceiverType If this is a class message, the type of the; /// class we are sending a message to.; ///; /// \param ReceiverExpr If this is an instance message, the expression; /// used to compute the receiver object.; ///; /// objc-message-args:; /// objc-selector; /// objc-keywordarg-list; ///; /// objc-keywordarg-list:; /// objc-keywordarg; /// objc-keywordarg-list objc-keywordarg; ///; /// objc-keywordarg:; /// selector-name[opt] ':' objc-keywordexpr; ///; /// objc-keywordexpr:; /// nonempty-expr-list; ///; /// nonempty-expr-list:; /// assignment-expression; /// nonempty-expr-list , assignment-expression; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap the sub-expression in a parenthesized expression, to distinguish; // a boxed expression from a literal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:9,Integrability,protocol,protocol-expression,9,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:36,Integrability,protocol,protocol,36,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:47,Integrability,protocol,protocol-name,47,/// objc-protocol-expression; /// \@protocol ( protocol-name ),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:31,Availability,error,error,31,"// MCDecl might be null due to error in method or c-function prototype, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:18,Availability,error,error,18,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:49,Performance,cache,cached,49,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:86,Performance,cache,cached,86,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:215,Safety,avoid,avoided,215,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:416,Testability,log,logic,416,"//===--- ParseOpenACC.cpp - OpenACC-specific parsing support --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the parsing logic for OpenACC language features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:29,Modifiability,extend,extended,29,"// An enum that contains the extended 'partial' parsed variants. This type; // should never escape the initial parse functionality, but is useful for; // simplifying the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:154,Usability,simpl,simplifying,154,"// An enum that contains the extended 'partial' parsed variants. This type; // should never escape the initial parse functionality, but is useful for; // simplifying the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:130,Availability,error,error,130,"/// Used for cases where we have a token we want to check against an; /// 'identifier-like' token, but don't want to give awkward error messages in; /// cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:136,Integrability,message,messages,136,"/// Used for cases where we have a token we want to check against an; /// 'identifier-like' token, but don't want to give awkward error messages in; /// cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Availability,recover,recover,103,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Safety,recover,recover,103,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:97,Availability,error,error,97,"/// Used for cases where we expect an identifier-like token, but don't want to; /// give awkward error messages in cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,Integrability,message,messages,103,"/// Used for cases where we expect an identifier-like token, but don't want to; /// give awkward error messages in cases where it is accidentially a keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:39,Deployability,update,update,39,// #pragma acc atomic is equivilent to update:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:44,Modifiability,extend,extended,44,"// OpenACCDirectiveKindEx is meant to be an extended list; // over OpenACCDirectiveKind, so any value below Invalid is one of the; // OpenACCDirectiveKind values. This switch takes care of all of the extra; // parsing required for the Extended values. At the end of this block,; // ExDirKind can be assumed to be a valid OpenACCDirectiveKind, so we can; // immediately cast it and use it as that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:235,Modifiability,Extend,Extended,235,"// OpenACCDirectiveKindEx is meant to be an extended list; // over OpenACCDirectiveKind, so any value below Invalid is one of the; // OpenACCDirectiveKind values. This switch takes care of all of the extra; // parsing required for the Extended values. At the end of this block,; // ExDirKind can be assumed to be a valid OpenACCDirectiveKind, so we can; // immediately cast it and use it as that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:19,Usability,clear,clear,19,"// FIXME: It isn't clear if the spec saying 'condition' means the same as; // it does in an if/while/etc (See ParseCXXCondition), however as it was; // written with Fortran/C in mind, we're going to assume it just means an; // 'expression evaluating to boolean'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:50,Usability,simpl,simplify,50,"// namespace; // OpenACC 3.3, section 1.7:; // To simplify the specification and convey appropriate constraint information,; // a pqr-list is a comma-separated list of pdr items. The one exception is a; // clause-list, which is a list of one or more clauses optionally separated by; // commas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Availability,Recover,Recovering,3,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:79,Availability,error,error,79,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Safety,Recover,Recovering,3,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:59,Integrability,depend,dependent,59,"// FIXME: this is required to be an integer expression (or dependent), so we; // should ensure that is the case by passing this to SEMA here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:84,Deployability,update,update,84,"// The 'self' clause is a var-list instead of a 'condition' in the case of; // the 'update' clause, so we have to handle it here. U se an assert to; // make sure we get the right differentiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:138,Testability,assert,assert,138,"// The 'self' clause is a var-list instead of a 'condition' in the case of; // the 'update' clause, so we have to handle it here. U se an assert to; // make sure we get the right differentiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:152,Performance,queue,queues,152,"/// OpenACC 3.3, section 2.16:; /// In this section and throughout the specification, the term wait-argument; /// means:; /// [ devnum : int-expr : ] [ queues : ] async-argument-list",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:5,Performance,queue,queues,5,// [ queues : ],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:11,Performance,queue,queues,11,// Consume queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:318,Safety,avoid,avoid,318,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:273,Usability,simpl,simply,273,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:104,Modifiability,variab,variable,104,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:149,Modifiability,variab,variable,149,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:273,Modifiability,variab,variable,273,"/// OpenACC 3.3, section 1.6:; /// In this spec, a 'var' (in italics) is one of the following:; /// - a variable name (a scalar, array, or compisite variable name); /// - a subarray specification with subscript ranges; /// - an array element; /// - a member of a composite variable; /// - a common block name between slashes (fortran only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:68,Performance,cache,cache,68,"/// OpenACC 3.3, section 2.10:; /// In C and C++, the syntax of the cache directive is:; ///; /// #pragma acc cache ([readonly:]var-list) new-line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:110,Performance,cache,cache,110,"/// OpenACC 3.3, section 2.10:; /// In C and C++, the syntax of the cache directive is:; ///; /// #pragma acc cache ([readonly:]var-list) new-line",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:66,Modifiability,variab,variable,66,"// The VarList is an optional `readonly:` followed by a list of a variable; // specifications. Consume something that looks like a 'tag', and diagnose if; // it isn't 'readonly'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:188,Modifiability,extend,extended,188,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:47,Performance,cache,cache,47,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:99,Usability,simpl,simple,99,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:136,Usability,simpl,simple,136,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Integrability,Rout,Routine,3,"// Routine has an optional paren-wrapped name of a function in the local; // scope. We parse the name, emitting any diagnostics",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:33,Integrability,wrap,wrapped,33,"// Routine has an optional paren-wrapped name of a function in the local; // scope. We parse the name, emitting any diagnostics",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,Availability,recover,recover,76,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:10,Integrability,rout,routine,10,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,Safety,recover,recover,76,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,Availability,recover,recover,52,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:65,Availability,failure,failures,65,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,Safety,recover,recover,52,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:33,Integrability,wrap,wrapped,33,// OpenACC has an optional paren-wrapped 'wait-argument'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:42,Availability,error,error,42,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Performance,Cache,Cache,3,"// Cache's paren var-list is required, so error here if it isn't provided.; // We know that the consumeOpen above left the first non-paren here, so; // diagnose, then continue as if it was completely omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:37,Modifiability,extend,extended,37,// namespace; // Map token string to extended OMP token kind that are; // OpenMPDirectiveKind + OpenMPDirectiveKindEx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:18,Modifiability,variab,variable,18,// Add the mapper variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,Availability,error,error,38,"// If anything went wrong we issue an error or warning and then skip the rest; // of the selector. However, commas are ambiguous so we look for the nesting; // of parentheses here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:38,Availability,error,error,38,"// If anything went wrong we issue an error or warning and then skip the rest; // of the set. However, commas are ambiguous so we look for the nesting; // of braces here as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:179,Performance,Perform,Perform,179,// Merge the parent/outer trait info into the one we just parsed and diagnose; // problems.; // TODO: Keep some source location in the TI to provide better diagnostics.; // TODO: Perform some kind of equivalence check on the condition and score; // expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:63,Availability,error,error,63,"/// <clause> [clause[ [,] clause] ... ]; ///; /// clauses: for error directive; /// 'at' '(' compilation | execution ')'; /// 'severity' '(' fatal | warning ')'; /// 'message' '(' msg-string ')'; /// ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:167,Integrability,message,message,167,"/// <clause> [clause[ [,] clause] ... ]; ///; /// clauses: for error directive; /// 'at' '(' compilation | execution ')'; /// 'severity' '(' fatal | warning ')'; /// 'message' '(' msg-string ')'; /// ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:15,Usability,simpl,simple,15,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' '); ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' '); ///; /// device_type-clause:; /// 'device_type' '(' 'host' | 'nohost' | 'any' )',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:182,Energy Efficiency,allocate,allocate-directive,182,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:228,Energy Efficiency,allocate,allocate,228,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:129,Modifiability,variab,variable-list,129,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:245,Modifiability,variab,variable-list,245,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:122,Usability,simpl,simple-variable-list,122,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:238,Usability,simpl,simple-variable-list,238,"/// Parsing of declarative OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list [<clause>]; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' [...]; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// declare-simd-directive:; /// annot_pragma_openmp 'declare simd' {<clause> [,]}; /// annot_pragma_openmp_end; /// <function declaration/definition>; ///; /// requires directive:; /// annot_pragma_openmp 'requires' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// assumes directive:; /// annot_pragma_openmp 'assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp_end; /// or; /// annot_pragma_openmp 'begin assumes' <clause> [[[,] <clause>] ... ]; /// annot_pragma_openmp 'end assumes'; /// annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:54,Security,access,accessible,54,// TODO Track the selector locations in a way that is accessible here; // to improve the diagnostic location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1062,Availability,error,error,1062,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1898,Availability,mask,masked,1898,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1923,Availability,mask,masked,1923,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1447,Deployability,update,update,1447,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:196,Energy Efficiency,allocate,allocate-directive,196,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:242,Energy Efficiency,allocate,allocate,242,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:143,Modifiability,variab,variable-list,143,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:259,Modifiability,variab,variable-list,259,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:136,Usability,simpl,simple-variable-list,136,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:252,Usability,simpl,simple-variable-list,252,"/// Parsing of declarative or executable OpenMP directives.; ///; /// threadprivate-directive:; /// annot_pragma_openmp 'threadprivate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// allocate-directive:; /// annot_pragma_openmp 'allocate' simple-variable-list; /// annot_pragma_openmp_end; ///; /// declare-reduction-directive:; /// annot_pragma_openmp 'declare' 'reduction' '(' <reduction_id> ':'; /// <type> {',' <type>} ':' <expression> ')' ['initializer' '('; /// ('omp_priv' '=' <expression>|<function_call>) ')']; /// annot_pragma_openmp_end; ///; /// declare-mapper-directive:; /// annot_pragma_openmp 'declare' 'mapper' '(' [<mapper-identifer> ':']; /// <type> <var> ')' [<clause>[[,] <clause>] ... ]; /// annot_pragma_openmp_end; ///; /// executable-directive:; /// annot_pragma_openmp 'parallel' | 'simd' | 'for' | 'sections' |; /// 'section' | 'single' | 'master' | 'critical' [ '(' <name> ')' ] |; /// 'parallel for' | 'parallel sections' | 'parallel master' | 'task' |; /// 'taskyield' | 'barrier' | 'taskwait' | 'flush' | 'ordered' | 'error'; /// | 'atomic' | 'for simd' | 'parallel for simd' | 'target' | 'target; /// data' | 'taskgroup' | 'teams' | 'taskloop' | 'taskloop simd' |; /// 'master taskloop' | 'master taskloop simd' | 'parallel master; /// taskloop' | 'parallel master taskloop simd' | 'distribute' | 'target; /// enter data' | 'target exit data' | 'target parallel' | 'target; /// parallel for' | 'target update' | 'distribute parallel for' |; /// 'distribute paralle for simd' | 'distribute simd' | 'target parallel; /// for simd' | 'target simd' | 'teams distribute' | 'teams distribute; /// simd' | 'teams distribute parallel for simd' | 'teams distribute; /// parallel for' | 'target teams' | 'target teams distribute' | 'target; /// teams distribute parallel for' | 'target teams distribute parallel; /// for simd' | 'target teams distribute simd' | 'masked' |; /// 'parallel masked' {clause} annot_pragma_openmp_end; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:54,Security,access,accessible,54,// TODO Track the selector locations in a way that is accessible here; // to improve the diagnostic location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Integrability,depend,depend,10,"// If the depend or doacross clause is specified, the ordered construct; // is a stand-alone directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:34,Modifiability,variab,variable-list,34,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Usability,simpl,simple,10,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:27,Usability,simpl,simple-variable-list,27,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:479,Deployability,update,update-clause,479,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:917,Deployability,release,release-clause,917,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:335,Energy Efficiency,schedul,schedule-clause,335,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:860,Energy Efficiency,allocate,allocate-clause,860,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:102,Safety,safe,safelen-clause,102,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1437,Availability,error,error,1437,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1017,Energy Efficiency,allocate,allocate,1017,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1484,Integrability,message,message,1484,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:156,Safety,safe,safelen,156,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:390,Availability,error,error,390,"// OpenMP [2.14.3.1, Restrictions]; // Only a single default clause may be specified on a parallel, task or; // teams directive.; // OpenMP [2.5, parallel Construct, Restrictions]; // At most one proc_bind clause can appear on the directive.; // OpenMP [5.0, Requires directive, Restrictions]; // At most one atomic_default_mem_order clause can appear; // on the directive; // OpenMP [5.1, error directive, Restrictions]; // At most one at clause can appear on the directive; // At most one severity clause can appear on the directive; // OpenMP 5.1, 2.11.7 loop Construct, Restrictions.; // At most one bind clause can appear on a loop directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:51,Energy Efficiency,schedul,schedule,51,"// OpenMP [2.7.1, Restrictions, p. 3]; // Only one schedule clause can appear on a loop directive.; // OpenMP 4.5 [2.10.4, Restrictions, p. 106]; // At most one defaultmap clause can appear on the directive.; // OpenMP 5.0 [2.12.5, target construct, Restrictions]; // At most one device clause can appear on the directive.; // OpenMP 5.1 [2.11.3, order clause, Restrictions]; // At most one order clause may appear on a construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:11,Usability,simpl,simple,11,/// Parses simple expression in parens for single-expression clauses of OpenMP; /// constructs.; /// \param RLoc Returned location of right paren.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:86,Safety,safe,safelen,86,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:364,Safety,safe,safelen-clause,364,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:386,Safety,safe,safelen,386,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:13,Modifiability,variab,variable,13,// Parse the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:332,Deployability,update,update-clause,332,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:353,Deployability,update,update,353,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:15,Usability,simpl,simple,15,/// Parsing of simple OpenMP clauses like 'default' or 'proc_bind'.; ///; /// default-clause:; /// 'default' '(' 'none' | 'shared' | 'private' | 'firstprivate' ')'; ///; /// proc_bind-clause:; /// 'proc_bind' '(' 'master' | 'close' | 'spread' ')'; ///; /// bind-clause:; /// 'bind' '(' 'teams' | 'parallel' | 'thread' ')'; ///; /// update-clause:; /// 'update' '(' 'in' | 'out' | 'inout' | 'mutexinoutset' |; /// 'inoutset' ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:94,Energy Efficiency,schedul,schedule,94,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:134,Energy Efficiency,schedul,schedule-clause,134,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:157,Energy Efficiency,schedul,schedule,157,"/// Parsing of OpenMP clauses with single expressions and some additional; /// argument like 'schedule' or 'dist_schedule'.; ///; /// schedule-clause:; /// 'schedule' '(' [ modifier [ ',' modifier ] ':' ] kind [',' expression ]; /// ')'; ///; /// if-clause:; /// 'if' '(' [ directive-name-modifier ':' ] expression ')'; ///; /// defaultmap:; /// 'defaultmap' '(' modifier [ ':' kind ] ')'; ///; /// device-clause:; /// 'device' '(' [ device-modifier ':' ] expression ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:45,Modifiability,extend,extended,45,// Only target executable directives support extended device construct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:167,Deployability,release,release,167,"/// Parse map-type in map clause.; /// map([ [map-type-modifier[,] [map-type-modifier[,] ...] map-type : ] list); /// where, map-type ::= to | from | tofrom | alloc | release | delete",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:11,Usability,simpl,simple,11,/// Parses simple expression in parens for single-expression clauses of OpenMP; /// constructs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:90,Integrability,depend,depend,90,// Currently the only reserved locator is 'omp_all_memory' which is only; // allowed on a depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:19,Integrability,depend,dependence,19,"// Handle optional dependence modifier.; // iterator(iterators-definition); // where iterators-definition is iterator-specifier [,; // iterators-definition ]; // where iterator-specifier is [ iterator-type ] identifier =; // range-specification",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,Integrability,depend,dependency,10,// Handle dependency type for depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:30,Integrability,depend,depend,30,// Handle dependency type for depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:26,Integrability,depend,depend,26,// Special processing for depend(source) clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:39,Modifiability,variab,variables,39,"// Colon not found, parse only list of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:9,Modifiability,variab,variable,9,// Parse variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:48,Integrability,depend,depend,48,// Exit from scope when the iterator is used in depend clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1160,Deployability,release,release,1160,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1616,Energy Efficiency,allocate,allocate-clause,1616,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1639,Energy Efficiency,allocate,allocate,1639,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:947,Integrability,depend,depend-clause,947,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:968,Integrability,depend,depend,968,"ng of OpenMP clause 'private', 'firstprivate', 'lastprivate',; /// 'shared', 'copyin', 'copyprivate', 'flush', 'reduction', 'task_reduction',; /// 'in_reduction', 'nontemporal', 'exclusive' or 'inclusive'.; ///; /// private-clause:; /// 'private' '(' list ')'; /// firstprivate-clause:; /// 'firstprivate' '(' list ')'; /// lastprivate-clause:; /// 'lastprivate' '(' list ')'; /// shared-clause:; /// 'shared' '(' list ')'; /// linear-clause:; /// 'linear' '(' linear-list [ ':' linear-step ] ')'; /// aligned-clause:; /// 'aligned' '(' list [ ':' alignment ] ')'; /// reduction-clause:; /// 'reduction' '(' [ modifier ',' ] reduction-identifier ':' list ')'; /// task_reduction-clause:; /// 'task_reduction' '(' reduction-identifier ':' list ')'; /// in_reduction-clause:; /// 'in_reduction' '(' reduction-identifier ':' list ')'; /// copyprivate-clause:; /// 'copyprivate' '(' list ')'; /// flush-clause:; /// 'flush' '(' list ')'; /// depend-clause:; /// 'depend' '(' in | out | inout : list | source ')'; /// map-clause:; /// 'map' '(' [ [ always [,] ] [ close [,] ]; /// [ mapper '(' mapper-identifier ')' [,] ]; /// to | from | tofrom | alloc | release | delete ':' ] list ')';; /// to-clause:; /// 'to' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// from-clause:; /// 'from' '(' [ mapper '(' mapper-identifier ')' ':' ] list ')'; /// use_device_ptr-clause:; /// 'use_device_ptr' '(' list ')'; /// use_device_addr-clause:; /// 'use_device_addr' '(' list ')'; /// is_device_ptr-clause:; /// 'is_device_ptr' '(' list ')'; /// has_device_addr-clause:; /// 'has_device_addr' '(' list ')'; /// allocate-clause:; /// 'allocate' '(' [ allocator ':' ] list ')'; /// nontemporal-clause:; /// 'nontemporal' '(' list ')'; /// inclusive-clause:; /// 'inclusive' '(' list ')'; /// exclusive-clause:; /// 'exclusive' '(' list ')'; ///; /// For 'linear' clause linear-list may have the following forms:; /// list; /// modifier(list); /// where modifier is 'val' (C) or 'ref', 'val' or 'uval'(C++).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:44,Performance,optimiz,optimize,44,"/// PragmaOptimizeHandler - ""\#pragma clang optimize on/off"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:33,Deployability,install,installed,33,// Remove the pragma handlers we installed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:127,Availability,error,errors,127,"// Pragma handling failed, and has been diagnosed. Slurp up the tokens; // until eof (really end of line) to prevent follow-on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:49,Usability,undo,undocumented,49,"// ,; // Ignore ""long"" and ""short"".; // They are undocumented, but widely used, section attributes which appear; // to do nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:3,Security,Validat,Validate,3,// Validate the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:34,Performance,scalab,scalable,34,// Look for vectorize_width(fixed|scalable),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:23,Availability,error,error,23,// Tokens following an error in an ill-formed constant expression will; // remain in the token stream and must be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:23,Availability,error,error,23,// Tokens following an error in an ill-formed constant expression will; // remain in the token stream and must be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:53,Energy Efficiency,power,power,53,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:132,Energy Efficiency,power,power,132,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:202,Energy Efficiency,power,power,202,"// #pragma 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'options 'align' '=' {'native','natural','mac68k','power','reset'}; // #pragma 'align' '(' {'native','natural','mac68k','power','reset'} ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:147,Performance,cache,cache,147,"// For each identifier token, insert into the token stream a; // annot_pragma_unused token followed by the identifier token.; // This allows us to cache a ""#pragma unused"" that occurs inside an inline; // C++ member function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:97,Modifiability,inherit,inheritance,97,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:286,Modifiability,inherit,inheritance-model,286,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:345,Modifiability,inherit,inheritance-model,345,"/// Handle '#pragma pointers_to_members'; // The grammar for this pragma is as follows:; //; // <inheritance model> ::= ('single' | 'multiple' | 'virtual') '_inheritance'; //; // #pragma pointers_to_members '(' 'best_case' ')'; // #pragma pointers_to_members '(' 'full_generality' [',' inheritance-model] ')'; // #pragma pointers_to_members '(' inheritance-model ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:27,Usability,Simpl,Simply,27,/// Handle all MS pragmas. Simply forwards the tokens after inserting; /// an annotation token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Energy Efficiency,allocate,allocate,11,// We must allocate this array with new because EnterTokenStream is going to; // delete it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:383,Availability,error,error,383,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:301,Safety,detect,detects,301,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:17,Performance,optimiz,optimize,17,// #pragma clang optimize off; // #pragma clang optimize on,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:48,Performance,optimiz,optimize,48,// #pragma clang optimize off; // #pragma clang optimize on,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:484,Deployability,pipeline,pipeline,484,"/// Handle the \#pragma clang loop directive.; /// #pragma clang 'loop' loop-hints; ///; /// loop-hints:; /// loop-hint loop-hints[opt]; ///; /// loop-hint:; /// 'vectorize' '(' loop-hint-keyword ')'; /// 'interleave' '(' loop-hint-keyword ')'; /// 'unroll' '(' unroll-hint-keyword ')'; /// 'vectorize_predicate' '(' loop-hint-keyword ')'; /// 'vectorize_width' '(' loop-hint-value ')'; /// 'interleave_count' '(' loop-hint-value ')'; /// 'unroll_count' '(' loop-hint-value ')'; /// 'pipeline' '(' disable ')'; /// 'pipeline_initiation_interval' '(' loop-hint-value ')'; ///; /// loop-hint-keyword:; /// 'enable'; /// 'disable'; /// 'assume_safety'; ///; /// unroll-hint-keyword:; /// 'enable'; /// 'disable'; /// 'full'; ///; /// loop-hint-value:; /// constant-expression; ///; /// Specifying vectorize(enable) or vectorize_width(_value_) instructs llvm to; /// try vectorizing the instructions of the loop it precedes. Specifying; /// interleave(enable) or interleave_count(_value_) instructs llvm to try; /// interleaving multiple iterations of the loop it precedes. The width of the; /// vector instructions is specified by vectorize_width() and the number of; /// interleaved loop iterations is specified by interleave_count(). Specifying a; /// value of 1 effectively disables vectorization/interleaving, even if it is; /// possible and profitable, and 0 is invalid. The loop vectorizer currently; /// only works on inner loops.; ///; /// The unroll and unroll_count directives control the concatenation; /// unroller. Specifying unroll(enable) instructs llvm to unroll the loop; /// completely if the trip count is known at compile time and unroll partially; /// if the trip count is not known. Specifying unroll(full) is similar to; /// unroll(enable) but will unroll the loop only if the trip count is known at; /// compile time. Specifying unroll(disable) disables unrolling for the; /// loop. Specifying unroll_count(_value_) instructs llvm to try to unroll the; /// loop the number of time",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Performance,optimiz,optimization,11,// Lex the optimization option and verify it is an identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:27,Performance,optimiz,optimization,27,"/// Handle the loop unroll optimization pragmas.; /// #pragma unroll; /// #pragma unroll unroll-hint-value; /// #pragma unroll '(' unroll-hint-value ')'; /// #pragma nounroll; /// #pragma unroll_and_jam; /// #pragma unroll_and_jam unroll-hint-value; /// #pragma unroll_and_jam '(' unroll-hint-value ')'; /// #pragma nounroll_and_jam; ///; /// unroll-hint-value:; /// constant-expression; ///; /// Loop unrolling hints can be specified with '#pragma unroll' or; /// '#pragma nounroll'. '#pragma unroll' can take a numeric argument optionally; /// contained in parentheses. With no argument the directive instructs llvm to; /// try to unroll the loop completely. A positive integer argument can be; /// specified to indicate the number of times the loop should be unrolled. To; /// maximize compatibility with other compilers the unroll count argument can be; /// specified with or without parentheses. Specifying, '#pragma nounroll'; /// disables unrolling of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:11,Performance,optimiz,optimize,11,"// #pragma optimize(""gsty"", on|off)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:415,Integrability,interface,interfaces,415,"//===--- Parser.cpp - C Language Family Parser ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Parser interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:65,Availability,error,error,65,"// We can't display the parentheses, so just dig the; // warning/error and return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Detect,Detect,3,// Detect common single-character typos and resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:44,Usability,resume,resume,44,// Detect common single-character typos and resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Availability,Recover,Recover,18,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Safety,Recover,Recover,18,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Availability,Error,Error,85,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:91,Availability,recover,recovery,91,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:91,Safety,recover,recovery,91,//===----------------------------------------------------------------------===//; // Error recovery.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:185,Safety,detect,detected,185,"// Important special case: The caller has given up and just wants us to; // skip the rest of the file. Do this without recursing, since we can; // get here precisely because the caller detected too much recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Performance,cache,cache,18,// Free the scope cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:38,Deployability,Install,Install,38,// Create the translation unit scope. Install it as the current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:372,Availability,error,error,372,"/// Parse the first top-level declaration in a translation unit.; ///; /// translation-unit:; /// [C] external-declaration; /// [C] translation-unit external-declaration; /// [C++] top-level-declaration-seq[opt]; /// [C++20] global-module-fragment[opt] module-declaration; /// top-level-declaration-seq[opt] private-module-fragment[opt]; ///; /// Note that in C, it is an error if there is no first declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:62,Availability,error,error,62,"// An empty Result might mean a line with ';' or some parsing error, ignore; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:436,Integrability,protocol,protocol-definition,436,"/// ParseExternalDeclaration:; ///; /// The `Attrs` that are passed in are C++11 attributes and appertain to the; /// declaration.; ///; /// external-declaration: [C99 6.9], declaration: [C++ dcl.dcl]; /// function-definition; /// declaration; /// [GNU] asm-definition; /// [GNU] __extension__ external-declaration; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] @end; /// [C++] linkage-specification; /// [GNU] asm-definition:; /// simple-asm-expr ';'; /// [C++11] empty-declaration; /// [C++11] attribute-declaration; ///; /// [C++11] empty-declaration:; /// ';'; ///; /// [C++0x/GNU] 'extern' 'template' declaration; ///; /// [C++20] module-import-declaration; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:573,Usability,simpl,simple-asm-expr,573,"/// ParseExternalDeclaration:; ///; /// The `Attrs` that are passed in are C++11 attributes and appertain to the; /// declaration.; ///; /// external-declaration: [C99 6.9], declaration: [C++ dcl.dcl]; /// function-definition; /// declaration; /// [GNU] asm-definition; /// [GNU] __extension__ external-declaration; /// [OBJC] objc-class-definition; /// [OBJC] objc-class-declaration; /// [OBJC] objc-alias-declaration; /// [OBJC] objc-protocol-definition; /// [OBJC] objc-method-definition; /// [OBJC] @end; /// [C++] linkage-specification; /// [GNU] asm-definition:; /// simple-asm-expr ';'; /// [C++11] empty-declaration; /// [C++11] attribute-declaration; ///; /// [C++11] empty-declaration:; /// ';'; ///; /// [C++0x/GNU] 'extern' 'template' declaration; ///; /// [C++20] module-import-declaration; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Integrability,rout,routine,8,"// This routine returns a DeclGroup, if the thing we parsed only contains a; // single decl, convert it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:731,Energy Efficiency,allocate,allocate-directive,731,"/// Parse either a function-definition or a declaration. We can't tell which; /// we have until we read up to the compound-statement in function-definition.; /// TemplateParams, if non-NULL, provides the template parameters when we're; /// parsing a C++ template-declaration.; ///; /// function-definition: [C99 6.9.1]; /// decl-specs declarator declaration-list[opt] compound-statement; /// [C90] function-definition: [C99 6.7.1] - implicit int result; /// [C90] decl-specs[opt] declarator declaration-list[opt] compound-statement; ///; /// declaration: [C99 6.7]; /// declaration-specifiers init-declarator-list[opt] ';'; /// [!C99] init-declarator-list ';' [TODO: warn in c99 mode]; /// [OMP] threadprivate-directive; /// [OMP] allocate-directive [TODO]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:72,Usability,simpl,simply,72,"// Because we assume that the DeclSpec has not yet been initialised, we simply; // overwrite the source range and attribute the provided leading declspec; // attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:43,Integrability,interface,interfaces,43,"// ObjC2 allows prefix attributes on class interfaces and protocols.; // FIXME: This still needs better diagnostics. We should only accept; // attributes here, no types, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:58,Integrability,protocol,protocols,58,"// ObjC2 allows prefix attributes on class interfaces and protocols.; // FIXME: This still needs better diagnostics. We should only accept; // attributes here, no types, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:73,Safety,safe,safe,73,"// Break out of the ParsingDeclSpec context, too. This const_cast is; // safe because we're always the sole owner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:16,Availability,error,error,16,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover from error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:151,Usability,clear,clear,151,"// C99 6.9.1p6: 'each declaration in the declaration list shall have at; // least one declarator'.; // NOTE: GCC just makes this an ext-warn. It's not clear what it does with; // the declarations though. It's trivial to ignore them, really hard to do; // anything else with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:80,Availability,error,error,80,"// If we don't have a comma, it is either the end of the list (a ';') or; // an error, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,Availability,recover,recover,13,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,Safety,recover,recover,13,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:35,Usability,simpl,simple-asm-expr,35,/// ParseSimpleAsm; ///; /// [GNU] simple-asm-expr:; /// 'asm' '(' asm-string-literal ')'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:80,Performance,cache,cached,80,// Push the current token back into the token stream (or revert it if it is; // cached) and use an annotation scope token for current token.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace them; // with the annotation token. We don't need to do this if we've; // just reverted back to a prior state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:496,Integrability,depend,dependent,496,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:335,Performance,perform,perform,335,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:415,Performance,perform,performed,415,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:41,Testability,log,logic,41,// FIXME: Move the tentative declaration logic into ClassifyName so we can; // typo-correct to tentatively-declared identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,Availability,recover,recover,134,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:49,Performance,perform,perform,49,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,Safety,recover,recover,134,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:250,Availability,error,error,250,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:256,Availability,recover,recovery,256,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:256,Safety,recover,recovery,256,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:107,Integrability,protocol,protocol-qualified,107,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:77,Modifiability,parameteriz,parameterized,77,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1107,Availability,error,error,1107,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1165,Availability,error,error,1165,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:391,Energy Efficiency,efficient,efficient,391,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:1148,Integrability,rout,routine,1148,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:336,Usability,simpl,simplifies,336,"/// TryAnnotateTypeOrScopeToken - If the current token position is on a; /// typename (possibly qualified in C++) or a C++ scope specifier not followed; /// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens; /// with a single annotation token representing the typename or C++ scope; /// respectively.; /// This simplifies handling of C++ scope specifiers and allows efficient; /// backtracking without the need to re-parse and resolve nested-names and; /// typenames.; /// It will mainly be called when we expect to treat identifiers as typenames; /// (if they are typenames). For example, in C we do not expect identifiers; /// inside expressions to be treated as typenames so it will not be called; /// for expressions in C.; /// The benefit for C/ObjC is that a typename will be annotated and; /// Actions.getTypeName will not be needed to be called again (e.g. getTypeName; /// will not be called twice, once to check whether we have a declaration; /// specifier, and another one to get the actual type inside; /// ParseDeclarationSpecifiers).; ///; /// This returns true if an error occurred.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:215,Usability,simpl,simple-template-id,215,"// Parse a C++ typename-specifier, e.g., ""typename T::type"".; //; // typename-specifier:; // 'typename' '::' [opt] nested-name-specifier identifier; // 'typename' '::' [opt] nested-name-specifier template [opt]; // simple-template-id",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:14,Availability,recover,recover,14,// Attempt to recover by skipping the invalid 'typename',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:14,Safety,recover,recover,14,// Attempt to recover by skipping the invalid 'typename',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:107,Integrability,protocol,protocol-qualified,107,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:77,Modifiability,parameteriz,parameterized,77,/// An Objective-C object type followed by '<' is a specialization of; /// a parameterized class type or a protocol-qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace; // them with the annotation token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:23,Availability,error,error,23,"// If an unrecoverable error occurred, we need to return true here,; // because the token stream is in a damaged state. We may not; // return a valid identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:162,Deployability,Update,Update,162,// A template-id that refers to a type was parsed into a; // template-id annotation in a context where we weren't allowed; // to produce a type annotation token. Update the template-id; // annotation token to a type annotation token now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:163,Availability,error,error,163,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:187,Availability,recover,recovered,187,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:245,Availability,error,error,245,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:228,Integrability,rout,routine,228,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:187,Safety,recover,recovered,187,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:16,Availability,failure,failure,16,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:38,Performance,load,loader,38,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:49,Safety,abort,abort,49,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Availability,recover,recover,8,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:114,Availability,recover,recover,114,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,Safety,recover,recover,8,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:114,Safety,recover,recover,114,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,Availability,recover,recovered,9,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,Safety,recover,recovered,9,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,Availability,recover,recovery,22,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:43,Availability,error,error,43,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,Safety,recover,recovery,22,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Availability,Recover,Recover,3,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Safety,Recover,Recover,3,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Availability,Recover,Recover,85,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Safety,Recover,Recover,85,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:455,Integrability,interface,interface,455,"//===--- ParseStmt.cpp - Statement and Block Parser -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Statement and Block portions of the Parser; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:456,Integrability,synchroniz,synchronized-statement,456,/// ParseStatementOrDeclaration - Read 'statement' or 'declaration'.; /// StatementOrDeclaration:; /// statement; /// declaration; ///; /// statement:; /// labeled-statement; /// compound-statement; /// expression-statement; /// selection-statement; /// iteration-statement; /// jump-statement; /// [C++] declaration-statement; /// [C++] try-block; /// [MS] seh-try-block; /// [OBC] objc-throw-statement; /// [OBC] objc-try-catch-statement; /// [OBC] objc-synchronized-statement; /// [GNU] asm-statement; /// [OMP] openmp-construct [TODO]; ///; /// labeled-statement:; /// identifier ':' statement; /// 'case' constant-expression ':' statement; /// 'default' ':' statement; ///; /// selection-statement:; /// if-statement; /// switch-statement; ///; /// iteration-statement:; /// while-statement; /// do-statement; /// for-statement; ///; /// expression-statement:; /// expression[opt] ';'; ///; /// jump-statement:; /// 'goto' identifier ';'; /// 'continue' ';'; /// 'break' ';'; /// 'return' expression[opt] ';'; /// [GNU] 'goto' '*' expression ';'; ///; /// [OBC] objc-throw-statement:; /// [OBC] '@' 'throw' expression ';'; /// [OBC] '@' 'throw' ';'; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Availability,error,errors,10,"// Handle errors here by skipping up to the next semicolon or '}', and; // eat the semicolon if that's what stopped us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Availability,Recover,Recover,3,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Safety,Recover,Recover,3,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:88,Deployability,update,updated,88,"// DeepestParsedCaseStmt - This is the deepest statement we have parsed, which; // gets updated each time a new case is parsed, and whose body is unset so; // far. When parsing 'case 4', this is the 'case 3' node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:103,Availability,error,error,103,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:109,Availability,recover,recovery,109,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:109,Safety,recover,recovery,109,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,Availability,recover,recover,52,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,Safety,recover,recover,52,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:20,Availability,error,error,20,"// If we had a sema error parsing this case, then just ignore it and; // continue parsing the sub-stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Deployability,Install,Install,3,// Install the body into the most deeply-nested case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Availability,Recover,Recover,3,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Safety,Recover,Recover,3,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:184,Availability,error,error,184,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:190,Availability,recover,recovery,190,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:334,Availability,recover,recover,334,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:391,Availability,error,error,391,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:485,Availability,recover,recover,485,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:622,Availability,error,errors,622,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:246,Integrability,depend,depending,246,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:175,Performance,perform,performs,175,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:190,Safety,recover,recovery,190,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:334,Safety,recover,recover,334,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:485,Safety,recover,recover,485,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,Availability,recover,recover,83,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,Safety,recover,recover,83,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:622,Safety,detect,detect,622,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:879,Usability,simpl,simpler,879,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do; // this if the body isn't a compound statement to avoid push/pop in common; // cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:185,Availability,error,error,185,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:122,Safety,avoid,avoid,122,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:68,Availability,error,error,68,"// Both invalid, or one is invalid and other is non-present: return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,Availability,recover,recovery,56,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,Safety,recover,recovery,56,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:202,Safety,avoid,avoid,202,"// C99 6.8.4p3 - In C99, the body of the switch statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:201,Safety,avoid,avoid,201,"// C99 6.8.5p5 - In C99, the body of the while statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,Safety,avoid,avoid,198,"// C99 6.8.5p5 - In C99, the body of the do statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:607,Usability,simpl,simple-declaration,607,/// ParseForStatement; /// for-statement: [C99 6.8.5.3]; /// 'for' '(' expr[opt] ';' expr[opt] ';' expr[opt] ')' statement; /// 'for' '(' declaration expr[opt] ';' expr[opt] ')' statement; /// [C++] 'for' '(' for-init-statement condition[opt] ';' expression[opt] ')'; /// [C++] statement; /// [C++0x] 'for'; /// 'co_await'[opt] [Coroutines]; /// '(' for-range-declaration ':' for-range-initializer ')'; /// statement; /// [OBJC2] 'for' '(' declaration 'in' expr ')' statement; /// [OBJC2] 'for' '(' expr 'in' expr ')' statement; ///; /// [C++] for-init-statement:; /// [C++] expression-statement; /// [C++] simple-declaration; /// [C++23] alias-declaration; ///; /// [C++0x] for-range-declaration:; /// [C++0x] attribute-specifier-seq[opt] type-specifier-seq declarator; /// [C++0x] for-range-initializer:; /// [C++0x] expression; /// [C++0x] braced-init-list [TODO],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:302,Availability,error,error,302,"// We already know this is not an init-statement within a for loop, so; // if we are parsing a C++11 range-based for loop, we should treat this; // expression statement as being a discarded value expression because; // we will err below. This way we do not warn on an unused expression; // that was an error in the first place, like with: for (expr : expr);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Availability,recover,recovery,10,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Safety,recover,recovery,10,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:104,Usability,clear,clearly,104,"// FIXME: The C++11 standard doesn't actually say that this is a; // discarded-value expression, but it clearly should be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:178,Modifiability,variab,variable,178,"// We need to perform most of the semantic analysis for a C++0x for-range; // statememt before parsing the body, in order to be able to deduce the type; // of an auto-typed loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:14,Performance,perform,perform,14,"// We need to perform most of the semantic analysis for a C++0x for-range; // statememt before parsing the body, in order to be able to deduce the type; // of an auto-typed loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:38,Modifiability,variab,variable,38,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:84,Performance,Perform,Perform,84,// In OpenMP loop region loop control variable must be captured and be; // private. Perform analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,Safety,avoid,avoid,199,"// C99 6.8.5p5 - In C99, the body of the for statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for; // for-init-statement/condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,Safety,safe,safe,199,"// Do not enter a scope for the brace, as the arguments are in the same scope; // (the function body) as the body itself. Instead, just read the statement; // list and put it into a CompoundStmt for safe keeping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:65,Usability,usab,usable,65,// Don't bother creating the full statement if we don't have any usable; // handlers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,Integrability,depend,dependent,10,"// Handle dependent statements by parsing the braces as a compound statement.; // This is not the same behavior as Visual C++, which don't treat this as a; // compound statement, but for Clang's type checking we can't have anything; // inside these braces escaping to the surrounding code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:111,Availability,failure,failure,111,"// If we consumed the entire line, tell MC that.; // Also do this if we consumed nothing as a way of reporting failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:12,Testability,assert,assert,12,"// For now, assert that the string we're working with is a substring; // of what we gave to MC. This lets us use the original tokens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:12,Testability,assert,assert,12,"// For now, assert that the start of the string exactly; // corresponds to the start of a token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:117,Testability,Assert,Assert,117,"// If we come up with an answer which seems sane, use it; otherwise,; // just point at the __asm keyword.; // FIXME: Assert the answer is sane once we handle .macro correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:3,Usability,Clear,Clear,3,// Clear the current token and advance to the first token in LineToks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:3,Performance,Perform,Perform,3,// Perform the lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:110,Safety,avoid,avoid,110,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:91,Security,access,access,91,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:85,Availability,error,error,85,"// If we've run into the poison token we inserted before, or there; // was a parsing error, then claim the entire line.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:88,Integrability,rout,routine,88,"/// ParseMicrosoftAsmStatement. When -fms-extensions/-fasm-blocks is enabled,; /// this routine is called to collect the tokens for an MS asm statement.; ///; /// [MS] ms-asm-statement:; /// ms-asm-block; /// ms-asm-block ms-asm-statement; ///; /// [MS] ms-asm-block:; /// '__asm' ms-asm-line '\n'; /// '__asm' '{' ms-asm-instruction-block[opt] '}' ';'[opt]; ///; /// [MS] ms-asm-instruction-block; /// ms-asm-line; /// ms-asm-line '\n' ms-asm-instruction-block; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:30,Security,sanitiz,sanitizer,30,// FIXME: init MCOptions from sanitizer flags here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:19,Modifiability,variab,variable,19,// Need address of variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:46,Modifiability,extend,extended,46,/// parseGNUAsmQualifierListOpt - Parse a GNU extended asm qualifier list.; /// asm-qualifier:; /// volatile; /// inline; /// goto; ///; /// asm-qualifier-list:; /// asm-qualifier; /// asm-qualifier-list asm-qualifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:36,Modifiability,extend,extended,36,"/// ParseAsmStatement - Parse a GNU extended asm statement.; /// asm-statement:; /// gnu-asm-statement; /// ms-asm-statement; ///; /// [GNU] gnu-asm-statement:; /// 'asm' asm-qualifier-list[opt] '(' asm-argument ')' ';'; ///; /// [GNU] asm-argument:; /// asm-string-literal; /// asm-string-literal ':' asm-operands[opt]; /// asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]; /// asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]; /// ':' asm-clobbers; ///; /// [GNU] asm-clobbers:; /// asm-string-literal; /// asm-clobbers ',' asm-string-literal; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:49,Availability,Error,Error,49,// Check if GNU-style InlineAsm is disabled.; // Error on anything other than empty string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:13,Usability,simpl,simple,13,"// We have a simple asm expression like 'asm(""foo"")'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:365,Safety,Avoid,Avoid,365,"/// ParseAsmOperands - Parse the asm-operands production as used by; /// asm-statement, assuming the leading ':' token was eaten.; ///; /// [GNU] asm-operands:; /// asm-operand; /// asm-operands ',' asm-operand; ///; /// [GNU] asm-operand:; /// asm-string-literal '(' expression ')'; /// '[' identifier ']' asm-string-literal '(' expression ')'; ///; //; // FIXME: Avoid unnecessary std::string trashing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:258,Security,access,access,258,"/// Parse a single declaration that declares a template,; /// template specialization, or explicit instantiation of a template.; ///; /// \param DeclEnd will receive the source location of the last token; /// within this declaration.; ///; /// \param AS the access specifier associated with this; /// declaration. Will be AS_none for namespace-scope declarations.; ///; /// \returns the new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:50,Availability,error,error,50,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Availability,recover,recovery,56,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Safety,recover,recovery,56,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Security,access,access,18,"// Turn off usual access checking for template specializations and; // instantiations.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - parameter-list;; // - template-argument-list;; // - noexcept-specifier;; // - dynamic-exception-specifications (deprecated in C++11, removed since; // C++17).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:139,Security,access,access,139,"// Turn off usual access checking for template specializations and; // instantiations.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - parameter-list;; // - template-argument-list;; // - noexcept-specifier;; // - dynamic-exception-specifications (deprecated in C++11, removed since; // C++17).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Error,Error,3,// Error parsing the declarator?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:73,Availability,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:73,Safety,recover,recover,73,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:546,Availability,error,error,546,"/// ParseTemplateParameters - Parses a template-parameter-list enclosed in; /// angle brackets. Depth is the depth of this template-parameter-list, which; /// is the number of template headers directly enclosing this template header.; /// TemplateParams is the current list of template parameters we're building.; /// The template parameter we parse will be added to this list. LAngleLoc and; /// RAngleLoc will receive the positions of the '<' and '>', respectively,; /// that enclose this template parameter list.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:109,Availability,error,error,109,// Somebody probably forgot to close the template. Skip ahead and; // try to get out of the expression. This error is currently; // subsumed by whatever goes on in ParseTemplateParameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:258,Availability,error,error,258,"// We return an invalid parameter as opposed to null to avoid having bogus; // diagnostics about an empty template parameter list.; // FIXME: Fix ParseTemplateParameterList to better handle nullptr results; // from here.; // Return a NTTP as if there was an error in a scope specifier, the user; // probably meant to write the type of a NTTP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,Safety,avoid,avoid,56,"// We return an invalid parameter as opposed to null to avoid having bogus; // diagnostics about an empty template parameter list.; // FIXME: Fix ParseTemplateParameterList to better handle nullptr results; // from here.; // Return a NTTP as if there was an error in a scope specifier, the user; // probably meant to write the type of a NTTP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:99,Availability,error,errors,99,"// If it's none of the above, then it must be a parameter declaration.; // NOTE: This will pick up errors in the closure of the template parameter; // list (e.g., template < ; Check here to implement >> style closures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:252,Availability,error,error,252,"/// Try parsing a type-constraint at the current location.; ///; /// type-constraint:; /// nested-name-specifier[opt] concept-name; /// nested-name-specifier[opt] concept-name; /// '<' template-argument-list[opt] '>'[opt]; ///; /// \returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,Availability,avail,available,31,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the type parameter into the local scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:103,Availability,error,error,103,"// Provide an ExtWarn if the C++1z feature of using 'typename' here is used.; // Generate a meaningful error if the user forgot to put class before the; // identifier, comma, or greater. Provide a fixit if the identifier, comma,; // or greater appear immediately or after 'struct'. In the latter case,; // replace the keyword with 'class'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:31,Availability,avail,available,31,"// Grab a default argument (if available).; // Per C++0x [basic.scope.pdecl]p9, we parse the default argument before; // we introduce the template parameter into the local scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Availability,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Safety,Recover,Recover,3,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:116,Availability,error,error,116,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:122,Availability,recover,recovery,122,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:215,Modifiability,extend,extend,215,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:122,Safety,recover,recovery,122,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:77,Usability,clear,clear,77,"// A hint to put a space between the '>>'s. In order to make the hint as; // clear as possible, we include the characters either side of the space in; // the replacement, rather than just inserting a space at SecondCharLoc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Deployability,Update,Update,3,// Update the token cache to match what we just did if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:20,Performance,cache,cache,20,// Update the token cache to match what we just did if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:19,Performance,cache,cached,19,"// If the previous cached token is being merged, delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:99,Integrability,rout,routine,99,"/// Parses a template-id that after the template name has; /// already been parsed.; ///; /// This routine takes care of parsing the enclosed template argument; /// list ('<' template-parameter-list [opt] '>') and placing the; /// results into a form that can be transferred to semantic analysis.; ///; /// \param ConsumeLastToken if true, then we will consume the last; /// token that forms the template-id. Otherwise, we will leave the; /// last token in the stream (e.g., so that it can be replaced with an; /// annotation token).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1910,Availability,error,error,1910,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:229,Integrability,rout,routine,229,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:35,Usability,simpl,simple-template-id,35,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:266,Usability,simpl,simple-template-id,266,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1400,Usability,simpl,simple-template-id,1400,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:1597,Usability,simpl,simple-template-id,1597,"/// Replace the tokens that form a simple-template-id with an; /// annotation token containing the complete template-id.; ///; /// The first token in the stream must be the name of a template that; /// is followed by a '<'. This routine will parse the complete; /// simple-template-id and replace the tokens with a single annotation; /// token with one of two different kinds: if the template-id names a; /// type (and \p AllowTypeAnnotation is true), the annotation token is; /// a type annotation that includes the optional nested-name-specifier; /// (\p SS). Otherwise, the annotation token is a template-id; /// annotation that does not include the optional; /// nested-name-specifier.; ///; /// \param Template the declaration of the template named by the first; /// token (an identifier), as returned from \c Action::isTemplateName().; ///; /// \param TNK the kind of template that \p Template; /// refers to, as returned from \c Action::isTemplateName().; ///; /// \param SS if non-NULL, the nested-name-specifier that precedes; /// this template name.; ///; /// \param TemplateKWLoc if valid, specifies that this template-id; /// annotation was preceded by the 'template' keyword and gives the; /// location of that keyword. If invalid (the default), then this; /// template-id was not preceded by a 'template' keyword.; ///; /// \param AllowTypeAnnotation if true (the default), then a; /// simple-template-id that refers to a class template, template; /// template parameter, or other template that produces a type will be; /// replaced with a type annotation token. Otherwise, the; /// simple-template-id is always replaced with a template-id; /// annotation token.; ///; /// \param TypeConstraint if true, then this is actually a type-constraint,; /// meaning that the template argument list can be omitted (and the template in; /// question must be a concept).; ///; /// If an unrecoverable parse error occurs and no annotation token can be; /// formed, this function returns true.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,recover,recover,18,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Safety,recover,recover,18,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:27,Performance,cache,cached,27,"// In case the tokens were cached, have Preprocessor replace them with the; // annotation token.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:104,Availability,failure,failure,104,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:261,Availability,error,error,261,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:444,Integrability,depend,dependent,444,"/// Replaces a template-id annotation token with a type; /// annotation token.; ///; /// If there was a failure when forming the type from the template-id,; /// a type annotation token will still be created, but will have a; /// NULL type pointer to signify an error.; ///; /// \param SS The scope specifier appearing before the template-id, if any.; ///; /// \param AllowImplicitTypename whether this is a context where T::type; /// denotes a dependent type.; /// \param IsClassName Is this template-id appearing in a context where we; /// know it names a class, such as in an elaborated-type-specifier or; /// base-specifier? ('typename' and 'template' are unneeded and disallowed; /// in those contexts.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:23,Integrability,depend,dependent,23,// We appear to have a dependent template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:90,Integrability,depend,dependent,90,"// If the next token signals the end of a template argument, then we have; // a (possibly-dependent) template name that could be a template template; // argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:22,Integrability,depend,dependent,22,// We may have a (non-dependent) template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:121,Availability,error,error,121,"/// ParseTemplateArgumentList - Parse a C++ template-argument-list; /// (C++ [temp.names]). Returns true if there was an error.; ///; /// template-argument-list: [C++ 14.2]; /// template-argument; /// template-argument-list ',' template-argument; ///; /// \param Template is only used for code completion, and may be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,error,error,18,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Availability,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Safety,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid the tentative parse when NextToken() can't begin a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,Availability,error,error,18,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Availability,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,Safety,recover,recovery,24,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:453,Integrability,interface,interfaces,453,"//===--- ParseTentative.cpp - Ambiguity Resolution Parsing ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the tentative parsing portions of the Parser; // interfaces, for ambiguity resolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:308,Usability,simpl,simple-declaration,308,"/// isCXXDeclarationStatement - C++-specialized function that disambiguates; /// between a declaration or an expression statement, when parsing function; /// bodies. Returns true for declaration, false for expression.; ///; /// declaration-statement:; /// block-declaration; ///; /// block-declaration:; /// simple-declaration; /// asm-definition; /// namespace-alias-definition; /// using-declaration; /// using-directive; /// [C++0x] static_assert-declaration; ///; /// asm-definition:; /// 'asm' '(' string-literal ')' ';'; ///; /// namespace-alias-definition:; /// 'namespace' identifier = qualified-namespace-specifier ';'; ///; /// using-declaration:; /// 'using' typename[opt] '::'[opt] nested-name-specifier; /// unqualified-id ';'; /// 'using' '::' unqualified-id ;; ///; /// using-directive:; /// 'using' 'namespace' '::'[opt] nested-name-specifier[opt]; /// namespace-name ';'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:312,Modifiability,variab,variable,312,"// If the scope is not empty, it could alternatively be something like; // a typedef or using declaration. That declaration might be private; // in the global context, which would be diagnosed by calling into; // isCXXSimpleDeclaration, but may actually be fine in the context of; // member functions and static variable definitions. Check if the next; // token is also an identifier and assume a declaration.; // We cannot check if the scopes match because the declarations could; // involve namespaces and friend declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,Usability,simpl,simple-declaration,3,// simple-declaration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:187,Availability,error,error,187,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:88,Usability,simpl,simple-declaration,88,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:365,Usability,simpl,simple-declaration,365,"/// isCXXSimpleDeclaration - C++-specialized function that disambiguates; /// between a simple-declaration or an expression-statement.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; /// Returns false if the statement is disambiguated as expression.; ///; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer ';' [C++17]; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; ///; /// for-range-declaration:; /// decl-specifier-seq declarator; /// decl-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; ///; /// In any of the above cases there can be a preceding attribute-specifier-seq,; /// but the caller is expected to handle that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1093,Usability,simpl,simple-type-specifier,1093,"// C++ 6.8p1:; // There is an ambiguity in the grammar involving expression-statements and; // declarations: An expression-statement with a function-style explicit type; // conversion (5.2.3) as its leftmost subexpression can be indistinguishable; // from a declaration where the first declarator starts with a '('. In those; // cases the statement is a declaration. [Note: To disambiguate, the whole; // statement might have to be examined to determine if it is an; // expression-statement or a declaration].; // C++ 6.8p3:; // The disambiguation is purely syntactic; that is, the meaning of the names; // occurring in such a statement, beyond whether they are type-names or not,; // is not generally used in or changed by the disambiguation. Class; // templates are instantiated as necessary to determine if a qualified name; // is a type-name. Disambiguation precedes parsing, and a statement; // disambiguated as a declaration may be an ill-formed declaration.; // We don't have to parse all of the decl-specifier-seq part. There's only; // an ambiguity if the first decl-specifier is; // simple-type-specifier/typename-specifier followed by a '(', which may; // indicate a function-style cast expression.; // isCXXDeclarationSpecifier will return TPResult::Ambiguous only in such; // a case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Availability,Error,Error,52,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: TryParseSimpleDeclaration doesn't look past the first initializer,; // and so gets some cases wrong. We can't carry on if we've already seen; // something which makes this statement invalid as a declaration in this case,; // since it can cause us to misparse valid code. Revisit this once; // TryParseInitDeclaratorList is fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:175,Usability,simpl,simple-type-specifier,175,"// FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '(',; // or an identifier which doesn't resolve as anything. We need tentative; // parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,Usability,simpl,simple-template-id,170,// elaborated-type-specifier:; // class-key attribute-specifier-seq[opt]; // nested-name-specifier[opt] identifier; // class-key nested-name-specifier[opt] template[opt] simple-template-id; // enum nested-name-specifier[opt] identifier; //; // FIXME: We don't support class-specifiers nor enum-specifiers here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:4,Usability,simpl,simple-declaration,4,/// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// (if AllowForRangeDecl specified); /// for ( for-range-declaration : for-range-initializer ) statement; /// for-range-declaration:; /// attribute-specifier-seqopt type-specifier-seq declarator; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:78,Usability,simpl,simple-declaration,78,// Two decl-specifiers in a row conclusively disambiguate this as being a; // simple-declaration. Don't bother calling isCXXDeclarationSpecifier in the; // overwhelmingly common case that the next token is a '('.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:280,Usability,simpl,simple-asm-expr,280,"/// Tentatively parse an init-declarator-list in order to disambiguate it from; /// an expression.; ///; /// init-declarator-list:; /// init-declarator; /// init-declarator-list ',' init-declarator; ///; /// init-declarator:; /// declarator initializer[opt]; /// [GNU] declarator simple-asm-expr[opt] attributes[opt] initializer[opt]; ///; /// initializer:; /// brace-or-equal-initializer; /// '(' expression-list ')'; ///; /// brace-or-equal-initializer:; /// '=' initializer-clause; /// [C++11] braced-init-list; ///; /// initializer-clause:; /// assignment-expression; /// braced-init-list; ///; /// braced-init-list:; /// '{' initializer-list ','[opt] '}'; /// '{' '}'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:9,Usability,simpl,simple-asm-expr,9,// [GNU] simple-asm-expr[opt] attributes[opt],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:728,Availability,error,error,728,"// MSVC and g++ won't examine the rest of declarators if '=' is; // encountered; they just conclude that we have a declaration.; // EDG parses the initializer completely, which is the proper behavior; // for this case.; //; // At present, Clang follows MSVC and g++, since the parser does not have; // the ability to parse an expression fully without recording the; // results of that parse.; // FIXME: Handle this case correctly.; //; // Also allow 'in' after an Objective-C declaration as in:; // for (int (^b)(void) in array). Ideally this should be done in the; // context of parsing for-init-statement of a foreach statement only. But,; // in any other context 'in' is invalid after a declaration and parser; // issues the error regardless of outcome of this decision.; // FIXME: Change if above assumption does not hold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Modifiability,variab,variables,52,// FIXME: Unify the parsing codepaths for condition variables and; // simple-declarations so that we don't need to eagerly figure out which; // kind we have here. (Just parse init-declarators until we reach a; // semicolon or right paren.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:70,Usability,simpl,simple-declarations,70,// FIXME: Unify the parsing codepaths for condition variables and; // simple-declarations so that we don't need to eagerly figure out which; // kind we have here. (Just parse init-declarators until we reach a; // semicolon or right paren.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:63,Usability,simpl,simple-declaration,63,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:434,Usability,simpl,simple-asm-expr,434,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:507,Usability,simpl,simple-declaration,507,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:758,Usability,simpl,simple-declaration,758,"/// Disambiguates between a declaration in a condition, a; /// simple-declaration in an init-statement, and an expression for; /// a condition of a if/switch statement.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; /// simple-declaration:; /// decl-specifier-seq init-declarator-list[opt] ';'; ///; /// Note that, unlike isCXXSimpleDeclaration, we must disambiguate all the way; /// to the ';' to disambiguate cases like 'int(x))' (an expression) from; /// 'int(x);' (a simple-declaration in an init-statement).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:71,Usability,simpl,simple-declaration,71,// A parenthesized initializer could be part of an expression or a; // simple-declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:727,Availability,error,error,727,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,Integrability,rout,routine,170,"/// Determine whether the next set of tokens contains a type-id.; ///; /// The context parameter states what context we're parsing right; /// now, which affects how this routine copes with the token; /// following the type-id. If the context is TypeIdInParens, we have; /// already parsed the '(' and we will cease lookahead when we hit; /// the corresponding ')'. If the context is; /// TypeIdAsTemplateArgument, we've already parsed the '<' or ','; /// before this template argument, and will cease lookahead when we; /// hit a '>', '>>' (in C++0x), or ','; or, in C++0x, an ellipsis immediately; /// preceding such. Returns true for a type-id and false for an expression.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// type-id:; /// type-specifier-seq abstract-declarator[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:52,Availability,Error,Error,52,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:235,Usability,simpl,simple-type-specifier,235,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:246,Integrability,message,message-send,246,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:516,Integrability,message,message,516,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:604,Integrability,message,message,604,"/// Returns true if this is a C++11 attribute-specifier. Per; /// C++11 [dcl.attr.grammar]p6, two consecutive left square bracket tokens; /// always introduce an attribute. In Objective-C++11, this rule does not; /// apply if either '[' begins a message-send.; ///; /// If Disambiguate is true, we try harder to determine whether a '[[' starts; /// an attribute-specifier, and return CAK_InvalidAttributeSpecifier if not.; ///; /// If OuterMightBeMessageSend is true, we assume the outer '[' is either an; /// Obj-C message send or the start of an attribute. Otherwise, we assume it; /// is not an Obj-C message send.; ///; /// C++11 [dcl.attr.grammar]:; ///; /// attribute-specifier:; /// '[' '[' attribute-list ']' ']'; /// alignment-specifier; ///; /// attribute-list:; /// attribute[opt]; /// attribute-list ',' attribute[opt]; /// attribute '...'; /// attribute-list ',' attribute '...'; ///; /// attribute:; /// attribute-token attribute-argument-clause[opt]; ///; /// attribute-token:; /// identifier; /// identifier '::' identifier; ///; /// attribute-argument-clause:; /// '(' balanced-token-seq ')'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:234,Integrability,Message,Message,234,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:298,Integrability,Message,Message,298,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:314,Integrability,message,message,314,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:380,Integrability,message,message,380,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,// We hit a hard error after deciding this was not an attribute.; // FIXME: Don't parse and annotate expressions when disambiguating; // against an attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:47,Integrability,message,message,47,"// Case 3: The inner construct is definitely a message send, so the; // outer construct is definitely not an attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:21,Integrability,message,message,21,// Case 4: Lambda in message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:117,Integrability,message,message,117,// No idea what this is; we couldn't parse it as a lambda-introducer.; // Might still be an attribute-specifier or a message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:76,Integrability,message,message-send,76,"// If we don't have a lambda-introducer, then we have an attribute or a; // message-send.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:11,Integrability,Message,Message,11,// Case 3: Message send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:113,Integrability,message,message,113,// Note that explicitly checking for `[[` and `]]` allows to fail as; // expected in the case of the Objective-C message send syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:228,Availability,Error,Error,228,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration; /// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could; /// be either a decl-specifier or a function-style cast, and TPResult::Error; /// if a parsing error was found and reported.; ///; /// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as; /// declaration specifiers but possibly valid as some other kind of construct; /// return TPResult::Ambiguous instead of TPResult::False. When this happens,; /// the intent is to keep trying to disambiguate, on the basis that we might; /// find a better reason to treat this construct as a declaration later on.; /// When this happens and the name could possibly be valid in some other; /// syntactic context, *InvalidAsDeclSpec is set to 'true'. The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:252,Availability,error,error,252,"/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration; /// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could; /// be either a decl-specifier or a function-style cast, and TPResult::Error; /// if a parsing error was found and reported.; ///; /// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as; /// declaration specifiers but possibly valid as some other kind of construct; /// return TPResult::Ambiguous instead of TPResult::False. When this happens,; /// the intent is to keep trying to disambiguate, on the basis that we might; /// find a better reason to treat this construct as a declaration later on.; /// When this happens and the name could possibly be valid in some other; /// syntactic context, *InvalidAsDeclSpec is set to 'true'. The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:921,Integrability,depend,dependent,921, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1535,Usability,simpl,simple-type-specifier,1535, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1681,Usability,simpl,simple-type-specifier,1681, The current cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-spec,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:1809,Usability,simpl,simple-template-id,1809,"urrent cases; /// that trigger this are:; ///; /// * When parsing X::Y (with no 'typename') where X is dependent; /// * When parsing X<Y> where X is undeclared; ///; /// decl-specifier:; /// storage-class-specifier; /// type-specifier; /// function-specifier; /// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:2391,Usability,simpl,simple-template-id,2391,"// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; ///; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// cv-qualifier:; /// 'const'; /// 'volatile'; /// [GNU] restrict; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:2900,Usability,simpl,simple-template-id,2900,"// 'friend'; /// 'typedef'; /// [C++11] 'constexpr'; /// [C++20] 'consteval'; /// [GNU] attributes declaration-specifiers[opt]; ///; /// storage-class-specifier:; /// 'register'; /// 'static'; /// 'extern'; /// 'mutable'; /// 'auto'; /// [GNU] '__thread'; /// [C++11] 'thread_local'; /// [C11] '_Thread_local'; ///; /// function-specifier:; /// 'inline'; /// 'virtual'; /// 'explicit'; ///; /// typedef-name:; /// identifier; ///; /// type-specifier:; /// simple-type-specifier; /// class-specifier; /// enum-specifier; /// elaborated-type-specifier; /// typename-specifier; /// cv-qualifier; ///; /// simple-type-specifier:; /// '::'[opt] nested-name-specifier[opt] type-name; /// '::'[opt] nested-name-specifier 'template'; /// simple-template-id [TODO]; /// 'char'; /// 'wchar_t'; /// 'bool'; /// 'short'; /// 'int'; /// 'long'; /// 'signed'; /// 'unsigned'; /// 'float'; /// 'double'; /// 'void'; /// [GNU] typeof-specifier; /// [GNU] '_Complex'; /// [C++11] 'auto'; /// [GNU] '__auto_type'; /// [C++11] 'decltype' ( expression ); /// [C++1y] 'decltype' ( 'auto' ); ///; /// type-name:; /// class-name; /// enum-name; /// typedef-name; ///; /// elaborated-type-specifier:; /// class-key '::'[opt] nested-name-specifier[opt] identifier; /// class-key '::'[opt] nested-name-specifier[opt] 'template'[opt]; /// simple-template-id; /// 'enum' '::'[opt] nested-name-specifier[opt] identifier; ///; /// enum-name:; /// identifier; ///; /// enum-specifier:; /// 'enum' identifier[opt] '{' enumerator-list[opt] '}'; /// 'enum' identifier[opt] '{' enumerator-list ',' '}'; ///; /// class-specifier:; /// class-head '{' member-specification[opt] '}'; ///; /// class-head:; /// class-key identifier[opt] base-clause[opt]; /// class-key nested-name-specifier identifier base-clause[opt]; /// class-key nested-name-specifier[opt] simple-template-id; /// base-clause[opt]; ///; /// class-key:; /// 'class'; /// 'struct'; /// 'union'; ///; /// cv-qualifier:; /// 'const'; /// 'volatile'; /// [GNU] restrict; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:81,Availability,error,error,81,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:263,Availability,recover,recover,263,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:276,Availability,error,errors,276,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:263,Safety,recover,recover,263,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:176,Usability,undo,undo,176,"// In C++17, this could be a type template for class template argument; // deduction. Try to form a type annotation for it. If we're in a; // template template argument, we'll undo this when checking the; // validity of the argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:83,Availability,error,error,83,"// A bare type template-name which can't be a template template; // argument is an error, and was probably intended to be a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:40,Integrability,depend,dependent,40,"// This might possibly be a type with a dependent scope specifier and; // a missing 'typename' keyword. Don't use TryAnnotateName in this case,; // since it will annotate as a primary expression, and we want to use the; // ""missing 'typename'"" logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:244,Testability,log,logic,244,"// This might possibly be a type with a dependent scope specifier and; // a missing 'typename' keyword. Don't use TryAnnotateName in this case,; // since it will annotate as a primary expression, and we want to use the; // ""missing 'typename'"" logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:23,Usability,simpl,simple-type-specifier,23,// type-specifier:; // simple-type-specifier; // class-specifier; // enum-specifier; // elaborated-type-specifier; // typename-specifier; // cv-qualifier; // class-specifier; // elaborated-type-specifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:10,Security,access,access,10,// OpenCL access qualifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:208,Availability,error,error,208,"// 'template-id(' can be a valid expression but not a valid decl spec if; // the template-name is not declared, but we don't consider this to be a; // definitive disambiguation. In any other context, it's an error either; // way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:156,Testability,test,test,156,// If we annotated then the current token should not still be ::; // FIXME we may want to also check for tok::annot_typename but; // currently don't have a test case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:83,Availability,error,error,83,"// A bare type template-name which can't be a template template; // argument is an error, and was probably intended to be a type.; // In C++17, this could be class template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:51,Usability,simpl,simple-type-id,51,"// If that succeeded, fallthrough into the generic simple-type-id case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:30,Usability,simpl,simple-type-specifier,30,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:407,Usability,simpl,simple-type-specifier,407,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:466,Usability,simpl,simple-type-specifier,466,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:35,Integrability,protocol,protocol-qualified,35,"// In Objective-C, we might have a protocol-qualified type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:25,Integrability,protocol,protocol,25,// Tentatively parse the protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,Usability,simpl,simple-type-specifier,3,// simple-type-specifier,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:11,Integrability,protocol,protocol-qualifiers,11,/// [ObjC] protocol-qualifiers:; //// '<' identifier-list '>',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:296,Availability,error,error,296,"/// isCXXFunctionDeclarator - Disambiguates between a function declarator or; /// a constructor-style initializer, when parsing declaration statements.; /// Returns true for function declarator and false for constructor-style; /// initializer.; /// If during the disambiguation process a parsing error is encountered,; /// the function returns true to let the declaration parsing code handle it.; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,Availability,redundant,redundant,254,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,Safety,redund,redundant,254,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:17,Availability,error,error,17,"// In case of an error, let the declaration parsing code handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:373,Modifiability,inherit,inherit,373,"// If we're disambiguating a template argument in a default argument in; // a class definition versus a parameter declaration, an '=' here; // disambiguates the parse one way or the other.; // If this is a parameter, it must have a default argument because; // (a) the previous parameter did, and; // (b) this must be the first declaration of the function, so we can't; // inherit any default arguments from elsewhere.; // FIXME: If we reach a ')' without consuming any '>'s, then this must; // also be a function parameter (that's missing its default argument).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:281,Availability,Error,Error,281,"/// TryParseFunctionDeclarator - We parsed a '(' and we want to try to continue; /// parsing as a function declarator.; /// If TryParseFunctionDeclarator fully parsed the function declarator, it will; /// return TPResult::Ambiguous, otherwise it will return either False() or; /// Error().; ///; /// '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; /// exception-specification[opt]; ///; /// exception-specification:; /// 'throw' '(' type-id-list[opt] ')'; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:105,Usability,simpl,simple-template-id,105,"/// Determine whether we might be looking at the '<' template-argument-list '>'; /// of a template-id or simple-template-id, rather than a less-than comparison.; /// This will often fail and produce an ambiguity, but should never be wrong; /// if it returns True or False.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:87,Usability,guid,guide,87,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:124,Usability,guid,guide,124,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:193,Usability,guid,guide,193,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:34,Modifiability,Rewrite,Rewrite,34,"//===- DeltaTree.cpp - B-Tree for Rewrite Delta tracking ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DeltaTree and related classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:143,Energy Efficiency,efficient,efficient,143,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:408,Energy Efficiency,efficient,efficiently,408,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:137,Performance,cache,cache,137,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:57,Availability,down,down,57,"// Otherwise, this is an interior node. Send the request down the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:133,Availability,down,down,133,"// Now that we have two nodes and a new element, insert the perclated value; // into ourself by moving all the later values/children down, then inserting; // the new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:156,Safety,avoid,avoid,156,"// Finally, if this interior node was full and a node is percolated up, split; // ourself and return that up the chain. Start by saving all our info to; // avoid having the split clobber it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:32,Performance,perform,performing,32,/// VerifyTree - Walk the btree performing assertions on various properties to; /// verify consistency. This is useful for debugging new changes to the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:43,Testability,assert,assertions,43,/// VerifyTree - Walk the btree performing assertions on various properties to; /// verify consistency. This is useful for debugging new changes to the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:8,Availability,down,down,8,// Walk down the tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:23,Availability,down,down,23,"// Otherwise, traverse down the tree. The selected subtree may be; // partially included in the range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:625,Energy Efficiency,green,green,625,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:2538,Integrability,wrap,wrap,2538,"position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:2573,Integrability,wrap,wrap,2573,"position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:762,Modifiability,variab,variables,762,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:858,Modifiability,Variab,Variable,858,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:896,Modifiability,variab,variable,896,"R""<<<(; <style type=""text/css"">; body { color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:1031,Modifiability,variab,variable,1031," color:#000000; background-color:#ffffff }; body { font-family:Helvetica, sans-serif; font-size:10pt }; h1 { font-size:14pt }; .FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }; .FileNav { margin-left: 5px; margin-right: 5px; display: inline; }; .FileNav a { text-decoration:none; font-size: larger; }; .divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }; .divider { background-color: gray; }; .code { border-collapse:collapse; width:100%; }; .code { font-family: ""Monospace"", monospace; font-size:10pt }; .code { line-height: 1.2em }; .comment { color: green; font-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { c",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:1598,Modifiability,variab,variable,1598,"ont-style: oblique }; .keyword { color: blue }; .string_literal { color: red }; .directive { color: darkmagenta }. /* Macros and variables could have pop-up notes hidden by default.; - Macro pop-up: expansion of the macro; - Variable pop-up: value (table) of the variable */; .macro_popup, .variable_popup { display: none; }. /* Pop-up appears on mouse-hover event. */; .macro:hover .macro_popup, .variable:hover .variable_popup {; display: block;; padding: 2px;; -webkit-border-radius:5px;; -webkit-box-shadow:1px 1px 7px #000;; border-radius:5px;; box-shadow:1px 1px 7px #000;; position: absolute;; top: -1em;; left:10em;; z-index: 1; }. .macro_popup {; border: 2px solid red;; background-color:#FFF0F0;; font-weight: normal;; }. .variable_popup {; border: 2px solid blue;; background-color:#F0F0FF;; font-weight: bold;; font-family: Helvetica, sans-serif;; font-size: 9pt;; }. /* Pop-up notes needs a relative position as a base where they pops up. */; .macro, .variable {; background-color: PaleGoldenRod;; position: relative;; }; .macro { color: DarkMagenta; }. #tooltiphint {; position: fixed;; width: 50em;; margin-left: -25em;; left: 50%;; padding: 10px;; border: 1px solid #b0b0b0;; border-radius: 2px;; box-shadow: 1px 1px 7px black;; background-color: #c0c0c0;; z-index: 2;; }. .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }; .num { text-align:right; font-size:8pt }; .num { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { backgro",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:3438,Usability,simpl,simpletable,3438," { color:#444444 }; .line { padding-left: 1ex; border-left: 3px solid #ccc }; .line { white-space: pre }; .msg { -webkit-box-shadow:1px 1px 7px #000 }; .msg { box-shadow:1px 1px 7px #000 }; .msg { -webkit-border-radius:5px }; .msg { border-radius:5px }; .msg { font-family:Helvetica, sans-serif; font-size:8pt }; .msg { float:left }; .msg { position:relative }; .msg { padding:0.25em 1ex 0.25em 1ex }; .msg { margin-top:10px; margin-bottom:10px }; .msg { font-weight:bold }; .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }; .msgT { padding:0x; spacing:0x }; .msgEvent { background-color:#fff8b4; color:#000000 }; .msgControl { background-color:#bbbbbb; color:#000000 }; .msgNote { background-color:#ddeeff; color:#000000 }; .mrange { background-color:#dfddf3 }; .mrange { border-bottom:1px solid #6F9DBE }; .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }; .PathIndex { -webkit-border-radius:8px }; .PathIndex { border-radius:8px }; .PathIndexEvent { background-color:#bfba87 }; .PathIndexControl { background-color:#8c8c8c }; .PathIndexPopUp { background-color: #879abc; }; .PathNav a { text-decoration:none; font-size: larger }; .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }; .CodeRemovalHint { background-color:#de1010 }; .CodeRemovalHint { border-bottom:1px solid #6F9DBE }; .msg.selected{ background-color:orange !important; }. table.simpletable {; padding: 5px;; font-size:12pt;; margin:20px;; border-collapse: collapse; border-spacing: 0px;; }; td.rowname {; text-align: right;; vertical-align: top;; font-weight: bold;; color:#444444;; padding-right:2ex;; }. /* Hidden text. */; input.spoilerhider + label {; cursor: pointer;; text-decoration: underline;; display: block;; }; input.spoilerhider {; display: none;; }; input.spoilerhider ~ .spoiler {; overflow: hidden;; margin: 10px auto 0;; height: 0;; opacity: 0;; }; input.spoilerhider:checked + label + .spoiler{; height: auto;; opacity: 1;; }; </style>; </head>; <body>)<<<""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:38,Safety,avoid,avoid,38,"// Lex all the tokens in raw mode, to avoid entering #includes or expanding; // macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:37,Deployability,update,update,37,"// Fill in Result.IdentifierInfo and update the token kind,; // looking up the identifier in the identifier table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:38,Safety,avoid,avoid,38,"// Lex all the tokens in raw mode, to avoid entering #includes or expanding; // macros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:104,Availability,error,error,104,"// If this is a ## token, change its kind to unknown so that repreprocessing; // it will not produce an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:69,Safety,avoid,avoid,69,"// If the tokens were already space separated, or if they must be to avoid; // them being implicitly pasted, add a space between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:37,Integrability,interface,interface,37,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:7,Modifiability,Rewrite,Rewriter,7,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:405,Modifiability,Rewrite,Rewriter,405,"//===- Rewriter.cpp - Code rewriting interface ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Rewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:27,Energy Efficiency,efficient,efficiently,27,// Walk RewriteRope chunks efficiently using MoveToNextPiece() instead of the; // character iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:8,Modifiability,Rewrite,RewriteRope,8,// Walk RewriteRope chunks efficiently using MoveToNextPiece() instead of the; // character iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:173,Availability,reliab,reliably,173,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:130,Modifiability,rewrite,rewrite,130,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:548,Modifiability,Rewrite,Rewriter,548,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:558,Modifiability,Rewrite,RewriteOptions,558,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:692,Modifiability,Rewrite,Rewrite,692,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:700,Modifiability,Rewrite,RewriteBufferTest,700,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:646,Testability,test,test,646,"// FIXME: Here, the offset of the start of the line is supposed to be; // expressed in terms of the original input not the ""real"" rewrite; // buffer. How do we compute that reliably? It might be tempting to use; // curLineStartOffs + OrigOffset - RealOffset, but that assumes the; // difference between the original and real offset is the same at the; // removed text and at the start of the line, but that's not true if; // edits were previously made earlier on the line. This bug is also; // documented by a FIXME on the definition of; // clang::Rewriter::RewriteOptions::RemoveLineIfEmpty. A reproducer for; // the implementation below is the test RemoveLineIfEmpty in; // clang/unittests/Rewrite/RewriteBufferTest.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:85,Modifiability,Rewrite,Rewriter,85,"//===----------------------------------------------------------------------===//; // Rewriter class; //===----------------------------------------------------------------------===//; /// getRangeSize - Return the size in bytes of the specified range if they; /// are in the same file. If not, this returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:264,Energy Efficiency,efficient,efficient,264,"/// getRewrittenText - Return the rewritten form of the text in the specified; /// range. If the start or end of the range was unrewritable or if they are; /// in different buffers, this returns an empty string.; ///; /// Note that this method is not particularly efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp:36,Modifiability,Rewrite,RewriteBuffer,36,/// getEditBuffer - Get or create a RewriteBuffer for the specified FileID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/Rewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:438,Energy Efficiency,power,powerful,438,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:7,Modifiability,Rewrite,RewriteRope,7,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:46,Modifiability,rewrite,rewriter,46,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:408,Modifiability,Rewrite,RewriteRope,408,"//===- RewriteRope.cpp - Rope specialized for rewriter --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RewriteRope class, which is a powerful string.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:376,Energy Efficiency,allocate,allocated,376,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1006,Energy Efficiency,adapt,adapted,1006,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1214,Energy Efficiency,efficient,efficient,1214,"// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our us",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1412,Energy Efficiency,efficient,efficiently,1412,"plitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. T",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1894,Energy Efficiency,reduce,reduce,1894,"rted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated.; /// RopePieceBTreeInterior - An interior node in the B+ Tree, which manages; /// up to '2*WidthFactor' other nodes in the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:2002,Energy Efficiency,reduce,reduced,2002,"rted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our use cases, this doesn't seem to; /// matter.; ///; /// The implementation below is primarily implemented in terms of three classes:; /// RopePieceBTreeNode - Common base class for:; ///; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated.; /// RopePieceBTreeInterior - An interior node in the B+ Tree, which manages; /// up to '2*WidthFactor' other nodes in the tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:4,Modifiability,Rewrite,RewriteRope,4,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1006,Modifiability,adapt,adapted,1006,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:1243,Modifiability,Rewrite,RewriteRope,1243,"// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is reduced, we don't attempt to maintain the; /// standard 'invariant' that each node in the tree contains at least; /// 'WidthFactor' children/values. For our us",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:165,Testability,log,log,165,"/// RewriteRope is a ""strong"" string class, designed to make insertions and; /// deletions in the middle of the string nearly constant time (really, they are; /// O(log N), but with a very low constant factor).; ///; /// The implementation of this datastructure is a conceptual linear sequence of; /// RopePiece elements. Each RopePiece represents a view on a separately; /// allocated and reference counted string. This means that splitting a very; /// long string can be done in constant time by splitting a RopePiece that; /// references the whole string into two rope pieces that reference each half.; /// Once split, another string can be inserted in between the two halves by; /// inserting a RopePiece in between the two others. All of this is very; /// inexpensive: it takes time proportional to the number of RopePieces, not the; /// length of the strings they represent.; ///; /// While a linear sequences of RopePieces is the conceptual model, the actual; /// implementation captures them in an adapted B+ Tree. Using a B+ tree (which; /// is a tree that keeps the values in the leaves and has where each node; /// contains a reasonable number of pointers to children/values) allows us to; /// maintain efficient operation when the RewriteRope contains a *huge* number; /// of RopePieces. The basic idea of the B+ Tree is that it allows us to find; /// the RopePiece corresponding to some offset very efficiently, and it; /// automatically balances itself on insertions of RopePieces (which can happen; /// for both insertions and erases of string ranges).; ///; /// The one wrinkle on the theory is that we don't attempt to keep the tree; /// properly balanced when erases happen. Erases of string data can both insert; /// new RopePieces (e.g. when the middle of some other rope piece is deleted,; /// which results in two rope pieces, which is just like an insert) or it can; /// reduce the number of RopePieces maintained by the B+Tree. In the case when; /// the number of RopePieces is",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:523,Energy Efficiency,efficient,efficient,523,"//===----------------------------------------------------------------------===//; // RopePieceBTreeNode Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeNode - Common base class of RopePieceBTreeLeaf and; /// RopePieceBTreeInterior. This provides some 'virtual' dispatching methods; /// and a flag that determines which subclass the instance is. Also; /// important, this node knows the full extend of the node, including any; /// children that it has. This allows efficient skipping over entire subtrees; /// when looking for an offset in the BTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:450,Modifiability,extend,extend,450,"//===----------------------------------------------------------------------===//; // RopePieceBTreeNode Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeNode - Common base class of RopePieceBTreeLeaf and; /// RopePieceBTreeInterior. This provides some 'virtual' dispatching methods; /// and a flag that determines which subclass the instance is. Also; /// important, this node knows the full extend of the node, including any; /// children that it has. This allows efficient skipping over entire subtrees; /// when looking for an offset in the BTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:516,Energy Efficiency,efficient,efficient,516,"//===----------------------------------------------------------------------===//; // RopePieceBTreeLeaf Class; //===----------------------------------------------------------------------===//; /// RopePieceBTreeLeaf - Directly manages up to '2*WidthFactor' RopePiece; /// nodes. This directly represents a chunk of the string with those; /// RopePieces concatenated. Since this is a B+Tree, all values (in this case; /// instances of RopePiece) are stored in leaves like this. To make iteration; /// over the leaves efficient, they maintain a singly linked list through the; /// NextLeaf field. This allows the B+Tree forward iterator to be constant; /// time for all increments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:77,Energy Efficiency,efficient,efficient,77,"/// NextLeaf - This is a pointer to the next leaf in the tree, allowing; /// efficient in-order forward iteration of the tree without traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:4,Usability,clear,clear,4,/// clear - Remove all rope pieces from this leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:3,Deployability,Update,Update,3,// Update the list of leaves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:89,Energy Efficiency,allocate,allocated,89,"// Okay, this node is full. Split it in half, moving WidthFactor children to; // a newly allocated interior node.; // Create the new node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:88,Availability,down,down,88,"// If the deletion request completely covers the child, delete it and move; // the rest down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:8,Availability,down,down,8,// Walk down the left side of the tree until we get to a leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:85,Modifiability,Rewrite,RewriteRope,85,"//===----------------------------------------------------------------------===//; // RewriteRope Implementation; //===----------------------------------------------------------------------===//; /// MakeRopeString - This copies the specified byte range into some instance of; /// RopeRefCountString, and return a RopePiece that represents it. This uses; /// the AllocBuffer object to aggregate requests for small strings into one; /// allocation instead of doing tons of tiny allocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp:83,Energy Efficiency,allocate,allocate,83,"// If we don't have enough room because this specific allocation is huge,; // just allocate a new rope piece for it alone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/RewriteRope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:54,Integrability,interface,interface,54,"//===- TokenRewriter.cpp - Token-based code rewriting interface -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TokenRewriter class, which is used for code; // transformations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:71,Safety,avoid,avoid,71,"// FIXME: This is horrible, we should use our own list or something to avoid; // this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:48,Modifiability,Rewrite,Rewriter,48,/// AddToken - Add the specified token into the Rewriter before the other; /// position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:154,Safety,avoid,avoid,154,"// If the diagnosed code is `[[fallthrough]];` and; // `-Wunreachable-code-fallthrough` is enabled, suppress `code will never; // be executed` warning to avoid generating diagnostic twice",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Safety,Avoid,Avoid,3,// Avoid reporting multiple unreachable code diagnostics that are; // triggered by the same conditional value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:165,Deployability,configurat,configuration,165,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:165,Modifiability,config,configuration,165,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:260,Performance,perform,performance,260,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:272,Performance,optimiz,optimization,272,"// As a heuristic prune all diagnostics not in the main file. Currently; // the majority of warnings in headers are false positives. These; // are largely caused by configuration state, e.g. preprocessor; // defined code, etc.; //; // Note that this is also a performance optimization. Analyzing; // headers many times can be expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:29,Availability,error,errors,29,/// Warn on logical operator errors in CFGBuilder,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:12,Testability,log,logical,12,/// Warn on logical operator errors in CFGBuilder,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:51,Safety,detect,detected,51,// Emit diagnostic if a recursive function call is detected for all paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:83,Safety,Avoid,Avoid,83,"// When not adding EH edges from calls, catch clauses; // can otherwise seem dead. Avoid noting them as dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:96,Modifiability,variab,variable,96,/// DiagUninitUse -- Helper function to produce a diagnostic for an; /// uninitialized use of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:93,Modifiability,variab,variable,93,"/// DiagnoseUninitializedUse -- Helper function for diagnosing uses of an; /// uninitialized variable. This manages the different forms of diagnostic; /// emitted for particular types of uses. Returns true if the use was diagnosed; /// as a warning. If a particular use is one we omit warnings for, returns; /// false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:34,Modifiability,variab,variable,34,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:199,Safety,avoid,avoid,199,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:396,Security,access,access,396,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:20,Modifiability,variab,variable,20,// Report where the variable was declared when the use wasn't within; // the initializer of that declaration & we didn't already suggest; // an initialization fixit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:37,Safety,avoid,avoid,37,"// Mark all case blocks reachable to avoid problems with switching on; // constants, covered enums, etc.; // These blocks can contain fall-through annotations, and we don't want to; // issue a warn_fallthrough_attr_unreachable for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:17,Safety,detect,detect,17,// Workaround to detect a statement thrown out by CFGBuilder:; // case X: {} case Y:; // case X: ; case Y:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:185,Modifiability,variab,variable,185,"// If there was only one read, followed by any number of writes, and the; // read is not within a loop, don't warn. Additionally, don't warn in a; // loop if the base object is a local variable -- local variables are often; // changed in loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:203,Modifiability,variab,variables,203,"// If there was only one read, followed by any number of writes, and the; // read is not within a loop, don't warn. Additionally, don't warn in a; // loop if the base object is a local variable -- local variables are often; // changed in loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:34,Security,access,accessed,34,// Classify the weak object being accessed for better warning text.; // This enum should stay in sync with the cases in; // warn_arc_repeated_use_of_weak and warn_arc_possible_repeated_use_of_weak.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:23,Security,access,accesses,23,// Print all the other accesses as notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:72,Modifiability,variab,variable,72,"// Specially handle the case where we have uses of an uninitialized; // variable, but the root cause is an idiomatic self-init. We want; // to report the diagnostic at the self-init since that is the root cause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:25,Availability,down,downgrade,25,"// If we have self-init, downgrade all uses to 'may be uninitialized'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:37,Modifiability,variab,variable,37,// Skip further diagnostics for this variable. We try to warn only; // on the first point at which a variable is used uninitialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:101,Modifiability,variab,variable,101,// Skip further diagnostics for this variable. We try to warn only; // on the first point at which a variable is used uninitialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Release,Release,3,// Release the uses vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Release,Release,3,// Release the uses vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:118,Safety,safe,safety,118,// anonymous namespace; //===----------------------------------------------------------------------===//; // -Wthread-safety; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:105,Safety,Unsafe,Unsafe,105,// namespace clang; //===----------------------------------------------------------------------===//; // Unsafe buffer usage analysis.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:81,Modifiability,variab,variables,81,// Recommend -fsafe-buffer-usage-suggestions?; // Lists as a string the names of variables in `VarGroupForVD` except for `VD`; // itself:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:61,Integrability,message,message,61,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:10,Modifiability,variab,variable,10,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:98,Modifiability,variab,variables,98,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:242,Availability,avail,available,242,"/// InterProceduralData aims to be a storage of whatever data should be passed; /// between analyses of different functions.; ///; /// At the moment, its primary goal is to make the information gathered during; /// the analysis of the blocks available during the analysis of the enclosing; /// function. This is important due to the fact that blocks are analyzed before; /// the enclosed function is even parsed fully, so it is not viable to access; /// anything in the outer scope while analyzing the block. On the other hand,; /// re-building CFG for blocks and re-analyzing them when we do have all the; /// information (i.e. during the analysis of the enclosing function) seems to be; /// ill-designed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:442,Security,access,access,442,"/// InterProceduralData aims to be a storage of whatever data should be passed; /// between analyses of different functions.; ///; /// At the moment, its primary goal is to make the information gathered during; /// the analysis of the blocks available during the analysis of the enclosing; /// function. This is important due to the fact that blocks are analyzed before; /// the enclosed function is even parsed fully, so it is not viable to access; /// anything in the outer scope while analyzing the block. On the other hand,; /// re-building CFG for blocks and re-analyzing them when we do have all the; /// information (i.e. during the analysis of the enclosing function) seems to be; /// ill-designed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:98,Integrability,depend,dependent,98,// An AST Visitor that calls a callback function on each callable DEFINITION; // that is NOT in a dependent context:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl; // `FunctionDecl->hasBody()` returns true if the function has a body; // somewhere defined. But we want to know if this `Node` has a body; // child. So we use `doesThisDeclarationHaveABody`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,Integrability,depend,dependent,18,// Not to analyze dependent decl,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:31,Availability,error,errors,31,// exit if having uncompilable errors or ignoring all warnings:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Safety,Unsafe,UnsafeBufferUsage,3,// UnsafeBufferUsage analysis settings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:30,Performance,perform,performs,30,// The Callback function that performs analyses:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Performance,Perform,Perform,3,// Perform unsafe buffer usage analysis:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:11,Safety,unsafe,unsafe,11,// Perform unsafe buffer usage analysis:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:57,Availability,error,errors,57,"// We avoid doing analysis-based warnings when there are errors for; // two reasons:; // (1) The CFGs often can't be constructed (if the body is invalid), so; // don't bother trying.; // (2) The code already has problems; running the analysis just takes more; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:6,Safety,avoid,avoid,6,"// We avoid doing analysis-based warnings when there are errors for; // two reasons:; // (1) The CFGs often can't be constructed (if the body is invalid), so; // don't bother trying.; // (2) The code already has problems; running the analysis just takes more; // time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:15,Integrability,depend,dependent,15,"// For code in dependent contexts, we'll do this at instantiation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:57,Safety,avoid,avoid,57,// Don't generate EH edges for CallExprs as we'd like to avoid the n^2; // explosion for destructors that can result and the compile time hit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:40,Safety,safe,safety,40,// Unreachable code analysis and thread safety require a linearized CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Deployability,Install,Install,3,// Install the logical handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:15,Testability,log,logical,15,// Install the logical handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:31,Testability,assert,assert,31,"// FIXME: We should be able to assert that block is non-null, but; // the CFG analysis can skip potentially-evaluated expressions in; // edge cases; see test/Sema/vla-2.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:153,Testability,test,test,153,"// FIXME: We should be able to assert that block is non-null, but; // the CFG analysis can skip potentially-evaluated expressions in; // edge cases; see test/Sema/vla-2.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:20,Safety,safe,safety,20,// Check for thread safety violations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:91,Availability,error,error,91,"// If none of the previous checks caused a CFG build, trigger one here; // for the logical error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:83,Testability,log,logical,83,"// If none of the previous checks caused a CFG build, trigger one here; // for the logical error handler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:50,Integrability,Interface,Interface,50,"//===- CodeCompleteConsumer.cpp - Code Completion Interface ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CodeCompleteConsumer class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,Energy Efficiency,efficient,efficient,27,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:119,Energy Efficiency,allocate,allocated,119,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:91,Integrability,rout,routine,91,// FIXME: It would be more efficient to teach Twine to tell us its size and; // then add a routine there to fill in an allocated char* with the contents; // of the string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:31,Performance,cache,cached,31,// Check whether we've already cached the parent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:27,Availability,avail,availability,27,/// Retrieve the effective availability of the given declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:11,Availability,avail,availability,11,// Set the availability based on attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:58,Integrability,protocol,protocols,58,"// FIXME: Forward declarations of Objective-C classes and protocols; // are not directly exposed, but we want code completion to treat them; // like a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:89,Security,expose,exposed,89,"// FIXME: Forward declarations of Objective-C classes and protocols; // are not directly exposed, but we want code completion to treat them; // like a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:20,Usability,simpl,simple,20,"// If the name is a simple identifier (by far the common case), or a; // zero-argument selector, just return a reference to that identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:69,Integrability,depend,dependent,69,"/// Build the coroutine body statements, including the; /// ""promise dependent"" statements when the promise type is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:120,Integrability,depend,dependent,120,"/// Build the coroutine body statements, including the; /// ""promise dependent"" statements when the promise type is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:59,Integrability,depend,dependent,59,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:176,Integrability,depend,depending,176,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:338,Performance,perform,perform,338,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:115,Safety,avoid,avoid,115,"// If the 'InlineParams' in Declarator is unused and big enough, put our; // parameter list there (in an effort to avoid new/delete traffic). If it; // is already used (consider a function returning a function pointer) or too; // small (function with too many parameters), go to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for bindings and stash them away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:36,Testability,assert,assert,36,"// Unlike the other cases, we don't assert that we actually get a decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:206,Availability,error,error,206,"/// Finish - This does final analysis of the declspec, rejecting things like; /// ""_Imaginary"" (lacking an FP type). After calling this method, DeclSpec is; /// guaranteed to be self-consistent, even if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Security,Validat,Validate,3,// Validate and finalize AltiVec vector declspec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:73,Modifiability,enhance,enhancements,73,// vector float is unsupported for ZVector unless we have the; // vector-enhancements facility 1 (ISA revision 12).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:8,Performance,perform,perform,8,//TODO: perform validation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:16,Security,validat,validation,16,//TODO: perform validation,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Security,Validat,Validate,3,// Validate the width of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,Availability,recover,recover,49,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,Safety,recover,recover,49,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,Availability,recover,recovered,21,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,Safety,recover,recovered,21,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp:585,Security,Access,AccessedEntity,585,"//===- DelayedDiagnostic.cpp - Delayed declarator diagnostics -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DelayedDiagnostic class implementation, which; // is used to record diagnostics that are being conditionally produced; // during declarator parsing.; //; // This file also defines AccessedEntity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DelayedDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp:72,Performance,load,load,72,// If the translation unit has external storage force external decls to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp:49,Performance,load,load,49,// Force external decls in the HLSL namespace to load from the PCH.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/HLSLExternalSemaSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp:260,Energy Efficiency,Allocate,Allocates,260,//===----------------------------------------------------------------------===//; // IdDeclInfoMap class; //===----------------------------------------------------------------------===//; /// IdDeclInfoMap - Associates IdDeclInfos with declaration names.; /// Allocates 'pools' (vectors of IdDeclInfos) to avoid allocating each; /// individual IdDeclInfo to heap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp:306,Safety,avoid,avoid,306,//===----------------------------------------------------------------------===//; // IdDeclInfoMap class; //===----------------------------------------------------------------------===//; /// IdDeclInfoMap - Associates IdDeclInfos with declaration names.; /// Allocates 'pools' (vectors of IdDeclInfos) to avoid allocating each; /// individual IdDeclInfo to heap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/IdentifierResolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:200,Safety,detect,detect,200,"/// JumpScopeChecker - This object is used by Sema to diagnose invalid jumps; /// into VLA and other protected scopes. For example, this rejects:; /// goto L;; /// int a[n];; /// L:; ///; /// We also detect jumps out of protected scopes when it's not possible to do; /// cleanups properly. Indirect jumps and ASM jumps can't do cleanups because; /// the target is unknown. Return statements with \c [[clang::musttail]] cannot; /// handle any cleanups due to the nature of a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,Availability,recover,recovering,27,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:43,Availability,error,errors,43,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,Safety,recover,recovering,27,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:69,Modifiability,variab,variable,69,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:191,Modifiability,variab,variable,191,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:505,Modifiability,variab,variable,505,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:627,Modifiability,variab,variable,627,"// C++11 [stmt.dcl]p3:; // A program that jumps from a point where a variable with automatic; // storage duration is not in scope to a point where it is in scope; // is ill-formed unless the variable has scalar type, class type with; // a trivial default constructor and a trivial destructor, a; // cv-qualified version of one of these types, or an array of one of; // the preceding types and is declared without an initializer.; // C++03 [stmt.dcl.p3:; // A program that jumps from a point where a local variable; // with automatic storage duration is not in scope to a point; // where it is in scope is ill-formed unless the variable has; // POD type and is declared without an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:9,Modifiability,variab,variable,9,"// For a variable of (array of) class type declared without an; // initializer, we will have call-style initialization and the initializer; // will be the CXXConstructExpr with no intervening nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:86,Deployability,install,installed,86,"// If the decl has an initializer, walk it with the potentially new; // scope we just installed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:57,Modifiability,variab,variables,57,/// Build scope information for a captured block literal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:28,Modifiability,variab,variables,28,// exclude captured __block variables; there's no destructor; // associated with the block literal for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:148,Safety,avoid,avoid,148,"// ""goto *&&lbl;"" is a special case which we treat as equivalent; // to a normal goto. In addition, we don't calculate scope in the; // operand (to avoid recording the address-of-label use), which; // works only because of the restricted set of expressions which; // we detect as constant targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:270,Safety,detect,detect,270,"// ""goto *&&lbl;"" is a special case which we treat as equivalent; // to a normal goto. In addition, we don't calculate scope in the; // operand (to avoid recording the address-of-label use), which; // works only because of the restricted set of expressions which; // we detect as constant targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:46,Modifiability,variab,variable,46,// Evaluate the C++17 init stmt and condition variable; // before entering the scope of the switch statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:54,Integrability,synchroniz,synchronized,54,"// Disallow jumps into the protected statement of an @synchronized, but; // allow jumps into the object expression it protects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,Integrability,synchroniz,synchronized,37,"// Recursively walk the AST for the @synchronized object expr, it is; // evaluated in the normal scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,Integrability,synchroniz,synchronized,37,"// Recursively walk the AST for the @synchronized part, protected by a new; // scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:64,Modifiability,extend,extended,64,// Disallow jumps out of scopes containing temporaries lifetime-extended to; // automatic storage duration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:146,Safety,avoid,avoid,146,"// Cases, labels, and defaults aren't ""scope parents"". It's also; // important to handle these iteratively instead of recursively in; // order to avoid blowing out the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:128,Availability,down,down,128,"// Collect a single representative of every scope containing an indirect; // goto. For most code bases, this substantially cuts down on the number of; // jump sites we'll have to consider later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:52,Safety,safe,safely,52,// Mark all the enclosing scopes from which you can safely jump; // into the target scope. 'Min' will end up being the index of; // the shallowest such scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:32,Availability,error,error,32,/// Return true if a particular error+note combination must be downgraded to a; /// warning in Microsoft mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:63,Availability,down,downgraded,63,/// Return true if a particular error+note combination must be downgraded to a; /// warning in Microsoft mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:47,Availability,down,downgraded,47,/// Return true if a particular note should be downgraded to a compatibility; /// warning in C++11 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:16,Security,Validat,Validate,16,"/// CheckJump - Validate that the specified jump statement is valid: that it is; /// jumping within or out of its current scope, not into a deeper one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:10,Availability,error,errors,10,// Handle errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:16,Modifiability,config,configure,16,// Go ahead and configure all the inline capacity. This is just a memset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:14,Energy Efficiency,allocate,allocate,14,"// Otherwise, allocate something new.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp:51,Modifiability,plugin,plugin,51,// Otherwise this may be an attribute defined by a plugin.; // Search for a ParsedAttrInfo whose name and syntax match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ParsedAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:360,Availability,avail,available,360,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:207,Modifiability,variab,variables,207,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:174,Usability,clear,clear,174,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:24,Modifiability,variab,variable,24,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:102,Modifiability,variab,variables,102,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:73,Usability,Clear,Clear,73,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:65,Availability,avail,available,65,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:124,Availability,avail,available,124,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:16,Modifiability,variab,variable,16,"// Consider the variable as NRVO candidate if the return slot is available; // for it in the current scope, or if it can be available in outer scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:19,Integrability,message,message,19,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:27,Security,access,accessing,27,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:428,Performance,perform,performs,428,"//===--- Sema.cpp - AST Builder and Semantic Analysis Implementation ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the actions class which performs semantic analysis and; // builds an AST out of a parse stream.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:106,Availability,avail,available,106,// This evaluation context exists to ensure that there's always at least one; // valid evaluation context available. It is never removed from the; // evaluation stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Integrability,Protocol,Protocol,48,// Create the built-in forward declaratino for 'Protocol'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:10,Performance,cache,cached,10,// Delete cached satisfactions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Availability,error,error,48,"/// makeUnavailableInSystemHeader - There is an error in the current; /// context. If we're still in a system header, and we can plausibly; /// make the relevant declaration unavailable instead of erroring, do; /// so and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:197,Availability,error,erroring,197,"/// makeUnavailableInSystemHeader - There is an error in the current; /// context. If we're still in a system header, and we can plausibly; /// make the relevant declaration unavailable instead of erroring, do; /// so and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:39,Availability,error,error,39,"// If we're not in a function, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:47,Availability,error,error,47,"// If we're in template instantiation, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:54,Availability,error,error,54,"// If that function's not in a system header, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:55,Availability,error,error,55,"// If the function is already unavailable, it's not an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:87,Usability,simpl,simply,87,"// C17 6.7.1p6 footnote 124: The implementation can treat any register; // declaration simply as an auto declaration. However, whether or not; // addressable storage is actually used, the address of any part of an; // object declared with storage-class specifier register cannot be; // computed, either explicitly(by use of the unary & operator as discussed; // in 6.5.3.2) or implicitly(by converting an array name to a pointer as; // discussed in 6.3.2.1).Thus, the only operator that can be applied to an; // array declared with storage-class specifier register is sizeof.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Modifiability,variab,variable,11,/*register variable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:8,Modifiability,variab,variable,8,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:114,Modifiability,variab,variable,114,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:231,Modifiability,variab,variable,231,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,Usability,usab,usable,17,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:16,Modifiability,variab,variable,16,"// If this is a variable template and none of its specializations is used,; // we should warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:60,Modifiability,variab,variable,60,/// Determine whether ND is an external-linkage function or variable whose; /// type has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:43,Modifiability,variab,variables,43,/// Obtains a sorted list of functions and variables that are undefined but; /// ODR-used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:85,Modifiability,variab,variable,85,"// C++ [basic.link]p8:; // A type without linkage shall not be used as the type of a variable; // or function with external linkage unless; // -- the entity has C language linkage; // -- the entity is not odr-used or is defined in the same TU; //; // As an extension, accept this in cases where the type is externally; // visible, since the function or variable actually can be defined in; // another translation unit in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:353,Modifiability,variab,variable,353,"// C++ [basic.link]p8:; // A type without linkage shall not be used as the type of a variable; // or function with external linkage unless; // -- the entity has C language linkage; // -- the entity is not odr-used or is defined in the same TU; //; // As an extension, accept this in cases where the type is externally; // visible, since the function or variable actually can be defined in; // another translation unit in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:36,Availability,error,error,36,"// FIXME: We can promote this to an error. The function or variable can't; // be defined anywhere else, so the program must necessarily violate the; // one definition rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:59,Modifiability,variab,variable,59,"// FIXME: We can promote this to an error. The function or variable can't; // be defined anywhere else, so the program must necessarily violate the; // one definition rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:140,Performance,perform,performed,140,"// If the template function is marked as late template parsed at this; // point, it has not been instantiated and therefore we have not; // performed semantic analysis on it yet, so we cannot know if the type; // can be considered complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:22,Availability,avail,available,22,// Friend classes are available as the TypeSourceInfo of the FriendDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:24,Availability,avail,available,24,// Friend functions are available through the NamedDecl of FriendDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:135,Integrability,inject,injected,135,/// This is called before the very first declaration in the translation unit; /// is parsed. Note that the ASTContext may have already injected some; /// declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:135,Security,inject,injected,135,/// This is called before the very first declaration in the translation unit; /// is parsed. Note that the ASTContext may have already injected some; /// declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:165,Deployability,install,installed,165,"// Transfer late parsed template instantiations over to the pending template; // instantiation list. During normal compilation, the late template parser; // will be installed and instantiating these templates will succeed.; //; // If we are building a TU prefix for serialization, it is also safe to; // transfer these over, even though they are not parsed. The end of the TU; // should be outside of any eager template instantiation scope, so when this; // AST is deserialized, these templates will not be parsed until the end of; // the combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:292,Safety,safe,safe,292,"// Transfer late parsed template instantiations over to the pending template; // instantiation list. During normal compilation, the late template parser; // will be installed and instantiating these templates will succeed.; //; // If we are building a TU prefix for serialization, it is also safe to; // transfer these over, even though they are not parsed. The end of the TU; // should be outside of any eager template instantiation scope, so when this; // AST is deserialized, these templates will not be parsed until the end of; // the combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:8,Performance,Perform,Perform,8,"// C++: Perform implicit template instantiations.; //; // FIXME: When we perform these implicit instantiations, we do not; // carefully keep track of the point of instantiation (C++ [temp.point]).; // This means that name lookup that occurs within the template; // instantiation will always happen at the end of the translation unit,; // so it will find some names that are not required to be found. This is; // valid, but we could do better by diagnosing if an instantiation uses a; // name that was not visible at its first point of instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:73,Performance,perform,perform,73,"// C++: Perform implicit template instantiations.; //; // FIXME: When we perform these implicit instantiations, we do not; // carefully keep track of the point of instantiation (C++ [temp.point]).; // This means that name lookup that occurs within the template; // instantiation will always happen at the end of the translation unit,; // so it will find some names that are not required to be found. This is; // valid, but we could do better by diagnosing if an instantiation uses a; // name that was not visible at its first point of instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:3,Performance,Load,Load,3,// Load pending instantiations from the external source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:65,Performance,perform,performed,65,// We pass an empty TypoCorrection to indicate no correction was performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:40,Performance,perform,perform,40,"// If code completion is enabled, don't perform any end-of-translation-unit; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:61,Performance,perform,perform,61,// Complete translation units and modules define vtables and perform implicit; // instantiations. PCH files do not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:59,Safety,safe,safe,59,"// If we are building a TU prefix for serialization, it is safe to transfer; // these over, even though they are not parsed. The end of the TU should be; // outside of any eager template instantiation scope, so when this AST is; // deserialized, these templates will not be parsed until the end of the; // combined TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,Integrability,interface,interface,31,"// If we are building a module interface unit, we need to have seen the; // module declaration by now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:3,Performance,Queue,Queue,3,"// Queue the submodules, so their exports will also be resolved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:113,Modifiability,variab,variable,113,"// If the tentative definition was completed, getActingDefinition() returns; // null. If we've already seen this variable before, insert()'s second; // return value is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:24,Performance,perform,performed,24,// No initialization is performed for a tentative definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,Availability,error,errors,17,"// If there were errors, disable 'unused' warnings since they will mostly be; // noise. Don't warn for a use from a module: either we should warn on all; // file-scope declarations in modules or not at all, but whether the; // declaration is used is immaterial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:10,Performance,Load,Load,10,// FIXME: Load additional unused private field candidates from the external; // source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:82,Modifiability,variab,variable,82,"// Check we've noticed that we're no longer parsing the initializer for every; // variable. If we miss cases, then at best we have a performance issue and; // at worst a rejects-valid bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:133,Performance,perform,performance,133,"// Check we've noticed that we're no longer parsing the initializer for every; // variable. If we miss cases, then at best we have a performance issue and; // at worst a rejects-valid bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:202,Modifiability,refactor,refactor,202,"// FIXME: It doesn't make sense to me that DiagID is an incoming argument here; // and yet we also use the current diag ID on the DiagnosticsEngine. This has; // been made more painfully obvious by the refactor that introduced this; // function, but it is possible that the incoming argument can be; // eliminated. If it truly cannot be (for example, there is some reentrancy; // issue I am not seeing yet), then there should at least be a clarifying; // comment somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:14,Availability,failure,failure,14,// Count this failure so that we know that template argument deduction; // has failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:28,Security,access,access,28,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:84,Security,Access,AccessCheckingSFINAE,84,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:146,Security,access,access,146,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,Usability,clear,clear,31,"// Now the diagnostic state is clear, produce a C++98 compatibility; // warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:147,Availability,error,error,147,"// If this is not a note, and we're in a template instantiation; // that is different from the last template instantiation where; // we emitted an error, print a template instantiation; // backtrace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Availability,error,error,11,// Respect error limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:48,Integrability,message,messages,48,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:158,Integrability,message,messages,158,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:243,Integrability,message,messages,243,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:1322,Integrability,depend,depends,1322,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:435,Modifiability,variab,variables,435,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:705,Modifiability,variab,variables,705,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:1075,Modifiability,variab,variables,1075,"/// Helper class that emits deferred diagnostic messages if an entity directly; /// or indirectly using the function that causes the deferred diagnostic; /// messages is known to be emitted.; ///; /// During parsing of AST, certain diagnostic messages are recorded as deferred; /// diagnostics since it is unknown whether the functions containing such; /// diagnostics will be emitted. A list of potentially emitted functions and; /// variables that may potentially trigger emission of functions are also; /// recorded. DeferredDiagnosticsEmitter recursively visits used functions; /// by each function to emit deferred diagnostics.; ///; /// During the visit, certain OpenMP directives or initializer of variables; /// with certain OpenMP attributes will cause subsequent visiting of any; /// functions enter a state which is called OpenMP device context in this; /// implementation. The state is exited when the directive or initializer is; /// exited. This state can change the emission states of subsequent uses; /// of functions.; ///; /// Conceptually the functions or variables to be visited form a use graph; /// where the parent node uses the child node. At any point of the visit,; /// the tree nodes traversed from the tree root to the current node form a use; /// stack. The emission state of the current node depends on two factors:; /// 1. the emission state of the root node; /// 2. whether the current node is in OpenMP device context; /// If the function is decided to be emitted, its contained deferred diagnostics; /// are emitted, together with the information about the use stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:234,Integrability,depend,depending,234,// Whether the visiting of the function has been done. Done[0] is for the; // case not in OpenMP device context. Done[1] is for the case in OpenMP; // device context. We need two sets because diagnostics emission may be; // different depending on whether it is in OpenMP device context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:11,Availability,error,error,11,// Respect error limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,Availability,error,errors,99,"// In CUDA, there are some constructs which may appear in semantically-valid; // code, but trigger errors if we ever generate code for the function in which; // they appear. Essentially every construct you're not allowed to use on the; // device falls into this category, because you are allowed to use these; // constructs in a __host__ __device__ function, but only if that function is; // never codegen'ed on the device.; //; // To handle semantic checking for these constructs, we keep track of the set of; // functions we know will be emitted, either because we could tell a priori that; // they would be emitted, or because they were transitively called by a; // known-emitted function.; //; // We also keep a partial call graph of which not-known-emitted functions call; // which other not-known-emitted functions.; //; // When we see something which is illegal if the current function is emitted; // (usually by way of CUDADiagIfDeviceCode, CUDADiagIfHostCode, or; // CheckCUDACall), we first check if the current function is known-emitted. If; // so, we immediately output the diagnostic.; //; // Otherwise, we ""defer"" the diagnostic. It sits in Sema::DeviceDeferredDiags; // until we discover that the function is known-emitted, at which point we take; // it out of this map and emit the diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:51,Availability,error,error,51,"// Emit our diagnostic and, if it was a warning or error, output a callstack; // if Fn isn't a priori known-emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:20,Availability,error,errors,20,"// Try to associate errors with the lexical context, if that is a function, or; // the value declaration otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:409,Deployability,update,update,409,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:99,Integrability,rout,routine,99,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:343,Integrability,inject,injects,343,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:343,Security,inject,injects,343,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:7,Performance,Cache,CachedFunctionScope,7,// Use CachedFunctionScope to avoid allocating memory when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:30,Safety,avoid,avoid,30,// Use CachedFunctionScope to avoid allocating memory when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:178,Modifiability,variab,variables,178,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:145,Performance,perform,performs,145,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:45,Security,access,accessible,45,// Check that the type of the VarDecl has an accessible copy constructor and; // resolve its destructor's exception specification.; // This also performs initialization of block variables when they are moved; // to the heap. It uses the same rules as applicable for implicit moves; // according to the C++ standard in effect ([class.copy.elision]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:41,Modifiability,variab,variables,41,// Set the EscapingByref flag of __block variables captured by; // escaping blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:38,Modifiability,variab,variable,38,// Nothing to do if this is a __block variable captured by a; // non-escaping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:30,Modifiability,variab,variable,30,// Check whether the captured variable is or contains an object of; // non-trivial C union type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp
