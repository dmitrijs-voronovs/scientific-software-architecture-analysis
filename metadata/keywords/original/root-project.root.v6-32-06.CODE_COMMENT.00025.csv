id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:1240,Availability,avail,available,1240,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:147,Integrability,depend,dependencies,147,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:365,Integrability,depend,dependence,365,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:457,Integrability,depend,dependencies,457,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:510,Integrability,depend,dependencies,510,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:690,Integrability,depend,dependence,690,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:877,Integrability,depend,dependence,877,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:560,Safety,avoid,avoid,560,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:653,Safety,avoid,avoid,653,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:197,Availability,avail,available,197,"// Attempt to break anti-dependence edges on the critical path. Walk the; // instructions from the bottom up, tracking information about liveness; // as we go to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:25,Integrability,depend,dependence,25,"// Attempt to break anti-dependence edges on the critical path. Walk the; // instructions from the bottom up, tracking information about liveness; // as we go to help determine which registers are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:388,Energy Efficiency,schedul,schedule,388,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:35,Integrability,depend,dependence,35,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:87,Integrability,depend,dependence,87,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:207,Integrability,depend,dependence,207,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:313,Integrability,depend,dependence,313,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:567,Integrability,depend,dependencies,567,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:717,Integrability,depend,dependencies,717,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:289,Safety,avoid,avoid,289,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:22,Integrability,depend,dependence,22,// Only consider anti-dependence edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies on non-allocatable registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:42,Availability,down,down,42,// Don't break anti-dependencies if a use down below requires; // this exact register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:20,Integrability,depend,dependencies,20,// Don't break anti-dependencies if a use down below requires; // this exact register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:185,Energy Efficiency,schedul,scheduled,185,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:26,Integrability,depend,dependencies,26,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:69,Integrability,depend,depends,69,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:112,Integrability,depend,dependency,112,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:250,Integrability,depend,dependencies,250,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:318,Integrability,depend,dependency,318,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If this instruction's defs have special allocation requirement, don't; // break this anti-dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:57,Integrability,depend,dependence,57,"// Look for a suitable register to use to break the anti-dependence.; //; // TODO: Instead of picking the first free register, consider which might; // be the best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:3,Deployability,Update,Update,3,// Update the references to the old register to refer to the new; // register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:39,Deployability,update,updated,39,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:127,Deployability,update,update,127,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependency,93,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,Integrability,depend,dependence,93,// We just went back in time and modified history; the; // liveness information for the anti-dependence reg is now; // inconsistent. Set the state as if it were dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:541,Energy Efficiency,schedul,scheduler,541,"//===- llvm/CodeGen/CriticalAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:473,Integrability,depend,dependence,473,"//===- llvm/CodeGen/CriticalAntiDepBreaker.h - Anti-Dep Support -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CriticalAntiDepBreaker class, which; // implements register anti-dependence breaking along a blocks; // critical path during post-RA scheduler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:66,Integrability,depend,dependencies,66,"/// The set of allocatable registers.; /// We'll be ignoring anti-dependencies on non-allocatable registers,; /// because they may not be safe to break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:138,Safety,safe,safe,138,"/// The set of allocatable registers.; /// We'll be ignoring anti-dependencies on non-allocatable registers,; /// because they may not be safe to break.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:79,Integrability,depend,dependencies,79,/// A set of registers which are live and cannot be changed to; /// break anti-dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:68,Energy Efficiency,Schedul,ScheduleDAG,68,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies along the critical path; /// of the ScheduleDAG and break them by renaming registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:404,Usability,simpl,simple,404,"//===- DeadMachineInstructionElim.cpp - Remove dead machine instructions --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level dead-code-elimination pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:109,Integrability,depend,dependent,109,"// Loop over all instructions in all blocks, from bottom to top, so that it's; // more likely that chains of dependent but ultimately dead instructions will; // be cleaned up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:121,Modifiability,variab,variable,121,// It is possible that some DBG_VALUE instructions refer to this; // instruction. They will be deleted in the live debug variable; // analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:7,Safety,Detect,DetectDeadLanes,7,"//===- DetectDeadLanes.cpp - SubRegister Lane Usage Analysis --*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:610,Safety,detect,detect,610,"//===- DetectDeadLanes.cpp - SubRegister Lane Usage Analysis --*- C++ -*---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:10,Deployability,PATCH,PATCHPOINT,10,"// FIXME: PATCHPOINT instructions announce a Def that does not always exist,; // they really need to be modeled differently!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:4,Deployability,update,update,4,/// update the operand status.; /// The first return value shows whether MF been changed.; /// The second return value indicates we need to call; /// DeadLaneDetector::computeSubRegisterLaneBitInfo and this function again; /// to propagate changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:314,Safety,safe,safe,314,"// Don't bother if we won't track subregister liveness later. This pass is; // required for correctness if subregister liveness is enabled because the; // register coalescer cannot deal with hidden dead defs. However without; // subregister liveness enabled, the expected benefits of this pass are small; // so we safe the compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:679,Energy Efficiency,Schedul,Schedule,679,"//=- llvm/CodeGen/DFAPacketizer.cpp - DFA Packetizer for VLIW -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:937,Energy Efficiency,consumption,consumption,937,"//=- llvm/CodeGen/DFAPacketizer.cpp - DFA Packetizer for VLIW -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:56,Availability,avail,available,56,// Check if the resources occupied by a MCInstrDesc are available in the; // current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:64,Availability,avail,available,64,// Check if the resources occupied by a machine instruction are available; // in the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:13,Energy Efficiency,schedul,scheduling,13,// Build the scheduling graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:34,Availability,avail,available,34,// Ask DFA if machine resource is available for MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:3,Integrability,Depend,Dependency,3,// Dependency check for MI with instructions in CurrentPacketMIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:26,Integrability,depend,dependency,26,// Allow packetization if dependency can be pruned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:21,Integrability,depend,dependency,21,// End the packet if dependency cannot be pruned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp:37,Availability,avail,available,37,"// End the packet if resource is not available, or if the instruction; // should not be added to the current packet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DFAPacketizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:437,Energy Efficiency,adapt,adapted,437,"//===- DwarfEHPrepare - Prepare exception handling for code generation ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:437,Modifiability,adapt,adapted,437,"//===- DwarfEHPrepare - Prepare exception handling for code generation ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:69,Usability,resume,resume,69,"/// Return the exception object from the value passed into; /// the 'resume' instruction (typically an aggregate). Clean up any dead; /// instructions, including the 'resume' instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:167,Usability,resume,resume,167,"/// Return the exception object from the value passed into; /// the 'resume' instruction (typically an aggregate). Clean up any dead; /// instructions, including the 'resume' instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:12,Usability,resume,resumes,12,/// Replace resumes that are not reachable from a cleanup landing pad with; /// unreachable and then simplify those blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:101,Usability,simpl,simplify,101,/// Replace resumes that are not reachable from a cleanup landing pad with; /// unreachable and then simplify those blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:16,Usability,Resume,ResumeInsts,16,/// Convert the ResumeInsts that are still present; /// into calls to the appropriate _Unwind_Resume function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:55,Usability,simpl,simplifycfg,55,"// Otherwise, insert unreachable instructions and call simplifycfg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:114,Usability,resume,resume,114,"// Instead of creating a new BB and PHI node, just append the call to; // _Unwind_Resume to the end of the single resume block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:41,Usability,Resume,ResumeInst,41,// Extract the exception object from the ResumeInst and add it to the PHI node; // that feeds the _Unwind_Resume call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:10,Testability,test,testing,10,// Stress testing mode - disable heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:205,Performance,perform,performs,205,"//===----------------------------------------------------------------------===//; // SSAIfConv; //===----------------------------------------------------------------------===//; //; // The SSAIfConv class performs if-conversion on SSA form machine code after; // determining if it is possible. The class contains no heuristics; external; // code should be used to determine when if-conversion is a good idea.; //; // SSAIfConv can convert both triangles and diamonds:; //; // Triangle: Head Diamond: Head; // | \ / \_; // | \ / |; // | [TF]BB FBB TBB; // | / \ /; // | / \ /; // Tail Tail; //; // Instructions in the conditional blocks TBB and/or FBB are spliced into the; // Head block, and phis in the Tail block are converted to select instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,Safety,safe,safely,65,/// Return true if all non-terminator instructions in MBB can be safely; /// speculated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,Safety,safe,safely,65,/// Return true if all non-terminator instructions in MBB can be safely; /// predicated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:46,Deployability,update,update,46,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:29,Integrability,depend,dependencies,29,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:97,Integrability,depend,dependency,97,/// Scan through instruction dependencies and update InsertAfter array.; /// Return false if any dependency is incompatible with if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:23,Modifiability,rewrite,rewrite,23,/// Insert selects and rewrite PHI operands to use them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:101,Safety,safe,safely,101,"// end anonymous namespace; /// canSpeculateInstrs - Returns true if all the instructions in MBB can safely; /// be speculated. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:19,Performance,load,loads,19,"// Don't speculate loads. Note that it may be possible and desirable to; // speculate GOT or constant pool loads that are guaranteed not to trap,; // but we don't support that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:107,Performance,load,loads,107,"// Don't speculate loads. Note that it may be possible and desirable to; // speculate GOT or constant pool loads that are guaranteed not to trap,; // but we don't support that for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:17,Integrability,depend,dependencies,17,// Check for any dependencies on Head instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:27,Integrability,depend,dependencies,27,"/// Check that there is no dependencies preventing if conversion.; ///; /// If instruction uses any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:73,Safety,safe,safely,73,"/// canPredicateInstrs - Returns true if all the instructions in MBB can safely; /// be predicates. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:17,Integrability,depend,dependencies,17,// Check for any dependencies on Head instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:32,Integrability,depend,depends,32,// Some of the conditional code depends in I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Deployability,Update,Update,3,// Update live regunits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Modifiability,rewrite,rewritePHIOperands,4,"/// rewritePHIOperands - When there are additional Tail predecessors, insert; /// select instructions in Head and rewrite PHI operands to use the selects.; /// Keep the PHI instructions in Tail to handle the other predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:114,Modifiability,rewrite,rewrite,114,"/// rewritePHIOperands - When there are additional Tail predecessors, insert; /// select instructions in Head and rewrite PHI operands to use the selects.; /// Keep the PHI instructions in Tail to handle the other predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite PHI operands TPred -> (DstReg, Head), remove FPred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:3,Deployability,Update,Update,3,// Update statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Deployability,Update,Update,4,/// Update the dominator tree after if-conversion erased some blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:4,Deployability,Update,Update,4,/// Update LoopInfo after if-conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:113,Usability,simpl,simply,113,"// If-conversion doesn't change loop structure, and it doesn't mess with back; // edges, so updating LoopInfo is simply removing the dead blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Availability,down,downward,22,// Adjust cycles with downward saturation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:59,Performance,optimiz,optimization,59,/// Helper class to simplify emission of cycle counts into optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:20,Usability,simpl,simplify,20,/// Helper class to simplify emission of cycle counts into optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:10,Testability,test,testing,10,// Stress testing mode disables all cost considerations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:76,Safety,predict,predictable,76,// Do not try to if-convert if the condition has a high chance of being; // predictable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:148,Performance,load,load,148,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:46,Safety,predict,predictable,46,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:187,Safety,predict,predictable,187,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:143,Integrability,depend,dependency,143,"// Assume that the depth of the first head terminator will also be the depth; // of the select instruction inserted, as determined by the flag dependency.; // TBB / FBB data dependencies may delay the select even more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:174,Integrability,depend,dependencies,174,"// Assume that the depth of the first head terminator will also be the depth; // of the select instruction inserted, as determined by the flag dependency.; // TBB / FBB data dependencies may delay the select even more.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Deployability,update,update,22,// If-convert MBB and update analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:233,Deployability,update,update,233,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:221,Safety,safe,safe,221,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:22,Deployability,update,update,22,// If-convert MBB and update analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:233,Deployability,update,update,233,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:221,Safety,safe,safe,221,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:8,Deployability,release,release,8,// Also release the next DomainValue in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Deployability,Update,Update,3,// Update DVRef to point to DV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Usability,Clear,Clear,3,// Clear the old DomainValue so we won't try to swizzle instructions twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:17,Usability,clear,clearances,17,// Save register clearances at end of MBB - used by enterBasicBlock().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:3,Deployability,Update,Update,3,// Update instructions with explicit execution domains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:14,Availability,avail,available,14,// Bitmask of available domains for this instruction after taking collapsed; // operands into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:34,Availability,avail,available,34,// Bitmask of domains that dv and available have in common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:12,Availability,avail,available,12,"// Restrict available domains to the ones in common with the operand.; // If there are no common domains, we must pay the cross-domain; // penalty for this operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:48,Availability,avail,available,48,"// Kill off any remaining uses that don't match available, and build a list of; // incoming DomainValues that we want to merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:247,Integrability,depend,dependencies,247,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:205,Safety,avoid,avoid,205,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:87,Usability,clear,clearance,87,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:46,Energy Efficiency,power,powers,46,// The backend has peephole optimizations for powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp:28,Performance,optimiz,optimizations,28,// The backend has peephole optimizations for powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandLargeDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:47,Performance,load,load,47,"//===--- ExpandMemCmp.cpp - Expand memcmp() to load/stores ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass tries to expand memcmp() calls into optimally-sized loads and; // compares for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:445,Performance,load,loads,445,"//===--- ExpandMemCmp.cpp - Expand memcmp() to load/stores ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass tries to expand memcmp() calls into optimally-sized loads and; // compares for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:134,Performance,load,loads,134,"// Represents the decomposition in blocks of the expansion. For example,; // comparing 33 bytes on X86+sse can be done with 2x16-byte loads and; // 1x1-byte load, which would be represented as [{16, 0}, {16, 16}, {1, 32}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:157,Performance,load,load,157,"// Represents the decomposition in blocks of the expansion. For example,; // comparing 33 bytes on X86+sse can be done with 2x16-byte loads and; // 1x1-byte load, which would be represented as [{16, 0}, {16, 16}, {1, 32}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:19,Performance,load,load,19,"// The size of the load for this block, in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:22,Performance,load,load,22,"// The offset of this load from the base pointer, in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:40,Performance,load,loads,40,// Do not expand if the total number of loads is larger than what the; // target allows. Note that it's important that we exit before completing; // the expansion to avoid using a ton of memory to store the expansion for; // large sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:166,Safety,avoid,avoid,166,// Do not expand if the total number of loads is larger than what the; // target allows. Note that it's important that we exit before completing; // the expansion to avoid using a ton of memory to store the expansion for; // large sizes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:40,Performance,load,loads,40,// We try to do as many non-overlapping loads as possible starting from the; // beginning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:48,Performance,load,load,48,"// There remain 0 to (MaxLoadSize - 1) bytes to load, this will be done with; // an overlapping load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:96,Performance,load,load,96,"// There remain 0 to (MaxLoadSize - 1) bytes to load, this will be done with; // an overlapping load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:25,Performance,load,loads,25,// Bail if the number of loads (non-overlapping + potential overlapping one); // is larger than the max allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,// Add non-overlapping loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:28,Performance,load,load,28,// Add the last overlapping load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:33,Performance,optimiz,optimize,33,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:46,Performance,Load,LoadSequence,46,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:107,Performance,load,loads,107,"// This part of code attempts to optimize the LoadSequence by merging allowed; // subsequences into single loads of allowed sizes from; // `MemCmpExpansionOptions::AllowedTailExpansions`. If it is for zero; // comparison or if no allowed tail expansions are specified, we exit early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:101,Performance,load,load,101,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:184,Performance,load,load,184,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:206,Performance,Load,LoadCmpBlocks,206,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:384,Performance,Load,LoadCmpBlock,384,"// Initialize the basic block structure required for expansion of memcmp call; // with given maximum load size and memcmp size parameter.; // This structure includes:; // 1. A list of load compare blocks - LoadCmpBlocks.; // 2. An EndBlock, split from original instruction point, which is the block to; // return from.; // 3. ResultBlock, block to branch to for early exit when a; // LoadCmpBlock finds a difference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:22,Availability,down,down,22,// Scale the max size down if the target can load more bytes than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:45,Performance,load,load,45,// Scale the max size down if the target can load more bytes than we need.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:27,Performance,load,loads,27,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:41,Performance,load,load,41,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:99,Performance,load,loads,99,"// If we allow overlapping loads and the load sequence is not already optimal,; // use overlapping loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:26,Performance,load,load,26,// Create a constant or a load from the source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:8,Modifiability,extend,extend,8,// Zero extend if Byte Swap intrinsic has different type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:8,Modifiability,extend,extend,8,// Zero extend if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:49,Performance,load,loading,49,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:86,Performance,load,loads,86,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:196,Performance,load,loaded,196,// This function creates the IR instructions for loading and comparing 1 byte.; // It loads 1 byte from each source of the memcmp parameters with the given; // GEPIndex. It then subtracts the two loaded values and adds this result to the; // final phi node for selecting the memcmp result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:86,Performance,Load,LoadCmpBlock,86,"// Early exit branch if difference found to EndBlock. Otherwise, continue to; // next LoadCmpBlock,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:61,Performance,load,loaded,61,/// Generate an equality comparison for one or more pairs of loaded values.; /// This is used in the case where the memcmp() call is compared equal or not; /// equal to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or. The type for the combinations is the largest load; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:146,Performance,load,load,146,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or. The type for the combinations is the largest load; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,loads,23,"// If we have multiple loads per block, we need to generate a composite; // comparison using xor+or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:23,Performance,load,load,23,"// If there's only one load per block, we just compare the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Performance,load,loaded,59,"// If there's only one load per block, we just compare the loaded values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:89,Performance,Load,LoadCmpBlock,89,"// Early exit branch if difference found to ResultBlock. Otherwise,; // continue to next LoadCmpBlock or EndBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:31,Performance,Load,LoadCmpBlock,31,// Add a phi edge for the last LoadCmpBlock to Endblock with a value of 0; // since early exit to ResultBlock was not taken (no difference was found in; // any of the bytes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:48,Performance,load,loading,48,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:90,Performance,Load,LoadSize,90,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:103,Performance,load,loads,103,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:142,Performance,Load,LoadSize,142,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:266,Performance,load,loaded,266,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:457,Performance,Load,LoadCmpBlock,457,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:510,Performance,Load,LoadCmpBlock,510,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:524,Performance,Load,Loading,524,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:657,Performance,load,loaded,657,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:637,Usability,simpl,simply,637,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:16,Performance,load,load,16,"// There is one load per block in this case, BlockIndex == LoadIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Performance,Load,LoadIndex,59,"// There is one load per block in this case, BlockIndex == LoadIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:11,Performance,load,loaded,11,// Add the loaded values to the phi nodes for calculating memcmp result only; // if result is not used in a zero equality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:89,Performance,Load,LoadCmpBlock,89,"// Early exit branch if difference found to ResultBlock. Otherwise, continue; // to next LoadCmpBlock or EndBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:31,Performance,Load,LoadCmpBlock,31,// Add a phi edge for the last LoadCmpBlock to Endblock with a value of 0; // since early exit to ResultBlock was not taken (no difference was found in; // any of the bytes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:115,Performance,load,loaded,115,// This function populates the ResultBlock with a sequence to calculate the; // memcmp result. It compares the two loaded source values and returns -1 if; // src1 < src2 and 1 if src1 > src2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:112,Usability,simpl,simply,112,"// Special case: if memcmp result is used in a zero equality, result does not; // need to be calculated and can simply return 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:26,Performance,load,load,26,// Note: this assumes one load per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:35,Performance,Load,LoadCmpBlocks,35,// This loop populates each of the LoadCmpBlocks with the IR sequence to; // handle multiple loads per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:93,Performance,load,loads,93,// This loop populates each of the LoadCmpBlocks with the IR sequence to; // handle multiple loads per block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:84,Performance,load,load,84,"/// A memcmp expansion that compares equality with 0 and only has one block of; /// load and compare can bypass the compare, branch, and phi IR that is required; /// in the general case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:345,Energy Efficiency,efficient,efficient,345,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:50,Performance,load,load,50,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:57,Performance,load,loaded,57,"// The i8 and i16 cases don't need compares. We zext the loaded values and; // subtract them to get the suitable negative, zero, or positive i32 result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:59,Modifiability,variab,variable,59,// In case of a successful match this call will set `Pred` variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:93,Modifiability,extend,extended,93,"// The result of memcmp is negative, zero, or positive, so produce that by; // subtracting 2 extended compare bits: sub (ugt, ult).; // If a target prefers to use selects to get -1/0/1, they should be able; // to transform this later. The inverse transform (going from selects to math); // may not be possible in the DAG because the selects got converted into; // branches before we got there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:148,Performance,load,loaded,148,"// If return value of memcmp is not used in a zero equality, we need to; // calculate which source was larger. The calculation requires the; // two loaded source values of each load compare block.; // These will be saved in the phi nodes created by setupResultBlockPHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:177,Performance,load,load,177,"// If return value of memcmp is not used in a zero equality, we need to; // calculate which source was larger. The calculation requires the; // two loaded source values of each load compare block.; // These will be saved in the phi nodes created by setupResultBlockPHINodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:33,Performance,load,load,33,// Create the number of required load compare basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:3,Deployability,Update,Update,3,// Update the terminator added by SplitBlock to branch to the first; // LoadCmpBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:72,Performance,Load,LoadCmpBlock,72,// Update the terminator added by SplitBlock to branch to the first; // LoadCmpBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:413,Performance,load,loadbb,413,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:575,Performance,load,load,575,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:603,Performance,load,load,603,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:860,Performance,load,loadbb,860,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:899,Performance,load,loadbb,899,"// This function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:978,Performance,load,loadbb,978,"is function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1159,Performance,load,loadbb,1159,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1419,Performance,load,load,1419,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1449,Performance,load,load,1449,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2013,Performance,load,load,2013,"_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2043,Performance,load,load,2043,"_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2533,Performance,load,load,2533," preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 %phi.res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2561,Performance,load,load,2561," preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 %phi.res",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:78,Availability,avail,available,78,"// TTI call to check if target would like to expand memcmp. Also, get the; // available load sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:88,Performance,load,load,88,"// TTI call to check if target would like to expand memcmp. Also, get the; // available load sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:42,Performance,load,loads,42,// Don't expand if this will require more loads than desired by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp:27,Energy Efficiency,Reduce,Reduce,27,/// runOnMachineFunction - Reduce subregister inserts and extracts to register; /// copies.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandPostRAPseudos.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp:16,Testability,log,logical,16,"// Canonicalize logical or/and reductions:; // Or reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp ne iReduxWidth %val, 0; // And reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp eq iReduxWidth %val, 11111",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandReductions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:49,Availability,mask,mask,49,///// Helpers {; /// \returns Whether the vector mask \p MaskVal has all lane bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:57,Availability,Mask,MaskVal,57,///// Helpers {; /// \returns Whether the vector mask \p MaskVal has all lane bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:46,Availability,mask,mask,46,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:31,Integrability,depend,depends,31,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:289,Performance,scalab,scalable,289,/// \returns A bitmask that is true where the lane position is less-than \p; /// EVLParam; ///; /// \p Builder; /// Used for instruction creation.; /// \p VLParam; /// The explicit vector length parameter to test against the lane; /// positions.; /// \p ElemCount; /// Static (potentially scalable) number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:208,Testability,test,test,208,/// \returns A bitmask that is true where the lane position is less-than \p; /// EVLParam; ///; /// \p Builder; /// Used for instruction creation.; /// \p VLParam; /// The explicit vector length parameter to test against the lane; /// positions.; /// \p ElemCount; /// Static (potentially scalable) number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:24,Performance,Scalab,Scalable,24,// TODO add caching; // Scalable vector %evl conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:26,Performance,perform,performs,26,// `get_active_lane_mask` performs an implicit less-than comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:12,Safety,safe,safe,12,// Blend in safe operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:7,Safety,safe,safely,7,// Can safely ignore the predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:45,Availability,mask,masked-off,45,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Safety,safe,safe,29,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Availability,mask,masked-out,29,// Insert neutral element in masked-out positions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:44,Availability,mask,mask,44,// Convert the %evl predication into vector mask predication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:58,Availability,mask,mask,58,// Converting a speculatable VP intrinsic means dropping %mask and %evl.; // No need to expand %evl into the %mask only to ignore that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:110,Availability,mask,mask,110,// Converting a speculatable VP intrinsic means dropping %mask and %evl.; // No need to expand %evl into the %mask only to ignore that code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:228,Availability,mask,mask,228,"// We have to preserve the predicating effect of %evl for this; // non-speculatable VP intrinsic.; // 1) Never discard %evl.; // 2) If this VP intrinsic will be expanded to non-VP code, make sure that; // %evl gets folded into %mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:76,Energy Efficiency,efficient,efficient,76,"// Overrides set - we are in testing, the following does not need to be; // efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,Testability,test,testing,29,"// Overrides set - we are in testing, the following does not need to be; // efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp:7,Availability,Fault,FaultMaps,7,"//===- FaultMaps.cpp ------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FaultMaps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp:30,Deployability,Patch,Patchable,30,"//===-- FEntryInsertion.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file edits function bodies to insert fentry calls.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FEntryInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:20,Availability,redundant,redundant,20,"// Try to eliminate redundant copy to register which we're going to; // spill, i.e. try to change:; // X = COPY Y; // SPILL X; // to; // SPILL Y; // If there are no uses of X between copy and STATEPOINT, that COPY; // may be eliminated.; // Reg - register we're about to spill; // RI - On entry points to statepoint.; // On successful copy propagation set to new spill point.; // IsKill - set to true if COPY is Kill (there are no uses of Y); // Returns either found source copy register or original one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:20,Safety,redund,redundant,20,"// Try to eliminate redundant copy to register which we're going to; // spill, i.e. try to change:; // X = COPY Y; // SPILL X; // to; // SPILL Y; // If there are no uses of X between copy and STATEPOINT, that COPY; // may be eliminated.; // Reg - register we're about to spill; // RI - On entry points to statepoint.; // On successful copy propagation set to new spill point.; // IsKill - set to true if COPY is Kill (there are no uses of Y); // Returns either found source copy register or original one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:236,Energy Efficiency,reduce,reduce,236,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:201,Modifiability,extend,extends,201,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:339,Modifiability,extend,extend,339,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Cache,Cache,3,"// Cache used frame indexes during statepoint re-write to re-use them in; // processing next statepoint instruction.; // Two strategies. One is to preserve the size of spill slot while another one; // extends the size of spill slots to reduce the number of them, causing; // the less total frame size. But unspill will have ""implicit"" any extend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:203,Performance,cache,cache,203,// Map size to list of frame indexes of this size. If the mode is; // FixupSCSExtendSlotSize then the key 0 is used to keep all frame indexes.; // If the size of required spill slot is greater than in a cache then the; // size will be increased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:110,Availability,avail,available,110,// Reset the current state of used frame indexes. After invocation of; // this function all frame indexes are available for allocation with; // the exception of slots reserved for landing pad processing (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:54,Modifiability,extend,extend,54,// If all sizes are kept together we probably need to extend the; // spill slot size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Availability,Mask,Mask,3,// Mask with callee saved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Cache,Cache,3,// Cache of frame indexes used on previous instruction processing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:79,Performance,cache,cache,79,// Iterates over statepoint meta args to find caller saver registers.; // Also cache the size of found registers.; // Returns true if caller save registers found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:48,Modifiability,rewrite,rewrite,48,"// Leave `undef` operands as is, StackMaps will rewrite them; // into a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:3,Performance,Perform,Perform,3,// Perform trivial copy propagation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp:160,Testability,log,logic,160,"// TODO If a block is an eh pad, or it has address taken, we don't remove; // it. Removing such blocks is possible, but it probably requires a more; // complex logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp:3,Deployability,Update,Update,3,// Update the jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCEmptyBasicBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:468,Availability,redundant,redundant,468,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:218,Safety,safe,safepoints,218,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:323,Safety,safe,safepoint,323,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:468,Safety,redund,redundant,468,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:32,Modifiability,rewrite,rewrites,32,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:126,Performance,load,loads,126,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:187,Performance,perform,performs,187,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:119,Usability,simpl,simple,119,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:120,Safety,safe,safe,120,/// GCMachineCodeAnalysis - This is a target-independent pass over the machine; /// function representation to identify safe points for the garbage collector; /// in the machine code. It inserts labels at safe points and populates a; /// GCMetadata record for each function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:205,Safety,safe,safe,205,/// GCMachineCodeAnalysis - This is a target-independent pass over the machine; /// function representation to identify safe points for the garbage collector; /// in the machine code. It inserts labels at safe points and populates a; /// GCMetadata record for each function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:112,Safety,safe,safe,112,/// CouldBecomeSafePoint - Predicate to conservatively determine whether the; /// instruction could introduce a safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:64,Safety,safe,safe,64,"// The natural definition of instructions which could introduce safe points; // are:; //; // - call, invoke (AfterCall, BeforeCall); // - phis (Loops); // - invoke, ret, unwind (Exit); //; // However, instructions as seemingly inoccuous as arithmetic can become; // libcalls upon lowering (e.g., div i64 on a 32-bit platform), so instead; // it is necessary to take a conservative approach.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:18,Safety,safe,safe,18,// llvm.gcroot is safe because it doesn't do anything at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:59,Performance,load,loads,59,/// runOnFunction - Replace gcread/gcwrite intrinsics with loads and stores.; /// Leave gcroot intrinsics; the code generator needs to see those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:34,Usability,simpl,simple,34,// Replace a write barrier with a simple store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:40,Performance,load,load,40,// Replace a read barrier with a simple load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:33,Usability,simpl,simple,33,// Replace a read barrier with a simple load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:188,Deployability,update,updated,188,// Do not treat tail or sibling call sites as safe points. This is; // legal since any arguments passed to the callee which live in the; // remnants of the callers frame will be owned and updated by the; // callee if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:46,Safety,safe,safe,46,// Do not treat tail or sibling call sites as safe points. This is; // legal since any arguments passed to the callee which live in the; // remnants of the callers frame will be owned and updated by the; // callee if required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:12,Safety,safe,safe,12,// Find all safe points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:672,Energy Efficiency,reduce,reduce,672,"//===- GlobalMerge.cpp - Internal globals merging -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:805,Modifiability,variab,variables,805,"merging -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; // ===------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:1706,Performance,optimiz,optimizations,1706,"; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:110,Performance,optimiz,optimization,110,"// FIXME: this could be a transitional option, and we probably need to remove; // it if only we are sure this optimization could always benefit all targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:23,Modifiability,variab,variable,23,/// Check if the given variable has been identified as must keep; /// \pre setMustKeepGlobalVariables must have been called on the Module that; /// contains GV,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,"/// Collect every variables marked as ""used"" or used in a landing pad; /// instruction for this Module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,"/// Collect every variables marked as ""used""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:36,Modifiability,variab,variables,36,// We don't support scalable global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:20,Performance,scalab,scalable,20,// We don't support scalable global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:201,Energy Efficiency,efficient,efficient,201,"// If we want to be smarter, look at all uses of each global, to try to; // discover all sets of globals used together, and how many times each of; // these sets occurred.; //; // Keep this reasonably efficient, by having an append-only list of all sets; // discovered so far (UsedGlobalSet), and mapping each ""together-ness"" unit of; // code (currently, a Function) to the set of globals seen so far that are; // used together in that unit (GlobalUsesByFunction).; //; // When we look at the Nth global, we know that any new set is either:; // - the singleton set {N}, containing this global only, or; // - the union of {N} and a previously-discovered set, containing some; // combination of the previous N-1 globals.; // Using that knowledge, when looking at the Nth global, we can keep:; // - a reference to the singleton set {N} (CurGVOnlySetIdx); // - a list mapping each previous set to its union with {N} (EncounteredUGS),; // if it actually occurs.; // We keep track of the sets of globals used together ""close enough"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:3,Safety,Avoid,Avoid,3,// Avoid repeating the create-global-set pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:228,Energy Efficiency,efficient,efficiently,228,"// Now, look at each merge-eligible global in turn.; // Keep track of the sets we already encountered to which we added the; // current global.; // Each element matches the same-index element in UsedGlobalSets.; // This lets us efficiently tell whether a set has already been expanded to; // include the current global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:17,Performance,optimiz,optimizing,17,"// If we're only optimizing for size, ignore non-minsize functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:13,Modifiability,variab,variables,13,"// If merged variables doesn't have external linkage, we needn't to expose; // the symbol after merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:68,Security,expose,expose,68,"// If merged variables doesn't have external linkage, we needn't to expose; // the symbol after merging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:126,Modifiability,variab,variables,126,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:205,Modifiability,variab,variable,205,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:267,Safety,avoid,avoids,267,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:79,Modifiability,variab,variable,79,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:312,Modifiability,variab,variable,312,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:209,Safety,safe,safe,209,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:237,Safety,safe,safe,237,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:106,Security,access,accessed,106,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:18,Modifiability,variab,variables,18,// Extract global variables from llvm.used array,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,Safety,safe,safe,12,"// Merge is safe for ""normal"" internal or external globals only",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,Safety,safe,safe,12,// It's not safe to merge globals that may be preempted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:50,Deployability,update,updated,50,"// If the target requires the counter value to be updated in the loop,; // insert a phi to hold the value. The intended purpose is for use by; // loop_decrement_reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:80,Deployability,update,update,80,"// Create a new cmp, that checks the returned value of loop_decrement*,; // and update the exit branch to use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:166,Integrability,message,message,166,"// TODO: there can be many reasons a loop is not considered a; // candidate, so we should let isHardwareLoopCandidate fill in the; // reason and then report a better message here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:92,Testability,test,tests,92,// Can we replace a conditional branch with an intrinsic that sets the; // loop counter and tests that is not zero?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:31,Testability,test,test,31,"// If we're trying to use the 'test and set' form of the intrinsic, we need; // to replace a conditional branch that is controlling entry to the loop. It; // is likely (guaranteed?) that the preheader has an unconditional branch to; // the loop header, so also check if it has a single predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:15,Safety,safe,safe,15,// If it's not safe to create a while loop then don't force it and create a; // do-while loop instead,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:370,Safety,avoid,avoid,370,"// FIXME: We've expanded Count where we hope to insert the counter setting; // intrinsic. But, in the case of the 'test and set' form, we may fallback to; // the just 'set' form and in which case the insertion block is most likely; // different. It means there will be instruction(s) in a block that possibly; // aren't needed. The isLoopEntryGuardedByCond is trying to avoid this issue,; // but it's doesn't appear to work in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:115,Testability,test,test,115,"// FIXME: We've expanded Count where we hope to insert the counter setting; // intrinsic. But, in the case of the 'test and set' form, we may fallback to; // the just 'set' form and in which case the insertion block is most likely; // different. It means there will be instruction(s) in a block that possibly; // aren't needed. The isLoopEntryGuardedByCond is trying to avoid this issue,; // but it's doesn't appear to work in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:103,Modifiability,variab,variable,103,"// The old condition may be dead now, and may have even created a dead PHI; // (the original induction variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:103,Modifiability,variab,variable,103,"// The old condition may be dead now, and may have even created a dead PHI; // (the original induction variable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:47,Performance,cache,cache,47,"/// One per MachineBasicBlock, this is used to cache the result; /// if-conversion feasibility analysis. This includes results from; /// TargetInstrInfo::analyzeBranch() (i.e. TBB, FBB, and Cond), and its; /// classification, and common tail block of its successors (if it's a; /// diamond shape), its size, whether it's predicable, and whether any; /// instruction can clobber the 'would-be' predicate.; ///; /// IsDone - True if BB is not to be considered for ifcvt.; /// IsBeingAnalyzed - True if BB is currently being analyzed.; /// IsAnalyzed - True if BB has been analyzed (info is still valid).; /// IsEnqueued - True if BB has been enqueued to be ifcvt'ed.; /// IsBrAnalyzable - True if analyzeBranch() returns false.; /// HasFallThrough - True if BB may fallthrough to the following BB.; /// IsUnpredicable - True if BB is known to be unpredicable.; /// ClobbersPred - True if BB could modify predicates (e.g. has; /// cmp, call, etc.); /// NonPredSize - Number of non-predicated instructions.; /// ExtraCost - Extra cost for multi-cycle instructions.; /// ExtraCost2 - Some instructions are slower when predicated; /// BB - Corresponding MachineBasicBlock.; /// TrueBB / FalseBB- See analyzeBranch().; /// BrCond - Conditions for end of block conditional branches.; /// Predicate - Predicate used in the BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:59,Performance,perform,performance,59,"// Even though we're optimising for size at the expense of performance,; // avoid creating really long predicated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:76,Safety,avoid,avoid,76,"// Even though we're optimising for size at the expense of performance,; // avoid creating really long predicated blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:22,Security,expose,expose,22,// Tail merge tend to expose more if-conversion opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:92,Performance,perform,perform,92,// Do an initial analysis for each basic block and find all the potential; // candidates to perform if-conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:44,Performance,queue,queue,44,"// If the block has been evicted out of the queue or it has already been; // marked dead (due to it being predicated), then skip it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:199,Performance,perform,performed,199,/// Returns true if the 'true' block (along with its predecessor) forms a valid; /// simple shape for ifcvt. It also returns the number of instructions that the; /// ifcvt would need to duplicate if performed in Dups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:85,Usability,simpl,simple,85,/// Returns true if the 'true' block (along with its predecessor) forms a valid; /// simple shape for ifcvt. It also returns the number of instructions that the; /// ifcvt would need to duplicate if performed in Dups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:364,Performance,perform,performed,364,"/// Returns true if the 'true' and 'false' blocks (along with their common; /// predecessor) forms a valid triangle shape for ifcvt. If 'FalseBranch' is; /// true, it checks if 'true' block's false branch branches to the 'false' block; /// rather than the other way around. It also returns the number of instructions; /// that the ifcvt would need to duplicate if performed in 'Dups'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:411,Deployability,update,update,411,"/// RescanInstructions - Run ScanInstructions on a pair of blocks.; /// @param TIB - True Iterator Begin, points to first non-shared instruction; /// @param FIB - False Iterator Begin, points to first non-shared instruction; /// @param TIE - True Iterator End, points past last non-shared instruction; /// @param FIE - False Iterator End, points past last non-shared instruction; /// @param TrueBBI - BBInfo to update for the true block.; /// @param FalseBBI - BBInfo to update for the false block.; /// @returns - false if either block cannot be predicated or if both blocks end; /// with a predicate-clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:471,Deployability,update,update,471,"/// RescanInstructions - Run ScanInstructions on a pair of blocks.; /// @param TIB - True Iterator Begin, points to first non-shared instruction; /// @param FIB - False Iterator Begin, points to first non-shared instruction; /// @param TIE - True Iterator End, points past last non-shared instruction; /// @param FIE - False Iterator End, points past last non-shared instruction; /// @param TrueBBI - BBInfo to update for the true block.; /// @param FalseBBI - BBInfo to update for the false block.; /// @returns - false if either block cannot be predicated or if both blocks end; /// with a predicate-clobbering instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:468,Safety,avoid,avoid,468,"/// ValidForkedDiamond - Returns true if the 'true' and 'false' blocks (along; /// with their common predecessor) form a diamond if a common tail block is; /// extracted.; /// While not strictly a diamond, this pattern would form a diamond if; /// tail-merging had merged the shared tails.; /// EBB; /// _/ \_; /// | |; /// TBB FBB; /// / \ / \; /// FalseBB TrueBB FalseBB; /// Currently only handles analyzable branches.; /// Specifically excludes actual diamonds to avoid overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:656,Integrability,depend,dependency,656,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:8,Safety,unsafe,unsafe,8,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:606,Safety,safe,safe,606,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:715,Safety,safe,safe,715,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:1236,Safety,unsafe,unsafe,1236,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:197,Usability,simpl,simple,197,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:1054,Usability,clear,clearly,1054,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:157,Safety,avoid,avoid,157,"// If it is already predicated but we couldn't analyze its terminator, the; // latter might fallthrough, but we can't determine where to.; // Conservatively avoid if-converting again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Testability,Test,Test,3,// Test predicate subsumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Usability,Simpl,Simple,3,"// Simple (split, no rejoin):; // EBB; // | \_; // | |; // | TBB---> exit; // |; // FBB",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:24,Safety,avoid,avoid,24,"// Check isSuccessor to avoid case where the next block is empty, but; // it's not a successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:58,Availability,mask,mask,58,// First handle regmasks. They clobber any entries in the mask which; // means that we need a def for those registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:131,Energy Efficiency,allocate,allocated,131,"// We also need to add an implicit def of this register for the later; // use to read from.; // For the register allocator to have allocated a register clobbered; // by the call which is used later, it must be the case that; // the call doesn't return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:17,Usability,simpl,simple,17,"/// If convert a simple (split, no rejoin) sub-CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if BB's address is taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:16,Deployability,update,updated,16,// Keep the CFG updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:245,Availability,avail,available,245,"// Now ifcvt'd block will look like this:; // BB:; // ...; // t, f = cmp; // if t op; // b BBf; //; // We cannot further ifcvt this block because the unconditional branch; // will have to be predicated on the new condition, that will not be; // available if cmp executes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info. BB can be iteratively if-converted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if BB's address is taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:16,Deployability,update,updated,16,// Keep the CFG updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,"// Update the edge probability for both CvtBBI->FalseBB and NextBBI.; // NewNext = New_Prob(BBI.BB, NextMBB) =; // Prob(BBI.BB, NextMBB) +; // Prob(BBI.BB, CvtMBB) * Prob(CvtMBB, NextMBB); // NewFalse = New_Prob(BBI.BB, CvtBBI->FalseBB) =; // Prob(BBI.BB, CvtMBB) * Prob(CvtMBB, CvtBBI->FalseBB)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info. BB can be iteratively if-converted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,// Something has changed. It's no longer safe to predicate these blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,Safety,abort,abort,18,// Conservatively abort if-conversion if either BB has its address taken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:50,Deployability,update,update,50,"// Since this instruction is going to be deleted, update call; // site info state if the instruction is call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:53,Safety,safe,safe,53,"// The branches have been checked to match, so it is safe to remove the; // branch in BB1 and rely on the copy in BB2. The complication is that; // the blocks may end with a return instruction, which may or may not; // be marked as ""branch"". If it's not, then it could be included in; // ""dups1"", leaving the blocks potentially empty after moving the common; // duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:50,Deployability,update,update,50,"// Since this instruction is going to be deleted, update call; // site info state if the instruction is call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,Safety,safe,safe,41,"// Removing branches from both blocks is safe, because we have already; // determined that both blocks have the same branch instructions. The branch; // will be added back at the end, unpredicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:116,Deployability,update,update,116,// We need to remove the edges to the true and false blocks manually since; // we didn't let IfConvertDiamondCommon update the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Deployability,Update,Update,3,// Update block info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:69,Deployability,update,update,69,"// If we're about to splice an INLINEASM_BR from FromBBI, we need to update; // ToBBI's successor list accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:138,Availability,down,down,138,// Remove the old edge but remember the edge probability so we can calculate; // the correct weights on the new edges being added further down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:53,Deployability,update,update,53,"// If the edge from ToBBI.BB to Succ already exists, update the; // probability of this edge by adding NewProb to it. An example is shown; // below, in which A is ToBBI.BB and B is FromMBB. In this case we; // don't have to set C as A's successor as it already is. We only need to; // update the edge probability on A->C. Note that B will not be; // immediately removed from A's successors. It is possible that B->D is; // not removed either if D is a fallthrough of B. Later the edge A->D; // (generated here) and B->D will be combined into one edge. To maintain; // correct edge probability of this combined edge, we need to set the edge; // probability of A->B to zero, which is already done above. The edge; // probability on A->D is calculated by scaling the original probability; // on A->B by the probability of B->D.; //; // Before ifcvt: After ifcvt (assume B->D is kept):; //; // A A; // /| /|\; // / B / B|; // | /| | ||; // |/ | | |/; // C D C D; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:285,Deployability,update,update,285,"// If the edge from ToBBI.BB to Succ already exists, update the; // probability of this edge by adding NewProb to it. An example is shown; // below, in which A is ToBBI.BB and B is FromMBB. In this case we; // don't have to set C as A's successor as it already is. We only need to; // update the edge probability on A->C. Note that B will not be; // immediately removed from A's successors. It is possible that B->D is; // not removed either if D is a fallthrough of B. Later the edge A->D; // (generated here) and B->D will be combined into one edge. To maintain; // correct edge probability of this combined edge, we need to set the edge; // probability of A->B to zero, which is already done above. The edge; // probability on A->D is calculated by scaling the original probability; // on A->B by the probability of B->D.; //; // Before ifcvt: After ifcvt (assume B->D is kept):; //; // A A; // /| /|\; // / B / B|; // | /| | ||; // |/ | | |/; // C D C D; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:748,Availability,fault,fault,748,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:769,Performance,Load,LoadStore,769,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:61,Security,access,accesses,61,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:440,Testability,test,test,440,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:96,Integrability,depend,dependences,96,"/// Helper function for \c computeDependence. Return true if \p A; /// and \p B do not have any dependences between them, and can be; /// re-ordered without changing program semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:194,Integrability,depend,dependency,194,/// A data type for representing the result computed by \c; /// computeDependence. States whether it is okay to reorder the; /// instruction passed to \c computeDependence with at most one; /// dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:48,Integrability,depend,dependency,48,"// If this is non-null, then MemOperation has a dependency on this; // instruction; and it needs to be hoisted to execute before MemOperation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Integrability,Depend,DependenceMI,23,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:179,Integrability,Depend,DependenceMI,179,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:207,Safety,safe,safely,207,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,Availability,Fault,FaultingMI,22,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:125,Integrability,Depend,Dependence,125,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:206,Integrability,depend,dependency,206,/// Return true if \p FaultingMI can be hoisted from after the; /// instructions in \p InstsSeenSoFar to before them. Set \p Dependence to a; /// non-null value if we also need to (and legally can) hoist a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,Integrability,depend,dependency,22,"// Found one possible dependency, keep track of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:16,Integrability,depend,dependencies,16,"// We found two dependencies, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:60,Integrability,depend,dependencies,60,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:165,Integrability,depend,dependencies,165,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:154,Performance,load,load-store,154,"// canHandle makes sure that we _can_ correctly analyze the dependencies; // between A and B here -- for instance, we should not be dealing with heap; // load-store dependencies here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Security,access,access,23,"// If it is not memory access, skip the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:3,Performance,Load,Load-Load,3,// Load-Load may alias,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:101,Testability,test,test,101,// Implementation restriction for faulting_op insertion; // TODO: This could be relaxed if we find a test case which warrants it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:101,Performance,perform,performed,101,// We need the base of the memory instruction to be same as the register; // where the null check is performed (i.e. PointerReg).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:78,Integrability,depend,depending,78,// Returns true if RegUsedInAddr is used for calculating the displacement; // depending on addressing mode. Also calculates the Displacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,Integrability,depend,depends,23,"// Sign of the product depends on the sign of the ImmVal, since Multiplier; // is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:285,Availability,fault,faulting,285,"// The register which is not null checked should be part of the Displacement; // calculation, otherwise we do not know whether the Displacement is made up; // by some symbolic values.; // This matters because we do not want to incorrectly assume that load from; // falls in the zeroth faulting page in the ""sane offset check"" below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:251,Performance,load,load,251,"// The register which is not null checked should be part of the Displacement; // calculation, otherwise we do not know whether the Displacement is made up; // by some symbolic values.; // This matters because we do not want to incorrectly assume that load from; // falls in the zeroth faulting page in the ""sane offset check"" below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:123,Availability,reliab,reliably,123,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:137,Availability,fault,faults,137,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:19,Security,access,access,19,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:116,Security,access,access,116,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:45,Security,access,access,45,"// Finally, check whether the current memory access aliases with previous one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:413,Availability,fault,faulting,413,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:621,Availability,fault,faults,621,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:85,Integrability,Depend,Dependency,85,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:203,Integrability,depend,dependencies,203,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:422,Performance,load,load,422,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:464,Performance,load,loaded,464,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:501,Performance,load,load,501,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:583,Performance,load,load,583,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:596,Performance,load,loading,596,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:702,Performance,load,load,702,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:172,Safety,safe,safe,172,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:286,Testability,test,test,286,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:7,Integrability,depend,dependence,7,// The dependence does not clobber live-ins in NullSucc block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:272,Availability,Fault,FaultingMI,272,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:297,Availability,fault,faulting,297,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:45,Performance,load,loads,45,"// We don't want to reason about speculating loads. Note -- at this point; // we should have already filtered out all of the other non-speculatable; // things, like calls and stores.; // We also do not want to hoist stores because it might change the memory; // while the FaultingMI may result in faulting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:17,Usability,simpl,simplest,17,// We handle the simplest case for now. We can potentially do better by using; // the machine dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:91,Testability,test,test,91,"// To prevent the invalid transformation of the following code:; //; // mov %rax, %rcx; // test %rax, %rax; // %rax = ...; // je throw_npe; // mov(%rcx), %r9; // mov(%rax), %r10; //; // into:; //; // mov %rax, %rcx; // %rax = ....; // faulting_load_op(""movl (%rax), %r10"", throw_npe); // mov(%rcx), %r9; //; // we must ensure that there are no instructions between the 'test' and; // conditional jump that modify %rax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:370,Testability,test,test,370,"// To prevent the invalid transformation of the following code:; //; // mov %rax, %rcx; // test %rax, %rax; // %rax = ...; // je throw_npe; // mov(%rcx), %r9; // mov(%rax), %r10; //; // into:; //; // mov %rax, %rcx; // %rax = ....; // faulting_load_op(""movl (%rax), %r10"", throw_npe); // mov(%rcx), %r9; //; // we must ensure that there are no instructions between the 'test' and; // conditional jump that modify %rax.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:274,Availability,Fault,FaultingLoad,274,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:691,Availability,fault,fault,691,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:769,Availability,fault,fault,769,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:811,Availability,fault,faulted,811,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1369,Integrability,depend,dependent,1369,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:934,Modifiability,extend,extended,934,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:194,Performance,Load,Load,194,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:619,Performance,load,load,619,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:757,Performance,load,load,757,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:797,Performance,load,load,797,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1224,Performance,load,load,1224,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1477,Performance,load,loaded,1477,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1341,Safety,safe,safety,1341,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:47,Testability,test,test,47,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:43,Availability,FAULT,FAULTING,43,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:82,Availability,FAULT,FAULTING,82,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:219,Availability,fault,faults,219,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:231,Availability,FAULT,FAULTING,231,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:4,Integrability,Wrap,Wrap,4,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:117,Performance,load,load,117,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:207,Security,access,access,207,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the null checks in NullCheckList into implicit null checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:33,Integrability,depend,dependent,33,// Remove the conditional branch dependent on the null check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:12,Availability,fault,faulting,12,"// Insert a faulting instruction where the conditional branch was; // originally. We check earlier ensures that this bit of code motion; // is legal. We do not touch the successors list for any basic block; // since we haven't changed control flow, we've just made it implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:47,Modifiability,rewrite,rewrite,47,// Build a list of indirectbrs that we want to rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:121,Availability,avail,available,121,// Handle the degenerate case of no successors by replacing the indirectbr; // with unreachable as there is no successor available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:196,Modifiability,rewrite,rewrite,196,// If we need to replace any indirectbrs we need to establish integer; // constants that will correspond to each of the basic blocks in the function; // whose address escapes. We do that here and rewrite all the blockaddress; // constants to just be those integer constants cast to a pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:74,Modifiability,rewrite,rewrite,74,// Skip blocks that aren't successors to an indirectbr we're going to; // rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp:7,Modifiability,rewrite,rewrite,7,"// Now rewrite the blockaddress to an integer constant based on the index.; // FIXME: This part doesn't properly recognize other uses of blockaddress; // expressions, for instance, where they are used to pass labels to; // asm-goto. This part of the pass needs a rework.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IndirectBrExpandPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Modifiability,Variab,Variables,3,"// Variables that are valid during spill(), but used by multiple methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:542,Performance,load,load,542,"//===----------------------------------------------------------------------===//; // Snippets; //===----------------------------------------------------------------------===//; // When spilling a virtual register, we also spill any snippets it is connected; // to. The snippets are small live ranges that only have a single real use,; // leftovers from live range splitting. Spilling them enables memory operand; // folding or tightens the live range around the single use.; //; // This minimizes register pressure and maximizes the store-to-load distance for; // spill slots which can be important in tight loops.; /// isFullCopyOf - If MI is a COPY to or from Reg, return the other register,; /// otherwise return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Performance,load,loads,20,// Allow stack slot loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:18,Modifiability,extend,extend,18,// Conservatively extend the stack slot range to the range of the original; // value. We may be able to do better with stack slot coloring by being more; // careful here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:62,Usability,clear,clear,62,"// We are going to spill SrcVNI immediately after its def, so clear out; // any later spills of the same value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,Availability,redundant,redundant,84,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,Safety,redund,redundant,84,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,Availability,down,down,25,// Follow sibling copies down the dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:86,Performance,load,load,86,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:118,Safety,avoid,avoids,118,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new register for the remat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:192,Performance,load,load,192,"//===----------------------------------------------------------------------===//; // Spilling; //===----------------------------------------------------------------------===//; /// If MI is a load or store of StackSlot, it can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:19,Security,access,access,19,// We have a stack access. Is it the right register and slot?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:175,Performance,Load,LoadMI,175,/// foldMemoryOperand - Try folding stack slot references in Ops into their; /// instructions.; ///; /// @param Ops Operand indices from AnalyzeVirtRegInBundle().; /// @param LoadMI Load instruction to use instead of stack slot when non-null.; /// @return True on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:182,Performance,Load,Load,182,/// foldMemoryOperand - Try folding stack slot references in Ops into their; /// instructions.; ///; /// @param Ops Operand indices from AnalyzeVirtRegInBundle().; /// @param LoadMI Load instruction to use instead of stack slot when non-null.; /// @return True on success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:77,Performance,load,load,77,// TII::foldMemoryOperand will do what we need here for statepoint; // (fold load into use and remove corresponding def). We will replace; // uses of removed def with loads (spillAroundUses).; // For that to work we need to untie def and use to pass it through; // foldMemoryOperand and signal foldPatchpoint that it is allowed to; // fold them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:167,Performance,load,loads,167,// TII::foldMemoryOperand will do what we need here for statepoint; // (fold load into use and remove corresponding def). We will replace; // uses of removed def with loads (spillAroundUses).; // For that to work we need to untie def and use to pass it through; // foldMemoryOperand and signal foldPatchpoint that it is allowed to; // fold them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:91,Deployability,patch,patchpoint,91,// Spill subregs if the target allows it.; // We always want to spill subregs for stackmap/patchpoint pseudos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Performance,load,load,20,// We cannot fold a load instruction into a def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:119,Testability,assert,assert,119,"// If we only have implicit uses, we won't be able to fold that.; // Moreover, TargetInstrInfo::foldMemoryOperand will assert if we try!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:158,Usability,simpl,simple,158,"// If we've folded a store into an instruction labelled with debug-info,; // record a substitution from the old operand to the memory operand. Handle; // the simple common case where operand 0 is the one being folded, plus when; // the destination operand is also a tied def. More values could be; // substituted / preserved with more analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:127,Performance,load,load,127,"// This is a debug-labelled instruction, but the operand being folded isn't; // at operand zero. Most likely this means it's a load being folded in.; // Substitute any register defs from operand zero up to the one being; // folded -- past that point, we don't know what the new operand indexes; // will be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:14,Security,access,accesses,14,// Stack slot accesses may coalesce away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:52,Availability,down,downstream,52,// This is a reload for a sib-reg copy. Drop spills downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite instruction operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:3,Deployability,Update,Update,3,// Update LiveStacks now that we are committed to spilling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:4,Performance,Optimiz,Optimizations,4,/// Optimizations after all the reg selections and spills are done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:97,Usability,clear,cleared,97,// save a copy of LiveInterval in StackSlotToOrigLI because the original; // LiveInterval may be cleared after all its references are spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:47,Availability,alive,alive,47,// TODO: We could be better here. If LI is not alive in landing pad; // we could hoist spill after LIP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:55,Availability,redundant,redundant,55,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,Safety,redund,redundant,11,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:55,Safety,redund,redundant,55,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:37,Availability,down,down,37,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:154,Availability,Redundant,Redundant,154,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:154,Safety,Redund,Redundant,154,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,Availability,redundant,redundant,75,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,Safety,redund,redundant,75,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,Availability,redundant,redundant,235,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:357,Availability,redundant,redundant,357,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,Safety,redund,redundant,235,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:357,Safety,redund,redundant,357,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,Availability,redundant,redundant,92,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,Safety,redund,redundant,92,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:36,Availability,down,down,36,// Sort the nodes in WorkSet in top-down order and save the nodes; // in Orders. Orders will be used for hoisting in runHoistSpills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:40,Usability,simpl,simply,40,"// If Block contains an original spill, simply continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,Usability,simpl,simply,25,"// No spills in subtree, simply continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,Availability,redundant,redundant,41,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:377,Availability,redundant,redundant,377,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,Safety,redund,redundant,41,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:377,Safety,redund,redundant,377,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:20,Deployability,update,update,20,// Stack live range update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,Availability,redundant,redundant,10,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,Safety,redund,redundant,10,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:435,Performance,Cache,CacheEntries,435,"// Initializes PhysRegEntries (instead of a SmallVector, PhysRegEntries is a; // buffer of size NumPhysRegs to speed up alloc/clear for targets with large; // reg files). Calloced memory is used for good form, and quites tools like; // Valgrind too, but zero initialized memory is not required by the algorithm:; // this is because PhysRegEntries works like a SparseSet and its entries are; // only valid when there is a corresponding CacheEntries assignment. There is; // also support for when pass managers are reused for targets with different; // numbers of PhysRegs: in this case PhysRegEntries is freed and reinitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:126,Usability,clear,clear,126,"// Initializes PhysRegEntries (instead of a SmallVector, PhysRegEntries is a; // buffer of size NumPhysRegs to speed up alloc/clear for targets with large; // reg files). Calloced memory is used for good form, and quites tools like; // Valgrind too, but zero initialized memory is not required by the algorithm:; // this is because PhysRegEntries works like a SparseSet and its entries are; // only valid when there is a corresponding CacheEntries assignment. There is; // also support for when pass managers are reused for targets with different; // numbers of PhysRegs: in this case PhysRegEntries is freed and reinitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:44,Deployability,update,update,44,"/// revalidate - LIU contents have changed, update tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:29,Performance,cache,cache,29,"// LIU's changed, invalidate cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:27,Availability,mask,mask,27,// Also check for register mask interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,Availability,mask,mask,12,// Register mask i clobbers PhysReg before the LIU interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:27,Availability,mask,mask,27,// Also check for register mask interference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:12,Availability,mask,mask,12,// Register mask i-1 clobbers PhysReg after the LIU interference.; // Model the regmask clobber as a dead def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:504,Availability,mask,masks,504,"//===- InterferenceCache.h - Caching per-block interference ----*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InterferenceCache remembers per-block interference from LiveIntervalUnions,; // fixed RegUnit interference, and register masks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:14,Performance,cache,cache,14,/// Entry - A cache entry containing interference information for all aliases; /// of PhysReg in all basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:10,Performance,Cache,Cache,10,/// Tag - Cache tag is changed when any of the underlying LiveIntervalUnions; /// change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:38,Availability,mask,mask,38,/// LIS - Used for accessing register mask interference maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Security,access,accessing,19,/// LIS - Used for accessing register mask interference maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:4,Deployability,update,update,4,/// update - Recompute Blocks[MBBNum],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Performance,cache,cache,19,"// We don't keep a cache entry for every physical register, that would use too; // much memory. Instead, a fixed number of cache entries are used in a round-; // robin manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:123,Performance,cache,cache,123,"// We don't keep a cache entry for every physical register, that would use too; // much memory. Instead, a fixed number of cache entries are used in a round-; // robin manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:14,Performance,cache,cache,14,// The actual cache entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,Performance,cache,cache,19,/// init - Prepare cache for a new function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:49,Performance,concurren,concurrent,49,/// getMaxCursors - Return the maximum number of concurrent cursors that can; /// be supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:31,Integrability,interface,interface,31,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:68,Performance,cache,cache,68,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:3,Deployability,Update,Update,3,"// Update reference counts. Nothing happens when RefCount reaches 0, so; // we don't have to check for E == CacheEntry etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:108,Performance,Cache,CacheEntry,108,"// Update reference counts. Nothing happens when RefCount reaches 0, so; // we don't have to check for E == CacheEntry etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:3,Deployability,Release,Release,3,// Release reference before getting a new one. That guarantees we can; // actually have CacheEntries live cursors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:88,Performance,Cache,CacheEntries,88,// Release reference before getting a new one. That guarantees we can; // actually have CacheEntries live cursors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:562,Performance,load,load,562,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1116,Performance,load,load,1116,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1151,Performance,load,load,1151,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1471,Performance,optimiz,optimized,1471,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1515,Performance,load,loads,1515,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1536,Performance,optimiz,optimized,1536,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1942,Performance,optimiz,optimized,1942,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:420,Security,Access,Access,420,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:473,Security,access,accesses,473,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:783,Security,access,accesses,783,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:29,Performance,load,load,29,/// Transform an interleaved load into target specific intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:16,Performance,load,load,16,/// Transform a load and a deinterleave intrinsic into target specific; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:47,Performance,load,load,47,"/// Returns true if the uses of an interleaved load by the; /// extractelement instructions in \p Extracts can be replaced by uses of the; /// shufflevector instructions in \p Shuffles instead. If so, the necessary; /// replacements are also performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:242,Performance,perform,performed,242,"/// Returns true if the uses of an interleaved load by the; /// extractelement instructions in \p Extracts can be replaced by uses of the; /// shufflevector instructions in \p Shuffles instead. If so, the necessary; /// replacements are also performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:162,Performance,load,load,162,"/// Given a number of shuffles of the form shuffle(binop(x,y)), convert them; /// to binop(shuffle(x), shuffle(y)) to allow the formation of an; /// interleaving load. Any newly created shuffles that operate on \p LI will; /// be added to \p Shuffles. Returns true, if any changes to the IR have been; /// made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask is a DE-interleave mask of the given factor; /// \p Factor like:; /// <Index, Index+Factor, ..., Index+(NumElts-1)*Factor>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:41,Availability,mask,mask,41,"/// Check if the mask is a DE-interleave mask of the given factor; /// \p Factor like:; /// <Index, Index+Factor, ..., Index+(NumElts-1)*Factor>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:41,Availability,mask,mask,41,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:100,Availability,mask,masks,100,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:148,Availability,mask,mask,148,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:209,Availability,mask,mask,209,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:65,Performance,load,load,65,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:32,Performance,load,load,32,// Make sure we don't produce a load wider than the input load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:58,Performance,load,load,58,// Make sure we don't produce a load wider than the input load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:17,Availability,mask,mask,17,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:128,Availability,mask,mask,128,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:473,Availability,mask,mask,473,"/// Check if the mask can be used in an interleaved store.; //; /// It checks for a more general pattern than the RE-interleave mask.; /// I.e. <x, y, ... z, x+1, y+1, ...z+1, x+2, y+2, ...z+2, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <4, 32, 5, 33, 6, 34, 7, 35>; /// E.g. For a Factor of 3 (LaneLen=4): <4, 32, 16, 5, 33, 17, 6, 34, 18, 7, 35, 19>; /// E.g. For a Factor of 4 (LaneLen=2): <8, 2, 12, 4, 9, 3, 13, 5>; ///; /// The particular case of an RE-interleave mask is:; /// I.e. <0, LaneLen, ... , LaneLen*(Factor - 1), 1, LaneLen + 1, ...>; /// E.g. For a Factor of 2 (LaneLen=4): <0, 4, 1, 5, 2, 6, 3, 7>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:30,Performance,load,load,30,"// Check if all users of this load are shufflevectors. If we encounter any; // users that are extractelement instructions or binary operators, we save; // them to later check if they can be modified to extract from one of the; // shufflevectors instead of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:260,Performance,load,load,260,"// Check if all users of this load are shufflevectors. If we encounter any; // users that are extractelement instructions or binary operators, we save; // them to later check if they can be modified to extract from one of the; // shufflevectors instead of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:102,Performance,load,load,102,// BinOpShuffles need to be handled a single time in case both operands of the; // binop are the same load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:31,Performance,load,load,31,// Try and modify users of the load that are extractelement instructions to; // use the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:130,Performance,load,load,130,// Try and modify users of the load that are extractelement instructions to; // use the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:59,Performance,load,load,59,// Try to create target specific intrinsics to replace the load and shuffles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:134,Performance,load,load,134,// Look for a suitable shufflevector instruction. The goal is to modify the; // extractelement instruction (which uses an interleaved load) to use one; // of the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:204,Performance,load,load,204,// Look for a suitable shufflevector instruction. The goal is to modify the; // extractelement instruction (which uses an interleaved load) to use one; // of the shufflevector instructions instead of the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:12,Performance,perform,perform,12,"// Finally, perform the replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:33,Performance,load,load,33,"// We now have a target-specific load, so delete the old one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,Performance,Load,Loads,56,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:431,Performance,load,load-combine,431,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:527,Performance,load,loads,527,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:589,Performance,load,load,589,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:644,Safety,detect,detectable,644,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:875,Safety,detect,detected,875,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:38,Performance,load,load,38,/// Scan the function for interleaved load candidates and execute the; /// replacement if applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:24,Performance,load,load,24,/// Replace interleaved load candidates. It does additional; /// analyses if this makes sense. Returns true on success and false; /// of nothing has been changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:138,Performance,load,load,138,"/// Given a set of VectorInfo containing candidates for a given interleave; /// factor, find a set that represents a 'factor' interleaved load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:192,Availability,error,error,192,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1431,Availability,error,error,1431,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:348,Performance,optimiz,optimization,348,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:370,Performance,load,loads,370,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:426,Performance,load,loads,426,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:539,Performance,load,loaded,539,"// InterleavedLoadCombine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1012,Performance,load,load,1012,"mbine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1192,Performance,load,load,1192,"mbine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1276,Performance,load,loads,1276,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1282,Performance,load,load,1282,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:14,Availability,Error,Error,14,/// Number of Error Bits e,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:103,Availability,Error,Error,103,"// Note: Addition is associative in two's complement even when in case of; // signed overflow.; //; // Error bits can only propagate into higher significant bits. As these are; // already regarded as undefined, there is no change.; //; // Theorem: Adding a constant to a polynomial does not change the error; // term.; //; // Proof:; //; // Since the addition is associative and commutes:; //; // (B + A + E*2^(n-e)) + C = B + (A + C) + E*2^(n-e); // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:302,Availability,error,error,302,"// Note: Addition is associative in two's complement even when in case of; // signed overflow.; //; // Error bits can only propagate into higher significant bits. As these are; // already regarded as undefined, there is no change.; //; // Theorem: Adding a constant to a polynomial does not change the error; // term.; //; // Proof:; //; // Since the addition is associative and commutes:; //; // (B + A + E*2^(n-e)) + C = B + (A + C) + E*2^(n-e); // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:420,Availability,error,errors,420,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:553,Availability,error,errors,553,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:615,Availability,down,down,615,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1285,Availability,error,error,1285,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1447,Availability,error,error,1447,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1473,Availability,error,error,1473,"// Note: Multiplication distributes over the addition; //; // Theorem: Multiplication distributes over the addition; //; // Proof(1):; //; // (B+A)*C =-; // = (B + A) + (B + A) + .. {C Times}; // addition is associative and commutes, hence; // = B + B + .. {C Times} .. + A + A + .. {C times}; // = B*C + A*C; // (see (function add) for signed values and overflows); // [qed]; //; // Theorem: If C has c trailing zeros, errors bits in A or B are shifted out; // to the left.; //; // Proof(2):; //; // Let B' and A' be the n-Bit inputs with some unknown errors EA,; // EB at e leading bits. B' and A' can be written down as:; //; // B' = B + 2^(n-e)*EB; // A' = A + 2^(n-e)*EA; //; // Let C' be an input with c trailing zero bits. C' can be written as; //; // C' = C*2^c; //; // Therefore we can compute the result by using distributivity and; // commutativity.; //; // (B'*C' + A'*C') = [B + 2^(n-e)*EB] * C' + [A + 2^(n-e)*EA] * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = (B'+A') * C' =; // = [B + 2^(n-e)*EB + A + 2^(n-e)*EA] * C' =; // = [B + A + 2^(n-e)*EB + 2^(n-e)*EA] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C' =; // = (B + A) * C' + [2^(n-e)*EB + 2^(n-e)*EA)] * C*2^c =; // = (B + A) * C' + C*(EB + EA)*2^(n-e)*2^c =; //; // Let EC be the final error with EC = C*(EB + EA); //; // = (B + A)*C' + EC*2^(n-e)*2^c =; // = (B + A)*C' + EC*2^(n-(e-c)); //; // Since EC is multiplied by 2^(n-(e-c)) the resulting error contains c; // less error bits than the input. c bits are shifted out to the left.; // [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:12,Testability,log,logical,12,/// Apply a logical shift right on the polynomial,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:2640,Availability,error,error,2640,"+ E * 2^(n-e') =; //; // Compute Y by applying distributivity first; //; // Y = (B >> 1) + (A >> 1) + E*2^(n-e') =; // = (b_h * 2^(n-1) + b_m * 2 + b_l) >> 1 +; // + (a_h * 2^(n-1) + a_m * 2) >> 1 +; // + E * 2^(n-e) >> 1 =; //; // Again, the shift is computed by dividing the terms by 2 and by cutting; // off b_l.; //; // = b_h * 2^(n-2) + b_m +; // + a_h * 2^(n-2) + a_m +; // + E * 2^(n-(e+1)) =; //; // Again, the sum is built by putting the overflow of [a_m + b+n] into; // the term 2^(n-1). But this time there is room for a second bit in the; // term 2^(n-2) we add this bit to a new term and denote it o_h in a; // second step.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) tran",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3339,Availability,error,error,3339,"e there is room for a second bit in the; // term 2^(n-2) we add this bit to a new term and denote it o_h in a; // second step.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) transforms to (the pre-condition on A can also be; // dropped); //; // Theorem(2): (B + A + E) >> 1 => (B >> 1) + (A >> 1) + E'; // where; // A, B, E, E' are two's complement numbers with the same bit; // width; //; // Let A + B + E = X; // Let (B >> 1) + (A >> 1) = Y; //; // Therefore we need to show that for every X and Y there is an E' which; // makes the equation; //; // X = Y + E'; //; // hold. This is trivially the case for E' = X - Y.; //; // [qed]; //; // Remark: Distributing lshr with and arbitrary n",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4201,Availability,error,error,4201,"+ a_h + (b_m + a_m) >> (n-2)] >> 1) * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // Let o_h = [b_h + a_h + (b_m + a_m) >> (n-2)] >> 1; // Further replace e+1 by e'.; //; // = o_h * 2^(n-1) +; // + ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Move o_h into the error term and construct E'. To ensure that there is; // no 2^x with negative x, this step requires pre(2) (e < n).; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + o_h * 2^(e'-1) * 2^(n-e') + | pre(2), move 2^(e'-1); // | out of the old exponent; // + E * 2^(n-e') =; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + [o_h * 2^(e'-1) + E] * 2^(n-e') + | move 2^(e'-1) out of; // | the old exponent; //; // Let E' = o_h * 2^(e'-1) + E; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E' * 2^(n-e'); //; // Because X and Y are distinct only in there error terms and E' can be; // constructed as shown the theorem holds.; // [qed]; //; // For completeness in case of the case e=n it is also required to show that; // distributivity can be applied.; //; // In this case Theorem(1) transforms to (the pre-condition on A can also be; // dropped); //; // Theorem(2): (B + A + E) >> 1 => (B >> 1) + (A >> 1) + E'; // where; // A, B, E, E' are two's complement numbers with the same bit; // width; //; // Let A + B + E = X; // Let (B >> 1) + (A >> 1) = Y; //; // Therefore we need to show that for every X and Y there is an E' which; // makes the equation; //; // X = Y + E'; //; // hold. This is trivially the case for E' = X - Y.; //; // [qed]; //; // Remark: Distributing lshr with and arbitrary number n can be expressed as; // ((((B + A) lshr 1) lshr 1) ... ) {n times}.; // This construction induces n additional error bits at the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:312,Testability,log,logical,312,"// Theorem(1): (B + A + E*2^(n-e)) >> 1 => (B >> 1) + (A >> 1) + E'*2^(n-e'); // where; // e' = e + 1,; // E is a e-bit number,; // E' is a e'-bit number,; // holds under the following precondition:; // pre(1): A % 2 = 0; // pre(2): e < n, (see Theorem(2) for the trivial case with e=n); // where >> expresses a logical shift to the right, with adding zeros.; //; // We need to show that for every, E there is a E'; //; // B = b_h * 2^(n-1) + b_m * 2 + b_l; // A = a_h * 2^(n-1) + a_m * 2 (pre(1)); //; // where a_h, b_h, b_l are single bits, and a_m, b_m are (n-2) bit numbers; //; // Let X = (B + A + E*2^(n-e)) >> 1; // Let Y = (B >> 1) + (A >> 1) + E*2^(n-e) >> 1; //; // X = [B + A + E*2^(n-e)] >> 1 =; // = [ b_h * 2^(n-1) + b_m * 2 + b_l +; // + a_h * 2^(n-1) + a_m * 2 +; // + E * 2^(n-e) ] >> 1 =; //; // The sum is built by putting the overflow of [a_m + b+n] into the term; // 2^(n-1). As there are no more bits beyond 2^(n-1) the overflow within; // this bit is discarded. This is expressed by % 2.; //; // The bit in position 0 cannot overflow into the term (b_m + a_m).; //; // = [ ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-1) +; // + ((b_m + a_m) % 2^(n-2)) * 2 +; // + b_l + E * 2^(n-e) ] >> 1 =; //; // The shift is computed by dividing the terms by 2 and by cutting off; // b_l.; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-(e+1)) =; //; // by the definition in the Theorem e+1 = e'; //; // = ([b_h + a_h + (b_m + a_m) >> (n-2)] % 2) * 2^(n-2) +; // + ((b_m + a_m) % 2^(n-2)) +; // + E * 2^(n-e') =; //; // Compute Y by applying distributivity first; //; // Y = (B >> 1) + (A >> 1) + E*2^(n-e') =; // = (b_h * 2^(n-1) + b_m * 2 + b_l) >> 1 +; // + (a_h * 2^(n-1) + a_m * 2) >> 1 +; // + E * 2^(n-e) >> 1 =; //; // Again, the shift is computed by dividing the terms by 2 and by cutting; // off b_l.; //; // = b_h * 2^(n-2) + b_m +; // + a_h * 2^(n-2) + a_m +; // + E * 2^(n-(e+1)) =; //; // Again, the sum is buil",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,// Test if the result will be zero,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:162,Availability,error,error,162,// The proof that shiftAmt LSBs are zero for at least one summand is only; // possible for the constant number.; //; // If this can be proven add shiftAmt to the error counter; // `ErrorMSBs`. Otherwise set all bits as undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:181,Availability,Error,ErrorMSBs,181,// The proof that shiftAmt LSBs are zero for at least one summand is only; // possible for the constant number.; //; // If this can be proven add shiftAmt to the error counter; // `ErrorMSBs`. Otherwise set all bits as undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:17,Modifiability,extend,extend,17,/// Apply a sign-extend or truncate operation on the polynomial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:13,Usability,Clear,Clearly,13,// Truncate: Clearly undefined Bits on the MSB side are removed; // if there are any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Modifiability,Extend,Extend,3,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:19,Modifiability,extend,extending,19,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:89,Modifiability,extend,extending,89,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:112,Modifiability,extend,extended,112,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:11,Usability,Clear,Clearly,11,// Extend: Clearly extending first and adding later is different; // to adding first and extending later in all extended bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test if there is a coefficient B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test coefficient B of two Polynomials are equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:13,Modifiability,variab,variable,13,// The index variable is different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:33,Testability,test,test,33,// Subtract both polynomials and test if it is fully defined and zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:119,Performance,load,loaded,119,"/// VectorInfo stores abstract the following information for each vector; /// element:; ///; /// 1) The memory address loaded into the element as Polynomial; /// 2) a set of load instruction necessary to construct the vector,; /// 3) a set of all other instructions that are necessary to create the vector and; /// 4) a pointer value that can be used as relative base for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:174,Performance,load,load,174,"/// VectorInfo stores abstract the following information for each vector; /// element:; ///; /// 1) The memory address loaded into the element as Polynomial; /// 2) a set of load instruction necessary to construct the vector,; /// 3) a set of all other instructions that are necessary to create the vector and; /// 4) a pointer value that can be used as relative base for all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:8,Performance,Load,Load,8,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:33,Performance,Load,Load,33,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:87,Performance,load,load,87,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,load,load,20,/// Basic-block the load instructions are within,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:39,Performance,load,load,39,/// Pointer value of all participation load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:18,Performance,load,load,18,/// Participating load instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:57,Performance,load,load,57,/// Test if the VectorInfo can be part of an interleaved load with the; /// specified factor.; ///; /// \param Factor of the interleave; /// \param DL Targets Datalayout; ///; /// \returns true if this is possible and false if not,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Testability,Test,Test,4,/// Test if the VectorInfo can be part of an interleaved load with the; /// specified factor.; ///; /// \param Factor of the interleave; /// \param DL Targets Datalayout; ///; /// \returns true if this is possible and false if not,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:363,Performance,load,loads,363,/// ShuffleVectorInst specialization to compute vector information.; ///; /// \param SVI ShuffleVectorInst to operate on; /// \param Result Result of the computation; ///; /// Compute the left and the right side vector information and merge them by; /// applying the shuffle operation. This function also ensures that the left; /// and right side have compatible loads. This means that all loads are with; /// in the same basic block and are based on the same pointer.; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:390,Performance,load,loads,390,/// ShuffleVectorInst specialization to compute vector information.; ///; /// \param SVI ShuffleVectorInst to operate on; /// \param Result Result of the computation; ///; /// Compute the left and the right side vector information and merge them by; /// applying the shuffle operation. This function also ensures that the left; /// and right side have compatible loads. This means that all loads are with; /// in the same basic block and are based on the same pointer.; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Performance,Load,LoadInst,4,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:150,Performance,Load,LoadInst,150,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:96,Safety,abort,abort,96,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:69,Modifiability,variab,variable,69,"// Compute base offset from zero based index, excluding the last; // variable operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:30,Performance,load,load,30,// Try to find an interleaved load using the front of Worklist as first line,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:30,Performance,Load,LoadInst,30,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:45,Performance,load,loads,45,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:129,Performance,load,load,129,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:87,Testability,test,tests,87,// The insertion point is the LoadInst which loads the first values. The; // following tests are used to proof that the combined load can be inserted; // just before InsertionPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,// Test if the offset is computed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:25,Performance,load,load,25,// Generate a set of all load instructions to be combined,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:53,Performance,load,load,53,// Generate a set of all instructions taking part in load; // interleaved. This list excludes the instructions necessary for the; // polynomial construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:121,Performance,perform,performance,121,"// Test if all participating instruction will be dead after the; // transformation. If intermediate results are used, no performance gain can; // be expected. Also sum the cost of the Instructions beeing left dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:3,Testability,Test,Test,3,"// Test if all participating instruction will be dead after the; // transformation. If intermediate results are used, no performance gain can; // be expected. Also sum the cost of the Instructions beeing left dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:59,Safety,abort,abort,59,"// If there are users outside the set to be eliminated, we abort the; // transformation. No gain can be expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,Load,LoadInst,20,// We know that all LoadInst are within the same BB. This guarantees that; // either everything or nothing is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:110,Performance,load,loaded,110,// We know that all LoadInst are within the same BB. This guarantees that; // either everything or nothing is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:23,Performance,load,loads,23,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:63,Performance,load,loads,63,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:210,Performance,load,loads,210,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:9,Safety,safe,safe,9,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:114,Security,access,access,114,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:73,Testability,test,test,73,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:41,Safety,detect,detectable,41,// All checks are done. Add instructions detectable by InterleavedAccessPass; // The old instruction will are left dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:28,Deployability,update,update,28,// Create the wide load and update the MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:19,Performance,load,load,19,// Create the wide load and update the MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:36,Safety,avoid,avoid,36,// Start with the highest factor to avoid combining and recombining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,Performance,scalab,scalable,20,// We don't support scalable vectors in this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:47,Performance,Load,Load,47,// Remove the first element of the Interleaved Load but put the others; // back on the list and continue searching,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:35,Performance,load,loads,35,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,Safety,detect,detectable,56,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out prefetches on unsupported architectures,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out pcmarker on unsupported architectures,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Usability,Simpl,Simply,3,// Simply strip out debugging intrinsics,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Modifiability,Extend,Extend,3,// Extend the amount to i32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:20,Usability,simpl,simple,20,// Verify this is a simple bswap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:658,Availability,error,error,658,"//===- JMCInstrumenter.cpp - JMC Instrumentation --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // JMCInstrumenter pass:; // - instrument each function with a call to __CheckForDebuggerJustMyCode. The; // sole argument should be defined in .msvcjmc. Each flag is 1 byte initilized; // to 1.; // - create the dummy COMDAT function __JustMyCode_Default to prevent linking; // error if __CheckForDebuggerJustMyCode is not available.; // - For MSVC:; // add ""/alternatename:__CheckForDebuggerJustMyCode=__JustMyCode_Default"" to; // ""llvm.linker.options""; // For ELF:; // Rename __JustMyCode_Default to __CheckForDebuggerJustMyCode and mark it as; // weak symbol.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:703,Availability,avail,available,703,"//===- JMCInstrumenter.cpp - JMC Instrumentation --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // JMCInstrumenter pass:; // - instrument each function with a call to __CheckForDebuggerJustMyCode. The; // sole argument should be defined in .msvcjmc. Each flag is 1 byte initilized; // to 1.; // - create the dummy COMDAT function __JustMyCode_Default to prevent linking; // error if __CheckForDebuggerJustMyCode is not available.; // - For MSVC:; // add ""/alternatename:__CheckForDebuggerJustMyCode=__JustMyCode_Default"" to; // ""llvm.linker.options""; // For ELF:; // Rename __JustMyCode_Default to __CheckForDebuggerJustMyCode and mark it as; // weak symbol.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:250,Security,hash,hash,250,"// Best effort path normalization. This is to guarantee an unique flag symbol; // is produced for the same directory. Some builds may want to use relative; // paths, or paths with a specific prefix (see the -fdebug-compilation-dir; // flag), so only hash paths in debuginfo. Don't expand them to absolute; // paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:49,Security,hash,hash,49,// The naming convention for the flag name is __<hash>_<file name> with '.' in; // <file name> replaced with '@'. For example C:\file.any.c would have a flag; // __D032E919_file@any@c. The naming convention match MSVC's format however; // the match is not required to make JMC work. The hashing function used here; // is different from MSVC's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:287,Security,hash,hashing,287,// The naming convention for the flag name is __<hash>_<file name> with '.' in; // <file name> replaced with '@'. For example C:\file.any.c would have a flag; // __D032E919_file@any@c. The naming convention match MSVC's format however; // the match is not required to make JMC work. The hashing function used here; // is different from MSVC's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:38,Energy Efficiency,schedul,scheduling,38,"// FIXME: it would be nice to make CI scheduling boundary, although in; // practice it does not matter much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:52,Security,Integrity,Integrity,52,"//===---- KCFI.cpp - Implements Kernel Control-Flow Integrity (KCFI) ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements Kernel Control-Flow Integrity (KCFI) indirect call; // check lowering. For each call instruction with a cfi-type attribute, it; // emits an arch-specific check before the call, and bundles the check and; // the call to prevent unintentional modifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:424,Security,Integrity,Integrity,424,"//===---- KCFI.cpp - Implements Kernel Control-Flow Integrity (KCFI) ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements Kernel Control-Flow Integrity (KCFI) indirect call; // check lowering. For each call instruction with a cfi-type attribute, it; // emits an arch-specific check before the call, and bundles the check and; // the call to prevent unintentional modifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:64,Safety,safe,safely,64,"// If the call instruction is bundled, we can only emit a check safely if; // it's the first instruction in the bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:3,Usability,Clear,Clear,3,// Clear the original call's CFI type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:451,Energy Efficiency,Schedul,SchedulingPriorityQueue,451,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:480,Energy Efficiency,schedul,schedules,480,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:523,Energy Efficiency,reduce,reduce,523,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:10,Performance,Latency,LatencyPriorityQueue,10,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:39,Performance,latency,latency-oriented,39,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:65,Performance,queue,queue,65,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:408,Performance,Latency,LatencyPriorityQueue,408,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:496,Performance,latency,latency,496,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:176,Availability,down,down,176,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:133,Energy Efficiency,schedul,scheduled,133,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:181,Energy Efficiency,schedul,schedule,181,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:45,Integrability,wrap,wraparound,45,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:56,Integrability,depend,dependencies,56,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:35,Energy Efficiency,schedul,scheduling,35,// The most important heuristic is scheduling the critical path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:15,Availability,avail,available,15,"// We found an available, but not scheduled, predecessor. If it's the; // only one we have found, keep track of it... otherwise give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:34,Energy Efficiency,schedul,scheduled,34,"// We found an available, but not scheduled, predecessor. If it's the; // only one we have found, keep track of it... otherwise give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:240,Availability,avail,available,240,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:3,Energy Efficiency,schedul,scheduledNode,3,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:32,Energy Efficiency,schedul,scheduled,32,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:203,Energy Efficiency,schedul,scheduling,203,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:114,Availability,avail,available,114,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:339,Availability,avail,available,339,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:439,Availability,avail,available,439,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:83,Energy Efficiency,schedul,scheduled,83,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:192,Energy Efficiency,schedul,scheduled,192,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:309,Energy Efficiency,schedul,scheduled,309,"/// AdjustPriorityOfUnscheduledPreds - One of the predecessors of SU was just; /// scheduled. If SU is not itself available, then there is at least one; /// predecessor node that has not been scheduled yet. If SU has exactly ONE; /// unscheduled predecessor, we want to increase its priority: it getting; /// scheduled will make this node available, so it is better than some other; /// node of the same priority that will not make a node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:13,Energy Efficiency,schedul,scheduled,13,// All preds scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:47,Availability,avail,available,47,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:93,Availability,avail,available,93,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:66,Energy Efficiency,schedul,scheduled,66,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:131,Performance,queue,queue,131,"// Okay, we found a single predecessor that is available, but not scheduled.; // Since it is available, it must be in the priority queue. First remove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:39,Performance,queue,queue,39,"// Reinsert the node into the priority queue, which recomputes its; // NumNodesSolelyBlocking value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:85,Availability,avail,available,85,/// getOrCreateLexicalScope - Find lexical scope for the given DebugLoc. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:178,Performance,Cache,Cache,178,"// Fetch all the blocks in DLs scope. Because the range / block list also; // contain any subscopes, any instruction that DL dominates can be found in; // the block set.; //; // Cache the set of fetched blocks to avoid repeatedly recomputing the set in; // the LiveDebugValues pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:213,Safety,avoid,avoid,213,"// Fetch all the blocks in DLs scope. Because the range / block list also; // contain any subscopes, any instruction that DL dominates can be found in; // the block set.; //; // Cache the set of fetched blocks to avoid repeatedly recomputing the set in; // the LiveDebugValues pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:683,Deployability,update,updated,683,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:52,Modifiability,variab,variables,52,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:577,Modifiability,variab,variables,577,"//===- LiveDebugVariables.cpp - Tracking debug info variables -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveDebugVariables analysis.; //; // Remove all DBG_VALUE instructions referencing virtual registers and replace; // them with a data structure tracking where live user variables are kept - in a; // virtual register or in a stack slot.; //; // Allow the data structure to be updated during register allocation when values; // are moved between registers and stack slots. Finally emit new DBG_VALUE; // instructions after register allocation is complete.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:22,Modifiability,variab,variable,22,/// Describes a debug variable value by location number and expression along; /// with some flags about the original usage of the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:107,Performance,perform,performance,107,"// FIXME: Debug values referencing 64+ unique machine locations are rare and; // currently unsupported for performance reasons. If we can verify that; // performance is acceptable for such debug values, we can increase the; // bit-width of LocNoCount to 14 to enable up to 16384 unique machine; // locations. We will also need to verify that this does not cause issues; // with LiveDebugVariables' use of IntervalMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:154,Performance,perform,performance,154,"// FIXME: Debug values referencing 64+ unique machine locations are rare and; // currently unsupported for performance reasons. If we can verify that; // performance is acceptable for such debug values, we can increase the; // bit-width of LocNoCount to 14 to enable up to 16384 unique machine; // locations. We will also need to verify that this does not cause issues; // with LiveDebugVariables' use of IntervalMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:60,Usability,simpl,simplest,60,"// Turn this into an undef debug value list; right now, the simplest form; // of this is an expression with one arg, and an undef debug operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:174,Integrability,wrap,wrapper,174,"// IntervalMap requires the value object to be very small, to the extent; // that we do not have enough room for an std::vector. Using a C-style array; // (with a unique_ptr wrapper for convenience) allows us to optimize for this; // specific case by packing the array size into only 6 bits (it is highly; // unlikely that any debug value will need 64+ locations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:212,Performance,optimiz,optimize,212,"// IntervalMap requires the value object to be very small, to the extent; // that we do not have enough room for an std::vector. Using a C-style array; // (with a unique_ptr wrapper for convenience) allows us to optimize for this; // specific case by packing the array size into only 6 bits (it is highly; // unlikely that any debug value will need 64+ locations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Performance,Cache,Cache,4,/// Cache to save the location where it can be used as the starting; /// position as input for calling MachineBasicBlock::SkipPHIsLabelsAndDebug.; /// This is to prevent MachineBasicBlock::SkipPHIsLabelsAndDebug from; /// repeatedly searching the same set of PHIs/Labels/Debug instructions; /// if it is called many times for the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:48,Modifiability,variab,variable,48,/// A user value is a part of a debug info user variable.; ///; /// A DBG_VALUE instruction notes that (a sub-register of) a virtual register; /// holds part of a user variable. The part is identified by a byte offset.; ///; /// UserValues are grouped into equivalence classes for easier searching. Two; /// user values are related if they are held by the same virtual register. The; /// equivalence class is the transitive closure of that relation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:168,Modifiability,variab,variable,168,/// A user value is a part of a debug info user variable.; ///; /// A DBG_VALUE instruction notes that (a sub-register of) a virtual register; /// holds part of a user variable. The part is identified by a byte offset.; ///; /// UserValues are grouped into equivalence classes for easier searching. Two; /// user values are related if they are held by the same virtual register. The; /// equivalence class is the transitive closure of that relation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:20,Modifiability,variab,variable,20,///< The debug info variable we are part of.; /// The part of the variable we describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:66,Modifiability,variab,variable,66,///< The debug info variable we are part of.; /// The part of the variable we describe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:32,Modifiability,variab,variable,32,///< The debug location for the variable. This is; ///< used by dwarf writer to find lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:53,Availability,down,down,53,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Modifiability,Extend,Extend,4,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:275,Performance,perform,performs,275,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:94,Availability,avail,available,94,"/// The value in LI may be copies to other registers. Determine if; /// any of the copies are available at the kill points, and add defs if; /// possible.; ///; /// \param DbgValue Location number of LI->reg, and DIExpression.; /// \param LocIntervals Scan for copies of the value for each location in the; /// corresponding LiveInterval->reg.; /// \param KilledAt The point where the range of DbgValue could be extended.; /// \param [in,out] NewDefs Append (Idx, DbgValue) of inserted defs here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:412,Modifiability,extend,extended,412,"/// The value in LI may be copies to other registers. Determine if; /// any of the copies are available at the kill points, and add defs if; /// possible.; ///; /// \param DbgValue Location number of LI->reg, and DIExpression.; /// \param LocIntervals Scan for copies of the value for each location in the; /// corresponding LiveInterval->reg.; /// \param KilledAt The point where the range of DbgValue could be extended.; /// \param [in,out] NewDefs Append (Idx, DbgValue) of inserted defs here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite virtual register locations according to the provided virtual; /// register map. Record the stack slot offsets for the locations that; /// were spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,Energy Efficiency,allocate,allocated,8,/// All allocated UserValue instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:8,Energy Efficiency,allocate,allocated,8,/// All allocated UserLabel instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:155,Deployability,update,updated,155,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:10,Modifiability,variab,variable,10,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:359,Safety,avoid,avoid,359,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Deployability,Release,Release,4,/// Release all memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:26,Modifiability,variab,variable,26,"// DBG_VALUE loc, offset, variable, expr; // DBG_VALUE_LIST variable, expr, locs...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:60,Modifiability,variab,variable,60,"// DBG_VALUE loc, offset, variable, expr; // DBG_VALUE_LIST variable, expr, locs...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Safety,Detect,Detect,3,"// Detect invalid DBG_VALUE instructions, with a debug-use of a virtual; // register that hasn't been defined yet. If we do not remove those here, then; // the re-insertion of the DBG_VALUE instruction after register allocation; // will be incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:36,Modifiability,variab,variable,36,"// Get or create the UserValue for (variable,offset) here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:56,Modifiability,extend,extended,56,// Stop when meeting a different location or an already extended interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:39,Availability,avail,available,39,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Usability,Clear,Clear,3,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:39,Availability,avail,available,39,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Usability,Clear,Clear,3,"// Clear `Kills`, as we have a new def available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:16,Modifiability,extend,extended,16,"// Is the value extended to reach this copy? If not, another def may be; // blocking it, or we are looking at a wrong value of LI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:76,Modifiability,extend,extend,76,"// If there are any killed locations we can't find a copy for, we can't; // extend the variable value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:87,Modifiability,variab,variable,87,"// If there are any killed locations we can't find a copy for, we can't; // extend the variable value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:26,Modifiability,extend,extended,26,// Collect all defs to be extended (Skipping undefs).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Extend,Extend,3,"// Extend all defs, and possibly add new ones along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:480,Usability,simpl,simply,480,"// FIXME: Handle sub-registers in addDefsFromCopies. The problem is that; // if the original location for example is %vreg0:sub_hi, and we find a; // full register copy in addDefsFromCopies (at the moment it only; // handles full register copies), then we must add the sub1 sub-register; // index to the new location. However, that is only possible if the new; // virtual register is of the same regclass (or if there is an; // equivalent sub-register in that regclass). For now, simply skip; // handling copies if a sub-register is involved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:210,Modifiability,extend,extend,210,"// For physregs, we only mark the start slot idx. DwarfDebug will see it; // as if the DBG_VALUE is valid up until the end of the basic block, or; // the next def of the physical register. So we do not need to extend the; // range. It might actually happen that the DBG_VALUE is the last use of; // the physical register (e.g. if this is an unused input argument to a; // function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:30,Modifiability,extend,extend,30,"// The computed intervals may extend beyond the range of the debug; // location's lexical scope. In this case, splitting of an interval; // can result in an interval outside of the scope being created,; // causing extra unnecessary DBG_VALUEs to be emitted. To prevent; // this, trim the intervals to the lexical scope in the case of inlined; // variables, since heavy inlining may cause production of dramatically big; // number of DBG_VALUEs to be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:346,Modifiability,variab,variables,346,"// The computed intervals may extend beyond the range of the debug; // location's lexical scope. In this case, splitting of an interval; // can result in an interval outside of the scope being created,; // causing extra unnecessary DBG_VALUEs to be emitted. To prevent; // this, trim the intervals to the lexical scope in the case of inlined; // variables, since heavy inlining may cause production of dramatically big; // number of DBG_VALUEs to be generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Variab,Variable,3,"// Variable locations at the first instruction of a block should be; // based on the block's SlotIndex, not the first instruction's index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:31,Modifiability,variab,variable,31,// Have we been asked to track variable locations using instruction; // referencing?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:9,Energy Efficiency,allocate,allocate,9,// Don't allocate the new LocNo until it is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:33,Energy Efficiency,Allocate,Allocate,33,// Overlapping correct location. Allocate NewLocNo now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:16,Availability,down,down,16,// Trim LocMapI down to the LII overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:247,Modifiability,rewrite,rewriteLocations,247,"// Finally, remove OldLocNo unless it is still used by some interval in the; // locInts map. One case when OldLocNo still is in use is when the register; // has been spilled. In such situations the spilled register is kept as a; // location until rewriteLocations is called (VirtRegMap is mapping the old; // register to the spill slot). So for a while we can have locations that map; // to virtual registers that have been removed from both the MachineFunction; // and from LiveIntervals.; //; // We may also just be using the location for a value with a different; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:83,Safety,safe,safely,83,// Split locations referring to OldReg. Iterate backwards so splitLocation can; // safely erase unused locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:241,Performance,optimiz,optimized,241,"// If we do not find a new register covering this PHI, then register; // allocation has dropped its location, for example because it's not live.; // The old VReg will not be mapped to a physreg, and the instruction; // number will have been optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:478,Modifiability,variab,variables,478,"// Build a set of new locations with new numbers so we can coalesce our; // IntervalMap if two vreg intervals collapse to the same physical location.; // Use MapVector instead of SetVector because MapVector::insert returns the; // position of the previously or newly inserted element. The boolean value; // tracks if the location was produced by a spill.; // FIXME: This will be problematic if we ever support direct and indirect; // frame index locations, i.e. expressing both variables in memory and; // 'int x, *px = &x'. The ""spilled"" bit must become part of the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:95,Availability,avail,available,95,"// This can create a %noreg operand in rare cases when the sub-register; // index is no longer available. That means the user value is in a; // non-existent sub-register, and %noreg is exactly what we want.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the locations and record the stack slot offsets for spills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Deployability,Update,Update,3,"// Update the interval map, but only coalesce left, since intervals to the; // right use the old location numbers. This should merge two contiguous; // DBG_VALUE intervals with different vregs that were allocated to the same; // physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:203,Energy Efficiency,allocate,allocated,203,"// Update the interval map, but only coalesce left, since intervals to the; // right use the old location numbers. This should merge two contiguous; // DBG_VALUE intervals with different vregs that were allocated to the same; // physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Testability,Test,Test,3,"// Test whether this location is legal with the given subreg. If the; // subregister has a nonzero offset, drop this location, it's too complex; // to describe. (TODO: future work).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:94,Modifiability,variab,variables,94,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:48,Performance,optimiz,optimized,48,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:133,Performance,optimiz,optimized,133,"// If there was no mapping for a value ID, it's optimized out. Create no; // DBG_PHI, and any variables using this value will become optimized out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:89,Safety,safe,safe,89,"// We have reached the end of the block and didn't find anywhere to; // insert! It's not safe to discard any debug instructions; place them; // in front of the first terminator, or in front of end().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:593,Deployability,update,updated,593,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:406,Integrability,interface,interface,406,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:50,Modifiability,variab,variables,50,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:551,Modifiability,variab,variables,551,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:747,Modifiability,variab,variables,747,"//===- LiveDebugVariables.h - Tracking debug info variables -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface to the LiveDebugVariables analysis.; //; // The analysis removes DBG_VALUE instructions for virtual registers and tracks; // live user variables in a data structure that can be updated during register; // allocation.; //; // After register allocation new DBG_VALUE instructions are emitted to reflect; // the new locations of user variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h:34,Modifiability,variab,variables,34,/// splitRegister - Move any user variables in OldReg to the live ranges in; /// NewRegs where they are live. Mark the values as unavailable where no new; /// register is live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:481,Safety,avoid,avoid,481,"//===----------------------------------------------------------------------===//; // Implementation of various methods necessary for calculation of live ranges.; // The implementation of the methods abstracts from the concrete type of the; // segment collection.; //; // Implementation of the class follows the Template design pattern. The base; // class contains generic algorithms that call collection-specific methods,; // which are provided in concrete subclasses. In order to avoid virtual calls; // these methods are provided by means of C++ template instantiation.; // The base class calls the methods of the subclass through method impl(),; // which casts 'this' pointer to the type of the subclass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:196,Energy Efficiency,allocate,allocated,196,"/// A counterpart of LiveRange::createDeadDef: Make sure the range has a; /// value defined at @p Def.; /// If @p ForVNI is null, and there is no value defined at @p Def, a new; /// value will be allocated using @p VNInfoAllocator.; /// If @p ForVNI is null, the return value is the value defined at @p Def,; /// either a pre-existing one, or the one newly created.; /// If @p ForVNI is not null, then @p Def should be the location where; /// @p ForVNI is defined. If the range does not have a value defined at; /// @p Def, the value @p ForVNI will be used instead of allocating a new; /// one. If the range already has a value defined at @p Def, it must be; /// same as @p ForVNI. In either case, @p ForVNI will be the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:40,Modifiability,extend,extend,40,"/// This method is used when we want to extend the segment specified; /// by I to end at the specified endpoint. To do this, we should; /// merge and eliminate all segments that this will overlap; /// with. The iterator is not invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:40,Modifiability,extend,extend,40,"/// This method is used when we want to extend the segment specified; /// by I to start at the specified endpoint. To do this, we should; /// merge and eliminate all segments that this will overlap with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:77,Modifiability,extend,extend,77,"// If we start in the middle of another segment, just delete a range and; // extend that segment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:14,Modifiability,extend,extend,14,"// Otherwise, extend the segment right after.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:97,Modifiability,extend,extend,97,"// If the inserted segment starts in the middle or right at the end of; // another segment, just extend that segment to contain the segment of S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:24,Safety,abort,abort,24,// Get next segment and abort if it was not adjacent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:33,Availability,avail,available,33,"// Use the segment set, if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:82,Safety,avoid,avoid,82,"// Determine if any of our values are mapped. This is uncommon, so we want; // to avoid the range scan if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:63,Modifiability,rewrite,rewrite,63,"// If we have to apply a mapping to our base range assignment, rewrite it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite Other values before changing the VNInfo ids.; // This can leave Other in an invalid state because we're not coalescing; // touching segments that now have identical values. That's OK since Other is; // not supposed to be valid after calling join();,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Deployability,Update,Update,3,// Update val# info. Renumber them and make sure they all belong to this; // LiveRange now. Also remove dead val#'s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:108,Modifiability,extend,extend,108,"// Not a V1 Segment.; // Okay, we found a V1 live range. If it had a previous, touching, V2 live; // range, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:14,Energy Efficiency,allocate,allocated,14,// Memory was allocated with BumpPtr allocator and is not freed here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:84,Availability,mask,mask,84,"/// For each VNI in \p SR, check whether or not that value defines part; /// of the mask describe by \p LaneMask and if not, remove that value; /// from \p SR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:70,Testability,assert,assert,70,"// If the subrange is empty at this point, the MIR is invalid. Do not assert; // and let the verifier catch this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:76,Energy Efficiency,Reduce,Reduce,76,// We have to split the subrange into a matching and non-matching part.; // Reduce lanemask of existing lane to non-matching part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:65,Availability,mask,masks,65,// Subrange lanemask should be disjunct to any previous subrange masks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:12,Availability,mask,mask,12,// subrange mask should not contained in maximum lane mask for the vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:54,Availability,mask,mask,54,// subrange mask should not contained in maximum lane mask for the vreg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Performance,Perform,Perform,3,// Perform a backwards merge of Spills and [SpillI;WriteI).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Usability,Clear,Clear,3,// Clear the dirty state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:11,Modifiability,Extend,Extend,11,"// Step 2: Extend live segments to all uses, constructing SSA form as; // necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:3,Usability,Clear,Clear,3,// Clear all kill flags. They will be reinserted after register allocation; // by LiveIntervals::addKillFlags().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp:116,Modifiability,extend,extend,116,"// MI is reading Reg. We may have visited MI before if it happens to be; // reading Reg multiple times. That is OK, extend() is idempotent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Deployability,Release,Release,3,"// Release VNInfo memory regions, VNInfo objects don't need to be dtor'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for all virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:14,Testability,test,testing,14,"// For stress testing, precompute live ranges of all physical register; // units, including reserved registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:50,Availability,mask,masks,50,"// Some block starts, such as EH funclets, create masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:52,Availability,mask,masks,52,"// Some block ends, such as funclet returns, create masks. Put the mask on; // the last instruction of the block, because MBB slot index intervals are; // half-open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:67,Availability,mask,mask,67,"// Some block ends, such as funclet returns, create masks. Put the mask on; // the last instruction of the block, because MBB slot index intervals are; // half-open.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:34,Availability,mask,mask,34,// Compute the number of register mask instructions in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:113,Modifiability,extend,extending,113,"// The physregs aliasing Unit are the roots and their super-registers.; // Create all values as dead defs before extending to uses. Note that roots; // may share super-registers. That's OK because createDeadDefs() is; // idempotent. It is very rare for a register unit to have multiple roots, so; // uniquing super-registers is probably not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:7,Modifiability,extend,extend,7,// Now extend LR to reach all uses.; // Ignore uses of reserved registers. We only track defs of those.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:37,Energy Efficiency,allocate,allocated,37,// Keep track of the live range sets allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend intervals to reach all uses in WorkList.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend the live range for VNI to be live at Idx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:23,Energy Efficiency,allocate,allocated,23,// Target may have not allocated this yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:13,Availability,mask,mask,13,// Compute a mask of lanes that are defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:94,Availability,mask,mask,94,//===----------------------------------------------------------------------===//; // Register mask functions; //===----------------------------------------------------------------------===//; /// Check whether use of reg in MI is live-through. Live-through means that; /// the value is alive on exit from Machine instruction. The example of such; /// use is a deopt value in statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:286,Availability,alive,alive,286,//===----------------------------------------------------------------------===//; // Register mask functions; //===----------------------------------------------------------------------===//; /// Check whether use of reg in MI is live-through. Live-through means that; /// the value is alive on exit from Machine instruction. The example of such; /// use is a deopt value in statepoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:46,Availability,mask,mask,46,// We are going to enumerate all the register mask slots contained in LI.; // Start with a binary search of RegMaskSlots to find a starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:41,Usability,Usab,UsableRegs,41,// This is the first overlap. Initialize UsableRegs to all ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:45,Availability,mask,mask,45,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:10,Usability,usab,usable,10,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:31,Availability,mask,mask,31,// *SlotI overlaps LI. Collect mask bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:232,Modifiability,extend,extend,232,//===----------------------------------------------------------------------===//; // IntervalUpdate class.; //===----------------------------------------------------------------------===//; /// Toolkit used by handleMove to trim or extend live intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:10,Deployability,Update,UpdateFlags,10,"// FIXME: UpdateFlags is a workaround that creates live intervals for all; // physregs, even those that aren't needed for regalloc, in order to update; // kill flags. This is wasteful. Eventually, LiveVariables will strip all kill; // flags, and postRA passes will use a live register utility instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:144,Deployability,update,update,144,"// FIXME: UpdateFlags is a workaround that creates live intervals for all; // physregs, even those that aren't needed for regalloc, in order to update; // kill flags. This is wasteful. Eventually, LiveVariables will strip all kill; // flags, and postRA passes will use a live register utility instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,"/// Update all live ranges touched by MI, assuming a move from OldIdx to; /// NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:16,Usability,clear,clear,16,// Aggressively clear all kill flags.; // They are reinserted by VirtRegRewriter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:81,Deployability,update,updateRange,81,"// If main range has a hole and we are moving a subrange use across; // the hole updateRange() cannot properly handle it since it only; // gets the LiveRange and not the whole LiveInterval. As a result; // we may end up with a main range not covering all subranges.; // This is extremely rare case, so let's check and reconstruct the; // main range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:22,Deployability,update,update,22,"// For physregs, only update the regunits that actually have a; // precomputed live range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,"/// Update a single live range, assuming an instruction has been moved from; /// OldIdx to NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:55,Availability,down,downwards,55,/// Update LR to reflect an instruction has been moved downwards from OldIdx; /// to NewIdx (OldIdx < NewIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,/// Update LR to reflect an instruction has been moved downwards from OldIdx; /// to NewIdx (OldIdx < NewIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:32,Modifiability,extend,extends,32,"// If the live-in value already extends to NewIdx, there is nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:96,Modifiability,extend,extends,96,// If we are here then OldIdx was just a use but not a def. We only have; // to ensure liveness extends to NewIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend the segment before NewIdx if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Modifiability,Extend,Extend,3,// Extend OldIdxIn.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:24,Modifiability,extend,extends,24,"// If the defined value extends beyond NewIdx, just move the beginning; // of the segment to NewIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:41,Modifiability,extend,extend,41,"// If NewIdx is behind the last segment, extend that and append a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:4,Deployability,Update,Update,4,/// Update LR to reflect an instruction has been moved upwards from OldIdx; /// to NewIdx (NewIdx < OldIdx).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Usability,Simpl,Simply,3,// Simply remove the dead def at OldIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:140,Modifiability,Extend,Extend,140,"// If the segment before OldIdx read a value defined earlier than; // NewIdx, the moved instruction also reads and forwards that; // value. Extend the lifetime of the new def point.; // Extend to where the previous range started, unless there is; // another redef first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:186,Modifiability,Extend,Extend,186,"// If the segment before OldIdx read a value defined earlier than; // NewIdx, the moved instruction also reads and forwards that; // value. Extend the lifetime of the new def point.; // Extend to where the previous range started, unless there is; // another redef first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:97,Availability,down,down,97,"// OldIdxIn and OldIdxVNI are now undef and can be overridden.; // We Slide [NewIdxIn, OldIdxIn) down one position.; // |- X0/NewIdxIn -| ... |- Xn-1 -||- Xn/OldIdxIn -||- OldIdxOut -|; // => |- undef/NexIdxIn -| |- X0 -| ... |- Xn-1 -| |- Xn/OldIdxOut -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:339,Availability,down,down,339,"// OldIdxVNI is a dead def that has been moved into the middle of; // another value in LR. That can happen when LR is a whole register,; // but the dead def is a write to a subreg that is dead at NewIdx.; // The dead def may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- X0/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:149,Availability,down,down,149,"// OldIdxVNI is a dead def. It may have been moved across other values; // in LR, so move OldIdxOut up to NewIdxOut. Slide [NewIdxOut;OldIdxOut); // down one position.; // |- X0/NewIdxOut -| ... |- Xn-1 -| |- Xn/OldIdxOut -| |- next - |; // => |- undef/NewIdxOut -| |- X0 -| ... |- Xn-1 -| |- next -|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:107,Availability,repair,repair,107,// FIXME: This doesn't currently handle early-clobber or multiple removed; // defs inside of the region to repair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:19,Availability,repair,repair,19,// Don't bother to repair a freshly calculated live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp:3,Safety,Detect,Detect,3,"// Detect overlap, handle above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:78,Availability,mask,mask,78,/// Remove all registers from the set that get clobbered by the register; /// mask.; /// The clobbers set will be the list of live registers clobbered; /// by the regmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:153,Integrability,depend,depends,153,"/// Simulates liveness when stepping forward over an instruction(bundle): Remove; /// killed-uses, add defs. This is the not recommended way, because it depends; /// on accurate kill flags. If possible use stepBackward() instead of this; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:27,Usability,simpl,simply,27,// To get the live-outs we simply merge the live-ins of all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:30,Deployability,update,update,30,"// The value is live-through, update LiveOut as well.; // Defer the Domtree lookup until it is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:41,Modifiability,extend,extend,41,// Is there a def in the same MBB we can extend?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:176,Performance,Perform,Perform,176,"// Find the single reaching def, or determine if Use is jointly dominated by; // multiple values, and we may need to create even more phi-defs to preserve; // VNInfo SSA form. Perform a search for all predecessor blocks where we; // know the dominating VNInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:150,Availability,avail,available,150,"// This function is called by a client after using the low-level API to add; // live-out and live-in blocks. The unique value optimization is not; // available, SplitEditor::transferValues handles that case directly anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:126,Performance,optimiz,optimization,126,"// This function is called by a client after using the low-level API to add; // live-out and live-in blocks. The unique value optimization is not; // available, SplitEditor::transferValues handles that case directly anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:32,Performance,perform,perform,32,"// Using Seen as a visited set, perform a BFS for all reaching defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:8,Deployability,update,updateSSA,8,"// Both updateSSA() and LiveRangeUpdater benefit from ordered blocks, but; // neither require it. Skip the sorting overhead for small updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:134,Deployability,update,updates,134,"// Both updateSSA() and LiveRangeUpdater benefit from ordered blocks, but; // neither require it. Skip the sorting overhead for small updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:87,Deployability,Update,UpdateSSA,87,"// Multiple values were found, so transfer the work list to the LiveIn array; // where UpdateSSA will use it as a work list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:29,Availability,down,down,29,"// Propagate live-out values down the dominator tree, inserting phi-defs; // when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:3,Performance,Cache,Cache,3,// Cache the DomTree node that defined the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:3,Performance,Cache,Cache,3,// Cache the DomTree node that defined the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:96,Modifiability,extend,extendRange,96,"// The value may be live-through even if Kill is set, as can happen when; // we are called from extendRange. In that case LiveOutSeen is true, and; // LiveOut indicates a foreign or missing value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp:22,Deployability,update,updateFromLiveIns,22,// Add liveness since updateFromLiveIns now skips this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeCalc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:94,Availability,avail,available,94,/// allUsesAvailableAt - Return true if all registers used by OrigMI at; /// OrigIdx are also available with the same value at UseIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:38,Availability,avail,available,38,// Verify that all used registers are available with the same values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:58,Modifiability,extend,extending,58,"// Since we're moving the DefMI load, make sure we're not extending any live; // ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:32,Performance,load,load,32,"// Since we're moving the DefMI load, make sure we're not extending any live; // ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:52,Performance,load,load,52,// We also need to make sure it is safe to move the load.; // Assume there are stores between DefMI and UseMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:35,Safety,safe,safe,35,// We also need to make sure it is safe to move the load.; // Assume there are stores between DefMI and UseMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:8,Performance,optimiz,optimize,8,"// Only optimize rematerialize case when the instruction has one def, since; // otherwise we could leave some dead defs in the code. This case is; // extremely rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:186,Integrability,depend,depend,186,"// The original live-range may have been shrunk to; // an empty live-range. It happens when it is dead, but; // we still keep it around to be able to rematerialize; // other values that depend on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:44,Availability,down,down,44,"// OrderOld == OrderNew, we need to iterate down from Old to see if it; // can reach New, if yes, New is dominated by Old.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:3,Deployability,Update,Update,3,// Update the dominator order to be the same as the insertion point.; // We do this to maintain a non-decreasing order without need to update; // all instruction orders after the insertion point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp:135,Deployability,update,update,135,// Update the dominator order to be the same as the insertion point.; // We do this to maintain a non-decreasing order without need to update; // all instruction orders after the insertion point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeShrink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:14,Usability,clear,clear,14,"// No need to clear Queries here, since LiveIntervalUnion::Query doesn't; // have anything important to clear and LiveRegMatrix's runOnFunction(); // does a std::unique_ptr::reset anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:104,Usability,clear,clear,104,"// No need to clear Queries here, since LiveIntervalUnion::Query doesn't; // have anything important to clear and LiveRegMatrix's runOnFunction(); // does a std::unique_ptr::reset anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:16,Performance,cache,cached,16,// Check if the cached information is valid.; // The same BitVector can be reused for all PhysRegs.; // We could cache multiple VirtRegs if it becomes necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:113,Performance,cache,cache,113,// Check if the cached information is valid.; // The same BitVector can be reused for all PhysRegs.; // We could cache multiple VirtRegs if it becomes necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:15,Energy Efficiency,allocate,allocated,15,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:249,Energy Efficiency,allocate,allocated,249,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:40,Performance,cache,caches,40,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:304,Performance,cache,cached,304,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:462,Performance,cache,cached,462,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:518,Performance,cache,cache,518,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:497,Safety,avoid,avoid,497,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:610,Safety,avoid,avoid,610,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:655,Safety,Avoid,Avoiding,655,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:559,Usability,usab,usability,559,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:704,Usability,simpl,simplify,704,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp:27,Usability,simpl,simply,27,// To get the live-outs we simply merge the live-ins of all successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegUnits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp:3,Deployability,Release,Release,3,"// Release VNInfo memory regions, VNInfo objects don't need to be dtor'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveStacks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:1076,Energy Efficiency,efficient,efficiently,1076,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:33,Modifiability,Variab,Variable,33,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:817,Modifiability,variab,variables,817,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:922,Modifiability,variab,variable,922,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:1105,Modifiability,variab,variables,1105,"//===-- LiveVariables.cpp - Live Variable Analysis for Machine Code -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariable analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:65,Availability,alive,alive,65,// We already know the block is live; // Mark the variable known alive in this bb,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:50,Modifiability,variab,variable,50,// We already know the block is live; // Mark the variable known alive in this bb,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:314,Availability,alive,alive,314,"// This situation can occur:; //; // ,------.; // | |; // | v; // | t2 = phi ... t1 ...; // | |; // | v; // | t1 = ...; // | ... = ... t1 ...; // | |; // `------'; //; // where there is a use in a PHI node that's a predecessor to the defining; // block. We don't want to mark all predecessors as having the value ""alive""; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:96,Availability,alive,alive,96,"// Add a new kill entry for this basic block. If this virtual register is; // already marked as alive in this basic block, that means it is alive in at; // least one of the successor blocks, it's not a kill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:140,Availability,alive,alive,140,"// Add a new kill entry for this basic block. If this virtual register is; // already marked as alive in this basic block, that means it is alive in at; // least one of the successor blocks, it's not a kill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Deployability,Update,Update,3,"// Update all dominating blocks to mark them as ""known live"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:16,Availability,alive,alive,16,"// If vr is not alive in any block, then defaults to dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:172,Modifiability,extend,extends,172,"// Partial uses. Mark register def dead and add implicit def of; // sub-registers which are used.; // dead EAX = op implicit-def AL; // That is, EAX def is dead but AL def extends pass it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:64,Availability,Mask,Mask,64,"// Call HandlePhysRegKill() for all live registers clobbered by Mask.; // Clobbered registers are always dead, sp there is no need to use; // HandlePhysRegDef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:8,Availability,mask,mask-preserved,8,// Skip mask-preserved regs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:55,Safety,avoid,avoids,55,// Kill the largest clobbered super-register.; // This avoids needless implicit operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Usability,Clear,Clear,3,// Clear kill and dead markers. LV will recompute them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:15,Availability,mask,masked,15,// Process all masked registers. (Call clobbers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:11,Availability,alive,alive,11,// Mark it alive only in the block we are representing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:73,Availability,avail,available,73,"// Loop over PhysRegDef / PhysRegUse, killing any registers that are; // available at the end of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:32,Deployability,update,updated,32,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:54,Integrability,depend,dependence,54,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:145,Integrability,depend,dependencies,145,"// FIXME: LiveIntervals will be updated to remove its dependence on; // LiveVariables to improve compilation time and eliminate bizarre pass; // dependencies. Until then, we can't change much in -O0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:18,Modifiability,variab,variable,18,"// Calculate live variable information in depth first order on the CFG of the; // function. This guarantees that we will see the definition of a virtual; // register before its uses due to dominance properties of SSA (except for PHI; // nodes, which are treated as a special case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:46,Availability,Alive,AliveBlocks,46,// Iterate over the worklist adding blocks to AliveBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:29,Deployability,Update,Update,29,/// replaceKillInstruction - Update register kill info by replacing a kill; /// instruction with a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:109,Modifiability,variab,variable,109,"/// analyzePHINodes - Gather information about the PHI nodes in here. In; /// particular, we want to map the variable information of a virtual register; /// which is used in a PHI node. We map that to the BB the vreg is coming from.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:9,Availability,alive,alive,9,// Is it alive in this successor?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:85,Modifiability,variab,variables,85,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:3,Deployability,Update,Update,3,// Update info for all live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:28,Modifiability,variab,variables,28,// Update info for all live variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:194,Deployability,update,updated,194,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB. LiveInSets[BB] is *not* updated (because it is not needed during; /// PHIElimination).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:85,Modifiability,variab,variables,85,/// addNewBlock - Add a new basic block BB as an empty succcessor to DomBB. All; /// variables that are live out of DomBB will be marked as passing live through; /// BB. LiveInSets[BB] is *not* updated (because it is not needed during; /// PHIElimination).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:118,Integrability,depend,dependent,118,// FIXME: Having an MCSubtargetInfo on the target machine is a hack due; // to some backends having subtarget feature dependent module level; // code generation. This is similar to the hack in the AsmPrinter for; // module level assembly etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:202,Availability,error,error,202,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:208,Integrability,message,message,208,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:38,Deployability,integrat,integratedAS,38,"// If there is explict option disable integratedAS, we can't use it for; // inlineasm either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:38,Integrability,integrat,integratedAS,38,"// If there is explict option disable integratedAS, we can't use it for; // inlineasm either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:43,Performance,perform,performance,43,"// The Null output is intended for use for performance analysis and testing,; // not real users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:68,Testability,test,testing,68,"// The Null output is intended for use for performance analysis and testing,; // not real users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,Availability,redundant,redundant,19,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,Safety,redund,redundant,19,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:26,Performance,load,load,26,"// libunwind is unable to load compact unwind dynamically, so we must generate; // DWARF unwind info for the JIT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:42,Energy Efficiency,allocate,allocate,42,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:468,Energy Efficiency,allocate,allocates,468,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:507,Security,access,access,507,"//===- LocalStackSlotAllocation.cpp - Pre-allocate locals to stack slots --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass assigns local frame indices to stack slots relative to one another; // and allocates additional base registers to access them when the target; // estimates they are likely to be out of range of stack pointer and frame; // pointer relative addressing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:44,Energy Efficiency,allocate,allocated,44,"// Tell MFI whether any base registers were allocated. PEI will only; // want to use the local block allocations from this pass if there were any.; // Otherwise, PEI can do a bit better job of getting the alignment right; // without a hole at the start since it knows the alignment of the stack; // at the start of local allocation, and this pass doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:19,Availability,avail,available,19,// Keep the offset available for base register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:61,Modifiability,variab,variables,61,// Make sure that the stack protector comes before the local variables on the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:38,Energy Efficiency,allocate,allocate,38,"// We need to make sure we didn't pre-allocate the stack protector when; // doing this.; // If we already have a stack protector, this will re-assign it to a slot; // that is **not** covering the protected objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:295,Energy Efficiency,allocate,allocated,295,"// Scan the function's instructions looking for frame index references.; // For each, ask the target if it wants a virtual base register for it; // based on what we can tell it about where the local will end up in the; // stack frame. If it wants one, re-use a suitable one we've previously; // allocated, or if there isn't one that fits the bill, allocate a new one; // and ask the target to create a defining instruction for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:348,Energy Efficiency,allocate,allocate,348,"// Scan the function's instructions looking for frame index references.; // For each, ask the target if it wants a virtual base register for it; // based on what we can tell it about where the local will end up in the; // stack frame. If it wants one, re-use a suitable one we've previously; // allocated, or if there isn't one that fits the bill, allocate a new one; // and ask the target to create a defining instruction for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:29,Deployability,patch,patchpoint,29,"// Debug value, stackmap and patchpoint instructions can't be out of; // range, so they don't need any updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:103,Deployability,update,updates,103,"// Debug value, stackmap and patchpoint instructions can't be out of; // range, so they don't need any updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:12,Energy Efficiency,allocate,allocate,12,"// For now, allocate the base register(s) within the basic block; // where they're used, and don't try to keep them around outside; // of that. It may be beneficial to try sharing them more broadly; // than that, but the increased register pressure makes that a; // tricky thing to balance. Investigate if re-materializing these; // becomes an issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:76,Energy Efficiency,allocate,allocated,76,// Consider replacing all frame index operands that reference; // an object allocated in the local block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:41,Energy Efficiency,allocate,allocate,41,// Loop through the frame references and allocate for them as necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:159,Safety,avoid,avoids,159,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:166,Security,access,accesses,166,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:39,Availability,avail,available,39,"// If we have a suitable base register available, use it; otherwise; // create a new one. Note that any offset encoded in the; // instruction itself will be taken into account by the target,; // so we don't have to adjust for it here when reusing a base; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:16,Safety,avoid,avoid,16,"// We'd like to avoid creating single-use virtual base registers.; // Because the FrameRefs are in sorted order, and we've already; // processed all FrameRefs before this one, just check whether or not; // the next FrameRef will be able to reuse this new register. If not,; // then don't bother creating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp:61,Deployability,update,updated,61,// N.B: IncomingProcessed and IncomingCompleted were already updated while; // processing this block's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp:9,Deployability,update,update,9,// Don't update successors here. We'll get to them anyway through this; // loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LoopTraversal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:427,Integrability,depend,depending,427,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:45,Modifiability,variab,variables,45,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:487,Modifiability,variab,variables,487,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:520,Modifiability,variab,variable,520,"//===- LowerEmuTLS.cpp - Add __emutls_[vt].* variables --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is required for targets depending on libgcc style; // emulated thread local storage variables. For every defined TLS variable xyz,; // an __emutls_v.xyz is generated. If there is non-zero initialized value; // an __emutls_t.xyz is also generated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:112,Energy Efficiency,allocate,allocated,112,"// When GV's init value is all 0, omit the EmuTlsTmplVar and let; // the emutls library function to reset newly allocated TLS variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp:126,Modifiability,variab,variables,126,"// When GV's init value is all 0, omit the EmuTlsTmplVar and let; // the emutls library function to reset newly allocated TLS variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowerEmuTLS.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp:463,Safety,avoid,avoid,463,"//===-- llvm/CodeGen/LowLevelType.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the more header-heavy bits of the LLT class to; /// avoid polluting users' namespaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp:463,Safety,avoid,avoid,463,"//===-- llvm/CodeGen/LowLevelTypeUtils.cpp --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file implements the more header-heavy bits of the LLT class to; /// avoid polluting users' namespaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LowLevelTypeUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:289,Availability,avail,available,289,"/// When an MBB is added to an MF, we need to update the parent pointer of the; /// MBB, the MBB numbering, and any instructions in the MBB to be on the right; /// operand list for registers.; ///; /// MBBs start out as #-1. When a MBB is added to a MachineFunction, it; /// gets the next available unique MBB number. If it is removed from a; /// MachineFunction, it goes back to being #-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:46,Deployability,update,update,46,"/// When an MBB is added to an MF, we need to update the parent pointer of the; /// MBB, the MBB numbering, and any instructions in the MBB to be on the right; /// operand list for registers.; ///; /// MBBs start out as #-1. When a MBB is added to a MachineFunction, it; /// gets the next available unique MBB number. If it is removed from a; /// MachineFunction, it goes back to being #-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:57,Deployability,update,update,57,"/// When we add an instruction to a basic block list, we update its parent; /// pointer and add its operands from reg use/def lists if appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:62,Deployability,update,update,62,"/// When we remove an instruction from a basic block list, we update its parent; /// pointer and remove its operands from reg use/def lists if appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:86,Deployability,update,update,86,"/// When moving a range of instructions from one MBB list to another, we need to; /// update the parent pointers and the use/def lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:65,Deployability,update,update,65,"// If splicing between two blocks within the same function, just update the; // parent pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:109,Modifiability,rewrite,rewrite,109,"// The block has a non-fallthrough conditional branch. If one of its; // successors is its layout successor, rewrite it to a fallthrough; // conditional branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:92,Performance,optimiz,optimization,92,"// Probability list is either empty (if successor list isn't empty, this means; // disabled optimization) or has the same size as successor list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:138,Safety,safe,safely,138,"// We need to make sure probability list is either empty or has the same size; // of successor list. When this function is called, we can safely delete all; // probability in the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:71,Performance,optimiz,optimization,71,// If probability list is empty it means we don't use it (disabled; // optimization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:35,Deployability,Update,Update,35,// New is already a successor.; // Update its probability instead of adding a duplicate edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:71,Performance,optimiz,optimization,71,// If probability list is empty it means we don't use it (disabled; // optimization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:66,Deployability,update,update,66,// This is called before MI is inserted into block so defer index update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:112,Deployability,update,updated,112,"// On some targets like Mips, branches may kill virtual registers. Make sure; // that LiveVariables is properly updated after updateTerminator replaces the; // terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:126,Deployability,update,updateTerminator,126,"// On some targets like Mips, branches may kill virtual registers. Make sure; // that LiveVariables is properly updated after updateTerminator replaces the; // terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit live-ins from the successor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update LiveVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update relevant live-through information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:106,Integrability,depend,depending,106,"// After splitting the edge and updating SlotIndexes, live intervals may be; // in one of two situations, depending on whether this block was the last in; // the function. If the original block was the last in the function, all; // live intervals will end prior to the beginning of the new split block. If; // the original block was not at the end of the function, all live intervals; // will extend to the end of the new split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:393,Modifiability,extend,extend,393,"// After splitting the edge and updating SlotIndexes, live intervals may be; // in one of two situations, depending on whether this block was the last in; // the function. If the original block was the last in the function, all; // live intervals will end prior to the beginning of the new split block. If; // the original block was not at the end of the function, all live intervals; // will extend to the end of the new split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update subranges with live values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update all intervals for registers whose uses may have been modified by; // updateTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:79,Deployability,update,updateTerminator,79,// Update all intervals for registers whose uses may have been modified by; // updateTerminator().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:74,Availability,mask,mask,74,// Performance might be harmed on HW that implements branching using exec mask; // where both sides of the branches are always executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Performance,Perform,Performance,3,// Performance might be harmed on HW that implements branching using exec mask; // where both sides of the branches are always executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:60,Modifiability,rewrite,rewrite,60,// Do we have an Indirect jump with a jumptable that we can rewrite?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:18,Deployability,update,update,18,"// We may need to update this's terminator, but we can't do that if; // analyzeBranch fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:221,Performance,optimiz,optimized,221,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Safety,Avoid,Avoid,3,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Deployability,Update,Update,3,// Update the successor information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:32,Safety,safe,safe,32,"// If we reached the end, it is safe to clobber Reg at the end of a block of; // no successor has it live in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:202,Availability,mask,mask,202,"// If we see a return block with successors, this must be a funclet return,; // which does not preserve any registers. If there are no successors, we don't; // care what kind of return it is, putting a mask after it is a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp:399,Usability,simpl,simplified,399,"//===- MachineBlockFrequencyInfo.cpp - MBB Frequency Analysis -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1222,Energy Efficiency,schedul,schedules,1222,"//===- MachineBlockPlacement.cpp - Basic Block Code Layout optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements basic block placement transformations using the CFG; // structure and branch probability estimates.; //; // The pass strives to preserve the structure of the CFG (that is, retain; // a topological ordering of basic blocks) in the absence of a *strong* signal; // to the contrary from probabilities. However, within the CFG structure, it; // attempts to choose an ordering which favors placing more likely sequences of; // blocks adjacent to each other.; //; // The algorithm works from the inner-most loop within a function outward, and; // at each stage walks through the basic blocks, trying to coalesce them into; // sequential chains where allowed by the CFG (or demanded by heavy; // probabilities). Finally, it walks the blocks in topological order, and the; // first time it reaches a chain of basic blocks, it schedules them in the; // function in-order.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:59,Performance,optimiz,optimization,59,"//===- MachineBlockPlacement.cpp - Basic Block Code Layout optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements basic block placement transformations using the CFG; // structure and branch probability estimates.; //; // The pass strives to preserve the structure of the CFG (that is, retain; // a topological ordering of basic blocks) in the absence of a *strong* signal; // to the contrary from probabilities. However, within the CFG structure, it; // attempts to choose an ordering which favors placing more likely sequences of; // blocks adjacent to each other.; //; // The algorithm works from the inner-most loop within a function outward, and; // at each stage walks through the basic blocks, trying to coalesce them into; // sequential chains where allowed by the CFG (or demanded by heavy; // probabilities). Finally, it walks the blocks in topological order, and the; // first time it reaches a chain of basic blocks, it schedules them in the; // function in-order.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:557,Deployability,update,updated,557,"/// A chain of blocks which will be laid out contiguously.; ///; /// This is the datastructure representing a chain of consecutive blocks that; /// are profitable to layout together in order to maximize fallthrough; /// probabilities and code locality. We also can use a block chain to represent; /// a sequence of basic blocks which have some external (correctness); /// requirement for sequential layout.; ///; /// Chains can be built around a single basic block and can be merged to grow; /// them. They participate in a block-to-chain mapping, which is updated; /// automatically as chains are merged together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:120,Usability,simpl,simplify,120,"/// A handle to the function-wide basic block to block chain mapping.; ///; /// This is retained in each block chain to simplify the computation of child; /// block chains for SCC-formation and iteration. We store the edges to child; /// basic blocks, and map them back to their associated chains using this; /// structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:262,Availability,down,down,262,"/// Merge a block chain into this one.; ///; /// This routine merges a block chain into this one. It takes care of forming; /// a contiguous sequence of basic blocks, updating the edge list, and; /// updating the block -> chain mapping. It does not free or tear down the; /// old chain, but the old chain's block list is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:54,Integrability,rout,routine,54,"/// Merge a block chain into this one.; ///; /// This routine merges a block chain into this one. It takes care of forming; /// a contiguous sequence of basic blocks, updating the edge list, and; /// updating the block -> chain mapping. It does not free or tear down the; /// old chain, but the old chain's block list is no longer valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,"// Update the incoming blocks to point to this chain, and add them to the; // chain structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:96,Energy Efficiency,schedul,scheduled,96,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:133,Energy Efficiency,schedul,scheduling,133,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:189,Energy Efficiency,schedul,scheduled,189,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:390,Energy Efficiency,schedul,scheduled,390,"// NDEBUG; /// Count of predecessors of any block within the chain which have not; /// yet been scheduled. In general, we will delay scheduling this chain; /// until those predecessors are scheduled (or we find a sufficiently good; /// reason to override this heuristic.) Note that when forming loop chains,; /// blocks outside the loop are ignored and treated as if they were already; /// scheduled.; ///; /// Note: This field is reinitialized multiple times - once for each loop,; /// and then once for the function as a whole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:37,Modifiability,variab,variable,37,/// Preferred loop exit.; /// Member variable for convenience. It may be removed by duplication deep; /// in the call stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:147,Energy Efficiency,reduce,reduce,147,"/// Allocator and owner of BlockChain structures.; ///; /// We build BlockChains lazily while processing the loop structure of; /// a function. To reduce malloc traffic, we allocate them using this; /// slab-like allocator, and destroy them after the pass completes. An; /// important guarantee is that this allocator produces stable pointers to; /// the chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:173,Energy Efficiency,allocate,allocate,173,"/// Allocator and owner of BlockChain structures.; ///; /// We build BlockChains lazily while processing the loop structure of; /// a function. To reduce malloc traffic, we allocate them using this; /// slab-like allocator, and destroy them after the pass completes. An; /// important guarantee is that this allocator produces stable pointers to; /// the chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:82,Energy Efficiency,efficient,efficiently,82,"/// Function wide BasicBlock to BlockChain mapping.; ///; /// This mapping allows efficiently moving from any given basic block to the; /// BlockChain it participates in, if any. We use it to, among other things,; /// allow implicitly defining edges between chains as the existing edges; /// between basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:126,Safety,safe,safely,126,"/// The set of basic blocks that have terminators that cannot be fully; /// analyzed. These basic blocks cannot be re-ordered safely by; /// MachineBlockPlacement, and we must preserve physical layout of these; /// blocks and their successors through the pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:33,Performance,optimiz,optimizing,33,/// Apply a post-processing step optimizing block placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:68,Testability,log,logging,68,/// Helper to print the name of a MBB.; ///; /// Only used by debug logging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:126,Integrability,rout,routine,126,"/// Mark a chain's successors as having one fewer preds.; ///; /// When a chain is being merged into the ""placed"" chain, this routine will; /// quickly walk the successors of each block in the chain and mark them as; /// having one fewer active predecessor. It also adds any successors of this; /// chain which reach the zero-predecessor state to the appropriate worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:266,Usability,simpl,simplicity,266,"/// Compare 2 BlockFrequency's with a small penalty for \p A.; /// In order to be conservative, we apply a X% penalty to account for; /// increased icache pressure and static heuristics. For small frequencies; /// we use only the numerators to improve accuracy. For simplicity, we assume the; /// penalty is less than 100%; /// TODO(iteratee): Use 64-bit fixed point edge frequencies everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:6,Safety,avoid,avoid,6,// To avoid reviewing the same predecessors twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Performance,Perform,Perform,3,// Perform the successor check only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:185,Usability,Simpl,Simple,185,"/// Pick the highest total weight pair of edges that can both be laid out.; /// The edges in \p Edges[0] are assumed to have a different destination than; /// the edges in \p Edges[1]. Simple counting shows that the best pair is either; /// the individual highest weight edges to the 2 different destinations, or in; /// case of a conflict, one of them should be replaced with a 2nd best edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:156,Usability,clear,clearly,156,"// Sort the edges, and then for each successor, find the best incoming; // predecessor. If the best incoming predecessors aren't the same,; // then that is clearly the best layout. If there is a conflict, one of the; // successors will have to fallthrough from the second best predecessor. We; // compare which combination is better overall.; // Sort for highest frequency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1070,Modifiability,extend,extend,1070,"// This will result in a trellis after tail duplication, so we don't; // need to copy Succ into this predecessor. In the presence; // of a trellis tail duplication can continue to be profitable.; // For example:; // A A; // |\ |\; // | \ | \; // | C | C+BB; // | / | |; // |/ | |; // BB => BB |; // |\ |\/|; // | \ |/\|; // | D | D; // | / | /; // |/ |/; // Succ Succ; //; // After BB was duplicated into C, the layout looks like the one on the; // right. BB and C now have the same successors. When considering; // whether Succ can be duplicated into all its unplaced predecessors, we; // ignore C.; // We can do this because C already has a profitable fallthrough, namely; // D. TODO(iteratee): ignore sufficiently cold predecessors for; // duplication and for this test.; //; // This allows trellises to be laid out in 2 separate chains; // (A,B,Succ,...) and later (C,D,...) This is a reasonable heuristic; // because it allows the creation of 2 fallthrough paths with links; // between them, and we correctly identify the best layout for these; // CFGs. We want to extend trellises that the user created in addition; // to trellises created by tail-duplication, so we just look for the; // CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:768,Testability,test,test,768,"// This will result in a trellis after tail duplication, so we don't; // need to copy Succ into this predecessor. In the presence; // of a trellis tail duplication can continue to be profitable.; // For example:; // A A; // |\ |\; // | \ | \; // | C | C+BB; // | / | |; // |/ | |; // BB => BB |; // |\ |\/|; // | \ |/\|; // | D | D; // | / | /; // |/ |/; // Succ Succ; //; // After BB was duplicated into C, the layout looks like the one on the; // right. BB and C now have the same successors. When considering; // whether Succ can be duplicated into all its unplaced predecessors, we; // ignore C.; // We can do this because C already has a profitable fallthrough, namely; // D. TODO(iteratee): ignore sufficiently cold predecessors for; // duplication and for this test.; //; // This allows trellises to be laid out in 2 separate chains; // (A,B,Succ,...) and later (C,D,...) This is a reasonable heuristic; // because it allows the creation of 2 fallthrough paths with links; // between them, and we correctly identify the best layout for these; // CFGs. We want to extend trellises that the user created in addition; // to trellises created by tail-duplication, so we just look for the; // CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:29,Availability,avail,available,29,"// If profile information is available, findDuplicateCandidates can do more; // precise benefit analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Deployability,integrat,integrated,48,// This is mainly for function exit BB.; // The integrated tail duplication is really designed for increasing; // fallthrough from predecessors from Succ to its successors. We may need; // other machanism to handle different cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Integrability,integrat,integrated,48,// This is mainly for function exit BB.; // The integrated tail duplication is really designed for increasing; // fallthrough from predecessors from Succ to its successors. We may need; // other machanism to handle different cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:72,Modifiability,extend,extend,72,// Map from last block to the chain that contains it. This allows us to extend; // chains as we find new triangles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:32,Safety,safe,safe,32,"// Iterating over a DenseMap is safe here, because the only thing in the body; // of the loop is inserting into another DenseMap (ComputedEdges).; // ComputedEdges is never iterated, so this doesn't lead to non-determinism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Testability,Benchmark,Benchmarking,3,"// Benchmarking has shown that due to branch correlation duplicating 2 or; // more triangles is profitable, despite the calculations assuming; // independence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:81,Availability,avail,available,81,"// When profile is not present, return the StaticLikelyProb.; // When profile is available, we need to handle the triangle-shape CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:216,Testability,log,logging,216,"/// Checks to see if the layout candidate block \p Succ has a better layout; /// predecessor than \c BB. If yes, returns true.; /// \p SuccProb: The probability adjusted for only remaining blocks.; /// Only used for logging; /// \p RealSuccProb: The un-adjusted probability.; /// \p Chain: The chain that BB belongs to and Succ is being considered for.; /// \p BlockFilter: if non-null, the set of blocks that make up the loop being; /// considered",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1131,Availability,avail,available,1131," | Pred; // | /; // Succ; // In this case, we are evaluating whether to select edge -> Succ, e.g.; // set Succ as the layout successor of BB. Picking Succ as BB's; // successor breaks the CFG constraints (FIXME: define these constraints).; // With this layout, Pred BB; // is forced to be outlined, so the overall cost will be cost of the; // branch taken from BB to Pred, plus the cost of back taken branch; // from Pred to Succ, as well as the additional cost associated; // with the needed unconditional jump instruction from Pred To Succ.; // The cost of the topological order layout is the taken branch cost; // from BB to Succ, so to make BB->Succ a viable candidate, the following; // must hold:; // 2 * freq(BB->Pred) * taken_branch_cost + unconditional_jump_cost; // < freq(BB->Succ) * taken_branch_cost.; // Ignoring unconditional jump cost, we get; // freq(BB->Succ) > 2 * freq(BB->Pred), i.e.,; // prob(BB->Succ) > 2 * prob(BB->Pred); //; // When real profile data is available, we can precisely compute the; // probability threshold that is needed for edge BB->Succ to be considered.; // Without profile data, the heuristic requires the branch bias to be; // a lot larger to make sure the signal is very strong (e.g. 80% default).; // -----------------------------------------------------------------; // Case 2: diamond like CFG (if-then-else):; // S; // / \; // | \; // BB Pred; // \ /; // Succ; // ..; //; // The current block is BB and edge BB->Succ is now being evaluated.; // Note that edge S->BB was previously already selected because; // prob(S->BB) > prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:2614,Availability,avail,available,2614,"ing evaluated.; // Note that edge S->BB was previously already selected because; // prob(S->BB) > prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq(BB->Succ) cost = 2 * freq (S->Pred); // = freq(S->Pred) + freq(S->BB); //; // If we have profile data (i.e, branch probabilities can be trusted), the; // cost (number of taken branches) with layout S->BB->Succ->Pred is 2 *; // freq(S->Pred) while the cost of topo order is freq(S->Pred) + freq(S->BB).; // We know Prob(S->BB) > Prob(S->Pred), so freq(S->BB) > freq(S->Pred), which; // means the cost of topological order is greater.; // When profile data is not available, however, we need to be more; // conservative. If the branch prediction is wrong, breaking the topo-order; // will actually yield a layout with large cost. For this reason, we need; // strong biased branch at block S with Prob(S->BB) in order to select; // BB->Succ. This is equivalent to looking the CFG backward with backward; // edge: Prob(Succ->BB) needs to >= HotProb in order to be selected (without; // profile data).; // --------------------------------------------------------------------------; // Case 3: forked diamond; // S; // / \; // / \; // BB Pred; // | \ / |; // | \ / |; // | X |; // | / \ |; // | / \ |; // S1 S2; //; // The current block is BB and edge BB->S1 is now being evaluated.; // As above S->BB was already selected because; // prob(S->BB) > prob(S->Pred). Assume that prob(BB->S1) >= prob(BB->S2).; //; // topo-order:; //; // S-------| ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred----| | S1----; // | | | |; // --(S1 or S2) ---Pred--; // |; // S2; //; // topo-c",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:2685,Safety,predict,prediction,2685," prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq(BB->Succ) cost = 2 * freq (S->Pred); // = freq(S->Pred) + freq(S->BB); //; // If we have profile data (i.e, branch probabilities can be trusted), the; // cost (number of taken branches) with layout S->BB->Succ->Pred is 2 *; // freq(S->Pred) while the cost of topo order is freq(S->Pred) + freq(S->BB).; // We know Prob(S->BB) > Prob(S->Pred), so freq(S->BB) > freq(S->Pred), which; // means the cost of topological order is greater.; // When profile data is not available, however, we need to be more; // conservative. If the branch prediction is wrong, breaking the topo-order; // will actually yield a layout with large cost. For this reason, we need; // strong biased branch at block S with Prob(S->BB) in order to select; // BB->Succ. This is equivalent to looking the CFG backward with backward; // edge: Prob(Succ->BB) needs to >= HotProb in order to be selected (without; // profile data).; // --------------------------------------------------------------------------; // Case 3: forked diamond; // S; // / \; // / \; // BB Pred; // | \ / |; // | \ / |; // | X |; // | / \ |; // | / \ |; // S1 S2; //; // The current block is BB and edge BB->S1 is now being evaluated.; // As above S->BB was already selected because; // prob(S->BB) > prob(S->Pred). Assume that prob(BB->S1) >= prob(BB->S2).; //; // topo-order:; //; // S-------| ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred----| | S1----; // | | | |; // --(S1 or S2) ---Pred--; // |; // S2; //; // topo-cost = freq(S->Pred) + freq(BB->S1) + freq(BB->S2); // + min(freq(Pred->S1), freq(Pred->S2)); // No",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,Availability,redundant,redundant,17,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,Safety,redund,redundant,17,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:444,Energy Efficiency,reduce,reduces,444,"// Do backward checking.; // For all cases above, we need a backward checking to filter out edges that; // are not 'strongly' biased.; // BB Pred; // \ /; // Succ; // We select edge BB->Succ if; // freq(BB->Succ) > freq(Succ) * HotProb; // i.e. freq(BB->Succ) > freq(BB->Succ) * HotProb + freq(Pred->Succ) *; // HotProb; // i.e. freq((BB->Succ) * (1 - HotProb) > freq(Pred->Succ) * HotProb; // Case 1 is covered too, because the first equation reduces to:; // prob(BB->Succ) > HotProb. (freq(Succ) = freq(BB) for a triangle)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:273,Safety,avoid,avoid,273,"/// Select the best successor for a block.; ///; /// This looks across all successors of a particular block and attempts to; /// select the ""best"" one to be the layout successor. It only considers direct; /// successors which also pass the block filter. It will attempt to avoid; /// breaking CFG structure, but cave and break such structures in the case of; /// very hot successor edges.; ///; /// \returns The best successor block found, or null if none are viable, along; /// with a boolean indicating if tail duplication is necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:130,Performance,perform,perform,130,"// For blocks with CFG violations, we may be able to lay them out anyway with; // tail-duplication. We keep this vector so we can perform the probability; // calculations the minimum number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:472,Performance,cache,cache,472,"/// Select the best block from a worklist.; ///; /// This looks through the provided worklist as a list of candidate basic; /// blocks and select the most profitable one to place. The definition of; /// profitable only really makes sense in the context of a loop. This returns; /// the most frequently visited block in the worklist, which in the case of; /// a loop, is the one most desirable to be physically close to the rest of the; /// loop body in order to improve i-cache behavior.; ///; /// \returns The best block found, or null if none are viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:55,Safety,avoid,avoid,55,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:427,Usability,Resume,Resume,427,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:542,Usability,Resume,Resume,542,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:309,Deployability,update,update,309,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:60,Integrability,rout,routine,60,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:415,Integrability,rout,routine,415,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:346,Safety,avoid,avoid,346,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:35,Availability,avail,available,35,"// If an immediate successor isn't available, look for the best viable; // block among those we've identified as not violating the loop's CFG at; // this point. This won't be a fallthrough, but it will increase locality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:365,Energy Efficiency,reduce,reduce,365,"// If bottom of block BB has only one successor OldTop, in most cases it is; // profitable to move it before OldTop, except the following case:; //; // -->OldTop<-; // | . |; // | . |; // | . |; // ---Pred |; // | |; // BB-----; //; // If BB is moved before OldTop, Pred needs a taken branch to BB, and it can't; // layout the other successor below it, so it can't reduce taken branch.; // In this case we keep its original layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:120,Energy Efficiency,reduce,reduced,120,"// Compute the fall through gains when move NewTop before OldTop.; //; // In following diagram, edges marked as ""-"" are reduced fallthrough, edges; // marked as ""+"" are increased fallthrough, this function computes; //; // SUM(increased fallthrough) - SUM(decreased fallthrough); //; // |; // | -; // V; // --->OldTop; // | .; // | .; // +| . +; // | Pred --->; // | |-; // | V; // --- NewTop <---; // |-; // V; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:905,Energy Efficiency,reduce,reduce,905,"/// Helper function of findBestLoopTop. Find the best loop top block; /// from predecessors of old top.; ///; /// Look for a block which is strictly better than the old top for laying; /// out before the old top of the loop. This looks for only two patterns:; ///; /// 1. a block has only one successor, the old loop top; ///; /// Because such a block will always result in an unconditional jump,; /// rotating it in front of the old top is always profitable.; ///; /// 2. a block has two successors, one is old top, another is exit; /// and it has more than one predecessors; ///; /// If it is below one of its predecessors P, only P can fall through to; /// it, all other predecessors need a jump to it, and another conditional; /// jump to loop header. If it is moved before loop header, all its; /// predecessors jump to it, then fall through to loop header. So all its; /// predecessors except P can reduce one taken branch.; /// At the same time, move it before old top increases the taken branch; /// to loop exit block, so the reduced taken branch will be compared with; /// the increased taken branch to the loop exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:1035,Energy Efficiency,reduce,reduced,1035,"/// Helper function of findBestLoopTop. Find the best loop top block; /// from predecessors of old top.; ///; /// Look for a block which is strictly better than the old top for laying; /// out before the old top of the loop. This looks for only two patterns:; ///; /// 1. a block has only one successor, the old loop top; ///; /// Because such a block will always result in an unconditional jump,; /// rotating it in front of the old top is always profitable.; ///; /// 2. a block has two successors, one is old top, another is exit; /// and it has more than one predecessors; ///; /// If it is below one of its predecessors P, only P can fall through to; /// it, all other predecessors need a jump to it, and another conditional; /// jump to loop header. If it is moved before loop header, all its; /// predecessors jump to it, then fall through to loop header. So all its; /// predecessors except P can reduce one taken branch.; /// At the same time, move it before old top increases the taken branch; /// to loop exit block, so the reduced taken branch will be compared with; /// the increased taken branch to the loop exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:159,Safety,avoid,avoid,159,"// Placing the latch block before the header may introduce an extra branch; // that skips this block the first time the loop is executed, which we want; // to avoid when optimising for size.; // FIXME: in theory there is a case that does not introduce a new branch,; // i.e. when the layout predecessor does not fallthrough to the loop header.; // In practice this never happens though: there always seems to be a preheader; // that can fallthrough and that is also placed before the header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:64,Integrability,rout,routine,64,/// Find the best loop exiting block for layout.; ///; /// This routine implements the logic to analyze the loop looking for the best; /// block to layout at the top of the loop. Typically this is done to maximize; /// fallthrough opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:87,Testability,log,logic,87,/// Find the best loop exiting block for layout.; ///; /// This routine implements the logic to analyze the loop looking for the best; /// block to layout at the top of the loop. Typically this is done to maximize; /// fallthrough opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:567,Safety,safe,safe,567,"// We don't want to layout the loop linearly in all cases. If the loop header; // is just a normal basic block in the loop, we want to look for what block; // within the loop is the best one to layout at the top. However, if the loop; // header has be pre-merged into a chain due to predecessors not having; // analyzable branches, *and* the predecessor it is merged with is *not* part; // of the loop, rotating the header into the middle of the loop will create; // a non-contiguous range of blocks which is Very Bad. So start with the; // header and only rotate if safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:681,Safety,avoid,avoid,681,"// Rotating a loop exit to the bottom when there is a fallthrough to top; // trades the entry fallthrough for an exit fallthrough.; // If there is no bottom->top edge, but the chosen exit block does have; // a fallthrough, we break that fallthrough for nothing in return.; // Let's consider an example. We have a built chain of basic blocks; // B1, B2, ..., Bn, where Bk is a ExitingBB - chosen exit block.; // By doing a rotation we get; // Bk+1, ..., Bn, B1, ..., Bk; // Break of fallthrough to B1 is compensated by a fallthrough from Bk.; // If we had a fallthrough Bk -> Bk+1 it is broken now.; // It might be compensated by fallthrough Bn -> B1.; // So we have a condition to avoid creation of extra branch by loop rotation.; // All below must be true to avoid loop rotation:; // If there is a fallthrough to top (B1); // There was fallthrough from chosen exit block (Bk) to next one (Bk+1); // There is no fallthrough from bottom (Bn) to top (B1).; // Please note that there is no exit fallthrough from Bn because we checked it; // above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:760,Safety,avoid,avoid,760,"// Rotating a loop exit to the bottom when there is a fallthrough to top; // trades the entry fallthrough for an exit fallthrough.; // If there is no bottom->top edge, but the chosen exit block does have; // a fallthrough, we break that fallthrough for nothing in return.; // Let's consider an example. We have a built chain of basic blocks; // B1, B2, ..., Bn, where Bk is a ExitingBB - chosen exit block.; // By doing a rotation we get; // Bk+1, ..., Bn, B1, ..., Bk; // Break of fallthrough to B1 is compensated by a fallthrough from Bk.; // If we had a fallthrough Bk -> Bk+1 it is broken now.; // It might be compensated by fallthrough Bn -> B1.; // So we have a condition to avoid creation of extra branch by loop rotation.; // All below must be true to avoid loop rotation:; // If there is a fallthrough to top (B1); // There was fallthrough from chosen exit block (Bk) to next one (Bk+1); // There is no fallthrough from bottom (Bn) to top (B1).; // Please note that there is no exit fallthrough from Bn because we checked it; // above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:54,Energy Efficiency,reduce,reduce,54,"/// Attempt to rotate a loop based on profile data to reduce branch cost.; ///; /// With profile data, we can determine the cost in terms of missed fall through; /// opportunities when rotating a loop chain and select the best rotation.; /// Basically, there are three kinds of cost to consider for each rotation:; /// 1. The possibly missed fall through edge (if it exists) from BB out of; /// the loop to the loop header.; /// 2. The possibly missed fall through edges (if they exist) from the loop; /// exits to BB out of the loop.; /// 3. The missed fall through edge (if it exists) from the last BB to the; /// first BB in the loop chain.; /// Therefore, the cost for a given rotation is the sum of costs listed above.; /// We select the best rotation with the smallest cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:91,Availability,avail,available,91,"/// Collect blocks in the given loop that are to be placed.; ///; /// When profile data is available, exclude cold blocks from the returned set;; /// otherwise, collect all blocks in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:65,Availability,avail,available,65,"// Filter cold blocks off from LoopBlockSet when profile data is available.; // Collect the sum of frequencies of incoming edges to the loop header from; // outside. If we treat the loop as a super block, this is the frequency of; // the loop. Then for each block in the loop, we calculate the ratio between; // its frequency and the frequency of the loop block. When it is too small,; // don't add it to the loop chain. If there are outer loops, then this block; // will be merged into the first outer loop chain for which this block is not; // cold anymore. This needs precise profile data and we only do this when; // profile data is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:637,Availability,avail,available,637,"// Filter cold blocks off from LoopBlockSet when profile data is available.; // Collect the sum of frequencies of incoming edges to the loop header from; // outside. If we treat the loop as a super block, this is the frequency of; // the loop. Then for each block in the loop, we calculate the ratio between; // its frequency and the frequency of the loop block. When it is too small,; // don't add it to the loop chain. If there are outer loops, then this block; // will be merged into the first outer loop chain for which this block is not; // cold anymore. This needs precise profile data and we only do this when; // profile data is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:268,Usability,clear,clear,268,"// If we selected just the header for the loop top, look for a potentially; // profitable exit block in the event that rotating the loop can eliminate; // branches by placing an exit edge at the bottom.; //; // Loops are processed innermost to uttermost, make sure we clear; // PreferredLoopExit before processing a new loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:67,Usability,simpl,simplify,67,// Ensure that every BB in the function has an associated chain to simplify; // the assumptions of the remaining algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:48,Deployability,update,update,48,"// Remember original layout ordering, so we can update terminators after; // reordering to point to the original layout successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update the terminator of the previous block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:33,Deployability,update,updateTerminator,33,// FIXME: It would be awesome of updateTerminator would just return rather; // than assert when the branch cannot be analyzed in order to remove this; // boiler plate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:84,Testability,assert,assert,84,// FIXME: It would be awesome of updateTerminator would just return rather; // than assert when the branch cannot be analyzed in order to remove this; // boiler plate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Deployability,update,updated,27,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:706,Deployability,update,updateTerminator,706,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:735,Usability,clear,clear,735,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:192,Performance,optimiz,optimize,192,"// For analyzeBranch.; // Now that all the basic blocks in the chain have the proper layout,; // make a final call to analyzeBranch with AllowModify set.; // Indeed, the target may be able to optimize the branches in a way we; // cannot because all branches may not be analyzable.; // E.g., the target may be able to remove an unconditional branch to; // a fallthrough when it occurs after predicated terminators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:252,Deployability,Update,Updated,252,"/// Tail duplicate \p BB into (some) predecessors if profitable, repeating if; /// it was duplicated into its chain predecessor and removed.; /// \p BB - Basic block that may be duplicated.; ///; /// \p LPred - Chosen layout predecessor of \p BB.; /// Updated to be the chain end if LPred is removed.; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// @return true if \p BB was removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:487,Deployability,update,update,487,"/// Tail duplicate \p BB into (some) predecessors if profitable, repeating if; /// it was duplicated into its chain predecessor and removed.; /// \p BB - Basic block that may be duplicated.; ///; /// \p LPred - Chosen layout predecessor of \p BB.; /// Updated to be the chain end if LPred is removed.; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// @return true if \p BB was removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:254,Energy Efficiency,schedul,scheduled,254,"// Iteratively try to duplicate again. It can happen that a block that is; // duplicated into is still small enough to be duplicated again.; // No need to call markBlockSuccessors in this case, as the blocks being; // duplicated from here on are already scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:49,Deployability,update,updated,49,"// The removal callback causes Chain.end() to be updated when a block is; // removed. On the first pass through the loop, the chain end should be the; // same as it was on function entry. On subsequent passes, because we are; // duplicating the block at the end of the chain, if it is removed the; // chain will have shrunk by one block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:46,Energy Efficiency,schedul,scheduled,46,"// If BB was duplicated into LPred, it is now scheduled. But because it was; // removed, markChainSuccessors won't be called for its chain. Instead we; // call markBlockSuccessors for LPred to achieve the same effect. This must go; // at the end because repeating the tail duplication can increase the number; // of unscheduled predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:350,Deployability,update,update,350,"/// Tail duplicate \p BB into (some) predecessors if profitable.; /// \p BB - Basic block that may be duplicated; /// \p LPred - Chosen layout predecessor of \p BB; /// \p Chain - Chain to which \p LPred belongs, and \p BB will belong.; /// \p BlockFilter - Set of blocks that belong to the loop being laid out.; /// Used to identify which blocks to update predecessor; /// counts.; /// \p PrevUnplacedBlockIt - Iterator pointing to the last block that was; /// chosen in the given order due to unnatural CFG; /// only needed if \p BB is removed and; /// \p PrevUnplacedBlockIt pointed to \p BB.; /// \p DuplicatedToLPred - True if the block was duplicated into LPred.; /// \return - True if the block was duplicated into all preds and removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update UnscheduledPredecessors to reflect tail-duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:167,Availability,avail,available,167,"// The size cost of duplication is the instruction size of the duplicated block.; // So we should scale the threshold accordingly. But the instruction size is not; // available on all targets, so we use the number of instructions instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:25,Energy Efficiency,reduce,reduced,25,// Compute the number of reduced taken branches if Pred falls through to BB; // instead of another successor. Then compare it with threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:929,Availability,avail,available,929,"// For each predecessors of BB, compute the benefit of duplicating BB,; // if it is larger than the threshold, add it into Candidates.; //; // If we have following control flow.; //; // PB1 PB2 PB3 PB4; // \ | / /\; // \ | / / \; // \ |/ / \; // BB----/ OB; // /\; // / \; // SB1 SB2; //; // And it can be partially duplicated as; //; // PB2+BB; // | PB1 PB3 PB4; // | | / /\; // | | / / \; // | |/ / \; // | BB----/ OB; // |\ /|; // | X |; // |/ \|; // SB2 SB1; //; // The benefit of duplicating into a predecessor is defined as; // Orig_taken_branch - Duplicated_taken_branch; //; // The Orig_taken_branch is computed with the assumption that predecessor; // jumps to BB and the most possible successor is laid out after BB.; //; // The Duplicated_taken_branch is computed with the assumption that BB is; // duplicated into PB, and one successor is layout after it (SB1 for PB1 and; // SB2 for PB2 in our case). If there is no available successor, the combined; // block jumps to all BB's successor, like PB3 in this example.; //; // If a predecessor has multiple successors, so BB can't be duplicated into; // it. But it can beneficially fall through to BB, and duplicate BB into other; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:24,Availability,avail,available,24,"// Profile count is not available, we can use block frequency instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:18,Performance,optimiz,optimization,18,"// For aggressive optimization, we can adjust some thresholds to be less; // conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Performance,optimiz,optimizing,27,// Apply a post-processing optimizing block placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:38,Performance,optimiz,optimizeBranches,38,// Re-create CFG chain so that we can optimizeBranches and alignBlocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:178,Integrability,depend,dependent,178,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:225,Integrability,interface,interface,225,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:211,Modifiability,extend,extending,211,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:3,Deployability,Update,Update,3,// Update basic block branches by inserting explicit fallthrough branches; // when required and re-optimize branches when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:99,Performance,optimiz,optimize,99,// Update basic block branches by inserting explicit fallthrough branches; // when required and re-optimize branches when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:27,Performance,optimiz,optimize,27,// It might be possible to optimize branches by flipping the condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:487,Security,integrity,integrity,487,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:444,Testability,test,test,444,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:469,Usability,simpl,simply,469,"//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This checks debug info after mir-debugify (+ pass-to-test). Currently; /// it simply checks the integrity of line info in DILocation and; /// DILocalVariable which mir-debugifiy generated before.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:33,Safety,Avoid,Avoid,33,// Find missing lines.; // TODO: Avoid meta instructions other than dbg_val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:16,Modifiability,variab,variables,16,// Find missing variables.; // TODO: Handle DBG_INSTR_REF which is under an experimental option now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,Performance,optimiz,optimizing,12,/// True if optimizing for code size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:253,Integrability,depend,dependent,253,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Performance,latency,latency,25,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:43,Performance,latency,latency,43,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:197,Performance,latency,latency,197,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:362,Performance,latency,latency,362,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:459,Performance,Latency,Latency,459,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:52,Performance,latency,latency,52,// Check each definition in NewRoot and compute the latency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:83,Performance,optimiz,optimize,83,/// The combiner's goal may differ based on which pattern it is attempting; /// to optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,Integrability,depend,dependency,12,// The data dependency chain must be improved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:33,Energy Efficiency,reduce,reduced,33,// The register pressure must be reduced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:210,Integrability,depend,dependent,210,"/// Estimate the latency of the new and original instruction sequence by summing; /// up the latencies of the inserted and deleted instructions. This assumes; /// that the inserted and deleted instructions are dependent instruction chains,; /// which might not hold in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:17,Performance,latency,latency,17,"/// Estimate the latency of the new and original instruction sequence by summing; /// up the latencies of the inserted and deleted instructions. This assumes; /// that the inserted and deleted instructions are dependent instruction chains,; /// which might not hold in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:347,Integrability,depend,dependency,347,"/// The DAGCombine code sequence ends in MI (Machine Instruction) Root.; /// The new code sequence ends in MI NewRoot. A necessary condition for the new; /// sequence to replace the old sequence is that it cannot lengthen the critical; /// path. The definition of ""improve"" may be restricted by specifying that the; /// new path improves the data dependency chain (MustReduceDepth).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:17,Performance,latency,latency,17,// Get depth and latency of NewRoot and Root.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:137,Integrability,depend,dependency,137,"// For a transform such as reassociation, the cost equation is; // conservatively calculated so that we must improve the depth (data; // dependency cycles) in the critical path to proceed with the transform.; // Being conservative also protects against inaccuracies in the underlying; // machine trace metrics and CPU models.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:193,Integrability,depend,dependency,193,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:10,Modifiability,flexible,flexible,10,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:246,Performance,latency,latency,246,// A more flexible cost calculation for the critical path includes the slack; // of the original code sequence. This may allow the transform to proceed; // even if the instruction depths (data dependency cycles) become worse.; // Account for the latency of the inserted and deleted instructions by,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:11,Integrability,rout,routine,11,/// helper routine to convert instructions into SC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:59,Deployability,update,updates,59,"/// Inserts InsInstrs and deletes DelInstrs. Incrementally updates instruction; /// depths if requested.; ///; /// \param MBB basic block to insert instructions in; /// \param MI current machine instruction; /// \param InsInstrs new instructions to insert in \p MBB; /// \param DelInstrs instruction to delete from \p MBB; /// \param TraceEnsemble is a pointer to the machine trace information; /// \param RegUnits set of live registers, needed to compute instruction depths; /// \param TII is target instruction info, used to call target hook; /// \param Pattern is used to call target hook finalizeInsInstrs; /// \param IncrementalUpdate if true, compute instruction depths incrementally,; /// otherwise invalidate the trace",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:54,Performance,latency,latency,54,// Check that the difference between original and new latency is decreasing for; // later patterns. This helps to discover sub-optimal pattern orderings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:3,Modifiability,Variab,Variable,3,// Variable is used in assert only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:23,Testability,assert,assert,23,// Variable is used in assert only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:163,Performance,Perform,Performs,163,/// Substitute a slow code sequence with a faster one by; /// evaluating instruction combining pattern.; /// The prototype of such a pattern is MUl + ADD -> MADD. Performs instruction; /// combining based on machine trace metrics. Only combine a sequence of; /// instructions when this neither lengthens the critical path nor increases; /// resource pressure. When optimizing for codesize always combine when the new; /// sequence is shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:365,Performance,optimiz,optimizing,365,/// Substitute a slow code sequence with a faster one by; /// evaluating instruction combining pattern.; /// The prototype of such a pattern is MUl + ADD -> MADD. Performs instruction; /// combining based on machine trace metrics. Only combine a sequence of; /// instructions when this neither lengthens the critical path nor increases; /// resource pressure. When optimizing for codesize always combine when the new; /// sequence is shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:272,Performance,perform,performance,272,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:492,Performance,latency,latency,492,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:527,Performance,latency,latency,527,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:1304,Performance,latency,latency,1304,"// The motivating example is:; //; // MUL Other MUL_op1 MUL_op2 Other; // \ / \ | /; // ADD/SUB => MADD/MSUB; // (=Root) (=NewRoot); // The DAGCombine code always replaced MUL + ADD/SUB by MADD. While this is; // usually beneficial for code size it unfortunately can hurt performance; // when the ADD is on the critical path, but the MUL is not. With the; // substitution the MUL becomes part of the critical path (in form of the; // MADD) and can lengthen it on architectures where the MADD latency is; // longer than the ADD latency.; //; // For each instruction we check if it can be the root of a combiner; // pattern. Then for each pattern the new code sequence in form of MI is; // generated and evaluated. When the efficiency criteria (don't lengthen; // critical path, don't use more resources) is met the new sequence gets; // hooked up into the basic block before the old sequence is removed.; //; // The algorithm does not try to evaluate all patterns and pick the best.; // This is only an artificial restriction though. In practice there is; // mostly one pattern, and getMachineCombinerPatterns() can order patterns; // based on an internal cost heuristic. If; // machine-combiner-verify-pattern-order is enabled, all patterns are; // checked to ensure later patterns do not provide better latency savings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:3,Deployability,Update,Update,3,// Update depths since the last incremental update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:44,Deployability,update,update,44,// Update depths since the last incremental update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Deployability,update,updates,25,// Use incremental depth updates for basic blocks above threshold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:132,Deployability,update,update,132,"// For big basic blocks, we only compute the full trace the first time; // we hit this. We do not invalidate the trace, but instead update the; // instruction depths incrementally.; // NOTE: Only the instruction depths up to MI are accurate. All other; // trace information is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:281,Deployability,update,updated,281,"// For big basic blocks, we only compute the full trace the first time; // we hit this. We do not invalidate the trace, but instead update the; // instruction depths incrementally.; // NOTE: Only the instruction depths up to MI are accurate. All other; // trace information is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,Deployability,update,updates,25,// Use incremental depth updates for basic blocks above treshold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:946,Availability,redundant,redundant,946,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:946,Safety,redund,redundant,946,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:404,Usability,simpl,simple,404,"//===- MachineCopyPropagation.cpp - Machine Copy Propagation Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is an extremely simple MachineInstr-level copy propagation pass.; //; // This pass forwards the source of COPYs to the users of their destinations; // when doing so is legal. For example:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg1; //; // If; // - %reg0 has not been clobbered by the time of the use of %reg1; // - the register class constraints are satisfied; // - the COPY def is the only value that reaches OP; // then this pass replaces the above with:; //; // %reg1 = COPY %reg0; // ...; // ... = OP %reg0; //; // This pass also removes some redundant COPYs. For example:; //; // %R1 = COPY %R0; // ... // No clobber of %R1; // %R0 = COPY %R1 <<< Removed; //; // or; //; // %R1 = COPY %R0; // ... // No clobber of %R0; // %R1 = COPY %R0 <<< Removed; //; // or; //; // $R0 = OP ...; // ... // No read/clobber of $R0 and $R1; // $R1 = COPY $R0 // $R0 is killed; // Replace $R0 with $R1 and remove the COPY; // $R1 = OP ...; // ...; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:31,Availability,avail,available,31,// Source of copy is no longer available for propagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,Availability,redundant,redundant,312,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,Safety,redund,redundant,312,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:270,Usability,clear,cleared,270,"// If DefReg becomes empty after removal, we can remove the; // SrcCopy from the tracker's copy maps. We only remove those; // entries solely record the Def is defined by Src. If an; // entry also contains the definition record of other Def'; // registers, it cannot be cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:86,Availability,avail,available,86,"// Remember source that's copied to Def. Once it's clobbered, then; // it's no longer available for copy propagation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:45,Availability,Avail,AvailSrc,45,// FIXME: Shall we simultaneously invalidate AvailSrc or AvailDef?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:57,Availability,Avail,AvailDef,57,// FIXME: Shall we simultaneously invalidate AvailSrc or AvailDef?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:18,Availability,avail,available,18,// Check that the available copy isn't clobbered by any regmasks between; // itself and the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Safety,Avoid,Avoid,3,// Avoid eliminating a copy from/to a reserved registers as we cannot predict; // the value (Example: The sparc zero register is writable but stays zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:70,Safety,predict,predict,70,// Avoid eliminating a copy from/to a reserved registers as we cannot predict; // the value (Example: The sparc zero register is writable but stays zero).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,Availability,redundant,redundantly,12,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,Safety,redund,redundantly,12,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Usability,Clear,Clear,3,// Clear undef flag from remaining copy if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:166,Safety,avoid,avoiding,166,/// Decide whether we should forward the source of \param Copy to its use in; /// \param UseI based on the physical register class constraints of the opcode; /// and avoiding introducing more cross-class COPYs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:427,Energy Efficiency,reduce,reduced,427,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:107,Safety,avoid,avoid,107,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:429,Deployability,update,update,429,"/// Check that \p MI does not have implicit uses that overlap with it's \p Use; /// operand (the register being replaced), since these can sometimes be; /// implicitly tied to other operands. For example, on AMDGPU:; ///; /// V_MOVRELS_B32_e32 %VGPR2, %M0<imp-use>, %EXEC<imp-use>, %VGPR2_VGPR3_VGPR4_VGPR5<imp-use>; ///; /// the %VGPR2 is implicitly tied to the larger reg operand, but we have no; /// way of knowing we need to update the latter when updating the former.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:13,Availability,avail,available,13,/// Look for available copies whose destination register is used by \p MI and; /// replace the use in \p MI with the copy's source register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:116,Energy Efficiency,allocate,allocated,116,// Look for non-tied explicit vreg uses that have an active COPY; // instruction that defines the physical register allocated to them.; // Replace the vreg with the source of the active COPY.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:236,Availability,error,error,236,"// Don't forward into undef use operands since doing so can cause problems; // with the machine verifier, since it doesn't treat undef reads as reads,; // so we can end up with a live range that ends on an undef read, leading to; // an error that the live range doesn't end on a read of the live range; // register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:66,Safety,safe,safe,66,// Check that the register is marked 'renamable' so we know it is safe to; // rename it without violating any constraints that aren't expressed in the; // IR (e.g. ABI or opcode requirements).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Usability,Clear,Clear,3,// Clear kill markers that may have been invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:99,Availability,avail,available,99,"// If 'Def' is previously source of another copy, then this earlier copy's; // source is no longer available. e.g.; // %xmm9 = copy %xmm2; // ...; // %xmm2 = copy %xmm0; // ...; // %xmm2 = copy %xmm9",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:34,Availability,mask,mask,34,// The instruction has a register mask operand which means that it clobbers; // a large set of registers. Treat clobbered registers the same way as; // defined registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:65,Availability,avail,available,65,// Any previous copy definition or reading the Defs is no longer available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Deployability,Update,Update,3,"// Update matching debug values, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:99,Deployability,update,update,99,"// Check if the register in the debug instruction is utilized; // in a copy instruction, so we can update the debug info if the; // register is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1112,Availability,avail,available,1112,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1092,Integrability,depend,depends,1092,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:442,Modifiability,rewrite,rewrite,442,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:520,Usability,simpl,simplify,520,"// We need at least 3 pairs of copies for the transformation to apply,; // because the first outermost pair cannot be removed since we don't; // recolor outside of the chain and that we need at least one temporary; // spill slot to shorten the chain. If we only have a chain of two; // pairs, we already have the shortest sequence this code can handle:; // the outermost pair for the temporary spill slot, and the pair that; // use that temporary spill slot for the other end of the chain.; // TODO: We might be able to simplify to one spill-reload pair if collecting; // more infomation about the outermost COPY.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Deployability,Update,Update,3,// Update track information via non-copy instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:393,Performance,perform,performs,393,"//===- MachineCSE.cpp - Machine Common Subexpression Elimination Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global common subexpression elimination on machine; // instructions using a scoped hash table based value numbering scheme. It; // must be run while the machine function is still in SSA form.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:485,Security,hash,hash,485,"//===- MachineCSE.cpp - Machine Common Subexpression Elimination Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global common subexpression elimination on machine; // instructions using a scoped hash table based value numbering scheme. It; // must be run while the machine function is still in SSA form.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:16,Safety,avoid,avoid,16,// Threshold to avoid excessive cost to compute isProfitableToCSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:383,Deployability,update,updated,383,"// FIXME: We should trivially coalesce subregister copies to expose CSE; // opportunities on instructions with truncated operands (see; // cse-add-with-overflow.ll). This can be done here as follows:; // if (SrcSubReg); // RC = TRI->getMatchingSuperRegClass(MRI->getRegClass(SrcReg), RC,; // SrcSubReg);; // MO.substVirtReg(SrcReg, SrcSubReg, *TRI);; //; // The 2-addr pass has been updated to handle coalesced subregs. However,; // some machine-specific code still can't handle it.; // To handle it properly we also need a way find a constrained subregister; // class given a super-reg class and subreg index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:61,Security,expose,expose,61,"// FIXME: We should trivially coalesce subregister copies to expose CSE; // opportunities on instructions with truncated operands (see; // cse-add-with-overflow.ll). This can be done here as follows:; // if (SrcSubReg); // RC = TRI->getMatchingSuperRegClass(MRI->getRegClass(SrcReg), RC,; // SrcSubReg);; // MO.substVirtReg(SrcReg, SrcSubReg, *TRI);; //; // The 2-addr pass has been updated to handle coalesced subregs. However,; // some machine-specific code still can't handle it.; // To handle it properly we also need a way find a constrained subregister; // class given a super-reg class and subreg index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:9,Modifiability,extend,extending,9,// Avoid extending live range of physical registers if they are; //allocatable or reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:3,Safety,Avoid,Avoid,3,// Avoid extending live range of physical registers if they are; //allocatable or reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:33,Performance,load,load,33,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Performance,load,loaded,102,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Performance,load,load,178,"// Okay, this instruction does a load. As a refinement, we allow the target; // to decide whether the loaded value is actually a constant. If so, we can; // actually use it as a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:37,Performance,load,loads,37,// FIXME: we should be able to hoist loads with no other side effects if; // there are no other instructions which can change memory in this loop.; // This is a trivial form of alias analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:22,Performance,load,loads,22,"// Ignore stack guard loads, otherwise the register that holds CSEed value may; // be spilled and get loaded back with corrupted data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Performance,load,loaded,102,"// Ignore stack guard loads, otherwise the register that holds CSEed value may; // be spilled and get loaded back with corrupted data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,Safety,avoid,avoid,102,// Too costly to compute if NumOfUses is very large. Conservatively assume; // MayIncreasePressure to avoid spending too much time here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,Availability,redundant,redundant,85,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,Safety,redund,redundant,85,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:97,Safety,safe,safe,97,"// If the instruction defines physical registers and the values *may* be; // used, then it's not safe to replace it with a common subexpression.; // It's also not safe if the instruction uses physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:163,Safety,safe,safe,163,"// If the instruction defines physical registers and the values *may* be; // used, then it's not safe to replace it with a common subexpression.; // It's also not safe if the instruction uses physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:315,Safety,detect,detected,315,"// ... Unless the CS is local or is in the sole predecessor block; // and it also defines the physical register which is not clobbered; // in between and the physical register uses were not clobbered.; // This can never be the case if the instruction both uses and; // defines the same physical register, which was detected above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:267,Integrability,depend,dependent,267,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:184,Modifiability,extend,extends,184,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:415,Modifiability,extend,extended,415,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:583,Modifiability,extend,extended,583,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:31,Performance,perform,perform,31,// Check if it's profitable to perform this CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,Availability,redundant,redundant,74,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,Safety,redund,redundant,74,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:50,Usability,clear,clear,50,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:9,Performance,perform,perform,9,"// Don't perform CSE if the result of the new instruction cannot exist; // within the constraints (register class, bank, or low-level type) of; // the old instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:12,Performance,perform,perform,12,// Actually perform the elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:48,Usability,clear,clear,48,"// OldReg may have been unused but is used now, clear the Dead flag",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:27,Usability,clear,clear,27,// Replace with NewReg and clear kill flags which may be wrong now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Availability,redundant,redundant,178,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:600,Modifiability,extend,extended,600,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,Safety,redund,redundant,178,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:48,Usability,clear,clear,48,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:59,Usability,clear,clear,59,"// If the instructions aren't in the same BB, bail out and clear the; // kill flag on all uses of the imp-def'd register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:3,Performance,Perform,Perform,3,// Perform a DFS walk to determine the order of visit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:7,Performance,perform,perform,7,// Now perform CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:26,Availability,redundant,redundant,26,// Two instrs are partial redundant if their basic blocks are reachable; // from one to another but one doesn't dominate another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:26,Safety,redund,redundant,26,// Two instrs are partial redundant if their basic blocks are reachable; // from one to another but one doesn't dominate another.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:106,Integrability,depend,dependent,106,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:23,Modifiability,extend,extends,23,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:254,Modifiability,extend,extended,254,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:422,Modifiability,extend,extended,422,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:167,Performance,optimiz,optimized,167,"// When hoisting, make sure we don't carry the debug location of; // the original instruction, as that's not correct and can cause; // unexpected jumps when debugging optimized code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:28,Safety,redund,redundancy,28,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:96,Safety,redund,redundancy,96,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:133,Safety,redund,redundancy,133,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:213,Safety,redund,redundancy,213,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:8,Usability,simpl,simple,8,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:306,Safety,safe,safe,306,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:18,Safety,safe,safe,18,// Otherwise it's safe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:485,Testability,test,tests,485,"//===- MachineDebugify.cpp - Attach synthetic debug info to everything ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This pass attaches synthetic debug info to everything. It can be used; /// to create targeted tests for debug info preservation, or test for CodeGen; /// differences with vs. without debug info.; ///; /// This isn't intended to have feature parity with Debugify.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:523,Testability,test,test,523,"//===- MachineDebugify.cpp - Attach synthetic debug info to everything ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This pass attaches synthetic debug info to everything. It can be used; /// to create targeted tests for debug info preservation, or test for CodeGen; /// differences with vs. without debug info.; ///; /// This isn't intended to have feature parity with Debugify.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:14,Modifiability,variab,variables,14,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:121,Modifiability,variab,variables,121,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:268,Modifiability,variab,variable,268,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:354,Modifiability,variab,variables,354,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:516,Modifiability,variab,variable,516,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:146,Usability,simpl,simple,146,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:243,Usability,simpl,simply,243,"// Find local variables defined by debugify. No attempt is made to match up; // MIR-level regs to the 'correct' IR-level variables: there isn't a simple; // way to do that, and it isn't necessary to find interesting CodeGen bugs.; // Instead, simply keep track of one variable per line. Later, we can insert; // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs; // which cover a wide range of lines can help stress the debug info passes:; // if we can't do that, fall back to using the local variable which precedes; // all the others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:25,Modifiability,variab,variable,25,// Find a suitable local variable for the DBG_VALUE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:40,Modifiability,variab,variables,40,"// Here we save the number of lines and variables into ""llvm.mir.debugify"".; // It is useful for mir-check-debugify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:17,Modifiability,variab,variables,17,// Add number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp:17,Modifiability,variab,variables,17,// Set number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDebugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:404,Usability,simpl,simple,404,"//===- MachineDominators.cpp - Machine Dominator Calculation --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // forward dominators on machine functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:3,Deployability,Update,Update,3,// Update dominator information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp:8,Deployability,update,update,8,"// Now, update DT with the collected dominance properties info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp:98,Modifiability,refactor,refactored,98,"// This code is very, very similar to PEI::calculateFrameObjectOffsets().; // It really should be refactored to share code. Until then, changes; // should keep in mind that there's tight coupling between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp:187,Modifiability,coupling,coupling,187,"// This code is very, very similar to PEI::calculateFrameObjectOffsets().; // It really should be refactored to share code. Until then, changes; // should keep in mind that there's tight coupling between the two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFrameInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:85,Performance,load,load,85,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:178,Safety,avoid,avoid,178,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:97,Security,hash,hash,97,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:194,Security,access,access,194,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:255,Security,access,access,255,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:80,Energy Efficiency,allocate,allocate,80,"/// Get the JumpTableInfo for this function.; /// If it does not already exist, allocate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a new MachineInstr. Use this instead of `new MachineInstr'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:259,Deployability,update,updateCallSiteInfo,259,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:56,Testability,assert,assertion,56,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:184,Testability,assert,assertion,184,"// Verify that a call site info is at valid state. This assertion should; // be triggered during the implementation of support for the; // call site info of a new architecture. If the assertion is triggered,; // back trace will tell where to insert a call to updateCallSiteInfo().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a new MachineBasicBlock. Use this instead of; /// `new MachineBasicBlock'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:93,Availability,robust,robust,93,// Set BBID for `-basic-block=sections=labels` and; // `-basic-block-sections=list` to allow robust mapping of profiles to basic; // blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:79,Safety,Avoid,Avoid,79,"// Iterate over all operands looking for defs to create substitutions for.; // Avoid creating new instr numbers unless we create a new substitution.; // While this has no functional effect, it risks confusing someone reading; // MIR output.; // Examine all the operands, or the first N specified by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:193,Safety,risk,risks,193,"// Iterate over all operands looking for defs to create substitutions for.; // Avoid creating new instr numbers unless we create a new substitution.; // While this has no functional effect, it risks confusing someone reading; // MIR output.; // Examine all the operands, or the first N specified by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:47,Deployability,install,install,47,"// Calculate the instruction number to use, or install a DBG_PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:206,Energy Efficiency,efficient,efficient,206,// Helper lambda to apply additional subregister substitutions to a known; // instruction/operand pair. Adds new (fake) substitutions so that we can; // record the subregister. FIXME: this isn't very space efficient if multiple; // values are tracked back through the same copies; cache something later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:281,Performance,cache,cache,281,// Helper lambda to apply additional subregister substitutions to a known; // instruction/operand pair. Adds new (fake) substitutions so that we can; // record the subregister. FIXME: this isn't very space efficient if multiple; // values are tracked back through the same copies; cache something later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:3,Testability,Test,Test,3,// Test for operand that defines something aliasing RegToSeek.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:400,Modifiability,variab,variable,400,"// We reached the start of the block before finding a defining instruction.; // There are numerous scenarios where this can happen:; // * Constant physical registers,; // * Several intrinsics that allow LLVM-IR to read arbitary registers,; // * Arguments in the entry block,; // * Exception handling landing pads.; // Validating all of them is too difficult, so just insert a DBG_PHI reading; // the variable value at this position, rather than checking it makes sense.; // Create DBG_PHI for specified physreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:318,Security,Validat,Validating,318,"// We reached the start of the block before finding a defining instruction.; // There are numerous scenarios where this can happen:; // * Constant physical registers,; // * Several intrinsics that allow LLVM-IR to read arbitary registers,; // * Arguments in the entry block,; // * Exception handling landing pads.; // Validating all of them is too difficult, so just insert a DBG_PHI reading; // the variable value at this position, rather than checking it makes sense.; // Create DBG_PHI for specified physreg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,Availability,redundant,redundant,32,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,Safety,redund,redundant,32,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:85,Performance,optimiz,optimized,85,"// Disable instr-ref at -O0: it's very slow (in compile time). We can still; // have optimized code inlined into this unoptimized code, however with; // fewer and less aggressive optimizations happening, coverage and accuracy; // should not suffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:179,Performance,optimiz,optimizations,179,"// Disable instr-ref at -O0: it's very slow (in compile time). We can still; // have optimized code inlined into this unoptimized code, however with; // fewer and less aggressive optimizations happening, coverage and accuracy; // should not suffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:45,Deployability,update,update,45,"/// If Old is the target of any jump tables, update the jump tables to branch; /// to New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:43,Deployability,update,update,43,"/// If Old is a target of the jump tables, update the jump table to branch to; /// New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:123,Safety,avoid,avoid,123,"// A constant may be a member of both Constants and MachineCPVsSharingEntries,; // so keep track of which we've deleted to avoid double deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:48,Energy Efficiency,allocate,allocated,48,/// Test whether the given two constants can be allocated the same constant pool; /// entry referenced by \param A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:4,Testability,Test,Test,4,/// Test whether the given two constants can be allocated the same constant pool; /// entry referenced by \param A.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:18,Safety,safe,safely,18,"// Constants only safely match if A doesn't contain undef/poison.; // As we'll be reusing A, it doesn't matter if B contain undef/poison.; // TODO: Handle cases where A and B have the same undef/poison elements.; // TODO: Merge A and B with mismatching undef/poison elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:94,Energy Efficiency,efficient,efficient,94,"// Check to see if we already have this constant.; //; // FIXME, this could be made much more efficient for large constant pools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:94,Energy Efficiency,efficient,efficient,94,"// Check to see if we already have this constant.; //; // FIXME, this could be made much more efficient for large constant pools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp:35,Integrability,depend,dependent,35,"// FIXME: This cutoff value is CPU dependent and should be moved to; // TargetTransformInfo once we consider enabling this on other platforms.; // The value is expressed as a ProfileSummaryInfo integer percentile cutoff.; // Defaults to 999950, i.e. all blocks colder than 99.995 percentile are split.; // The default was empirically determined to be optimal when considering cutoff; // values between 99%-ile to 100%-ile with respect to iTLB and icache metrics on; // Intel CPUs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunctionSplitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:80,Availability,reliab,reliably,80,"// Replicate ties between the operands, which addOperand was not; // able to do reliably.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:115,Deployability,update,update,115,"/// Move NumOps MachineOperands from Src to Dst, with support for overlapping; /// ranges. If MRI is non-null also update use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:64,Integrability,depend,depends,64,"// Don't call the MachineOperand destructor. A lot of this code depends on; // MachineOperand having a trivial destructor anyway, and adding a call here; // wouldn't make it 'destructor-correct'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:51,Energy Efficiency,allocate,allocated,51,// See if we can just steal the extra info already allocated for the; // instruction. We can do this whenever the pre- and post-instruction symbols; // are the same (including null).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:41,Usability,simpl,simpler,41,// Try handling easy numbers of MIs with simpler mechanisms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:60,Usability,clear,clear,60,"// If there was only one symbol and we're removing it, just clear info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:60,Usability,clear,clear,60,"// If there was only one symbol and we're removing it, just clear info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:120,Testability,log,logic,120,"// For now, the just return the union of the flags. If the flags get more; // complicated over time, we might need more logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:12,Integrability,wrap,wrapping,12,// Copy the wrapping flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:22,Testability,test,test,22,"// We have passed the test above that both instructions have the same; // opcode, so we know that both instructions are bundles here. Let's compare; // MIs inside the bundle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:167,Safety,safe,safe,167,"// Clients may or may not want to ignore defs when testing for equality.; // For example, machine CSE pass only cares about finding common; // subexpressions, so it's safe to ignore virtual register defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:51,Testability,test,testing,51,"// Clients may or may not want to ignore defs when testing for equality.; // For example, machine CSE pass only cares about finding common; // subexpressions, so it's safe to ignore virtual register defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:4,Usability,clear,clearKillInfo,4,/// clearKillInfo - Clears kill flags on all operands.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:20,Usability,Clear,Clears,20,/// clearKillInfo - Clears kill flags on all operands.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:40,Safety,safe,safe,40,"/// isSafeToMove - Return true if it is safe to move this instruction. If; /// SawStore is set to true, it means that there is a store (or call) between; /// the instruction's location and its intended destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:69,Performance,load,loads,69,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:166,Performance,load,loads,166,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:205,Performance,load,load,205,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:227,Performance,load,load,227,"// Ignore stuff that we obviously can't move.; //; // Treat volatile loads as stores. This is not strictly necessary for; // volatiles, but it is required for atomic loads. It is not allowed to move; // a load across an atomic load with Ordering > Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:34,Performance,load,load,34,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:81,Performance,load,loaded,81,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:121,Performance,load,load,121,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:242,Performance,load,load,242,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:304,Performance,load,load,304,"// See if this instruction does a load. If so, we have to guarantee that the; // loaded value doesn't change between the load and the its intended; // destination. The check for isInvariantLoad gives the target the chance to; // classify the load as always returning a constant, e.g. a constant pool; // load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:29,Performance,load,load,29,"// Otherwise, this is a real load. If there is a store between the load and; // end of block, we can't move it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:67,Performance,load,load,67,"// Otherwise, this is a real load. If there is a store between the load and; // end of block, we can't move it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:407,Energy Efficiency,allocate,allocated,407,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:17,Integrability,interface,interface,17,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:376,Integrability,wrap,wrap,376,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:35,Security,access,accesses,35,// Let the target decide if memory accesses cannot possibly overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:49,Security,access,access,49,// Memory operations without memory operands may access anything. Be; // conservative and assume `MayAlias`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:179,Availability,avail,available,179,"/// hasOrderedMemoryRef - Return true if this instruction may have an ordered; /// or volatile memory reference, or if the information describing the memory; /// reference is not available. Return false if it is known to have no ordered; /// memory references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:33,Security,access,access,33,// An instruction known never to access memory won't have a volatile access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:69,Security,access,access,69,// An instruction known never to access memory won't have a volatile access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:97,Performance,load,loading,97,/// isDereferenceableInvariantLoad - Return true if this instruction will never; /// trap and is loading from a location whose value is invariant across a run of; /// this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:30,Performance,load,load,30,"// If the instruction doesn't load at all, it isn't an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:65,Performance,load,load,65,"// If the instruction doesn't load at all, it isn't an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:106,Performance,load,load,106,"// If the instruction has lost its memoperands, conservatively assume that; // it may not be an invariant load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:176,Deployability,update,updated,176,"// If the memory operand has ordering side effects, we can't move the; // instruction. Such an instruction is technically an invariant load,; // but the caller code would need updated to expect that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:135,Performance,load,load,135,"// If the memory operand has ordering side effects, we can't move the; // instruction. Such an instruction is technically an invariant load,; // but the caller code would need updated to expect that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:5,Performance,load,load,5,// A load from a constant PseudoSourceValue is invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:92,Availability,Failure,Failure,92,// DEBUG_VALUE nodes do not contribute to code generation and should; // always be ignored. Failure to do so may result in trying to modify; // KILL flags on DEBUG_VALUE nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:34,Availability,mask,mask,34,"// This is a call with a register mask operand.; // Mask clobbers are always dead, so add defs for the non-dead defines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:52,Availability,Mask,Mask,52,"// This is a call with a register mask operand.; // Mask clobbers are always dead, so add defs for the non-dead defines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:24,Security,hash,hash,24,// Build up a buffer of hash code components.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:44,Modifiability,Variab,Variable,44,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:88,Modifiability,Variab,Variable,88,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:44,Modifiability,Variab,Variable,44,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:88,Modifiability,Variab,Variable,88,"// Non-Variadic Operands: Location, Offset, Variable, Expression; // Variadic Operands: Variable, Expression, Locations...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp:161,Integrability,rout,routine,161,"/// finalizeBundle - Finalize a machine instruction bundle which includes; /// a sequence of instructions starting from FirstMI to LastMI (exclusive).; /// This routine adds a BUNDLE instruction to represent the bundle, it adds; /// IsInternalRead markers to MachineOperands which are defined inside the; /// bundle, and it copies externally visible defs and uses to the BUNDLE; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstrBundle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:426,Availability,redundant,redundant,426,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:596,Availability,redundant,redundant,596,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:461,Performance,load,loads,461,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:503,Performance,load,loads,503,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:426,Safety,redund,redundant,426,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:596,Safety,redund,redundant,596,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:388,Usability,simpl,simple,388,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:55,Availability,redundant,redundant,55,// Walk through the instructions in MBB and remove any redundant; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:55,Safety,redund,redundant,55,// Walk through the instructions in MBB and remove any redundant; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:3,Usability,Clear,Clear,3,// Clear any previous kill flag on Reg found before I in MBB. Walk backwards; // in MBB and if needed continue in predecessors until a use/def of Reg is; // encountered. This seems to be faster in practice than tracking kill flags; // in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:301,Performance,load,load,301,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:311,Performance,load,load-address,311,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:137,Usability,simpl,simple,137,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:40,Performance,load,load-address,40,"// If FrameReg is modified, no previous load-address instructions (using; // it) are valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:3,Usability,Clear,Clear,3,// Clear any entries in map that MI clobbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:393,Performance,perform,performs,393,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:710,Security,expose,exposed,710,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:675,Usability,simpl,simple,675,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:61,Deployability,update,updated,61,// Machine dominator tree for the cur loop; // State that is updated as we process loops,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:102,Performance,load,load,102,// True if it's the first LICM in the loop.; // Holds information about whether it is allowed to move load instructions; // out of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:84,Performance,load,loads,84,"// If a MBB does not dominate loop exiting blocks then it may not safe; // to hoist loads from this block.; // Tri-state: 0 - false, 1 - true, 2 - unknown",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:66,Safety,safe,safe,66,"// If a MBB does not dominate loop exiting blocks then it may not safe; // to hoist loads from this block.; // Tri-state: 0 - false, 1 - true, 2 - unknown",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:104,Deployability,update,update,104,/// Examine the instruction for potentai LICM candidate. Also; /// gather register def and frame object update information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Safety,safe,safe,76,"// If it's using a non-loop-invariant register, then it's obviously not; // safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:19,Safety,avoid,avoid,19,"// FIXME: For now, avoid instructions with multiple defs, unless; // it's a dead implicit def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:100,Safety,safe,safe,100,"// If we have already seen another instruction that defines the same; // register, then this is not safe. Two defs is indicated by setting a; // PhysRegClobbers bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:108,Performance,load,load,108,// Only consider reloads for now and remats which do not have register; // operands. FIXME: Consider unfold load folding instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:185,Performance,load,load,185,"// Now evaluate whether the potential candidates qualify.; // 1. Check if the candidate defined register is defined by another; // instruction in the loop.; // 2. If the candidate is a load from stack slot (always true for now),; // check if the slot is stored anywhere in the loop.; // 3. Make sure candidate def should not clobber; // registers read by the terminator. Similarly its def should not be; // clobbered by the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Safety,safe,safe,76,"// If it's using a non-loop-invariant register, then it's obviously; // not safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:82,Safety,safe,safe,82,"/// When an instruction is found to only use loop invariant operands that is; /// safe to hoist, this instruction is called to do the dirty work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:62,Performance,load,load,62,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:97,Safety,safe,safe,97,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Performance,Perform,Perform,3,// Perform a DFS walk to determine the order of visit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:7,Performance,perform,perform,7,// Now perform LICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:4,Deployability,Update,Update,4,/// Update estimate of register pressure after the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:126,Deployability,update,updates,126,"/// Calculate the additional register pressure that the registers used in MI; /// cause.; ///; /// If 'ConsiderSeen' is true, updates 'RegSeen' and uses the information to; /// figure out which usages are live-ins.; /// FIXME: Figure out a way to consider 'RegSeen' from all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:44,Performance,load,loads,44,/// Return true if this machine instruction loads from global offset table or; /// constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:102,Deployability,update,updated,102,"// FIXME: If targets would like to look through instructions that aren't; // pure copies, this can be updated to a query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:138,Safety,safe,safe,138,"/// Returns true if the instruction may be a suitable candidate for LICM.; /// e.g. If the instruction is a call, then it's obviously not safe to hoist it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:14,Performance,load,load,14,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:202,Performance,load,load,202,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:234,Performance,Load,Loads,234,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:304,Performance,load,load,304,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:265,Safety,safe,safe,265,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:180,Safety,safe,safe,180,// Convergent attribute has been used on operations that involve inter-thread; // communication which results are implicitly affected by the enclosing; // control flows. It is not safe to hoist or sink such operations across; // control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,Modifiability,extend,extended,76,// A PHI inside the loop causes a copy because the live range of Reg is; // extended across the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:20,Performance,latency,latency,20,"/// Compute operand latency between a def of 'Reg' and an use in the current; /// loop, return true if the target considered it high.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:68,Performance,latency,latency,68,"/// Return true if the instruction is marked ""cheap"" or the operand latency; /// between its def and a use is one or less.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:65,Deployability,update,update,65,/// Traverse the back trace from header to the current block and update their; /// register pressures to reflect the effect of hoisting MI from the current; /// block to the preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure of blocks from loop header to current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:336,Modifiability,extend,extending,336,"// Besides removing computation from the loop, hoisting an instruction has; // these effects:; //; // - The value defined by the instruction becomes live across the entire; // loop. This increases register pressure in the loop.; //; // - If the value is used by a PHI in the loop, a copy will be required for; // lowering the PHI after extending the live range.; //; // - When hoisting the last use of a value in the loop, that value no longer; // needs to be live in the loop. This lowers register pressure in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:114,Availability,down,down,114,// Rematerializable instructions should always be hoisted providing the; // register allocator can just pull them down again when needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:28,Performance,latency,latency,28,"// FIXME: If there are long latency loop-invariant instructions inside the; // loop at this point, why didn't the optimizer's LICM hoist them?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:114,Performance,optimiz,optimizer,114,"// FIXME: If there are long latency loop-invariant instructions inside the; // loop at this point, why didn't the optimizer's LICM hoist them?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:189,Performance,latency,latency,189,"// Estimate register pressure to determine whether to LICM the instruction.; // In low register pressure situation, we can be more aggressive about; // hoisting. Also, favors hoisting long latency instructions even in; // moderately high pressure situation.; // Cheap instructions will only be hoisted if they don't increase register; // pressure at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:109,Safety,safe,safe,109,"// Visit BBs from header to current BB, if hoisting this doesn't cause; // high register pressure, then it's safe to proceed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:9,Safety,risk,risk,9,// Don't risk increasing register pressure if it would create copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:13,Performance,load,load,13,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:53,Performance,load,load,53,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:122,Performance,load,load,122,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:143,Performance,load,load,143,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:23,Performance,load,loads,23,// Don't unfold simple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:16,Usability,simpl,simple,16,// Don't unfold simple loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:38,Performance,load,load,38,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:101,Performance,load,loading,101,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:69,Testability,test,test,69,"// If not, we may be able to unfold a load and hoist that.; // First test whether the instruction is loading from an amenable; // memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:27,Performance,load,load,27,"// If unfolding produced a load that wasn't loop-invariant or profitable to; // hoist, discard the new instructions and bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure for the unfolded instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:68,Deployability,Update,Update,68,// Otherwise we successfully unfolded a load that we can hoist.; // Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:40,Performance,load,load,40,// Otherwise we successfully unfolded a load that we can hoist.; // Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:81,Performance,load,loads,81,/// Initialize AllowedToHoistLoads with information about whether invariant; /// loads can be moved outside a given loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:106,Performance,load,load,106,"// Going from the innermost to outermost loops, check if a loop has; // instructions preventing invariant load hoisting. If such instruction is; // found, mark this loop and its parent as non-hoistable and continue; // investigating the next loop.; // Visiting in a reversed pre-ordered DFS manner; // allows us to not process all the instructions of the outer loop if the; // inner loop is proved to be non-load-hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:408,Performance,load,load-hoistable,408,"// Going from the innermost to outermost loops, check if a loop has; // instructions preventing invariant load hoisting. If such instruction is; // found, mark this loop and its parent as non-hoistable and continue; // investigating the next loop.; // Visiting in a reversed pre-ordered DFS manner; // allows us to not process all the instructions of the outer loop if the; // inner loop is proved to be non-load-hoistable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:21,Performance,load,loads,21,// Do not CSE normal loads because between them could be store instructions; // that change the loaded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:96,Performance,load,loaded,96,// Do not CSE normal loads because between them could be store instructions; // that change the loaded value,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Usability,Clear,Clear,3,"// Clear Dup dead flag if any, we reuse it for Reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:83,Safety,safe,safe,83,"/// When an instruction is found to use only loop invariant operands; /// that are safe to hoist, this instruction is called to do the dirty work.; /// It returns true if the instruction is hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:37,Performance,load,load,37,"// If not, try unfolding a hoistable load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Deployability,Update,Update,3,// Update register pressure for BBs from header to this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:3,Usability,Clear,Clear,3,"// Clear the kill flags of any register this instruction defines,; // since they may need to be live throughout the entire loop; // rather than just live for part of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:93,Safety,avoid,avoid,93,// Check if the preheader candidate is a successor of any other loop; // headers. We want to avoid having two loop setups in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:306,Safety,safe,safe,306,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:18,Safety,safe,safe,18,// Otherwise it's safe to move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:12,Usability,clear,clear,12,// We don't clear the ExternalContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:3,Deployability,Update,Update,3,// Update the set entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:117,Availability,error,error,117,"// If the inline asm had metadata associated with it, pull out a location; // cookie corresponding to which line the error occurred on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:18,Usability,Clear,Clear,18,// No change.; // Clear the IsRenamable bit to keep it conservatively correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:114,Deployability,update,update,114,"// Otherwise, we have to change the register. If this operand is embedded; // into a machine function, we need to update the old and new register's; // use/def lists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:83,Availability,mask,masks,83,"// We don't know the size of the RegMask, so we can't deep compare the two; // reg masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:59,Availability,mask,mask,59,// Check if the flag's bitmask has the bits of the current mask set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:3,Usability,Clear,Clear,3,// Clear the bits which were serialized from the flag's bitmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:77,Usability,simpl,simply,77,// isDebug() is exactly true for register operands of a DBG_VALUE. So we; // simply infer it when parsing and do not need to print it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:3,Deployability,Update,Update,3,// Update the alignment value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:8,Deployability,update,update,8,"// Also update the base and offset, because the new alignment may; // not be applicable with the old ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:109,Availability,avail,available,109,"// FIXME: Implement addrspace printing/parsing in MIR.; // For now, print this even though parsing it is not available in MIR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:420,Integrability,interface,interfaces,420,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:534,Integrability,depend,dependent,534,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:622,Integrability,message,message,622,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:396,Performance,Optimiz,Optimization,396,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1535,Availability,avail,available,1535,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1651,Availability,avail,available,1651,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:1987,Usability,simpl,simplified,1987,"by placing every instruction from every basic block in a; /// suffix tree, and repeatedly querying that tree for repeated sequences of; /// instructions. If a sequence of instructions appears often, then it ought; /// to be beneficial to pull out into a function.; ///; /// The MachineOutliner communicates with a given target using hooks defined in; /// TargetInstrInfo.h. The target supplies the outliner with information on how; /// a specific sequence of instructions should be outlined. This information; /// is used to deduce the number of instructions necessary to; ///; /// * Create an outlined function; /// * Call that outlined function; ///; /// Targets must implement; /// * getOutliningCandidateInfo; /// * buildOutlinedFrame; /// * insertOutlinedCall; /// * isFunctionSafeToOutlineFrom; ///; /// in order to make use of the MachineOutliner.; ///; /// This was originally presented at the 2016 LLVM Developers' Meeting in the; /// talk ""Reducing Code Size Using Outlining"". For a high-level overview of; /// how this pass works, the talk is available on YouTube at; ///; /// https://www.youtube.com/watch?v=yorld-WSOeU; ///; /// The slides for the talk are available at; ///; /// http://www.llvm.org/devmtg/2016-11/Slides/Paquette-Outliner.pdf; ///; /// The talk provides an overview of how the outliner finds candidates and; /// ultimately outlines them. It describes how the main data structure for this; /// pass, the suffix tree, is queried and purged for candidates. It also gives; /// a simplified suffix tree construction algorithm for suffix trees based off; /// of the algorithm actually used here, Ukkonen's algorithm.; ///; /// For the original RFC for this pass, please see; ///; /// http://lists.llvm.org/pipermail/llvm-dev/2016-August/104170.html; ///; /// For more information on the suffix tree data structure, please see; /// https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Availability,avail,available,13,/// The next available integer to assign to a \p MachineInstr that; /// cannot be outlined.; ///; /// Set to -3 for compatability with \p DenseMapInfo<unsigned>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Availability,avail,available,13,/// The next available integer to assign to a \p MachineInstr that can; /// be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:46,Deployability,Update,Updates,46,"/// Maps \p *It to a legal integer.; ///; /// Updates \p CanOutlineWithPrevInstr, \p HaveLegalRange, \p InstrListForMBB,; /// \p UnsignedVecForMBB, \p InstructionIntegerMap, and \p LegalInstrNumber.; ///; /// \returns The integer that \p *It was mapped to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:49,Deployability,Update,Updates,49,"/// Maps \p *It to an illegal integer.; ///; /// Updates \p InstrListForMBB, \p UnsignedVecForMBB, and \p; /// IllegalInstrNumber.; ///; /// \returns The integer that \p *It was mapped to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:240,Safety,unsafe,unsafe,240,"/// Transforms a \p MachineBasicBlock into a \p vector of \p unsigneds; /// and appends it to \p UnsignedVec and \p InstrList.; ///; /// Two instructions are assigned the same integer if they are identical.; /// If an instruction is deemed unsafe to outline, then it will be assigned an; /// unique integer. The resulting mapping is placed into a suffix tree and; /// queried for candidates.; ///; /// \param MBB The \p MachineBasicBlock to be translated into integers.; /// \param TII \p TargetInstrInfo for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:18,Performance,perform,perform,18,// True if we can perform outlining given the last mapped (non-invisible); // instruction. This lets us know if we have a legal range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:140,Safety,safe,safe,140,// `It` is now positioned at the beginning of a range of instructions; // which may be outlinable. Check if each instruction is known to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:90,Safety,safe,safe,90,/// Set to true if the outliner should run on all functions in the module; /// considered safe for outlining.; /// Set to true by default for compatibility with llc's -run-pass option.; /// Set when the pass is constructed in TargetPassConfig.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:20,Performance,optimiz,optimized,20,/* Outlined code is optimized code by definition. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:21,Modifiability,variab,variables,21,// Don't add any new variables to the subprogram.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:91,Deployability,update,updates,91,// The following code is to add implicit def operands to the call; // instruction. It also updates call site information for moved; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:301,Security,expose,exposed,301,// Copy over the defs in the outlined range.; // First inst in outlined range <-- Anything that's defined in this; // ... .. range has to be added as an; // implicit Last inst in outlined range <-- def to the call; // instruction. Also remove call site information for outlined block; // of code. The exposed uses need to be copied in the outlined range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,Availability,redundant,redundant,37,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,Safety,redund,redundant,37,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:13,Security,expose,exposed,13,"// If it's a exposed use, add it to the call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:129,Deployability,pipeline,pipeline,129,// MachineModuleAnalysis is a module analysis pass that is never invalidated; // because we don't run any module pass in codegen pipeline. This is very; // important because the codegen state is stored in MMI which is the analysis; // result of MachineModuleAnalysis. MMI should not be recomputed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:48,Deployability,pipeline,pipeline,48,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:89,Deployability,pipeline,pipeline,89,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:115,Deployability,pipeline,pipeline,115,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp:166,Deployability,pipeline,pipeline,166,// No need to pop this callback later since MIR pipeline is flat which means; // current pipeline is the top-level pipeline. Callbacks are not used after; // current pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:47,Deployability,Pipeline,Pipeliner,47,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:447,Deployability,pipeline,pipeliner,447,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:809,Deployability,pipeline,pipelined,809,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1240,Deployability,pipeline,pipeline,1240,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1407,Deployability,pipeline,pipelined,1407,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:421,Energy Efficiency,Schedul,Scheduling,421,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:892,Energy Efficiency,schedul,scheduled,892,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1018,Energy Efficiency,Schedul,ScheduleDAGInstrs,1018,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1417,Energy Efficiency,schedul,schedule,1417,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1073,Integrability,depend,dependences,1073,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1578,Modifiability,rewrite,rewrite,1578,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:730,Performance,optimiz,optimized,730,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:750,Performance,optimiz,optimized,750,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:1141,Performance,perform,perform,1141,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:37,Deployability,pipeline,pipeliner,37,/// A command line argument to force pipeliner to use specified initial; /// interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:65,Deployability,pipeline,pipeline,65,/// A command line argument to limit the number of stages in the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,Integrability,depend,dependences,58,/// A command line option to disable the pruning of chain dependences due to; /// an unrelated Phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:76,Integrability,depend,dependences,76,/// A command line option to disable the pruning of loop carried order; /// dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:37,Deployability,pipeline,pipeliner,37,/// A command line argument to force pipeliner to use specified issue; /// width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:54,Energy Efficiency,Schedul,Scheduling,54,"/// The ""main"" function for implementing Swing Modulo Scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:10,Deployability,pipeline,pipeline,10,// Cannot pipeline loops without instruction itineraries if we are using; // DFA for the pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Deployability,pipeline,pipeliner,89,// Cannot pipeline loops without instruction itineraries if we are using; // DFA for the pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:232,Energy Efficiency,schedul,schedule,232,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Performance,perform,perform,15,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Deployability,pipeline,pipelined,44,/// Return true if the loop can be software pipelined. The algorithm is; /// restricted to loops with a single basic block. Make sure that the; /// branch in the loop can be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:183,Energy Efficiency,Schedul,Schedule,183,/// The SMS algorithm consists of the following main steps:; /// 1. Computation and analysis of the dependence graph.; /// 2. Ordering of the nodes (instructions).; /// 3. Attempt to Schedule the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:100,Integrability,depend,dependence,100,/// The SMS algorithm consists of the following main steps:; /// 1. Computation and analysis of the dependence graph.; /// 2. Ordering of the nodes (instructions).; /// 3. Attempt to Schedule the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Energy Efficiency,schedul,schedule,20,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Energy Efficiency,Schedul,ScheduleDAGInstrs,41,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:81,Energy Efficiency,schedul,scheduling,81,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:117,Energy Efficiency,Schedul,Scheduling,117,/// We override the schedule function in ScheduleDAGInstrs to implement the; /// scheduling part of the Swing Modulo Scheduling algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Testability,test,testing,25,// This flag is used for testing and can cause correctness problems.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Energy Efficiency,schedul,schedule,9,// Can't schedule a loop without a valid MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Deployability,pipeline,pipeline,9,// Don't pipeline large loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Deployability,pipeline,pipeline,23,// No need to generate pipeline if there are no overlapped iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Energy Efficiency,schedul,schedule,16,// Generate the schedule as a ModuloSchedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Deployability,pipeline,pipeliner,32,/// Clean up after the software pipeliner runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:198,Energy Efficiency,Schedul,ScheduleDAGInstrs,198,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:145,Integrability,depend,dependence,145,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:263,Integrability,depend,dependences,263,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:31,Performance,load,load,31,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:87,Performance,load,load,87,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:163,Integrability,depend,dependence,163,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:10,Performance,perform,perform,10,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:102,Performance,load,load,102,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,Integrability,depend,dependence,171,"// Second, the more expensive check that uses alias analysis on the; // base registers. If they alias, and the load offset is less than; // the store offset, the mark the dependence as loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:111,Performance,load,load,111,"// Second, the more expensive check that uses alias analysis on the; // base registers. If they alias, and the load offset is less than; // the store offset, the mark the dependence as loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:4,Deployability,Update,Update,4,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:50,Energy Efficiency,Schedul,ScheduleDAGInstrs,50,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:19,Integrability,depend,dependences,19,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Integrability,depend,dependences,93,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:139,Integrability,depend,dependences,139,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:196,Integrability,depend,dependence,196,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:254,Integrability,depend,dependence,254,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:291,Integrability,depend,dependence,291,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:346,Integrability,depend,dependences,346,"/// Update the phi dependences to the DAG because ScheduleDAGInstrs no longer; /// processes dependences for PHIs. This function adds true dependences; /// from a PHI to a use, and a loop carried dependence from the use to the; /// PHI. The loop carried dependence is represented as an anti dependence; /// edge. This function also removes chain dependences between unrelated; /// PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:57,Integrability,depend,dependence,57,"// If the register is used by a Phi, then create an anti dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependent,25,// Add a chain edge to a dependent Phi that isn't an existing; // predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Integrability,depend,dependence,59,"// If the register is defined by a Phi, then create a true dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependent,25,// Add a chain edge to a dependent Phi that isn't an existing; // predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Integrability,depend,dependences,16,// Remove order dependences from an unrelated Phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Energy Efficiency,reduce,reduce,89,/// Iterate over each DAG node and see if we can change any dependences; /// in order to reduce the recurrence MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Integrability,depend,dependences,60,/// Iterate over each DAG node and see if we can change any dependences; /// in order to reduce the recurrence MII.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:84,Deployability,update,update,84,"// See if an instruction can use a value from the previous iteration.; // If so, we update the base and offset of the instruction and change; // the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:149,Integrability,depend,dependences,149,"// See if an instruction can use a value from the previous iteration.; // If so, we update the base and offset of the instruction and change; // the dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependence,14,// Remove the dependence. The value now depends on a prior iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:40,Integrability,depend,depends,40,// Remove the dependence. The value now depends on a prior iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Integrability,depend,dependence,20,// Remove the chain dependence between the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:9,Integrability,depend,dependence,9,// Add a dependence between the new instruction and the instruction; // that defines the new base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Deployability,update,update,59,// Remember the base and offset information so that we can update the; // instruction during code generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:12,Energy Efficiency,Schedul,Schedule,12,"// No valid Schedule Class Desc for schedClass, should be; // Pseudo/PostRAPseudo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:12,Energy Efficiency,Schedul,Schedule,12,"// No valid Schedule Class Desc for schedClass, should be; // Pseudo/PostRAPseudo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:51,Energy Efficiency,schedul,scheduled,51,/// Calculate the maximum register pressure of the scheduled instructions stream,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:144,Energy Efficiency,schedul,scheduled,144,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:118,Integrability,depend,depend,118,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,Availability,alive,alive,171,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Modifiability,variab,variables,22,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Modifiability,variab,variables,109,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:215,Modifiability,variab,variable,215,"// Search for live-in variables. They are factored into the register pressure; // from the begining. Live-in variables used by every iteration should be; // considered as alive throughout the loop. For example, the variable `c` in; // following code. \code; // int c = ...;; // for (int i = 0; i < n; i++); // a[i] += b[i] + c;; // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Modifiability,variab,variable,14,// Ignore the variable that appears only on one side of phi instruction; // because it's used only at the first iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Modifiability,variab,variables,38,"// Indexed by #Iter. To treat ""local"" variables of each stage separately, we; // manage the liveness of the registers independently by iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:73,Energy Efficiency,schedul,scheduling,73,"// Used to calculate register pressure, which is independent of loop; // scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:210,Integrability,depend,dependences,210,"// end anonymous namespace; /// Calculate the resource constrained minimum initiation interval for the; /// specified loop. We use the DFA to model the resources needed for; /// each instruction, and we ignore dependences. A different DFA is created; /// for each cycle that is required. When adding a new instruction, we attempt; /// to add it to each existing DFA, until a legal space is found. If the; /// instruction cannot be reserved in an existing DFA, we create a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Integrability,depend,dependences,22,"/// Swap all the anti dependences in the DAG. That means it is no longer a DAG,; /// but we do this to find the circuits, and then change them back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Integrability,depend,dependency,20,// Remove this anti dependency and add one in the reverse direction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Integrability,depend,dependence,60,// Only create a back-edge on the first and last nodes of a dependence; // chain. This records any chains and adds them later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Performance,load,load,38,// A chain edge between a store and a load is treated as a back-edge in the; // adjacency matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:57,Integrability,depend,dependences,57,// Add back-edges in the adjacency matrix for the output dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Integrability,depend,dependence,42,/// Identify an elementary circuit in the dependence graph starting at the; /// specified node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:48,Integrability,depend,dependence,48,/// Identify all the elementary circuits in the dependence graph using; /// Johnson's circuit algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Integrability,depend,dependences,21,"// Swap all the anti dependences in the DAG. That means it is no longer a DAG,; // but we do this to find the circuits, and then change them back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependences,14,// Change the dependences back so that we've created a DAG again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:144,Deployability,pipeline,pipeliner,144,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:572,Energy Efficiency,schedul,scheduled,572,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:668,Energy Efficiency,schedul,scheduled,668,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:746,Energy Efficiency,schedul,scheduling,746,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Integrability,depend,dependencies,21,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:231,Integrability,depend,dependence,231,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:154,Safety,avoid,avoid,154,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:690,Safety,avoid,avoid,690,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:22,Integrability,depend,dependencies,22,// Add the artificial dependencies if it does not form a cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:132,Safety,avoid,avoid,132,"/// Return true for DAG nodes that we ignore when computing the cost functions.; /// We ignore the back-edge recurrence in order to avoid unbounded recursion; /// in the calculation of the ASAP, ALAP, etc functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:58,Energy Efficiency,schedul,scheduling,58,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:99,Energy Efficiency,schedul,schedule,99,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:143,Energy Efficiency,schedul,schedule,143,"/// Compute several functions need to order the nodes for scheduling.; /// ASAP - Earliest time to schedule a node.; /// ALAP - Latest time to schedule a node.; /// MOV - Mobility function, difference between ALAP and ASAP.; /// D - Depth of each node.; /// H - Height of each node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:117,Energy Efficiency,schedul,schedule,117,"/// Check if the existing node-sets are profitable. If not, then ignore the; /// recurrent node-sets, and attempt to schedule all nodes together. This is; /// a heuristic. If the MII is large and all the recurrent node-sets are small,; /// then it's best to try to schedule all instructions together instead of; /// starting with the recurrent node-sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:265,Energy Efficiency,schedul,schedule,265,"/// Check if the existing node-sets are profitable. If not, then ignore the; /// recurrent node-sets, and attempt to schedule all nodes together. This is; /// a heuristic. If the MII is large and all the recurrent node-sets are small,; /// then it's best to try to schedule all instructions together instead of; /// starting with the recurrent node-sets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Usability,simpl,simple,41,// Check if the node-set contains only a simple add recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Energy Efficiency,schedul,scheduled,32,/// Remove nodes that have been scheduled in previous NodeSets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:113,Energy Efficiency,schedul,scheduled,113,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:35,Integrability,depend,dependence,35,"/// Compute an ordered list of the dependence graph nodes, which; /// indicates the order that the nodes will be scheduled. This is a; /// two-level algorithm. First, a partial order is created, which; /// consists of a list of sets ordered from highest to lowest priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:80,Availability,down,down,80,"// If some of the successors are in the existing node-set, then use the; // top-down ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:44,Integrability,depend,dependence,44,// Back-edges are predecessors with an anti-dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Deployability,pipeline,pipelined,59,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:69,Energy Efficiency,schedul,schedule,69,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:134,Energy Efficiency,schedul,schedule,134,"/// Process the nodes in the computed order and create the pipelined schedule; /// of the instructions, if possible. Return true if a schedule is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,Energy Efficiency,schedul,schedule,36,// Keep increasing II until a valid schedule is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Energy Efficiency,schedul,schedule,15,"// Compute the schedule time for the instruction, which is based; // upon the scheduled time for any predecessors/successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:78,Energy Efficiency,schedul,scheduled,78,"// Compute the schedule time for the instruction, which is based; // upon the scheduled time for any predecessors/successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:45,Energy Efficiency,schedul,schedule,45,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Integrability,depend,dependences,89,// These values are set when the size of the schedule window is limited; // due to chain dependences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,scheduling,8,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:156,Integrability,depend,dependence,156,// When scheduling a Phi it is better to start at the late cycle and go; // backwards. The default order may insert the Phi too far away from; // its first dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,Energy Efficiency,schedul,schedule,21,"// Even if we find a schedule, make sure the schedule doesn't exceed the; // allowable number of stages. We keep trying if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:45,Energy Efficiency,schedul,schedule,45,"// Even if we find a schedule, make sure the schedule doesn't exceed the; // allowable number of stages. We keep trying if this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:38,Deployability,pipeline,pipelined,38,"// If a schedule is found, ensure non-pipelined instructions are in stage 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule is found, ensure non-pipelined instructions are in stage 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule is found, check if it is a valid schedule too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:50,Energy Efficiency,schedul,schedule,50,"// If a schedule is found, check if it is a valid schedule too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:8,Energy Efficiency,schedul,schedule,8,"// If a schedule was found and the option is enabled, check if the schedule; // might generate additional register spills/fills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:67,Energy Efficiency,schedul,schedule,67,"// If a schedule was found and the option is enabled, check if the schedule; // might generate additional register spills/fills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:174,Modifiability,rewrite,rewrite,174,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:186,Performance,load,load,186,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:238,Performance,load,load,238,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:310,Performance,load,load,310,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:339,Performance,load,load,339,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:11,Performance,load,load,11,// Get the load instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:32,Performance,load,load,32,// Check for the post-increment load/store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Security,access,access,42,// Make sure that the instructions do not access the same memory location in; // the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:89,Energy Efficiency,schedul,scheduling,89,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:127,Energy Efficiency,schedul,schedule,127,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:104,Integrability,depend,depend,104,/// Apply changes to the instruction if needed. The changes are need; /// to improve the scheduling and depend up on the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:39,Integrability,depend,dependence,39,/// Return true for an order or output dependence that is loop carried; /// potentially. A dependence is loop carried if the destination defines a value; /// that may be used or defined by the source in a subsequent iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:91,Integrability,depend,dependence,91,/// Return true for an order or output dependence that is loop carried; /// potentially. A dependence is loop carried if the destination defines a value; /// that may be used or defined by the source in a subsequent iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,Integrability,depend,dependence,59,// Assume ordered loads and stores may have a loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:18,Performance,load,loads,18,// Assume ordered loads and stores may have a loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,Integrability,depend,dependence,41,// The conservative assumption is that a dependence between memory operations; // may be loop carried. The following code checks when it can be proved that; // there is no loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:185,Integrability,depend,dependence,185,// The conservative assumption is that a dependence between memory operations; // may be loop carried. The following code checks when it can be proved that; // there is no loop carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:110,Security,access,accesses,110,"// This is the main test, which checks the offset values and the loop; // increment value to determine if the accesses may be loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,Testability,test,test,20,"// This is the main test, which checks the offset values and the loop; // increment value to determine if the accesses may be loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:11,Energy Efficiency,schedul,schedule,11,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Energy Efficiency,schedul,schedule,93,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:177,Energy Efficiency,schedul,scheduled,177,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:193,Integrability,rout,routine,193,/// Try to schedule the node at the specified StartCycle and continue; /// until the node is schedule or the EndCycle is reached. This function; /// returns true if the node is scheduled. This routine may search either; /// forward or backward for a place to insert the instruction based upon; /// the relative values of StartCycle and EndCycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:29,Integrability,depend,depends,29,// The terminating condition depends on the direction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:36,Energy Efficiency,schedul,scheduled,36,// Return the cycle of the earliest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,Energy Efficiency,schedul,scheduled,34,// Return the cycle of the latest scheduled instruction in the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,Energy Efficiency,schedul,scheduling,16,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:125,Energy Efficiency,schedul,scheduled,125,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:79,Integrability,depend,depends,79,/// Compute the scheduling start slot for the instruction. The start slot; /// depends on any predecessor or successor nodes scheduled already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:47,Energy Efficiency,schedul,scheduled,47,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:131,Energy Efficiency,schedul,scheduled,131,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:97,Integrability,depend,depends,97,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Integrability,depend,dependences,42,"// Because we're processing a DAG for the dependences, we recognize; // the back-edge in recurrences by anti dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Integrability,depend,dependences,109,"// Because we're processing a DAG for the dependences, we recognize; // the back-edge in recurrences by anti dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:106,Energy Efficiency,schedul,scheduled,106,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:77,Integrability,depend,dependent,77,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:33,Energy Efficiency,schedul,scheduled,33,// Add the instruction after the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:34,Energy Efficiency,schedul,scheduled,34,// Add the instruction before the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:19,Integrability,depend,dependences,19,// Check for order dependences between instructions. Make sure the source; // is ordered before the destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:24,Integrability,depend,dependences,24,"// We did not handle HW dependences in previous for loop,; // and we normally set Latency = 0 for Anti deps,; // so may have nodes in same cycle with Anti denpendent on HW regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:82,Performance,Latency,Latency,82,"// We did not handle HW dependences in previous for loop,; // and we normally set Latency = 0 for Anti deps,; // so may have nodes in same cycle with Anti denpendent on HW regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Integrability,depend,dependence,14,// A circular dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:96,Integrability,depend,dependence,96,// OrderAfterDef takes precedences over OrderBeforeDef. The latter is due; // to a loop-carried dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,Deployability,update,updated,60,// The uncommon case when the instruction order needs to be updated because; // there is both a use and def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Energy Efficiency,schedul,scheduled,23,/// Return true if the scheduled Phi has a loop carried operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:25,Integrability,depend,dependences,25,/// Determine transitive dependences of unpipelineable instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:72,Integrability,depend,depends,72,"// Determine all instructions upon which any unpipelineable instruction depends; // and ensure that they are in stage 0. If unable to do so, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,Deployability,pipeline,pipelined,15,// Put the non-pipelined instruction as early as possible in the schedule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:65,Energy Efficiency,schedul,schedule,65,// Put the non-pipelined instruction as early as possible in the schedule,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:522,Availability,robust,robust,522,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:181,Deployability,pipeline,pipeliner,181,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:26,Energy Efficiency,schedul,schedule,26,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:121,Energy Efficiency,schedul,scheduled,121,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:459,Testability,test,test,459,"// Check if the generated schedule is valid. This function checks if; // an instruction that uses a physical register is scheduled in a; // different stage than the definition. The pipeliner does not handle; // physical register values that may cross a basic block boundary.; // Furthermore, if a physical def/use pair is assigned to the same; // cycle, orderDependence does not guarantee def/use ordering, so that; // case should be considered invalid. (The test checks for both; // earlier and same-cycle use to be more robust.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:326,Deployability,update,updated,326,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:460,Deployability,pipeline,pipeliner,460,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:485,Deployability,pipeline,pipelined,485,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:49,Energy Efficiency,schedul,scheduling,49,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:142,Energy Efficiency,schedul,scheduled,142,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:495,Energy Efficiency,schedul,schedule,495,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:367,Testability,assert,assert,367,"/// A property of the node order in swing-modulo-scheduling is; /// that for nodes outside circuits the following holds:; /// none of them is scheduled after both a successor and a; /// predecessor.; /// The method below checks whether the property is met.; /// If not, debug information is printed and statistics information updated.; /// Note that we do not use an assert statement.; /// The reason is that although an invalid node oder may prevent; /// the pipeliner from finding a pipelined schedule for arbitrary II,; /// it does not lead to the generation of incorrect code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:24,Performance,perform,perform,24,"// sort, so that we can perform a binary search",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:46,Energy Efficiency,schedul,scheduled,46,// instructions in circuits are allowed to be scheduled; // after both a successor and predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:320,Deployability,update,updates,320,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:167,Performance,load,load,167,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:301,Performance,load,load,301,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:126,Deployability,update,updated,126,"// Check that the instruction appears in the InstrChanges structure,; // which contains instructions that can have the offset updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:3,Deployability,Update,Update,3,// Update the base register and adjust the offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:109,Energy Efficiency,allocate,allocated,109,"// Look for an instruction of the form p' = op(p), which uses and defines; // two virtual registers that get allocated to the same physical register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Energy Efficiency,schedul,schedule,14,"/// After the schedule has been formed, call this function to combine; /// the instructions from the different stages/cycles. That is, this; /// function creates a schedule that represents a single iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:164,Energy Efficiency,schedul,schedule,164,"/// After the schedule has been formed, call this function to combine; /// the instructions from the different stages/cycles. That is, this; /// function creates a schedule that represents a single iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:91,Energy Efficiency,schedul,scheduled,91,"// Erase all the elements in the later stages. Only one iteration should; // remain in the scheduled list, and it contains all the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,Energy Efficiency,schedul,schedule,14,/// Print the schedule information to the given output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:53,Energy Efficiency,schedul,schedule,53,/// Utility function used for debugging to print the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:93,Availability,Mask,Masks,93,// We currently limit the resource kinds to 64 and below so that we can use; // uint64_t for Masks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,Availability,avail,available,42,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:64,Energy Efficiency,schedul,scheduling,64,"// Sort the instructions by the number of available choices for scheduling,; // least to most. Use the number of critical resources as the tie breaker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:23,Energy Efficiency,consumption,consumption,23,// Count each resource consumption and divide it by the number of units.; // ResMII is the max value among them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp:404,Usability,simpl,simple,404,"//===- MachinePostDominators.cpp -Machine Post Dominator Calculation ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements simple dominator construction algorithms for finding; // post dominators on machine functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePostDominators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegionInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:4,Usability,clear,clearVirtRegs,4,/// clearVirtRegs - Remove all virtual registers (after physreg assignment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:3,Deployability,Update,Update,3,// Update Prev pointer. This also works when Src was pointing to itself; // in a 1-element list. In that case Head == Dst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:28,Energy Efficiency,efficient,efficient,28,// TODO: This could be more efficient by bulk changing the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:179,Modifiability,extend,extend,179,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:153,Performance,optimiz,optimization,153,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:4,Usability,clear,clearKillFlags,4,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:78,Usability,clear,clear,78,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:88,Safety,avoid,avoid,88,"// The livein has no non-dbg uses. Drop it.; //; // It would be preferable to have isel avoid creating live-in; // records for unused arguments in the first place, but it's; // complicated by the debug info code for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:8,Availability,mask,masks,8,// Lane masks are only defined for vregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Energy Efficiency,Schedul,Scheduler,50,"//===- MachineScheduler.cpp - Machine Instruction Scheduler ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:400,Energy Efficiency,schedul,schedules,400,"//===- MachineScheduler.cpp - Machine Instruction Scheduler ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // MachineScheduler schedules machine instructions after phi elimination. It; // preserves LiveIntervals so it can be invoked before register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:49,Integrability,depend,depend,49,"/// In some situations a few uninteresting nodes depend on nearly all other; /// nodes in the graph, provide a cutoff to hide them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Safety,Avoid,Avoid,15,// NDEBUG; /// Avoid quadratic complexity in unusually large basic blocks by limiting the; /// size of the ready lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:105,Energy Efficiency,Schedul,Scheduling,105,//===----------------------------------------------------------------------===//; // Machine Instruction Scheduling Pass and Registry; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduler,29,/// Base class for a machine scheduler class that can run at any point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Energy Efficiency,schedul,scheduler,20,/// A dummy default scheduler factory indicates whether the scheduler; /// is overridden on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:60,Energy Efficiency,schedul,scheduler,60,/// A dummy default scheduler factory indicates whether the scheduler; /// is overridden on the command line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Energy Efficiency,schedul,scheduler,57,/// MachineSchedOpt allows command line selection of the scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,/// Instantiate a ScheduleDAGInstrs that will be owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduler,14,"// Select the scheduler, or set the default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:19,Energy Efficiency,schedul,scheduler,19,// Get the default scheduler set by the target for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:47,Energy Efficiency,schedul,scheduling,47,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:161,Energy Efficiency,schedul,scheduler,161,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:188,Modifiability,config,configure,188,/// Instantiate a ScheduleDAGInstrs for PostRA scheduling that will be owned by; /// the caller. We don't have a command line option to override the postRA; /// scheduler. The Target must configure it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Energy Efficiency,schedul,scheduler,18,// Get the postRA scheduler set by the target for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:723,Deployability,update,update,723,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:109,Energy Efficiency,schedul,scheduling,109,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:289,Energy Efficiency,schedul,scheduling,289,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:357,Energy Efficiency,schedul,scheduling,357,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:524,Energy Efficiency,schedul,schedulers,524,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:558,Energy Efficiency,schedul,scheduling,558,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:708,Energy Efficiency,schedul,scheduler,708,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:785,Energy Efficiency,Schedul,ScheduleDAGInstrs,785,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:900,Energy Efficiency,schedul,scheduling,900,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:770,Performance,cache,cached,770,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:341,Safety,avoid,avoids,341,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:404,Usability,simpl,simplifying,404,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:852,Usability,simpl,simpler,852,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:1006,Usability,simpl,simplicity,1006,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduler,28,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Performance,optimiz,optimization,73,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduler,28,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Performance,optimiz,optimization,73,"// Instantiate the selected scheduler for this target, function, and; // optimization level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:69,Energy Efficiency,schedul,scheduling,69,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:147,Energy Efficiency,schedul,scheduling,147,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:352,Energy Efficiency,schedul,scheduling,352,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:415,Energy Efficiency,schedul,scheduling,415,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:450,Energy Efficiency,schedul,scheduling,450,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:551,Energy Efficiency,schedul,scheduling,551,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:267,Integrability,depend,dependencies,267,"/// Return true of the given instruction should not be included in a scheduling; /// region.; ///; /// MachineScheduler does not currently support scheduling across calls. To; /// handle calls, the DAG builder needs to be modified to create register; /// anti/output dependencies on the registers clobbered by the call's regmask; /// operand. In PreRA scheduling, the stack pointer adjustment already prevents; /// scheduling across calls. In PostRA scheduling, we need the isCall to enforce; /// the boundary, but there would be no benefit to postRA scheduling across; /// calls this late anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,schedul,scheduling,27,/// A region of an MBB for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:48,Energy Efficiency,schedul,scheduling,48,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:114,Energy Efficiency,schedul,scheduling,114,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:173,Energy Efficiency,schedul,scheduling,173,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:268,Energy Efficiency,schedul,scheduling,268,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:329,Energy Efficiency,schedul,scheduling,329,"/// RegionBegin is the first instruction in the scheduling region, and; /// RegionEnd is either MBB->end() or the scheduling boundary after the; /// last instruction in the scheduling region. These iterators cannot refer; /// to instructions outside of the identified scheduling region because; /// those may be reordered before scheduling this region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid decrementing RegionEnd for blocks with no terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Energy Efficiency,schedul,scheduling,28,// It's possible we found a scheduling region that only has debug; // instructions. Don't bother scheduling these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:97,Energy Efficiency,schedul,scheduling,97,// It's possible we found a scheduling region that only has debug; // instructions. Don't bother scheduling these.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:467,Availability,down,down,467,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,Energy Efficiency,schedul,scheduling,24,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,scheduling,87,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:510,Energy Efficiency,Schedul,Scheduler,510,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:558,Energy Efficiency,schedul,schedule,558,"// Break the block into scheduling regions [I, RegionEnd). RegionEnd; // points to the scheduling boundary at the bottom of the region. The DAG; // does not include RegionEnd, but the region does (i.e. the next; // RegionEnd is above the previous RegionBegin). If the current block has; // no terminator then RegionEnd == MBB->end() for the bottom region.; //; // All the regions of MBB are first found and stored in MBBRegions, which; // will be processed (MBB) top-down if initialized with true.; //; // The Scheduler may insert instructions during either schedule() or; // exitRegion(), even for empty regions. So the local iterators 'I' and; // 'RegionEnd' are invalid across these calls. Instructions must not be; // added to other regions than the current one without updating MBBRegions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduler,14,"// Notify the scheduler of the region, even if we may skip scheduling; // it. Perhaps it still needs to be bundled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:59,Energy Efficiency,schedul,scheduling,59,"// Notify the scheduler of the region, even if we may skip scheduling; // it. Perhaps it still needs to be bundled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Skip empty scheduling regions (0 or 1 schedulable instructions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:41,Energy Efficiency,schedul,schedulable,41,// Skip empty scheduling regions (0 or 1 schedulable instructions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule a region: possibly reorder instructions.; // This invalidates the original region iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:85,Energy Efficiency,Schedul,ScheduleDAGMI,85,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:127,Energy Efficiency,schedul,scheduling,127,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:179,Energy Efficiency,schedul,scheduling,179,//===----------------------------------------------------------------------===//; // ScheduleDAGMI - Basic machine instruction scheduling. This is; // independent of PreRA/PostRA scheduling and involves no extra book-keeping for; // virtual registers.; // ===----------------------------------------------------------------------===/; // Provide a vtable anchor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,ReleaseSucc,4,"/// ReleaseSucc - Decrement the NumPredsLeft count of a successor. When; /// NumPredsLeft reaches zero, release the successor node.; ///; /// FIXME: Adjust SuccSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Deployability,release,release,104,"/// ReleaseSucc - Decrement the NumPredsLeft count of a successor. When; /// NumPredsLeft reaches zero, release the successor node.; ///; /// FIXME: Adjust SuccSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Energy Efficiency,schedul,scheduled,54,"// SU->TopReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,release,releaseSuccessors,4,/// releaseSuccessors - Call releaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Deployability,release,releaseSucc,29,/// releaseSuccessors - Call releaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,ReleasePred,4,"/// ReleasePred - Decrement the NumSuccsLeft count of a predecessor. When; /// NumSuccsLeft reaches zero, release the predecessor node.; ///; /// FIXME: Adjust PredSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:106,Deployability,release,release,106,"/// ReleasePred - Decrement the NumSuccsLeft count of a predecessor. When; /// NumSuccsLeft reaches zero, release the predecessor node.; ///; /// FIXME: Adjust PredSU height based on MinLatency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Energy Efficiency,schedul,scheduled,54,"// SU->BotReadyCycle was set to CurrCycle when it was scheduled. However,; // CurrCycle may have advanced since then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,release,releasePredecessors,4,/// releasePredecessors - Call releasePred on each of SU's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Deployability,release,releasePred,31,/// releasePredecessors - Call releasePred on each of SU's predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:100,Energy Efficiency,schedul,scheduling,100,"/// enterRegion - Called back from PostMachineScheduler::runOnMachineFunction; /// after crossing a scheduling boundary. [begin, end) includes all instructions; /// in the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:261,Energy Efficiency,schedul,scheduled,261,"/// enterRegion - Called back from PostMachineScheduler::runOnMachineFunction; /// after crossing a scheduling boundary. [begin, end) includes all instructions; /// in the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Energy Efficiency,schedul,scheduler,42,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:93,Energy Efficiency,schedul,scheduling,93,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Performance,perform,perform,116,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Availability,down,down,54,// Advance RegionBegin if the first instruction moves down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the instruction stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:2,Deployability,Update,UpdateFlags,2,/*UpdateFlags=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,schedul,scheduling,15,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:216,Energy Efficiency,schedul,scheduling,216,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:256,Energy Efficiency,schedul,schedulers,256,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:110,Usability,simpl,simplified,110,"/// Per-region scheduling driver, called back from; /// PostMachineScheduler::runOnMachineFunction. This is a simplified driver; /// that does not consider liveness or register pressure. It is useful for; /// PostRA scheduling and potentially other custom schedulers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Performance,queue,queue,104,// Initialize the strategy before modifying the DAG.; // This may initialize a DFSResult to be used for queue priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queues,20,// Initialize ready queues now that the DAG and priority data are finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:124,Deployability,update,updateQueues,124,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:223,Deployability,release,released,223,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,"// Notify the scheduling strategy before updating the DAG.; // This sets the scheduled node's ReadyCycle to CurrCycle. When updateQueues; // runs, it can then use the accurate ReadyCycle time to determine whether; // newly released nodes can move to the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,schedul,schedule,27,// A SUnit is ready to top schedule if it has no predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,schedule,30,// A SUnit is ready to bottom schedule if it has no successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:33,Energy Efficiency,schedul,scheduler,33,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,Performance,queue,queues,43,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:136,Deployability,Release,Release,136,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduling,29,"// Release all DAG roots for scheduling, not including EntrySU/ExitSU.; //; // Nodes with unreleased weak edges can still be roots.; // Release top roots in forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,// Release bottom roots in reverse order so the higher priority nodes appear; // first. This is more natural and slightly more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:127,Energy Efficiency,efficient,efficient,127,// Release bottom roots in reverse order so the higher priority nodes appear; // first. This is more natural and slightly more efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Energy Efficiency,schedul,scheduler,11,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Energy Efficiency,schedul,scheduling,34,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:21,Performance,queue,queues,21,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Release,Release,3,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,Energy Efficiency,schedul,scheduling,38,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Integrability,depend,dependent,11,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Energy Efficiency,schedul,scheduler,62,"/// Reinsert any remaining debug_values, just like the PostRA scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,schedule,29,// Bail off when there is no schedule model to query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,schedule,29,// Bail off when there is no schedule model to query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:85,Energy Efficiency,Schedul,ScheduleDAGMILive,85,//===----------------------------------------------------------------------===//; // ScheduleDAGMILive - Base class for MachineInstr scheduling with LiveIntervals; // preservation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:133,Energy Efficiency,schedul,scheduling,133,//===----------------------------------------------------------------------===//; // ScheduleDAGMILive - Base class for MachineInstr scheduling with LiveIntervals; // preservation.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:96,Energy Efficiency,schedul,scheduling,96,"/// enterRegion - Called back from MachineScheduler::runOnMachineFunction after; /// crossing a scheduling boundary. [begin, end) includes all instructions in; /// the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:257,Energy Efficiency,schedul,scheduled,257,"/// enterRegion - Called back from MachineScheduler::runOnMachineFunction after; /// crossing a scheduling boundary. [begin, end) includes all instructions in; /// the region, including the boundary itself and single-instruction regions; /// that don't get scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,ScheduleDAGMI,3,// ScheduleDAGMI initializes SchedImpl's per-region policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Energy Efficiency,schedul,scheduled,52,// Setup the register pressure trackers for the top scheduled and bottom; // scheduled regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,// Setup the register pressure trackers for the top scheduled and bottom; // scheduled regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Availability,Down,DownwardPressureDelta,64,// Close one end of the tracker so we can call; // getMaxUpward/DownwardPressureDelta before advancing across any; // instructions. This converts currently live regs into live ins/outs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Energy Efficiency,reduce,reduce,26,// For each live out vreg reduce the pressure change associated with other; // uses of the same vreg below the live-out reaching def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Energy Efficiency,schedul,scheduled,107,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Performance,Cache,Cache,3,// Cache the list of excess pressure sets in this region. This will also track; // the max pressure in the scheduled code for these sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,/// Update the PressureDiff array for liveness after scheduling this; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduling,53,/// Update the PressureDiff array for liveness after scheduling this; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:631,Deployability,update,update,631,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,schedul,schedule,4,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:105,Energy Efficiency,schedul,scheduling,105,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:206,Energy Efficiency,schedul,scheduling,206,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:369,Energy Efficiency,schedul,schedulers,369,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:476,Energy Efficiency,schedul,scheduling,476,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:512,Energy Efficiency,schedul,scheduler,512,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:546,Energy Efficiency,Schedul,ScheduleDAGMILive,546,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:344,Modifiability,extend,extended,344,"/// schedule - Called back from MachineScheduler::runOnMachineFunction; /// after setting up the current scheduling region. [RegionBegin, RegionEnd); /// only includes instructions that have DAG nodes, not scheduling boundaries.; ///; /// This is a skeletal driver, with all the functionality pushed into helpers,; /// so that it can be easily extended by experimental schedulers. Generally,; /// implementing MachineSchedStrategy should be sufficient to implement a new; /// scheduling algorithm. However, if a scheduler further subclasses; /// ScheduleDAGMILive then it will want to override this virtual method in order; /// to update any specialized state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:104,Performance,queue,queue,104,// Initialize the strategy before modifying the DAG.; // This may initialize a DFSResult to be used for queue priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queues,20,// Initialize ready queues now that the DAG and priority data are finalized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduling,14,// Notify the scheduling strategy after updating the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:311,Availability,avail,available,311,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Energy Efficiency,schedul,scheduling,62,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:336,Energy Efficiency,schedul,scheduler,336,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:1197,Energy Efficiency,schedul,scheduling,1197,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:585,Performance,latency,latency,585,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:124,Performance,latency,latency,124,"// Assume that a path spanning two iterations is a cycle, which could; // overestimate in strange cases. This allows cyclic latency to be; // estimated as the minimum slack of the vreg's depth or height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Energy Efficiency,schedul,scheduler,42,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,queue,queues,52,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:28,Deployability,update,update,28,/// Move an instruction and update register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update top scheduled pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:14,Energy Efficiency,schedul,scheduled,14,// Update top scheduled pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:143,Performance,load,loads,143,//===----------------------------------------------------------------------===//; // BaseMemOpClusterMutation - DAG post-processing to cluster loads or stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:74,Performance,load,loads,74,/// Post-process the DAG to create cluster edges between neighboring; /// loads or between neighboring stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:101,Availability,avail,available,101,// FIXME: Don't compare everything twice. Maybe use C++20 three way; // comparison instead when it's available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:164,Integrability,depend,dependent,164,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:352,Integrability,depend,dependencies,352,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Performance,load,loads,42,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:76,Performance,load,load,76,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:115,Performance,load,load,115,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:286,Performance,load,loads,286,"// end namespace llvm; // Sorting all the loads/stores first, then for each load/store, checking the; // following load/store one by one, until reach the first non-dependent one and; // call target hook to see if they can cluster.; // If FastCluster is enabled, we assume that, all the loads/stores have been; // preprocessed and now, they didn't have dependencies on each other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Integrability,depend,dependent,56,// Decision to cluster mem ops is taken based on target dependent logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:66,Testability,log,logic,66,// Decision to cluster mem ops is taken based on target dependent logic,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:21,Performance,load,load,21,// Seek for the next load/store to do the cluster.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Integrability,depend,dependency,52,// Skip if MemOpb has been clustered already or has dependency with; // MemOpa.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Integrability,depend,dependent,70,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:99,Performance,load,load,99,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:217,Performance,load,loads,217,// Copy successor edges from SUa to SUb. Interleaving computation; // dependent on SUa can prevent load combining due to register reuse.; // Predecessor edges do not need to be copied from SUb to SUa since; // nearby loads should have effectively the same inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:88,Energy Efficiency,schedul,scheduled,88,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:75,Integrability,depend,dependent,75,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:201,Integrability,depend,depend,201,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:279,Integrability,depend,dependency,279,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:350,Integrability,depend,dependency,350,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,Safety,avoid,avoid,45,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:112,Integrability,depend,dependency,112,"// We only want to cluster the mem ops that have the same ctrl(non-data); // pred so that they didn't have ctrl dependency for each other. But for; // store instrs, we can still cluster them if the pred is load instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:206,Performance,load,load,206,"// We only want to cluster the mem ops that have the same ctrl(non-data); // pred so that they didn't have ctrl dependency for each other. But for; // store instrs, we can still cluster them if the pred is load instr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:65,Performance,load,loads,65,/// Callback from DAG postProcessing to create cluster edges for loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Performance,load,loads,31,// Collect all the clusterable loads/stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:32,Integrability,depend,dependency,32,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,Performance,load,loads,11,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Safety,avoid,avoid,116,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Performance,load,loads,15,"// Sorting the loads/stores, so that, we can stop the cluster as early as; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:41,Performance,load,loads,41,// Trying to cluster all the neighboring loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Modifiability,variab,variable,157,"/// Post-process the DAG to create weak edges from all uses of a copy to; /// the one use that defines the copy's source vreg, most likely an induction; /// variable increment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:79,Energy Efficiency,schedul,scheduling,79,// RegionEndIdx is the slot index of the last non-debug instruction in the; // scheduling region. So we may have RegionBeginIdx == RegionEndIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:476,Modifiability,extend,extended,476,"// end namespace llvm; /// constrainLocalCopy handles two possibilities:; /// 1) Local src:; /// I0: = dst; /// I1: src = ...; /// I2: = dst; /// I3: dst = src (copy); /// (create pred->succ edges I0->I1, I2->I1); ///; /// 2) Local copy:; /// I0: dst = src (copy); /// I1: = dst; /// I2: src = ...; /// I3: = dst; /// (create pred->succ edges I1->I2, I3->I2); ///; /// Although the MachineScheduler is currently constrained to single blocks,; /// this algorithm should handle extended blocks. An EBB is a set of; /// contiguously numbered blocks such that the previous block in the EBB is; /// always the single predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:216,Energy Efficiency,schedul,scheduling,216,"// Check if either the dest or source is local. If it's live across a back; // edge, it's not local. Note that if both vregs are live across the back; // edge, we cannot successfully contrain the copy without cyclic scheduling.; // If both the copy's source and dest are local live intervals, then we; // should treat the dest as the global for the purpose of adding; // constraints. This adds edges from source's other uses to the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Energy Efficiency,schedul,schedulers,191,"//===----------------------------------------------------------------------===//; // MachineSchedStrategy helpers used by GenericScheduler, GenericPostScheduler; // and possibly other custom schedulers.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:149,Energy Efficiency,schedul,scheduling,149,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Performance,Latency,Latency,42,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,Safety,Hazard,HazardRec,9,"// A new HazardRec is created for each DAG and owned by SchedBoundary.; // Destroying and reconstructing it is very expensive though. So keep; // invalid, placeholder HazardRecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:167,Safety,Hazard,HazardRecs,167,"// A new HazardRec is created for each DAG and owned by SchedBoundary.; // Destroying and reconstructing it is very expensive though. So keep; // invalid, placeholder HazardRecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:81,Performance,latency,latency,81,// Track the maximum number of stall cycles that could arise either from the; // latency of a DAG edge or the number of cycles that a processor resource is; // reserved (SchedBoundary::ReservedCycles).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:312,Availability,avail,available,312,"/// Compute the stall cycles based on this SUnit's ready time. Heuristics treat; /// these ""soft stalls"" differently than the hard stall cycles based on CPU; /// resources and computed by checkHazard(). A fully in-order model; /// (MicroOpBufferSize==0) will not make use of this since instructions are not; /// available for scheduling until they are ready. However, a weaker in-order; /// model may use this for heuristics. For example, if a processor has in-order; /// behavior when reading certain resources, this may come into play.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:326,Energy Efficiency,schedul,scheduling,326,"/// Compute the stall cycles based on this SUnit's ready time. Heuristics treat; /// these ""soft stalls"" differently than the hard stall cycles based on CPU; /// resources and computed by checkHazard(). A fully in-order model; /// (MicroOpBufferSize==0) will not make use of this since instructions are not; /// available for scheduling until they are ready. However, a weaker in-order; /// model may use this for heuristics. For example, if a processor has in-order; /// behavior when reading certain resources, this may come into play.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:82,Energy Efficiency,schedul,scheduled,82,/// Compute the next cycle at which the given processor resource unit; /// can be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,schedul,scheduling,17,// For bottom-up scheduling add the cycles needed for the current operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,/// Compute the next cycle at which the given processor resource can be; /// scheduled. Returns the next cycle and the index of the processor resource; /// instance in the reserved cycles vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:103,Availability,avail,available,103,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Availability,avail,available,157,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:316,Availability,avail,available,316,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:513,Energy Efficiency,schedul,schedule,513,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:215,Safety,hazard,hazarding,215,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:240,Safety,hazard,hazarding,240,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:83,Energy Efficiency,schedul,scheduler,83,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:157,Energy Efficiency,Schedul,ScheduleHazardRecognizer,157,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:475,Energy Efficiency,schedul,scheduler,475,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,Safety,hazard,hazard,24,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:115,Safety,hazard,hazard,115,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:209,Safety,hazard,hazard,209,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:428,Safety,hazard,hazards,428,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:357,Testability,log,logic,357,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:450,Usability,simpl,simple,450,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:58,Performance,latency,latency,58,// Find the unscheduled node in ReadySUs with the highest latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:73,Energy Efficiency,schedul,scheduled,73,"// ReadyCycle was been bumped up to the CurrCycle when this node was; // scheduled, but CurrCycle may have been eagerly advanced immediately after; // scheduling, so may now be greater than ReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:151,Energy Efficiency,schedul,scheduling,151,"// ReadyCycle was been bumped up to the CurrCycle when this node was; // scheduled, but CurrCycle may have been eagerly advanced immediately after; // scheduling, so may now be greater than ReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Safety,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Security,interlock,interlocks,13,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,"// Update the current micro-ops, which will issue in the next cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Integrability,Depend,DependentLatency,13,// Decrement DependentLatency based on the next cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,Safety,Hazard,HazardRec,10,// Bypass HazardRec virtual calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,Performance,latency,latency,46,// Bypass getHazardType calls in case of long latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:78,Deployability,Release,ReleaseAtCycle,78,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:134,Deployability,pipeline,pipelined,134,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:187,Deployability,release,released,187,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:270,Deployability,pipeline,pipelined,270,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,Energy Efficiency,schedul,scheduled,45,/// Add the given processor resource to this scheduled zone.; ///; /// \param ReleaseAtCycle indicates the number of consecutive (non-pipelined); /// cycles during which this resource is released.; ///; /// \param AcquireAtCycle indicates the number of consecutive (non-pipelined); /// cycles at which the resource is aquired after issue (assuming no stalls).; ///; /// \return the next cycle at which the instruction may execute without; /// oversubscribing resources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update Executed resources counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:25,Energy Efficiency,schedul,scheduled,25,/// Move the boundary of scheduled code by one SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update the reservation table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Deployability,pipeline,pipeline,98,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,Energy Efficiency,schedul,scheduled,13,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:76,Energy Efficiency,schedul,scheduling,76,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:88,Usability,clear,clear,88,"// Calls are scheduled with their preceding instructions. For bottom-up; // scheduling, clear the pipeline state before emitting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Availability,avail,available,64,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling an instruction may have made pending instructions available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,// checkHazard should prevent scheduling multiple instructions per cycle that; // exceed the issue width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Energy Efficiency,schedul,scheduled,72,"// We don't currently model the OOO reorder buffer, so consider all; // scheduled MOps to be ""retired"". We do loosely model in-order resource; // latency. If this instruction uses an in-order resource, account for any; // likely stall cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:146,Performance,latency,latency,146,"// We don't currently model the OOO reorder buffer, so consider all; // scheduled MOps to be ""retired"". We do loosely model in-order resource; // latency. If this instruction uses an in-order resource, account for any; // likely stall cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update resource counts and critical resource.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,Energy Efficiency,schedul,scheduled,9,// Scale scheduled micro-ops for comparing with the critical resource.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:84,Availability,down,down,84,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Energy Efficiency,schedul,scheduling,89,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:131,Energy Efficiency,schedul,schedule,131,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:249,Usability,simpl,simply,249,"// For reserved resources, record the highest cycle using the resource.; // For top-down scheduling, this is the cycle in which we schedule this; // instruction plus the number of cycles the operations reserves the; // resource. For bottom-up is it simply the instruction's cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,// Update ExpectedLatency and DependentLatency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Integrability,Depend,DependentLatency,30,// Update ExpectedLatency and DependentLatency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Deployability,Update,Update,3,"// Update CurrMOps after calling bumpCycle to handle stalls, since bumpCycle; // resets CurrMOps. Loop to handle instructions with more MOps than issue in; // one cycle. Since we commonly reach the max MOps here, opportunistically; // bump the cycle to avoid uselessly checking everything in the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:253,Safety,avoid,avoid,253,"// Update CurrMOps after calling bumpCycle to handle stalls, since bumpCycle; // resets CurrMOps. Loop to handle instructions with more MOps than issue in; // one cycle. Since we commonly reach the max MOps here, opportunistically; // bump the cycle to avoid uselessly checking everything in the readyQ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,Energy Efficiency,reduce,reduce,159,// Bump the cycle count for issue group constraints.; // This must be done after NextCycle has been adjust for all other stalls.; // Calling bumpCycle(X) will reduce CurrMOps by one issue group and set; // currCycle to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Availability,avail,available,42,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Release,Release,4,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,queue,queue,52,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,Availability,avail,available,10,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Performance,queue,queue,20,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Safety,safe,safe,42,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:12,Performance,queue,queue,12,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:113,Safety,hazard,hazard,113,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Safety,hazard,hazard,42,// Defer any ready instrs that now have a hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Safety,Hazard,HazardRec,70,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:137,Safety,hazard,hazard,137,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:20,Testability,assert,assert,20,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Testability,assert,assert,57,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Performance,Queue,Queue,72,// This is useful information to dump after bumpNode.; // Note that the Queue contents are more useful before pickNodeFromQueue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:546,Availability,Avail,Available,546,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:245,Deployability,update,updated,245,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,schedule,87,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:274,Energy Efficiency,schedul,scheduling,274,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:317,Energy Efficiency,schedul,scheduled,317,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:368,Energy Efficiency,schedul,scheduled,368,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:223,Integrability,depend,dependent,223,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:625,Integrability,depend,dependent,625,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,Performance,latency,latency,22,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Performance,latency,latency-limited,107,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Performance,latency,latency,191,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:234,Performance,latency,latency,234,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:475,Performance,latency,latency,475,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:500,Performance,queue,queue,500,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:635,Performance,latency,latency,635,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:106,Energy Efficiency,schedul,scheduling,106,/// Returns true if the current cycle plus remaning latency is greater than; /// the critical path in the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,Performance,latency,latency,52,/// Returns true if the current cycle plus remaning latency is greater than; /// the critical path in the scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:86,Performance,latency,latency,86,"// The current cycle is already greater than the critical path, so we are; // already latency limited and don't need to compute the remaining latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:142,Performance,latency,latency,142,"// The current cycle is already greater than the critical path, so we are; // already latency limited and don't need to compute the remaining latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,schedul,scheduled,17,"// If we haven't scheduled anything yet, then we aren't latency limited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Performance,latency,latency,56,"// If we haven't scheduled anything yet, then we aren't latency limited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:31,Energy Efficiency,schedul,scheduling,31,/// Set the CandPolicy given a scheduling zone given the current resources and; /// latencies inside and outside the zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Performance,latency,latency,50,// Apply preemptive heuristics based on the total latency and resources; // inside and outside this zone. Potential stalls should be considered before; // following this policy.; // Compute the critical resource outside the zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:163,Energy Efficiency,schedul,scheduling,163,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Performance,latency,latency,29,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:84,Performance,latency,latency,84,"// Schedule aggressively for latency in PostRA mode. We don't check for; // acyclic latency during PostRA, and highly out-of-order processors will; // skip PostRA scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:72,Modifiability,refactor,refactor,72,"/// Return true if this heuristic determines order.; /// TODO: Consider refactor return type of these functions as integer or enum,; /// as we may need to differentiate whether TryCand is better than Cand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,Energy Efficiency,schedul,scheduled,116,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:172,Energy Efficiency,schedul,scheduled,172,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Performance,latency,latency,108,"// Prefer the candidate with the lesser depth, but only if one of them has; // depth greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Energy Efficiency,schedul,scheduled,118,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:174,Energy Efficiency,schedul,scheduled,174,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:110,Performance,latency,latency,110,"// Prefer the candidate with the lesser height, but only if one of them has; // height greater than the total latency scheduled so far, otherwise either; // of them could be scheduled now with no stall.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Safety,Hazard,HazardRecognizers,50,"// Initialize resource counts.; // Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:140,Safety,Hazard,HazardRecs,140,"// Initialize resource counts.; // Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:30,Energy Efficiency,schedul,scheduling,30,/// Initialize the per-region scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:159,Energy Efficiency,schedul,schedulable,159,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:96,Performance,optimiz,optimizations,96,"// For generic targets, we default to bottom-up, because it's simpler and more; // compile-time optimizations have been implemented in that direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:62,Usability,simpl,simpler,62,"// For generic targets, we default to bottom-up, because it's simpler and more; // compile-time optimizations have been implemented in that direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Energy Efficiency,schedul,scheduling,56,// Check -misched-topdown/bottomup can force or unforce scheduling direction.; // e.g. -misched-bottomup=false allows scheduling in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Energy Efficiency,schedul,scheduling,118,// Check -misched-topdown/bottomup can force or unforce scheduling direction.; // e.g. -misched-bottomup=false allows scheduling in both directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Deployability,release,release,53,// Cannot completely remove virtual function even in release mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:129,Energy Efficiency,drain,drain,129,"/// Set IsAcyclicLatencyLimited if the acyclic path is longer than the cyclic; /// critical path by more cycles than it takes to drain the instruction buffer.; /// We estimate an upper bounds on in-flight instructions as:; ///; /// CyclesPerIteration = max( CyclicPath, Loop-Resource-Height ); /// InFlightIterations = AcyclicPath / CyclesPerIteration; /// InFlightResources = InFlightIterations * LoopResources; ///; /// TODO: Check execution resources in addition to IssueCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,Energy Efficiency,schedul,scheduled,22,"// If we have already scheduled the physreg produce/consumer, immediately; // schedule the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:78,Energy Efficiency,schedul,schedule,78,"// If we have already scheduled the physreg produce/consumer, immediately; // schedule the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:58,Energy Efficiency,schedul,schedule,58,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,Integrability,depend,dependent,98,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:87,Energy Efficiency,schedul,scheduling,87,"// If we have a move immediate and all successors have been assigned, bias; // towards scheduling this later. Make sure all register defs are to; // physical registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:111,Energy Efficiency,efficient,efficient,111,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:520,Energy Efficiency,schedul,scheduled,520,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:547,Modifiability,extend,extending,547,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:239,Performance,queue,queue,239,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid exceeding the target's limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,Usability,simpl,simply,118,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:232,Usability,clear,clear,232,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:57,Energy Efficiency,schedul,schedule,57,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:74,Performance,latency,latency,74,"// For loops that are acyclic path limited, aggressively schedule for; // latency. Within an single cycle, whenever CurrMOps > 0, allow normal; // heuristics to take precedence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:46,Availability,down,downstream,46,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:94,Energy Efficiency,reduce,reduce,94,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:291,Energy Efficiency,schedul,scheduler,291,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Performance,optimiz,optimizations,70,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:191,Performance,Optimiz,Optimizations,191,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:225,Performance,load,loads,225,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:323,Performance,load,loads,323,// Keep clustered nodes together to encourage downstream peephole; // optimizations which may reduce resource requirements.; //; // This is a best effort to set things up for a post-RA pass. Optimizations; // like generating loads of multiple registers should ideally be done within; // the scheduler pass by combining the loads during DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid increasing the max pressure of the entire region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Integrability,depend,dependence,34,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Performance,latency,latency,26,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Performance,latency,latency,89,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:176,Energy Efficiency,schedul,scheduling,176,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:265,Energy Efficiency,schedul,scheduled,265,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:37,Performance,queue,queue,37,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:102,Performance,cache,cached,102,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:63,Performance,queue,queue,63,/// Pick the best candidate node from either the top or bottom queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Energy Efficiency,Schedul,Schedule,3,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:79,Energy Efficiency,efficient,efficient,79,"// Schedule as far as possible in the direction of no choice. This is most; // efficient, but also provides the best heuristics for CriticalPSets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Availability,down,down,15,"// Set the top-down policy based on the state of the current top zone and; // the instructions outside the zone, including the bottom zone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:56,Energy Efficiency,schedul,scheduled,56,// See if BotCand is still valid (because we previously scheduled from Top).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:38,Energy Efficiency,schedul,schedule,38,/// Pick the best node to balance the schedule. Implements MachineSchedStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:16,Energy Efficiency,schedul,scheduled,16,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:99,Energy Efficiency,schedul,scheduled,99,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Integrability,depend,dependence,55,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Deployability,Update,Update,4,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:164,Deployability,update,update,164,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Energy Efficiency,schedul,scheduler,15,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:39,Energy Efficiency,schedul,scheduling,39,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:132,Energy Efficiency,Schedul,ScheduleDAGMILive,132,"/// Update the scheduler's state after scheduling a node. This is the same node; /// that was just returned by pickNode(). However, ScheduleDAGMILive needs to; /// update it's state based on the current cycle before MachineSchedStrategy; /// does.; ///; /// FIXME: Eventually, we may bundle physreg copies rather than rescheduling; /// them here. See comments in biasPhysReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,Energy Efficiency,schedul,scheduler,43,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:92,Energy Efficiency,schedul,scheduler,92,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:48,Modifiability,extend,extend,48,// Register DAG post-processors.; //; // FIXME: extend the mutation API to allow earlier mutations to instantiate; // data and pass it to later mutations. Have a single mutation that gathers; // the interesting nodes in one pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Safety,Hazard,HazardRecognizers,18,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty,; // or are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:108,Safety,Hazard,HazardRecs,108,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty,; // or are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:60,Energy Efficiency,schedul,scheduling,60,"/// Apply a set of heuristics to a new candidate for PostRA scheduling.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:27,Energy Efficiency,consumption,consumption,27,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,schedule,55,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:34,Integrability,depend,dependence,34,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Performance,latency,latency,26,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Safety,Avoid,Avoid,3,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:26,Energy Efficiency,schedul,schedule,26,/// Pick the next node to schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Availability,down,down,15,"// Set the top-down policy based on the state of the current top zone and; // the instructions outside the zone, including the bottom zone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:64,Deployability,update,updated,64,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:17,Energy Efficiency,Schedul,ScheduleDAGMI,17,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Energy Efficiency,schedul,scheduled,35,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:77,Energy Efficiency,schedul,scheduled,77,/// Called after ScheduleDAGMI has scheduled an instruction and updated; /// scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:89,Energy Efficiency,Schedul,Scheduler,89,//===----------------------------------------------------------------------===//; // ILP Scheduler. Currently for experimental analysis of heuristics.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule based on the ILP metric.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:39,Deployability,update,updated,39,// Restore the heap in ReadyQ with the updated DFS results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Integrability,interface,interface,35,/// Implement MachineSchedStrategy interface.; /// -----------------------------------------; /// Callback to select the highest priority node from the ready Q.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:4,Energy Efficiency,Schedul,Scheduler,4,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,Energy Efficiency,schedul,scheduled,55,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:29,Energy Efficiency,schedul,scheduled,29,"/// Callback after a node is scheduled. Mark a newly scheduled tree, notify; /// DFSResults, and resort the priority Q.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:53,Energy Efficiency,schedul,scheduled,53,"/// Callback after a node is scheduled. Mark a newly scheduled tree, notify; /// DFSResults, and resort the priority Q.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:130,Testability,Test,Testing,130,//===----------------------------------------------------------------------===//; // Machine Instruction Shuffler for Correctness Testing; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:107,Energy Efficiency,schedul,scheduling,107,"/// Apply a less-than relation on the node order, which corresponds to the; /// instruction order prior to scheduling. IsReverse implements greater-than.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:167,Energy Efficiency,schedul,scheduled,167,// Using a less-than relation (SUnitOrder<false>) for the TopQ priority; // gives nodes with a higher number higher priority causing the latest; // instructions to be scheduled first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:8,Energy Efficiency,schedul,scheduling,8,"// When scheduling bottom-up, use greater-than as the queue priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:54,Performance,queue,queue,54,"// When scheduling bottom-up, use greater-than as the queue priority.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:35,Integrability,interface,interface,35,/// Implement MachineSchedStrategy interface.; /// -----------------------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:121,Energy Efficiency,Schedul,ScheduleDAGMILive,121,// !NDEBUG; //===----------------------------------------------------------------------===//; // GraphWriter support for ScheduleDAGMILive.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:708,Security,expose,exposed,708,"//===- MachineSink.cpp - Sinking for machine instructions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass moves instructions into successor blocks when possible, so that; // they aren't executed on paths where their results aren't needed.; //; // This pass is not intended to be a replacement or a complete alternative; // for an LLVM-IR-level sinking pass. It is only designed to sink simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:673,Usability,simpl,simple,673,"//===- MachineSink.cpp - Sinking for machine instructions -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass moves instructions into successor blocks when possible, so that; // they aren't executed on paths where their results aren't needed.; //; // This pass is not intended to be a replacement or a complete alternative; // for an LLVM-IR-level sinking pass. It is only designed to sink simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:123,Modifiability,variab,variable,123,"/// DBG_VALUE pointer and flag. The flag is true if this DBG_VALUE is; /// post-dominated by another DBG_VALUE of the same variable location.; /// This is necessary to detect sequences such as:; /// %0 = someinst; /// DBG_VALUE %0, !123, !DIExpression(); /// %1 = anotherinst; /// DBG_VALUE %1, !123, !DIExpression(); /// Where if %0 were to sink, the DBG_VAUE should not sink with it, as that; /// would re-order assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:168,Safety,detect,detect,168,"/// DBG_VALUE pointer and flag. The flag is true if this DBG_VALUE is; /// post-dominated by another DBG_VALUE of the same variable location.; /// This is necessary to detect sequences such as:; /// %0 = someinst; /// DBG_VALUE %0, !123, !DIExpression(); /// %1 = anotherinst; /// DBG_VALUE %1, !123, !DIExpression(); /// Where if %0 were to sink, the DBG_VAUE should not sink with it, as that; /// would re-order assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:20,Modifiability,variab,variables,20,/// Record of debug variables that have had their locations set in the; /// current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:4,Performance,Cache,Cached,4,/// Cached BB's register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:208,Deployability,update,updates,208,"/// Postpone the splitting of the given critical; /// edge (\p From, \p To).; ///; /// We do not split the edges on the fly. Indeed, this invalidates; /// the dominance information and thus triggers a lot of updates; /// of that information underneath.; /// Instead, we postpone all the splits after each iteration of; /// the main loop. That way, the information is at least valid; /// for the lifetime of an iteration.; ///; /// \return True if the edge is marked as toSplit, false otherwise.; /// False can be returned if, for instance, this is not profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:19,Usability,clear,clear,19,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:49,Integrability,depend,dependent,49,// Convergent operations may not be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:191,Usability,simpl,simplifies,191,// Don't sink defs/uses of hard registers or if the instruction defines more; // than one register.; // Don't sink more than two register uses - it'll cover most of the cases and; // greatly simplifies the register pressure checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:175,Performance,load,load,175,"// Scan uses of the destination register. Every use, except the last, must be; // a copy, with a chain of copies terminating with either a copy into a hard; // register, or a load/store instruction where the use is part of the; // address (*not* the stored value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:190,Modifiability,extend,extended,190,// If the register class of the register we are replacing is a superset; // of any of the register classes of the operands of the materialized; // instruction don't consider that live range extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:105,Availability,avail,available,105,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:244,Deployability,update,updated,244,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Performance,perform,performing,15,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:319,Usability,clear,clear,319,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:77,Modifiability,extend,extended,77,"// The operand registers of the ""sunk"" instruction have their live range; // extended and their kill flags may no longer be correct. Conservatively; // clear the kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:152,Usability,clear,clear,152,"// The operand registers of the ""sunk"" instruction have their live range; // extended and their kill flags may no longer be correct. Conservatively; // clear the kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:66,Modifiability,extend,extended,66,// The registers of the addressing mode may have their live range extended; // and their kill flags may no longer be correct. Conservatively clear the; // kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:141,Usability,clear,clear,141,// The registers of the addressing mode may have their live range extended; // and their kill flags may no longer be correct. Conservatively clear the; // kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Usability,Clear,Clear,3,"// Clear the StoreInstrCache, since we may invalidate it by erasing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:161,Usability,clear,clear,161,// Collect operands that need to be cleaned up because the registers no longer; // exist (in COPYs and debug instructions). We cannot delete instructions or; // clear operands while traversing register uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:29,Usability,clear,clear,29,// Delete the dead COPYs and clear operands in debug instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:44,Performance,load,loads,44,/// Return true if this machine instruction loads from global offset table or; /// constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:7,Usability,clear,clear,7,// Now clear any kill flags for recorded registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Performance,Cache,Cache,3,"// Cache all successors, sorted by frequency info and cycle depth.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:14,Modifiability,variab,variable,14,"// Record the variable for any DBG_VALUE, to avoid re-ordering any of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:45,Safety,avoid,avoid,45,"// Record the variable for any DBG_VALUE, to avoid re-ordering any of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Safety,Avoid,Avoid,3,// Avoid breaking back edge. From == To means backedge for single BB cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:122,Performance,Cache,CachedRegisterPressure,122,"// Currently to save compiling time, MBB's register pressure will not change; // in one ProcessBlock iteration because of CachedRegisterPressure. but MBB's; // register pressure is changed after sinking any instructions into it.; // FIXME: need a accurate and cheap register pressure estiminate model here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:63,Performance,cache,cache,63,// FIXME - If finding successor is compile time expensive then cache results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,Availability,alive,alive,46,"// If MI is in cycle and all its operands are alive across the whole cycle or; // if no operand sinking make register pressure set exceed limit, it is; // profitable to sink MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:119,Performance,cache,cached,119,"/// Get the sorted sequence of successors for this MachineBasicBlock, possibly; /// computing it if it was not already cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:39,Performance,cache,cache,39,// Do we have the sorted successors in cache ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:160,Energy Efficiency,allocate,allocated,160,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:36,Safety,safe,safe,36,// Virtual register uses are always safe to sink.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Safety,safe,safe,15,"// If it's not safe to move defs of the register class, then abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:61,Safety,abort,abort,61,"// If it's not safe to move defs of the register class, then abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:106,Availability,reliab,reliable,106,"// Otherwise, we should look at all the successors and decide which one; // we should sink to. If we have reliable block frequency information; // (frequency != 0) available, give successors with smaller frequencies; // higher priority, otherwise prioritize smaller cycle depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:164,Availability,avail,available,164,"// Otherwise, we should look at all the successors and decide which one; // we should sink to. If we have reliable block frequency information; // (frequency != 0) available, give successors with smaller frequencies; // higher priority, otherwise prioritize smaller cycle depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:35,Safety,safe,safe,35,"// Def is used locally, it's never safe to move this def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:12,Safety,safe,safe,12,// It's not safe to sink instructions to EH landing pad. Control flow into; // landing pad is implicitly defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:99,Performance,optimiz,optimization,99,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:283,Performance,optimiz,optimization,283,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:38,Usability,usab,usable,38,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,Availability,recover,recover,114,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,Safety,recover,recover,114,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:135,Modifiability,variab,variable,135,"// Sink a copy of debug users to the insert position. Mark the original; // DBG_VALUE location as 'undef', indicating that any earlier variable; // location should be terminated as we've optimised away the value at this; // point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:68,Performance,cache,cached,68,// Does these two blocks pair be queried before and have a definite cached; // result?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:88,Performance,Cache,Cache,88,"// We still have chance to sink MI if all stores between are not; // aliased to MI.; // Cache all store instructions, so that we don't need to go through; // all From reachable blocks for next load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:193,Performance,load,load,193,"// We still have chance to sink MI if all stores between are not; // aliased to MI.; // Cache all store instructions, so that we don't need to go through; // all From reachable blocks for next load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:32,Performance,cache,cache,32,"// If there is no store at all, cache the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:18,Usability,clear,clear,18,// Conservatively clear any kill flags on uses of sunk instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,Safety,safe,safe,46,/// SinkInstruction - Determine whether it is safe to sink the specified machine; /// instruction out of its current block into a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:49,Integrability,depend,dependent,49,// Convergent operations may not be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:47,Performance,perform,performance,47,"// Don't break implicit null checks. This is a performance heuristic, and not; // required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:245,Availability,down,down,245,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:393,Availability,down,down,393,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:20,Performance,load,load,20,// We cannot sink a load across a critical edge - there may be stores in; // other code paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:64,Modifiability,variab,variable,64,// Sink any users that don't pass any other DBG_VALUEs for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,Availability,recover,recovered,93,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,Safety,recover,recovered,93,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:19,Usability,clear,clear,19,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.; // Note that we have to clear the kill flags for any register this instruction; // uses as we may sink over another instruction which currently kills the; // used registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:123,Usability,clear,clear,123,"// Conservatively, clear any kill flags, since it's possible that they are no; // longer correct.; // Note that we have to clear the kill flags for any register this instruction; // uses as we may sink over another instruction which currently kills the; // used registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,Usability,clear,clear,15,// Remember to clear kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:657,Integrability,wrap,wrapping,657,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:1440,Integrability,wrap,wrapping,1440,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:500,Safety,avoid,avoids,500,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:584,Security,expose,exposes,584,"//===----------------------------------------------------------------------===//; // This pass is not intended to be a replacement or a complete alternative; // for the pre-ra machine sink pass. It is only designed to sink COPY; // instructions which should be handled after RA.; //; // This pass sinks COPY instructions into a successor block, if the COPY is not; // used in the current block and the COPY is live-in to a single successor; // (i.e., doesn't require the COPY to be duplicated). This avoids executing the; // copy on paths where their results aren't needed. This also exposes; // additional opportunites for dead copy elimination and shrink wrapping.; //; // These copies were either not handled by or are inserted after the MachineSink; // pass. As an example of the former case, the MachineSink pass cannot sink; // COPY instructions with allocatable source registers; for AArch64 these type; // of copy instructions are frequently used to move function parameters (PhyReg); // into virtual registers in the entry block.; //; // For the machine IR below, this pass will sink %w19 in the entry into its; // successor (%bb.1) because %w19 is only live-in in %bb.1.; // %bb.0:; // %wzr = SUBSWri %w1, 1; // %w19 = COPY %w0; // Bcc 11, %bb.2; // %bb.1:; // Live Ins: %w19; // BL @fun; // %w0 = ADDWrr %w0, %w19; // RET %w0; // %bb.2:; // %w0 = COPY %wzr; // RET %w0; // As we sink %w19 (CSR in AArch64) into %bb.1, the shrink-wrapping pass will be; // able to see %bb.0 as a candidate.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:204,Safety,safe,safe,204,"// FIXME: instead of isUse(), readsReg() would be a better fix here,; // For example, we can ignore modifications in reg with undef. However,; // it's not perfectly clear if skipping the internal read is safe in all; // other targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:165,Usability,clear,clear,165,"// FIXME: instead of isUse(), readsReg() would be a better fix here,; // For example, we can ignore modifications in reg with undef. However,; // it's not perfectly clear if skipping the internal read is safe in all; // other targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:58,Safety,avoid,avoid,58,"// We must sink this DBG_VALUE if its operand is sunk. To avoid searching; // for DBG_VALUEs later, record them when they're encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:54,Integrability,depend,dependency,54,// Don't sink the COPY if it would violate a register dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Usability,Clear,Clear,3,// Clear the kill flag if SrcReg is killed between MI and the end of the; // block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp:39,Performance,optimiz,optimization,39,"//===- MachineSizeOpts.cpp - code size optimization related code ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp:435,Performance,optimiz,optimization,435,"//===- MachineSizeOpts.cpp - code size optimization related code ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:48,Deployability,Update,Update,48,"//===- MachineSSAUpdater.cpp - Unstructured SSA Update Tool ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MachineSSAUpdater class. It's based on SSAUpdater; // class in lib/Transforms/Utils.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:74,Deployability,update,updates,74,/// Initialize - Reset this object to get ready for a new set of SSA; /// updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:59,Availability,avail,available,59,/// AddAvailableValue - Indicate that a rewritten value is available in the; /// specified block with the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:652,Availability,Avail,AvailableVals,652,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:696,Modifiability,rewrite,rewriter,696,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:44,Modifiability,variab,variable,44,"// If there is no definition of the renamed variable in this block, just use; // GetValueAtEndOfBlock to do our work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:4,Modifiability,Rewrite,RewriteUse,4,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:17,Modifiability,Rewrite,Rewrite,17,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp:74,Availability,Avail,AvailableVals,74,"// end namespace llvm; /// GetValueAtEndOfBlockInternal - Check to see if AvailableVals has an entry; /// for the specified BB and if so, return it. If not, construct SSA form by; /// first calculating the required placement of PHIs and then inserting new; /// PHIs where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:390,Security,hash,hashing,390,"//===- lib/CodeGen/MachineStableHash.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:459,Security,hash,hash,459,"//===- lib/CodeGen/MachineStableHash.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:13,Security,hash,hash,13,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:78,Security,hash,hash,78,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:111,Security,hash,hashing,111,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:132,Testability,test,testing,132,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:24,Security,hash,hash,24,// Build up a buffer of hash code components.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Security,Hash,Hash,9,// TODO: Hash more stuff like block alignment and branch probabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Security,Hash,Hash,9,// TODO: Hash lots more stuff like function alignment and stack objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:462,Testability,test,tests,462,"//===- MachineStripDebug.cpp - Strip debug info ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file This removes debug info from everything. It can be used to ensure; /// tests can be debugified without affecting the output MIR.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:167,Integrability,depend,depends,167,"// FIXME: We should remove all of them. However, AArch64 emits an; // invalid `DBG_VALUE $lr` with only one operand instead of; // the usual three and has a test that depends on it's; // preservation. Preserve it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:157,Testability,test,test,157,"// FIXME: We should remove all of them. However, AArch64 emits an; // invalid `DBG_VALUE $lr` with only one operand instead of; // the usual three and has a test that depends on it's; // preservation. Preserve it for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:302,Integrability,depend,depend,302,//===----------------------------------------------------------------------===//; // Fixed block information; //===----------------------------------------------------------------------===//; //; // The number of instructions in a basic block and the CPU resources used by; // those instructions don't depend on any given trace strategy.; /// Compute the resource usage in basic block MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace above MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:79,Deployability,update,update,79,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace above MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:56,Usability,simpl,simple,56,// Compute resources from trace above. The top block is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace below MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:79,Deployability,update,update,79,// Update resource-related information in the TraceBlockInfo for MBB.; // Only update resources related to the trace below MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:391,Availability,down,downwards,391,"//===----------------------------------------------------------------------===//; // Trace Selection Strategies; //===----------------------------------------------------------------------===//; //; // A trace selection strategy is implemented as a sub-class of Ensemble. The; // trace through a block B is computed by two DFS traversals of the CFG; // starting from B. One upwards, and one downwards. During the upwards DFS,; // pickTracePred() is called on the post-ordered blocks. During the downwards; // DFS, pickTraceSucc() is called in a post-order.; //; // We never allow traces that leave loops, but we do allow traces to enter; // nested loops. We also never allow traces to contain back-edges.; //; // This means that a loop header can never appear above the center block of a; // trace, except as the trace head. Below the center block, loop exiting edges; // are banned.; //; // Return true if an edge from the From loop to the To loop is leaving a loop.; // Either of To and From can be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:495,Availability,down,downwards,495,"//===----------------------------------------------------------------------===//; // Trace Selection Strategies; //===----------------------------------------------------------------------===//; //; // A trace selection strategy is implemented as a sub-class of Ensemble. The; // trace through a block B is computed by two DFS traversals of the CFG; // starting from B. One upwards, and one downwards. During the upwards DFS,; // pickTracePred() is called on the post-ordered blocks. During the downwards; // DFS, pickTraceSucc() is called in a post-order.; //; // We never allow traces that leave loops, but we do allow traces to enter; // nested loops. We also never allow traces to contain back-edges.; //; // This means that a loop header can never appear above the center block of a; // trace, except as the trace head. Below the center block, loop exiting edges; // are banned.; //; // Return true if an edge from the From loop to the To loop is leaving a loop.; // Either of To and From can be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new Ensemble on demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:233,Safety,avoid,avoid,233,"//===----------------------------------------------------------------------===//; // Trace building; //===----------------------------------------------------------------------===//; //; // Traces are built by two CFG traversals. To avoid recomputing too much, use a; // set abstraction that confines the search to the current loop, and doesn't; // revisit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:9,Availability,down,downwards,9,// Run a downwards post-order search for the trace end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Usability,Clear,Clear,3,"// Clear any per-instruction data. We only have to do this for BadMBB itself; // because the instructions in that block may change. Other blocks may be; // invalidated, but their instructions will stay the same, so there is no; // need to erase the Cycle entries. They will be overwritten when we; // recompute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:90,Integrability,Depend,Dependencies,90,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:256,Integrability,depend,dependencies,256,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:416,Integrability,depend,dependencies,416,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:455,Integrability,depend,dependency,455,//===----------------------------------------------------------------------===//; // Data Dependencies; //===----------------------------------------------------------------------===//; //; // Compute the depth and height of each instruction based on data dependencies; // and instruction latencies. These cycle numbers assume that the CPU can issue; // an infinite number of instructions per cycle as long as their dependencies; // are ready.; // A data dependency is represented as a defining MI and operand numbers on the; // defining and using MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:50,Integrability,depend,dependencies,50,// end anonymous namespace; // Get the input data dependencies that must be ready before UseMI can issue.; // Return true if UseMI has any physreg operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,Integrability,depend,dependencies,22,"// Get the input data dependencies of a PHI instruction, using Pred as the; // preferred predecessor.; // This will add at most one dependency to Deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:132,Integrability,depend,dependency,132,"// Get the input data dependencies of a PHI instruction, using Pred as the; // preferred predecessor.; // This will add at most one dependency to Deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:54,Integrability,depend,dependencies,54,// No predecessor at the beginning of a trace. Ignore dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:116,Availability,down,downwards,116,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:48,Deployability,update,update,48,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:12,Integrability,depend,dependencies,12,// Identify dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update RegUnits to reflect live registers after UseMI.; // First kills.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:217,Integrability,depend,dependency,217,"/// The length of the critical path through a trace is the maximum of two path; /// lengths:; ///; /// 1. The maximum height+depth over all instructions in the trace center block.; ///; /// 2. The longest cross-block dependency chain. For small blocks, it is; /// possible that the critical path through the trace doesn't include any; /// instructions in the block.; ///; /// This function computes the second number from the live-in list of the; /// center block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies outside the current trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,// Collect all data dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,Integrability,depend,dependencies,22,"// Filter and process dependencies, computing the earliest issue cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies from outside the current trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Performance,latency,latency,7,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:62,Performance,latency,latency,62,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update critical path length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Availability,down,down,34,"// Go through trace blocks in top-down order, stopping after the center block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,Integrability,depend,dependencies,20,// Identify physreg dependencies for MI when scanning instructions upwards.; // Return the issue height of MI after considering any live regunits.; // Height is the issue height computed from virtual register dependencies alone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:209,Integrability,depend,dependencies,209,// Identify physreg dependencies for MI when scanning instructions upwards.; // Return the issue height of MI after considering any live regunits.; // Height is the issue height computed from virtual register dependencies alone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:77,Deployability,update,update,77,"// This is a def of Reg. Remove corresponding entries from RegUnits, and; // update MI Height to consider the physreg dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:118,Integrability,depend,dependencies,118,"// This is a def of Reg. Remove corresponding entries from RegUnits, and; // update MI Height to consider the physreg dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:37,Integrability,depend,dependency,37,"// We may not know the UseMI of this dependency, if it came from the; // live-in list. SchedModel can handle a NULL UseMI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:33,Deployability,Update,Update,33,// Now we know the height of MI. Update any regunits read.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:30,Performance,latency,latency,30,// Adjust height by Dep.DefMI latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update Heights[DefMI] to be the maximum height seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:45,Deployability,update,updated,45,// Just add the register. The height will be updated later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:63,Deployability,update,updates,63,/// Compute instruction heights in the trace through MBB. This updates MBB and; /// the blocks below it in the trace. It is assumed that the trace has already; /// been computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Performance,latency,latency,34,"// For virtual registers, the def latency is included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:31,Performance,latency,latency,31,"// For register units, the def latency is not included because we don't; // know the def yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Integrability,depend,dependencies,7,// Get dependencies from PHIs in the trace successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:106,Integrability,depend,dependencies,106,"// If MBB is the last block in the trace, and it has a back-edge to the; // loop header, get loop-carried dependencies from PHIs in the header. For; // that purpose, pretend that all the loop header PHIs have height 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:32,Integrability,depend,depend,32,"// Don't process PHI deps. They depend on the specific predecessor, and; // we'll get them when visiting the predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:29,Integrability,depend,dependencies,29,// There may also be regunit dependencies to include in the height.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update the required height of any virtual registers read by MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update critical path length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:3,Deployability,Update,Update,3,// Update virtual live-in heights. They were added by addLiveIns() with a 0; // height because the final height isn't known until now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,Performance,latency,latency,7,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:62,Performance,latency,latency,62,// Add latency if DefMI is a real instruction. Transients get latency 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Energy Efficiency,schedul,schedule,34,// Assume issue width 1 without a schedule model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:34,Energy Efficiency,schedul,schedule,34,// Assume issue width 1 without a schedule model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Safety,Avoid,Avoid,3,// Avoid querying the MachineFunctionProperties for each operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:27,Availability,avail,available,27,// Analysis information if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:148,Availability,error,error,148,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:54,Usability,clear,clearing,54,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:168,Usability,clear,clear,168,// If we're mid-GlobalISel and we already triggered the fallback path then; // it's expected that the MIR is somewhat broken but that's ok since we'll; // reset it and clear the FailedISel attribute in ResetMachineFunctions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:61,Availability,avail,available,61,// We don't want to verify LiveVariables if LiveIntervals is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:275,Integrability,message,message,275,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:294,Safety,avoid,avoid,294,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:96,Usability,clear,clear,96,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:92,Energy Efficiency,reduce,reduce,92,"// Don't report a type mismatch if there is no actual mismatch, only a; // type missing, to reduce noise:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:107,Usability,clear,clear,107,// Only the first valid type for a type index will be printed: don't; // overwrite it later so it's always clear which type was expected:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Safety,Avoid,Avoid,3,// Avoid out of bounds in checks below. This was already reported earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:11,Performance,load,loads,11,// Generic loads and stores must have a single MachineMemOperand; // describing that access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:85,Security,access,access,85,// Generic loads and stores must have a single MachineMemOperand; // describing that access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:75,Integrability,interface,interface,75,"// TODO: Should verify number of def and use operands, but the current; // interface requires passing in IR types for mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:121,Testability,test,tests,121,"// A fully-formed DBG_VALUE must have a location. Ignore partially formed; // DBG_VALUEs: these are convenient to use in tests, but should never get; // generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:110,Performance,scalab,scalable,110,"// The next two checks allow COPY between physical and virtual registers,; // when the virtual register has a scalable size and the physical register; // has a fixed size. These checks allow COPY between *potentialy* mismatched; // sizes. However, once RegisterBankSelection occurs, MachineVerifier should; // be able to resolve a fixed size for the scalable vector, and at that; // point this function will know for sure whether the sizes are mismatched; // and correctly report a size mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:350,Performance,scalab,scalable,350,"// The next two checks allow COPY between physical and virtual registers,; // when the virtual register has a scalable size and the physical register; // has a fixed size. These checks allow COPY between *potentialy* mismatched; // sizes. However, once RegisterBankSelection occurs, MachineVerifier should; // be able to resolve a fixed size for the scalable vector, and at that; // point this function will know for sure whether the sizes are mismatched; // and correctly report a size mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:270,Safety,Detect,DetectDeadLanes,270,"// This is a generic virtual register.; // Do not allow undef uses for generic virtual registers. This ensures; // getVRegDef can never fail and return null on a generic register.; //; // FIXME: This restriction should probably be broadened to all SSA; // MIR. However, DetectDeadLanes/ProcessImplicitDefs technically still; // run on the SSA function just before phi elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:231,Energy Efficiency,allocate,allocated,231,"// Debug value instruction is permitted to use undefined vregs.; // This is a performance measure to skip the overhead of immediately; // pruning unused debug operands. The final undef substitution occurs; // when debug values are allocated in LDVImpl::handleDebugValue, so; // these verifications always apply after this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:78,Performance,perform,performance,78,"// Debug value instruction is permitted to use undefined vregs.; // This is a performance measure to skip the overhead of immediately; // pruning unused debug operands. The final undef substitution occurs; // when debug values are allocated in LDVImpl::handleDebugValue, so; // these verifications always apply after this pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:95,Performance,load,loading,95,"// For a memory-to-memory move, we need to check if the frame; // index is used for storing or loading, by inspecting the; // memory operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:483,Performance,perform,performed,483,"// The LR can correspond to the whole reg and its def slot is not obliged; // to be the same as the MO' def slot. E.g. when we check here ""normal""; // subreg MO but there is other EC subreg MO in the same instruction so the; // whole reg has EC def slot and differs from the currently checked MO' def; // slot. For example:; // %0 [16e,32r:0) 0@16e L..3 [16e,32r:0) 0@16e L..C [16r,32r:0) 0@16r; // Check that there is an early-clobber def of the same superregister; // somewhere is performed in visitMachineFunctionAfter()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:13,Performance,cache,cached,13,// Check the cached regunit intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:12,Availability,mask,masked,12,// Kill any masked registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:344,Energy Efficiency,efficient,efficient,344,"// This implements a set of registers that serves as a filter: can filter other; // sets by passing through elements not in the filter and blocking those that; // are. Any filter implicitly includes the full set of physical registers upon; // creation, thus filtering them all out. The filter itself as a set only grows,; // and needs to be as efficient as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:175,Availability,down,down,175,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:62,Deployability,continuous,continuously,62,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:32,Performance,perform,performs,32,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:157,Performance,tune,tuned,157,"// Reserving space in sets once performs better than doing so continuously; // and pays easily for double look-ups (even in Dense with SparseUniverseMax; // tuned all the way down) and double iteration (the second one is over a; // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:474,Energy Efficiency,efficient,efficient,474,"// VRegs indexed within SparseUniverseMax are tracked by Sparse, those beyound; // are tracked by Dense. The only purpose of the threashold and the Dense set; // is to have a reasonably growing memory usage in pathological cases (large; // number of very sparse VRegFilter instances live at the same time). In; // practice even in the worst-by-execution time cases having all elements; // tracked by Sparse (very large SparseUniverseMax scenario) tends to be more; // space efficient than if tracked by Dense. The threashold is set to keep the; // worst-case memory usage within 2x of figures determined empirically for; // ""all Dense"" scenario in such worst-by-execution-time cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:30,Availability,avail,available,30,// Now check liveness info if available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:59,Availability,Alive,AliveBlocks,59,// Our vregsRequired should be identical to LiveVariables' AliveBlocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:18,Performance,cache,cached,18,// Verify all the cached regunit intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:60,Availability,mask,mask,60,// An operand %0:sub0 reads %0:sub1..n. Invert the lane; // mask for subregister defs. Read-undef defs will be handled by; // readsReg below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:109,Performance,perform,perform,109,"// Make sure that the corresponding machine operand for a ""dead"" live; // range has the dead flag. We cannot perform this check for subregister; // liveranges as partially dead values are allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Deployability,Update,Update,3,// Update stack state by checking contents of MBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:439,Energy Efficiency,schedul,scheduling,439,"//===- MacroFusion.cpp - Macro Fusion -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the implementation of the DAG scheduling mutation; /// to pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:91,Energy Efficiency,Schedul,ScheduleDAGInstrs,91,"// Though the reachability checks above could be made more generic,; // perhaps as part of ScheduleDAGInstrs::addEdge(), since such edges are valid,; // the extra computation cost makes it less interesting in general cases.; // Create a single weak edge between the adjacent instrs. The only effect is; // to cause bottom-up scheduling to heavily prioritize the clustered instrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:325,Energy Efficiency,schedul,scheduling,325,"// Though the reachability checks above could be made more generic,; // perhaps as part of ScheduleDAGInstrs::addEdge(), since such edges are valid,; // the extra computation cost makes it less interesting in general cases.; // Create a single weak edge between the adjacent instrs. The only effect is; // to cause bottom-up scheduling to heavily prioritize the clustered instrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:302,Energy Efficiency,schedul,scheduled,302,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:104,Integrability,depend,dependencies,104,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:139,Integrability,depend,dependent,139,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:224,Integrability,depend,dependent,224,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:241,Integrability,depend,dependencies,241,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:14,Performance,latency,latency,14,// Adjust the latency between both instrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:105,Energy Efficiency,schedul,scheduled,105,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:13,Integrability,depend,dependencies,13,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:48,Integrability,depend,dependent,48,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:102,Energy Efficiency,schedul,scheduled,102,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:25,Integrability,depend,dependent,25,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:42,Integrability,depend,dependencies,42,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:60,Integrability,depend,dependency,60,"// ExitSU comes last by design, which acts like an implicit dependency; // between ExitSU and any bottom root in the graph. We should transfer; // this to FirstSU as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:33,Energy Efficiency,schedul,scheduling,33,"// For each of the SUnits in the scheduling block, try to fuse the instr in; // it with one in its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:47,Energy Efficiency,schedul,scheduling,47,"/// Implement the fusion of instr pairs in the scheduling DAG,; /// anchored at the instr in AnchorSU..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:44,Integrability,depend,dependencies,44,// Explorer for fusion candidates among the dependencies of the anchor instr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:10,Integrability,depend,dependencies,10,// Ignore dependencies other than data or strong ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp:51,Integrability,wrap,wrapper,51,"//===- MBFIWrapper.cpp - MachineBlockFrequencyInfo wrapper ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class keeps track of branch frequencies of newly created blocks and; // tail-merged blocks. Used by the TailDuplication and MachineBlockPlacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MBFIWrapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:669,Energy Efficiency,schedul,scheduling,669,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:728,Energy Efficiency,reduce,reduce,728,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:774,Energy Efficiency,schedul,schedules,774,"//===-------------- MIRCanonicalizer.cpp - MIR Canonicalizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to employ a canonical code transformation so; // that code compiled with slightly different IR passes can be diffed more; // effectively than otherwise. This is done by renaming vregs in a given; // LiveRange in a canonical way. This pass also does a pseudo-scheduling to; // move defs closer to their use inorder to reduce diffs caused by slightly; // different schedules.; //; // Basic Usage:; //; // llc -o - -run-pass mir-canonicalizer example.mir; //; // Reorders instructions canonically.; // Renames virtual register operands canonically.; // Strips certain MIR artifacts (optionally).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp:238,Deployability,patch,patch,238,// Not folding COPY instructions if regbankselect has not set the RCs.; // Why are we only considering Register Classes? Because the verifier; // sometimes gets upset if the register classes don't match even if the; // types do. A future patch might add COPY folding for matching types in; // pre-registerbankselect code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRCanonicalizerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:83,Security,hash,hash,83,"// TODO(xur): Remove this once we switch to ImprovedFSDiscriminator.; // Compute a hash value using debug line number, and the line numbers from the; // inline stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:59,Usability,simpl,simplify,59,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators including this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:3,Availability,Mask,Mask,3,// Mask of discriminators for bits specific to this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp:510,Testability,test,tests,510,"//===----------------------- MIRNamer.cpp - MIR Namer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The purpose of this pass is to rename virtual register operands with the goal; // of making it easier to author easier to read tests for MIR. This pass reuses; // the vreg renamer used by MIRCanonicalizerPass.; //; // Basic Usage:; //; // llc -o - -run-pass mir-namer example.mir; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRNamerPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:4,Integrability,Synchroniz,Synchronization,4,/// Synchronization scope names registered with LLVMContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:33,Testability,assert,asserted,33,// Check whether the register is asserted in regmask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:19,Modifiability,variab,variable,19,// Print the debug variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp:31,Performance,load,load,31,// Machine memory operands can load/store to/from constant value pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:445,Performance,load,loader,445,"//===-------- MIRSampleProfile.cpp: MIRSampleFDO (For FSAFDO) -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the implementation of the MIRSampleProfile loader, mainly; // for flow sensitive SampleFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:3,Performance,Load,Load,3,// Load pseudo probe descriptors for probe-based function samples.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:355,Availability,mainten,maintenance,355,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:10,Performance,load,load,10,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:139,Performance,load,loading,139,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:294,Usability,undo,undo,294,"// Do not load non-FS profiles. A line or probe can get a zero-valued; // discriminator at certain pass which could result in accidentally loading; // the corresponding base counter in the non-FS profile, while a non-zero; // discriminator would end up getting zero samples. This could in turn undo; // the sample distribution effort done by previous BFI maintenance and the; // probe distribution factor work for pseudo probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashVRegs,3,/* HashVRegs */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashConstantPoolIndices,3,/* HashConstantPoolIndices */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Security,Hash,HashMemOperands,3,/* HashMemOperands */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:10,Security,hash,hashable,10,// Gets a hashable artifact from a given MachineOperand (ie an unsigned).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:226,Security,hash,hash,226,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:419,Security,hash,hashed,419,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:146,Testability,test,test,146,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:100,Security,hash,hash,100,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:166,Security,hash,hashes,166,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:193,Security,hash,hash,193,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Safety,Avoid,Avoid,3,"// Avoid non regs, instructions defining physical regs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:38,Security,hash,hash,38,"/// Given an Instruction, construct a hash of the operands; /// of the instructions along with the opcode.; /// When dealing with virtual registers, just hash the opcode of; /// the instruction defining that vreg.; /// Handle immediates, registers (physical and virtual) explicitly,; /// and return a common value for the other cases.; /// Instruction will be named in the following scheme; /// bb<block_no>_hash_<collission_count>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:154,Security,hash,hash,154,"/// Given an Instruction, construct a hash of the operands; /// of the instructions along with the opcode.; /// When dealing with virtual registers, just hash the opcode of; /// the instruction defining that vreg.; /// Handle immediates, registers (physical and virtual) explicitly,; /// and return a common value for the other cases.; /// Instruction will be named in the following scheme; /// bb<block_no>_hash_<collission_count>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:4,Performance,Perform,Perform,4,"/// Perform replacing of registers based on the <old,new> vreg map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:40,Integrability,depend,depending,40,"/// Same as the above, but sets a BBNum depending on BB traversal that; /// will be used as prefix for the vreg names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:436,Integrability,inject,injection,436,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML eviction advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:436,Security,inject,injection,436,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML eviction advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:23,Deployability,release,release,23,// Generated header in release (AOT) mode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Integrability,inject,injection,42,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Security,inject,injection,42,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:131,Testability,log,log,131,"// #ifdef LLVM_HAVE_TFLITE; /// The score injection pass.; /// This pass calculates the score for a function and inserts it in the log, but; /// this happens only in development mode. It's a no-op otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Performance,Perform,Performs,4,/// Performs this pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:68,Availability,error,error,68,// The model can only accept a specified number of opcodes and will error it if; // fed an opcode it hasn't seen before. This constant sets the current cutoff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:39,Availability,mask,mask,39,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:188,Availability,mask,mask,188,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:111,Integrability,contract,contract,111,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:234,Safety,avoid,avoid,234,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Usability,learn,learns,13,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:110,Availability,avail,available,110,"// The ML advisor will typically have a sparse input to the evaluator, because; // various phys regs won't be available. It's easier (maintenance-wise) to; // bulk-reset the state of the evaluator each time we are about to use it; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:134,Availability,mainten,maintenance-wise,134,"// The ML advisor will typically have a sparse input to the evaluator, because; // various phys regs won't be available. It's easier (maintenance-wise) to; // bulk-reset the state of the evaluator each time we are about to use it; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:42,Deployability,release,release,42,/// The ML evictor (commonalities between release and development mode),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:81,Availability,error,error,81,"// The assumption is that if the Runner could not be constructed, we emit-ed; // error, and we shouldn't be asking for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:111,Testability,log,log,111,"/// This just calls Evaluate on the Runner, but in the development mode; /// case, if we're just capturing the log of the default advisor, it needs; /// to call the latter instead, so we need to pass all the necessary; /// parameters for it. In the development case, it will also log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:280,Testability,log,log,280,"/// This just calls Evaluate on the Runner, but in the development mode; /// case, if we're just capturing the log of the default advisor, it needs; /// to call the latter instead, so we need to pass all the necessary; /// parameters for it. In the development case, it will also log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:44,Energy Efficiency,allocate,allocated,44,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Performance,Load,Load,4,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:28,Usability,learn,learn,28,"// Point-in-time: we didn't learn this, so we always delegate to the; // default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:159,Testability,log,logging,159,"// Hold on to a default advisor for:; // 1) the implementation of canEvictHintInterference, because we didn't; // learn that nuance yet; 2) for bootstrapping (logging) in the development; // mode case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:114,Usability,learn,learn,114,"// Hold on to a default advisor for:; // 1) the implementation of canEvictHintInterference, because we didn't; // learn that nuance yet; 2) for bootstrapping (logging) in the development; // mode case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:43,Deployability,Release,Release,43,// ===================================; // Release (AOT) - specifics; // ===================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:130,Testability,log,log,130,// ===================================; // Development mode-specifics; // ===================================; //; // Features we log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:255,Availability,error,error,255,"// The function pass manager would run all the function passes for a; // function, so we assume the last context belongs to this function. If; // this invariant ever changes, we can implement at that time switching; // contexts. At this point, it'd be an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Testability,log,log,13,"// We always log the output; in particular, if we're not evaluating, we; // don't have an output spec json file. That's why we handle the; // 'normal' output separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:68,Performance,load,load,68,"// OK, so if we made it this far, this LR is an eviction candidate, load its; // features.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,Availability,avail,available,13,"// Number of available candidates - if 0, no need to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:86,Availability,avail,available,86,// Make sure we don't have leftover partial state from an attempt where we; // had no available candidates and bailed out early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:128,Availability,mask,mask,128,"// Track the index->register mapping because AllocationOrder doesn't do that; // and we'd have to scan it.; // Also track their mask, to write asserts/debug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:143,Testability,assert,asserts,143,"// Track the index->register mapping because AllocationOrder doesn't do that; // and we'd have to scan it.; // Also track their mask, to write asserts/debug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:140,Usability,simpl,simpler,140,"// Track the largest value of features seen during this eviction session. We; // only normalize (some of) the float features, but it's just simpler to; // dimension 'Largest' to all the features, especially since we have the; // 'DoNotNormalize' list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:134,Availability,avail,available,134,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:148,Availability,mask,mask,148,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:293,Performance,load,load,293,"// Same overal idea as in the default eviction policy - we visit the values; // of AllocationOrder one at a time. If it's not legally available, we mask; // off the corresponding feature column (==do nothing because we already; // reset all the features to 0) Use Pos to capture the column we load; // features at - in AllocationOrder order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:33,Usability,learn,learn,33,"// Nothing to decide, nothing to learn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:53,Availability,mask,masked,53,"// If we must find eviction, the candidate should be masked out of the; // decision making process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:57,Availability,mask,mask,57,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:7,Integrability,contract,contract,7,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:106,Safety,avoid,avoid,106,"// If the segments are not overlapping, we need to move to the beginning; // index of the next segment to avoid having instructions not attached to; // any register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:58,Testability,log,logging,58,"// Find the index of the selected PhysReg. We need it for logging,; // otherwise this is wasted cycles (but so would starting development mode; // without a model nor logging)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:167,Testability,log,logging,167,"// Find the index of the selected PhysReg. We need it for logging,; // otherwise this is wasted cycles (but so would starting development mode; // without a model nor logging)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:94,Testability,log,log,94,"// TODO(mtrofin): when we support optional rewards, this can go away. In the; // meantime, we log the ""pretend"" reward (0) for the previous observation; // before starting a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:461,Testability,test,testing,461,"//===- MLRegAllocEvictAdvisor.cpp - ML eviction advisor -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Function declarations of utilities related to feature extraction for unit; // testing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:3,Testability,Log,Logically,3,"// Logically, we can think of the feature set given to the evaluator as a 2D; // matrix. The rows are the features (see next). The columns correspond to the; // interferences. We treat the candidate virt reg as an 'interference', too, as; // its feature set is the same as that of the interferring ranges. So we'll have; // MaxInterferences + 1 columns and by convention, we will use the last column; // for the virt reg seeking allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h:71,Modifiability,variab,variable,71,"// The number of instructions that a specific live range might have is variable,; // but we're passing in a single matrix of instructions and tensorflow saved; // models only support a fixed input size, so we have to cap the number of; // instructions that can be passed along. The specific value was derived from; // experimentation such that the majority of eviction problems would be; // completely covered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:436,Integrability,inject,injection,436,"//===- MLRegAllocPriorityAdvisor.cpp - ML priority advisor-----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML priority advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:436,Security,inject,injection,436,"//===- MLRegAllocPriorityAdvisor.cpp - ML priority advisor-----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the ML priority advisor and reward injection pass; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:81,Availability,error,error,81,"// The assumption is that if the Runner could not be constructed, we emit-ed; // error, and we shouldn't be asking for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:43,Deployability,Release,Release,43,// ===================================; // Release (AOT) - specifics; // ===================================,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:130,Testability,log,log,130,// ===================================; // Development mode-specifics; // ===================================; //; // Features we log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:255,Availability,error,error,255,"// The function pass manager would run all the function passes for a; // function, so we assume the last context belongs to this function. If; // this invariant ever changes, we can implement at that time switching; // contexts. At this point, it'd be an error",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:16,Testability,log,logs,16,// Save all the logs (when requested).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:13,Testability,log,log,13,"// We always log the output; in particular, if we're not evaluating, we; // don't have an output spec json file. That's why we handle the; // 'normal' output separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp:94,Testability,log,log,94,"// TODO(mtrofin): when we support optional rewards, this can go away. In the; // meantime, we log the ""pretend"" reward (0) for the previous observation; // before starting a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocPriorityAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Deployability,pipeline,pipeline,37,"//===- ModuloSchedule.cpp - Software pipeline schedule expansion ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:46,Energy Efficiency,schedul,schedule,46,"//===- ModuloSchedule.cpp - Software pipeline schedule expansion ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:251,Deployability,pipeline,pipelined,251,"// Remember the registers that are used in different stages. The index is; // the iteration, or stage, that the instruction is scheduled in. This is; // a map between register names in the original block and the names created; // in each stage of the pipelined loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,Energy Efficiency,schedul,scheduled,127,"// Remember the registers that are used in different stages. The index is; // the iteration, or stage, that the instruction is scheduled in. This is; // a map between register names in the original block and the names created; // in each stage of the pipelined loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:85,Deployability,update,updated,85,// The renaming destination by Phis for the registers across stages.; // This map is updated during Phis generation to point to the most recent; // renaming destination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:52,Deployability,pipeline,pipeline,52,// Generate the prolog instructions that set up the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:51,Deployability,pipeline,pipelined,51,"// Rearrange the instructions to generate the new, pipelined loop,; // and update register names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:75,Deployability,update,update,75,"// Rearrange the instructions to generate the new, pipelined loop,; // and update register names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:59,Deployability,update,update,59,"// Copy any terminator instructions to the new kernel, and update; // names as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:52,Deployability,pipeline,pipeline,52,// Generate the epilog instructions to complete the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:50,Modifiability,variab,variables,50,// Remove dead instructions due to loop induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Deployability,pipeline,pipeline,17,/// Generate the pipeline prolog code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Deployability,pipeline,pipeline,17,/// Generate the pipeline epilog code. The epilog code finishes the iterations; /// that were started in either the prolog or the kernel. We create a basic; /// block for each stage that needs to complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:34,Integrability,depend,depending,34,// Add instructions to the epilog depending on the current block.; // Process instructions in original program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:51,Deployability,update,updated,51,// Instructions with memoperands in the epilog are updated with; // conservative values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:58,Deployability,pipeline,pipelined,58,/// Generate Phis for the specific block in the generated pipelined code.; /// This function looks at the Phis from the original code to guide the; /// creation of new Phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:137,Usability,guid,guide,137,/// Generate Phis for the specific block in the generated pipelined code.; /// This function looks at the Phis from the original code to guide the; /// creation of new Phis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:113,Integrability,depend,depends,113,"// Compute the stage number for the initial value of the Phi, which; // comes from the prolog. The prolog to use depends on to which kernel/; // epilog that we're adding the Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:126,Energy Efficiency,schedul,scheduled,126,"// Adjust the number of Phis needed depending on the number of prologs left,; // and the distance from where the Phi is first scheduled. The number of; // Phis cannot exceed the number of prolog stages. Each stage can; // potentially define two values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:36,Integrability,depend,depending,36,"// Adjust the number of Phis needed depending on the number of prologs left,; // and the distance from where the Phi is first scheduled. The number of; // Phis cannot exceed the number of prolog stages. Each stage can; // potentially define two values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:237,Energy Efficiency,schedul,scheduled,237,"// In the epilog, we may need to look back one stage to get the correct; // Phi name, because the epilog and prolog blocks execute the same stage.; // The correct name is from the previous block only when the Phi has; // been completely scheduled prior to the epilog, and Phi value is not; // needed in multiple stages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:78,Energy Efficiency,schedul,scheduled,78,// Adjust the computations below when the phi and the loop definition; // are scheduled in different stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:26,Energy Efficiency,schedul,scheduled,26,"// If the Phi hasn't been scheduled, then use the initial Phi operand; // value. Otherwise, use the scheduled version of the instruction. This; // is a little complicated when a Phi references another Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:100,Energy Efficiency,schedul,scheduled,100,"// If the Phi hasn't been scheduled, then use the initial Phi operand; // value. Otherwise, use the scheduled version of the instruction. This; // is a little complicated when a Phi references another Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Energy Efficiency,schedul,scheduled,37,// Check if the Phi has already been scheduled in a prolog stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:37,Energy Efficiency,schedul,scheduled,37,"// Check if the Phi has already been scheduled, but the loop instruction; // is either another Phi, or doesn't occur in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:159,Energy Efficiency,schedul,scheduled,159,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:122,Integrability,depend,depends,122,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:114,Energy Efficiency,schedul,scheduled,114,"// Check if we can reuse an existing Phi. This occurs when a Phi; // references another Phi, and the other Phi is scheduled in an; // earlier stage. We can try to reuse an existing Phi up until the last; // stage of the current Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Deployability,Update,Update,3,// Update the map with the new Phi name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:45,Deployability,pipeline,pipelined,45,"// We define the Phis after creating the new pipelined code, so; // we need to rename the Phi values in scheduled instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:104,Energy Efficiency,schedul,scheduled,104,"// We define the Phis after creating the new pipelined code, so; // we need to rename the Phi values in scheduled instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:23,Energy Efficiency,schedul,scheduled,23,"// If the Phi has been scheduled, use the new name for rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:125,Energy Efficiency,schedul,scheduled,125,// Check if we need to rename any uses that occurs after the loop. The; // register to replace depends on whether the Phi is scheduled in the; // epilog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:95,Integrability,depend,depends,95,// Check if we need to rename any uses that occurs after the loop. The; // register to replace depends on whether the Phi is scheduled in the; // epilog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:20,Integrability,depend,dependent,20,"// In the kernel, a dependent Phi uses the value from this Phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Deployability,Update,Update,3,// Update the map with the new Phi name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:72,Energy Efficiency,schedul,scheduling,72,// Check if we need to rename a Phi that has been eliminated due to; // scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:59,Deployability,pipeline,pipelined,59,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:168,Deployability,pipeline,pipelined,168,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:132,Energy Efficiency,schedul,scheduled,132,/// Generate Phis for the specified block in the generated pipelined code.; /// These are new Phis needed because the definition is scheduled after the; /// use in the pipelined sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:18,Energy Efficiency,schedul,scheduled,18,// An instruction scheduled in stage 0 and is used after the loop; // requires a phi in the epilog for the last definition from either; // the kernel or prolog.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:40,Energy Efficiency,Schedul,Scheduled,40,"// Example for; // Org:; // %Org = ... (Scheduled at Stage#0, NumPhi = 2); //; // Prolog0 (Stage0):; // %Clone0 = ...; // Prolog1 (Stage1):; // %Clone1 = ...; // Kernel (Stage2):; // %Phi0 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi1 = Phi %Clone0, Prolog1, %Phi0, Kernel; // %Clone2 = ...; // Epilog0 (Stage3):; // %Phi2 = Phi %Clone1, Prolog1, %Clone2, Kernel; // %Phi3 = Phi %Clone0, Prolog1, %Phi0, Kernel; // Epilog1 (Stage4):; // %Phi4 = Phi %Clone0, Prolog0, %Phi2, Epilog0; //; // VRMap = {0: %Clone0, 1: %Clone1, 2: %Clone2}; // VRMapPhi (after Kernel) = {0: %Phi1, 1: %Phi0}; // VRMapPhi (after Epilog0) = {0: %Phi3, 1: %Phi2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:20,Deployability,update,update,20,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:48,Integrability,depend,depend,48,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:95,Modifiability,variab,variable,95,"/// Remove instructions that generate values with no uses.; /// Typically, these are induction variable operations that generate values; /// used in the loop itself. A dead instruction has a definition with; /// no uses, or uses that occur in the original loop only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,Safety,safe,safe,17,"// Check if it's safe to remove the instruction due to side effects.; // We can, and want to, remove Phis here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Deployability,Update,Update,4,/// Update the memory operand with a new offset when the pipeliner; /// generates a new copy of the instruction that refers to a; /// different memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:57,Deployability,pipeline,pipeliner,57,/// Update the memory operand with a new offset when the pipeliner; /// generates a new copy of the instruction that refers to a; /// different memory location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:38,Deployability,pipeline,pipelined,38,"/// Clone the instruction for the new pipelined loop and update the; /// memory operands, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:57,Deployability,update,update,57,"/// Clone the instruction for the new pipelined loop and update the; /// memory operands, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:38,Deployability,pipeline,pipelined,38,"/// Clone the instruction for the new pipelined loop. If needed, this; /// function updates the instruction using the values saved in the; /// InstrChanges structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:84,Deployability,update,updates,84,"/// Clone the instruction for the new pipelined loop. If needed, this; /// function updates the instruction using the values saved in the; /// InstrChanges structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Deployability,Update,Update,4,/// Update the machine instruction with new virtual registers. This; /// function may change the definitions and/or uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:34,Energy Efficiency,schedul,scheduled,34,// The loop value hasn't yet been scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:53,Energy Efficiency,schedul,scheduled,53,"// The loop value is another phi, which has not been scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:49,Energy Efficiency,schedul,scheduled,49,"// The loop value is another phi, which has been scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:117,Energy Efficiency,schedul,scheduled,117,"/// Rewrite the Phi values in the specified block to use the mappings; /// from the initial operand. Once the Phi is scheduled, we switch; /// to using the loop value instead of the Phi value, so those names; /// do not need to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the Phi values in the specified block to use the mappings; /// from the initial operand. Once the Phi is scheduled, we switch; /// to using the loop value instead of the Phi value, so those names; /// do not need to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:25,Energy Efficiency,schedul,scheduled,25,"/// Rewrite a previously scheduled instruction to use the register value; /// from the new instruction. Make sure the instruction occurs in the; /// basic block, and we don't change the uses in the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a previously scheduled instruction to use the register value; /// from the new instruction. Make sure the instruction occurs in the; /// basic block, and we don't change the uses in the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,Energy Efficiency,schedul,scheduled,31,// Rewrite uses that have been scheduled already to use the new; // Phi register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite uses that have been scheduled already to use the new; // Phi register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:29,Energy Efficiency,schedul,scheduled,29,// This is the stage for the scheduled instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:7,Energy Efficiency,schedul,scheduled,7,"// The scheduled instruction occurs before the scheduled Phi, and the; // Phi is not loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:47,Energy Efficiency,schedul,scheduled,47,"// The scheduled instruction occurs before the scheduled Phi, and the; // Phi is not loop carried.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:62,Energy Efficiency,schedul,schedule,62,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:4,Modifiability,Rewrite,Rewrites,4,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,Performance,perform,perform,127,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:81,Energy Efficiency,schedul,schedule,81,// Reg is used by MI. Return the new register MI should use to adhere to the; // schedule. Insert phis as necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:31,Energy Efficiency,schedul,schedule,31,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:61,Energy Efficiency,schedul,schedule,61,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:265,Energy Efficiency,schedul,schedule,265,"// Rearrange the loop to be in schedule order. Note that the schedule may; // contain instructions that are not owned by the loop block (InstrChanges and; // friends), so we gracefully handle unowned instructions and delete any; // instructions that weren't in the schedule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:28,Energy Efficiency,schedul,scheduled,28,// At this point all of the scheduled instructions are between FirstMI; // and the end of the block. Kill from the first non-phi to FirstMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:25,Usability,simpl,simple,25,// Non-phi producers are simple to remap. Insert as many phis as the; // difference between the consumer and producer stages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:196,Deployability,pipeline,pipeliner,196,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:8,Energy Efficiency,schedul,schedule,8,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:118,Energy Efficiency,schedul,scheduled,118,"// This schedule is only representable if ProducerStage == ConsumerStage+1.; // In addition, Consumer's cycle must be scheduled after Producer in the; // rescheduled loop. This is enforced by the pipeliner's ASAP and ALAP; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:18,Modifiability,variab,variables,18,// Silence unused variables in non-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:35,Testability,assert,asserts,35,// Silence unused variables in non-asserts mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:200,Modifiability,rewrite,rewrite,200,// Peel off the first phi from Defaults and insert a phi between producer; // and consumer. This phi will not be at the front of the block so we; // consider it illegal. It will only exist during the rewrite process; it; // needs to exist while we peel off prologs because these could take the; // default value. After that we can replace all uses with the loop producer; // value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:100,Energy Efficiency,schedul,scheduled,100,// The consumer optionally consumes LoopProducer in the same iteration; // (because the producer is scheduled at an earlier cycle than the consumer); // or the initial value. To facilitate this we create an illegal block here; // by embedding a phi in the middle of the block. We will fix this up; // immediately prior to pruning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:41,Modifiability,rewrite,rewrite,41,"// Found a phi taking undef as input, so rewrite it to take InitReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:44,Deployability,pipeline,pipelined,44,"/// Describes an operand in the kernel of a pipelined loop. Characteristics of; /// the operand are discovered, such as how many in-loop PHIs it has to jump; /// through and defaults for these phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:93,Safety,avoid,avoid,93,// Helper to clone Phi instructions into the destination block. We clone Phi; // greedily to avoid combinatorial explosion of Phi instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:97,Modifiability,variab,variable,97,// Keep track at which iteration each phi belongs to. We need it to know; // what version of the variable to use during prologue/epilogue stitching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:56,Deployability,update,updated,56,// Move stage one block at a time so that Phi nodes are updated correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:50,Performance,optimiz,optimize,50,"// Now all remapping has been done, we're free to optimize the generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:39,Modifiability,rewrite,rewrite,39,// Clone all phis in BB into NewBB and rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:133,Availability,error,error,133,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:12,Energy Efficiency,schedul,schedule,12,// Dump the schedule before we invalidate and remap all its instructions.; // Stash it in a string so we can print it if we found an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:16,Performance,optimiz,optimized,16,// The expander optimized away the kernel. We can't do any useful checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:35,Energy Efficiency,Schedul,Scheduler,35,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:473,Energy Efficiency,Schedul,ScheduleHazardRecognizer,473,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp:448,Integrability,wrap,wrapper,448,"//===- MultiHazardRecognizer.cpp - Scheduler Support ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MultiHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:7,Performance,Optimiz,OptimizePHIs,7,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:26,Performance,Optimiz,Optimize,26,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:393,Performance,optimiz,optimizes,393,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:106,Performance,optimiz,optimizations,106,"// Find dead PHI cycles and PHI cycles that can be replaced by a single; // value. InstCombine does these optimizations, but DAG legalization may; // introduce new opportunities, e.g., when i64 values are split up for; // 32-bit targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:4,Performance,Optimiz,OptimizeBB,4,/// OptimizeBB - Remove dead PHI cycles and PHI cycles that can be replaced by; /// a single value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp:51,Performance,multi-thread,multi-thread,51,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp:183,Safety,avoid,avoid,183,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:8,Deployability,Patch,PatchableFunction,8,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:32,Deployability,Patch,Patchable,32,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp:454,Deployability,patch,patchable-function,454,"//===-- PatchableFunction.cpp - Patchable prologues for LLVM -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements edits function bodies in place to support the; // ""patchable-function"" attribute.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PatchableFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:535,Modifiability,extend,extended,535,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1760,Modifiability,Rewrite,Rewrite,1760,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:40,Performance,Optimiz,Optimizations,40,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:383,Performance,Perform,Perform,383,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:400,Performance,optimiz,optimizations,400,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:445,Performance,Optimiz,Optimize,445,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:473,Performance,Optimiz,Optimization,473,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:747,Performance,optimiz,optimization,747,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:874,Performance,Optimiz,Optimize,874,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:903,Performance,Optimiz,Optimization,903,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1486,Performance,Optimiz,Optimize,1486,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1495,Performance,Load,Loads,1495,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1510,Performance,Load,Loads,1510,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1563,Performance,load,load,1563,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1590,Performance,load,loads,1590,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1682,Performance,Optimiz,Optimize,1682,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1791,Safety,avoid,avoid,1791,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Performance,Optimiz,Optimize,3,// Optimize Extensions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:290,Modifiability,rewrite,rewrite,290,"/// Helper class to track the possible sources of a value defined by; /// a (chain of) copy related instructions.; /// Given a definition (instruction and definition index), this class; /// follows the use-def chain to find successive suitable sources.; /// The given source can be used to rewrite the definition into; /// def = COPY src.; ///; /// For instance, let us consider the following snippet:; /// v0 =; /// v2 = INSERT_SUBREG v1, v0, sub0; /// def = COPY v2.sub0; ///; /// Using a ValueTracker for def = COPY v2.sub0 will give the following; /// suitable sources:; /// v2.sub0 and v0.; /// Then, def can be rewritten into def = COPY v0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:32,Performance,perform,perform,32,/// MachineRegisterInfo used to perform tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:37,Performance,perform,perform,37,/// Optional TargetInstrInfo used to perform some complex tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:46,Availability,avail,available,46,"/// Following the use-def chain, get the next available source; /// for the tracked value.; /// \return A ValueTrackerResult containing a set of registers; /// and sub registers with tracked values. A ValueTrackerResult with; /// an empty set of registers means no source was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:11,Availability,error,error,11,"// It's an error to translate this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1026 = SUBREG_TO_REG 0, %reg1024, 4; //; // into this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1027 = COPY %reg1025:4; // %reg1026 = SUBREG_TO_REG 0, %reg1027, 4; //; // The problem here is that SUBREG_TO_REG is there to assert that an; // implicit zext occurs. It doesn't insert a zext instruction. If we allow; // the COPY here, it will give us the value after the <sext>, not the; // original value of %reg1024 before <sext>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:319,Testability,assert,assert,319,"// It's an error to translate this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1026 = SUBREG_TO_REG 0, %reg1024, 4; //; // into this:; //; // %reg1025 = <sext> %reg1024; // ...; // %reg1027 = COPY %reg1025:4; // %reg1026 = SUBREG_TO_REG 0, %reg1027, 4; //; // The problem here is that SUBREG_TO_REG is there to assert that an; // implicit zext occurs. It doesn't insert a zext instruction. If we allow; // the COPY here, it will give us the value after the <sext>, not the; // original value of %reg1024 before <sext>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:18,Modifiability,extend,extend,18,// We may want to extend the live range of the extension result in order; // to replace these uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:54,Modifiability,extend,extend,54,// Both will be live out of the def MBB anyway. Don't extend live range of; // the extension result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Extend,Extend,3,// Extend the liveness of the extension result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:137,Availability,down,down,137,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:28,Modifiability,extend,extended,28,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:62,Modifiability,extend,extend,62,"// Look for PHI uses of the extended result, we don't want to extend the; // liveness of a PHI input. It breaks all kinds of assumptions down; // stream. A PHI use is expected to be the kill of its source values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:32,Usability,clear,clear,32,"// About to add uses of DstReg, clear DstReg's kill flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:111,Performance,optimiz,optimize,111,"// If this instruction is a comparison against zero and isn't comparing a; // physical register, we can try to optimize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:14,Performance,optimiz,optimize,14,// Attempt to optimize the comparison instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize a select instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Usability,simpl,simpler,15,/// Check if a simpler conditional branch can be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:781,Availability,avail,available,781,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:153,Modifiability,Rewrite,RewriteMap,153,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:678,Modifiability,rewrite,rewrite,678,"/// Try to find the next source that share the same register file; /// for the value defined by \p Reg and \p SubReg.; /// When true is returned, the \p RewriteMap can be used by the client to; /// retrieve all Def -> Use along the way up to the next source. Any found; /// Use that is not itself a key for another entry, is the next source to; /// use. During the search for the next source, multiple sources can be found; /// given multiple incoming sources of a PHI instruction. In this case, we; /// look in each PHI source for the next source; all found next sources must; /// share the same register file as \p Reg and \p SubReg. The client should; /// then be capable to rewrite all intermediate PHIs to get the next source.; /// \return False if no alternative sources are available. True otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:89,Safety,abort,abort,89,"// Follow the chain of copies until we find a more suitable source, a phi; // or have to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Safety,Abort,Abort,3,// Abort at the end of a chain (without finding a suitable source).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:66,Safety,avoid,avoid,66,// An existent entry with multiple sources is a PHI cycle we must avoid.; // Otherwise it's an entry with a valid next source we already found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:10,Modifiability,extend,extend,10,"// Do not extend the live-ranges of physical registers as they add; // constraints to the register allocator. Moreover, if we want to extend; // the live-range of a physical register, unlike SSA virtual register,; // we will have to check that they aren't redefine before the related use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:134,Modifiability,extend,extend,134,"// Do not extend the live-ranges of physical registers as they add; // constraints to the register allocator. Moreover, if we want to extend; // the live-range of a physical register, unlike SSA virtual register,; // we will have to check that they aren't redefine before the related use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:66,Performance,optimiz,optimize,66,"// If we did not find a more suitable source, there is nothing to optimize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Modifiability,extend,extended,15,"// Since we're extended the lifetime of RegPair.Reg, clear the; // kill flags to account for that and make RegPair.Reg reaches; // the new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:53,Usability,clear,clear,53,"// Since we're extended the lifetime of RegPair.Reg, clear the; // kill flags to account for that and make RegPair.Reg reaches; // the new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Integrability,Interface,Interface,4,/// Interface to query instructions amenable to copy rewriting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:606,Modifiability,rewrite,rewrite,606,"/// Get the next rewritable source (SrcReg, SrcSubReg) and; /// the related value that it affects (DstReg, DstSubReg).; /// A source is considered rewritable if its register class and the; /// register class of the related DstReg may not be register; /// coalescer friendly. In other words, given a copy-like instruction; /// not all the arguments may be returned at rewritable source, since; /// some arguments are none to be register coalescer friendly.; ///; /// Each call of this method moves the current source to the next; /// rewritable source.; /// For instance, let CopyLike be the instruction to rewrite.; /// CopyLike has one definition and one source:; /// dst.dstSubIdx = CopyLike src.srcSubIdx.; ///; /// The first call will give the first rewritable source, i.e.,; /// the only source this instruction has:; /// (SrcReg, SrcSubReg) = (src, srcSubIdx).; /// This source defines the whole definition, i.e.,; /// (DstReg, DstSubReg) = (dst, dstSubIdx).; ///; /// The second and subsequent calls will return false, as there is only one; /// rewritable source.; ///; /// \return True if a rewritable source has been found, false otherwise.; /// The output arguments are valid if and only if true is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the current source with \p NewReg and \p NewSubReg if possible.; /// \return True if the rewriting was possible, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewriter,4,/// Rewriter for COPY instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:20,Modifiability,rewrite,rewrite,20,/// Helper class to rewrite uncoalescable copy like instructions; /// into new COPY (coalescable friendly) instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,Rewrite,Rewriter,13,/// \see See Rewriter::getNextRewritableSource(); /// All such sources need to be considered rewritable in order to; /// rewrite a uncoalescable copy-like instruction. This method return; /// each definition that must be checked if rewritable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:121,Modifiability,rewrite,rewrite,121,/// \see See Rewriter::getNextRewritableSource(); /// All such sources need to be considered rewritable in order to; /// rewrite a uncoalescable copy-like instruction. This method return; /// each definition that must be checked if rewritable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for INSERT_SUBREG instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,Rewrite,Rewriter,13,"/// \see See Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = INSERT_SUBREG Src1, Src2.src2SubIdx, subIdx.; /// Src1 has the same register class has dst, hence, there is; /// nothing to rewrite.; /// Src2.src2SubIdx, may not be register coalescer friendly.; /// Therefore, the first call to this method returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx).; ///; /// Subsequence calls will return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:227,Modifiability,rewrite,rewrite,227,"/// \see See Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = INSERT_SUBREG Src1, Src2.src2SubIdx, subIdx.; /// Src1 has the same register class has dst, hence, there is; /// nothing to rewrite.; /// Src2.src2SubIdx, may not be register coalescer friendly.; /// Therefore, the first call to this method returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx).; ///; /// Subsequence calls will return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:44,Modifiability,rewrite,rewrite,44,"// If we already get the only source we can rewrite, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for EXTRACT_SUBREG instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:9,Modifiability,Rewrite,Rewriter,9,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst.dstSubIdx = EXTRACT_SUBREG Src, subIdx.; /// There is only one rewritable source: Src.subIdx,; /// which defines dst.dstSubIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:44,Modifiability,rewrite,rewrite,44,"// If we already get the only source we can rewrite, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:26,Modifiability,rewrite,rewrite,26,// The only source we can rewrite is the input register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:71,Modifiability,rewrite,rewrite,71,"// If we find a source that does not require to extract something,; // rewrite the operation with a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the operation as a COPY.; // Get rid of the sub-register index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:16,Modifiability,rewrite,rewriter,16,/// Specialized rewriter for REG_SEQUENCE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:227,Availability,avail,available,227,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = REG_SEQUENCE Src1.src1SubIdx, subIdx1, Src2.src2SubIdx, subIdx2.; /// Each call will return a different source, walking all the available; /// source.; ///; /// The first call returns:; /// (SrcReg, SrcSubReg) = (Src1, src1SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx1).; ///; /// The second call returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx2).; ///; /// And so on, until all the sources have been traversed, then; /// it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:9,Modifiability,Rewrite,Rewriter,9,"/// \see Rewriter::getNextRewritableSource(); /// Here CopyLike has the following form:; /// dst = REG_SEQUENCE Src1.src1SubIdx, subIdx1, Src2.src2SubIdx, subIdx2.; /// Each call will return a different source, walking all the available; /// source.; ///; /// The first call returns:; /// (SrcReg, SrcSubReg) = (Src1, src1SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx1).; ///; /// The second call returns:; /// (SrcReg, SrcSubReg) = (Src2, src2SubIdx).; /// (DstReg, DstSubReg) = (dst, subIdx2).; ///; /// And so on, until all the sources have been traversed, then; /// it returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:13,Modifiability,rewrite,rewrite,13,"// We cannot rewrite out of bound operands.; // Moreover, rewritable sources are at odd positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:113,Energy Efficiency,allocate,allocated,113,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:53,Modifiability,Rewrite,Rewriter,53,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:123,Modifiability,Rewrite,Rewriter,123,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:154,Modifiability,rewrite,rewriter,154,// end anonymous namespace; /// Get the appropriated Rewriter for \p MI.; /// \return A pointer to a dynamically allocated Rewriter or nullptr if no; /// rewriter works for \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:51,Modifiability,Rewrite,RewriteMap,51,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:101,Modifiability,rewrite,rewrite,101,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:336,Testability,test,test,336,"/// Given a \p Def.Reg and Def.SubReg pair, use \p RewriteMap to find; /// the new source to use for rewrite. If \p HandleMultipleSources is true and; /// multiple sources for a given \p Def are found along the way, we found a; /// PHI instructions that needs to be rewritten.; /// TODO: HandleMultipleSources should be removed once we test PHI handling; /// with coalescable copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:85,Modifiability,rewrite,rewrite,85,"// Multiple sources, recurse into each source to find a new source; // for it. Then, rewrite the PHI accordingly to its new edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:83,Performance,optimiz,optimization,83,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:330,Performance,optimiz,optimization,330,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:386,Performance,optimiz,optimization,386,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Safety,avoid,avoid,42,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:10,Modifiability,rewrite,rewrite,10,// Do not rewrite physical definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:17,Modifiability,rewrite,rewriter,17,// Get the right rewriter for the current copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each rewritable source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:25,Modifiability,rewrite,rewrite,25,// Get the new source to rewrite. TODO: Only enable handling of multiple; // sources (PHIs) once we have a motivating example and testcases for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:130,Testability,test,testcases,130,// Get the new source to rewrite. TODO: Only enable handling of multiple; // sources (PHIs) once we have a motivating example and testcases for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:15,Modifiability,extend,extended,15,"// We may have extended the live-range of NewSrc, account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:210,Safety,avoid,avoid,210,"// TODO: We could have a clean-up method to tidy the instruction.; // E.g., v0 = INSERT_SUBREG v1, v1.sub0, sub0; // => v0 = COPY v1; // Currently we haven't seen motivating example for that and we; // want to avoid untested code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:61,Modifiability,Rewrite,RewriteMap,61,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:128,Modifiability,Rewrite,RewriteMap,128,"/// Rewrite the source found through \p Def, by using the \p RewriteMap; /// and create a new COPY instruction. More info about RewriteMap in; /// PeepholeOptimizer::findNextSource. Right now this is only used to handle; /// Uncoalescable copies, since they are copy like instructions that aren't; /// recognized by the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Modifiability,rewrite,rewrite,42,// Find the new source to use in the COPY rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:6,Modifiability,extend,extended,6,"// We extended the lifetime of NewSrc.Reg, clear the kill flags to; // account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:43,Usability,clear,clear,43,"// We extended the lifetime of NewSrc.Reg, clear the kill flags to; // account for that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:101,Performance,optimiz,optimization,101,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:410,Performance,optimiz,optimized,410,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each rewritable source by generating new COPYs. This works; // differently from optimizeCoalescableCopy since it first makes sure that all; // definitions can be rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:91,Performance,optimiz,optimizeCoalescableCopy,91,// Rewrite each rewritable source by generating new COPYs. This works; // differently from optimizeCoalescableCopy since it first makes sure that all; // definitions can be rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:82,Modifiability,rewrite,rewrite,82,"// If a physical register is here, this is probably for a good reason.; // Do not rewrite that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:28,Modifiability,rewrite,rewrite,28,"// If we do not know how to rewrite this definition, there is no point; // in trying to kill this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the ""copy"" in a way the register coalescer understands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:92,Performance,load,loads,92,/// Check whether MI is a candidate for folding into a later instruction.; /// We only fold loads to virtual registers and the virtual register defined; /// has a single user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:6,Energy Efficiency,reduce,reduce,6,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:81,Performance,load,loads,81,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:137,Performance,load,load,137,"// To reduce compilation time, we check MRI->hasOneNonDBGUser when inserting; // loads. It should be checked when processing uses of the load, since; // uses can be removed during peephole.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:120,Performance,optimiz,optimization,120,"/// Try folding register operands that are defined by move immediate; /// instructions, i.e. a trivial constant folding optimization, if; /// and only if the def and use are in the same BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:143,Testability,log,logic,143,// FIXME: This is very simple and misses some cases which should be handled when; // motivating examples are found.; //; // The copy rewriting logic should look at uses as well as defs and be able to; // eliminate copies across blocks.; //; // Later copies that are subregister extracts will also not be eliminated since; // only the first copy is considered.; //; // e.g.; // %1 = COPY %0; // %2 = COPY %0:sub1; //; // Should replace %2 uses with %1:sub1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:23,Usability,simpl,simple,23,// FIXME: This is very simple and misses some cases which should be handled when; // motivating examples are found.; //; // The copy rewriting logic should look at uses as well as defs and be able to; // eliminate copies across blocks.; //; // Later copies that are subregister extracts will also not be eliminated since; // only the first copy is considered.; //; // e.g.; // %1 = COPY %0; // %2 = COPY %0:sub1; //; // Should replace %2 uses with %1:sub1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,Modifiability,extend,extended,42,// Lifetime of the previous copy has been extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:29,Safety,Avoid,Avoid,29,// %vreg = COPY $physreg; // Avoid using a datastructure which can track multiple live non-allocatable; // phys->virt copies since LLVM doesn't seem to do this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:20,Performance,optimiz,optimization,20,"// Potential missed optimization opportunity: we saw a different virtual; // register get a copy of the non-allocatable physical register, and we only; // track one such copy. Avoid getting confused by this new non-allocatable; // physical register definition, and remove it from the tracked copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:176,Safety,Avoid,Avoid,176,"// Potential missed optimization opportunity: we saw a different virtual; // register get a copy of the non-allocatable physical register, and we only; // track one such copy. Avoid getting confused by this new non-allocatable; // physical register definition, and remove it from the tracked copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,Availability,redundant,redundant,856,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,Safety,redund,redundant,856,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:895,Safety,avoid,avoided,895,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:191,Performance,perform,perform,191,"// During this forward scan, at some point it needs to answer the question; // ""given a pointer to an MI in the current BB, is it located before or; // after the current instruction"".; // To perform this, the following set keeps track of the MIs already seen; // during the scan, if a MI is not in the set, it is assumed to be located; // after. Newly created MIs have to be inserted in the set as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:69,Performance,optimiz,optimization,69,// Skip debug instructions. They should not affect this peephole; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Performance,optimiz,optimizeExtInstr,3,// optimizeExtInstr might have created new instructions after MI; // and before the already incremented MII. Adjust MII so that the; // next iteration sees the new instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:25,Performance,load,load,25,"// Check whether MI is a load candidate for folding into a later; // instruction. If MI is not a candidate, check whether we can fold an; // earlier load into MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:149,Performance,load,load,149,"// Check whether MI is a load candidate for folding into a later; // instruction. If MI is not a candidate, check whether we can fold an; // earlier load into MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:109,Performance,load,loads,109,"// We visit each operand even after successfully folding a previous; // one. This allows us to fold multiple loads into a single; // instruction. We do assume that optimizeLoadInstr doesn't insert; // foldable uses earlier in the argument list. Since we don't restart; // iteration, we'd miss such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:164,Performance,optimiz,optimizeLoadInstr,164,"// We visit each operand even after successfully folding a previous; // one. This allows us to fold multiple loads into a single; // instruction. We do assume that optimizeLoadInstr doesn't insert; // foldable uses earlier in the argument list. Since we don't restart; // iteration, we'd miss such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:19,Performance,load,load,19,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:30,Performance,optimiz,optimizeCmpInstr,30,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:58,Performance,optimiz,optimizeCmpInstr,58,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:154,Performance,optimiz,optimizeLoadInstr,154,"// We need to fold load after optimizeCmpInstr, since; // optimizeCmpInstr can enable folding by converting SUB to CMP.; // Save FoldAsLoadDefReg because optimizeLoadInstr() resets it and; // we need it for markUsesInDebugValueAsUndef().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update LocalMIs since we replaced MI with FoldMI and deleted; // DefMI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update the call site info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:71,Performance,load,load,71,"// If we run into an instruction we can't fold across, discard; // the load candidates. Note: We might be able to fold *into* this; // instruction, so this needs to be after the folding logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:186,Testability,log,logic,186,"// If we run into an instruction we can't fold across, discard; // the load candidates. Note: We might be able to fold *into* this; // instruction, so this needs to be after the folding logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:56,Security,expose,expose,56,// Bail if there are effects that a plain copy will not expose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:621,Testability,assert,assertion,621,"// If we are composing subregs, bail out.; // The case we are checking is Def.<subreg> = REG_SEQUENCE.; // This should almost never happen as the SSA property is tracked at; // the register level (as opposed to the subreg level).; // I.e.,; // Def.sub0 =; // Def.sub1 =; // is a valid SSA representation for Def.sub0 and Def.sub1, but not for; // Def. Thus, it must not be generated.; // However, some code could theoretically generates a single; // Def.sub0 (i.e, not defining the other subregs) and we would; // have this case.; // If we can ascertain (or force) that this never happens, we could; // turn that into an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:127,Testability,assert,assert,127,"// If we are composing subreg, bail out.; // Same remark as getNextSourceFromRegSequence.; // I.e., this may be turned into an assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:161,Availability,avail,available,161,"// We are looking at:; // Def = INSERT_SUBREG v0, v1, sub1; // There are two cases:; // 1. DefSubReg == sub1, get v1.; // 2. DefSubReg != sub1, the value may be available through v0.; // #1 Check if the inserted register matches the required sub index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:31,Availability,avail,available,31,"// At this point, the value is available in v0 via the same subreg; // we used for Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:27,Availability,avail,available,27,"// Otherwise, the value is available in the v0.sub0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,"// Update definition, definition index, and subregister for the; // next call of getNextSource.; // Update the current register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:100,Deployability,Update,Update,100,"// Update definition, definition index, and subregister for the; // next call of getNextSource.; // Update the current register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Deployability,Update,Update,3,// Update the result before moving up in the use-def chain; // with the instruction containing the last found sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:60,Performance,perform,performance,60,/// Split critical edges where necessary for good coalescer performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:55,Deployability,update,update,55,// A set of live-in regs for each MBB which is used to update LV; // efficiently also with large functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:69,Energy Efficiency,efficient,efficiently,69,// A set of live-in regs for each MBB which is used to update LV; // efficiently also with large functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:47,Deployability,update,updater,47,// TODO: we should use the incremental DomTree updater here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update live variable information if there is any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:15,Modifiability,variab,variable,15,// Update live variable information if there is any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:26,Deployability,update,update,26,"// If the result is dead, update LV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update LiveIntervals for the new copy or implicit def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Deployability,Update,Update,3,// Update LiveVariables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:10,Safety,safe,safe,10,"// Find a safe location to insert the copy, this may be the first terminator; // in the block (or end()).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:19,Deployability,update,update,19,// We only need to update the LiveVariables kill of SrcReg if this was the; // last PHI use of SrcReg to be lowered on this CFG edge and it is not live; // out of the predecessor. We can also ignore undef sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:150,Modifiability,variab,variable,150,"// We want to be able to insert a kill of the register if this PHI (aka,; // the copy we just inserted) is the last use of the source value. Live; // variable analysis conservatively handles this by saying that the value; // is live until the end of the block the PHI entry lives in. If the value; // really is dead at the PHI copy, there will be no successor blocks which; // have the value live-in.; // Okay, if we now know that the value is not live out of the block, we; // can add a kill marker in this block saying that it kills the incoming; // value!; // In our final twist, we have to decide which instruction kills the; // register. In most cases this is the copy, however, terminator; // instructions at the end of the block may also use the value. In this; // case, we should mark the last such terminator as being the killing; // block, not the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Safety,Avoid,Avoid,3,// Avoid splitting backedges of loops. It would introduce small; // out-of-line blocks into the loop which is very bad for code placement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:238,Safety,risk,risk,238,"// LV doesn't consider a phi use live-out, so isLiveOut only returns true; // when the source register is live-out for some other reason than a phi; // use. That means the copy we will insert in PreMBB won't be a kill, and; // there is a risk it may not be coalesced away.; //; // If the copy would be a kill, there is no need to split the edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:108,Safety,avoid,avoid,108,"// If Reg is not live-in to MBB, it means it must be live-in to some; // other PreMBB successor, and we can avoid the interference by splitting; // the edge.; //; // If Reg *is* live-in to MBB, the interference is inevitable and a copy; // is likely to be left after coalescing. If we are looking at a loop; // exiting edge, split it so we won't insert code in the loop, otherwise; // don't bother.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp:32,Safety,safe,safe,32,"// findCopyInsertPoint - Find a safe place in MBB to insert a copy from SrcReg; // when following the CFG edge to SuccMBB. This needs to be after any def of; // SrcReg, but before any subsequent point where control flow might jump out of; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h:36,Safety,safe,safe,36,"/// findPHICopyInsertPoint - Find a safe place in MBB to insert a copy from; /// SrcReg when following the CFG edge to SuccMBB. This needs to be after; /// any def of SrcReg, but before any subsequent point where control flow; /// might jump out of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:828,Availability,down,down,828,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1166,Availability,down,down,1166,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:550,Energy Efficiency,schedul,schedulers,550,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:750,Energy Efficiency,schedul,scheduling,750,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:804,Energy Efficiency,schedul,scheduler,804,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:833,Energy Efficiency,schedul,scheduler,833,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:872,Energy Efficiency,schedul,scheduling,872,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:994,Energy Efficiency,schedul,scheduler,994,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1075,Energy Efficiency,schedul,scheduling,1075,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1214,Energy Efficiency,schedul,scheduling,1214,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:40,Safety,hazard,hazard,40,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:409,Safety,hazard,hazard,409,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:500,Safety,hazard,hazard,500,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:638,Safety,hazard,hazard,638,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:717,Safety,hazard,hazards,717,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1047,Safety,hazard,hazards,1047,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1265,Safety,hazard,hazard,1265,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:1323,Safety,hazard,hazards,1323,"//===----- PostRAHazardRecognizer.cpp - hazard recognizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This runs the hazard recognizer and emits noops when necessary. This; /// gives targets a way to run the hazard recognizer without running one of; /// the schedulers. Example use cases for this pass would be:; ///; /// - Targets that need the hazard recognizer to be run at -O0.; /// - Targets that want to guarantee that hazards at the beginning of; /// scheduling regions are handled correctly. The post-RA scheduler is; /// a top-down scheduler, but when there are multiple scheduling regions; /// in a basic block, it visits the regions in bottom-up order. This; /// makes it impossible for the scheduler to gauranttee it can correctly; /// handle hazards at the beginning of scheduling regions.; ///; /// This pass traverses all the instructions in a program in top-down order.; /// In contrast to the instruction scheduling passes, this pass never resets; /// the hazard recognizer to ensure it can correctly handles noop hazards at; /// the beginning of blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:46,Safety,hazard,hazard,46,// Return if the target has not implemented a hazard recognizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:18,Safety,Hazard,HazardRec,18,// We do not call HazardRec->reset() here to make sure we are handling noop; // hazards at the start of basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:80,Safety,hazard,hazards,80,// We do not call HazardRec->reset() here to make sure we are handling noop; // hazards at the start of basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:405,Availability,down,down,405,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:501,Availability,avail,available,501,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:761,Deployability,pipeline,pipeline,761,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:11,Energy Efficiency,Schedul,SchedulePostRAList,11,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:41,Energy Efficiency,schedul,scheduler,41,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:415,Energy Efficiency,schedul,scheduler,415,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:520,Energy Efficiency,schedul,schedule,520,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:643,Energy Efficiency,schedul,schedule,643,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:709,Energy Efficiency,schedul,schedule,709,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:492,Performance,queue,queue,492,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:583,Performance,queue,queue,583,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:743,Safety,hazard,hazards,743,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:11,Energy Efficiency,schedul,scheduling,11,// Post-RA scheduling is enabled with; // TargetSubtargetInfo.enablePostRAScheduler(). This flag can be used to; // override the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Energy Efficiency,schedul,schedule,29,// If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Availability,Avail,AvailableQueue,4,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:55,Availability,avail,available,55,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:34,Performance,queue,queue,34,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:201,Availability,avail,available,201,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:249,Availability,Avail,AvailableQueue,249,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:143,Performance,latency,latency,143,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Safety,Hazard,HazardRec,4,/// HazardRec - The hazard recognizer to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Safety,hazard,hazard,20,/// HazardRec - The hazard recognizer to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Integrability,depend,dependence,24,"/// AntiDepBreak - Anti-dependence breaking object, or NULL if none",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:8,Energy Efficiency,schedul,schedule,8,/// The schedule. Null SUnit*'s represent noop instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Energy Efficiency,schedul,scheduling,58,/// startBlock - Initialize register live-range state for scheduling in; /// this block.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:19,Energy Efficiency,schedul,scheduler,19,/// Initialize the scheduler state for the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,/// Initialize the scheduler state for the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Energy Efficiency,schedul,scheduler,20,/// Notify that the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:43,Energy Efficiency,schedul,scheduling,43,/// Notify that the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,Schedule,15,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:57,Energy Efficiency,schedul,scheduling,57,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Deployability,Update,Update,14,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Energy Efficiency,schedul,scheduled,105,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,scheduling,46,/// Initialize state associated with the next scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Energy Efficiency,schedul,schedule,14,/// Print the schedule before exiting the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:28,Energy Efficiency,schedul,scheduled,28,/// dumpSchedule - dump the scheduled Sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,// Check for explicit enable/disable of post-ra scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:74,Deployability,upgrade,upgrade,74,// Check that post-RA scheduling is enabled for this target.; // This may upgrade the AntiDepMode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:22,Energy Efficiency,schedul,scheduling,22,// Check that post-RA scheduling is enabled for this target.; // This may upgrade the AntiDepMode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Energy Efficiency,schedul,schedule,29,// If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:44,Energy Efficiency,schedul,scheduling,44,// Initialize register live-range state for scheduling in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:121,Availability,down,down,121,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Energy Efficiency,Schedul,Schedule,3,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:126,Energy Efficiency,schedul,scheduling,126,// Schedule each sequence of instructions not interrupted by a label; // or anything else that effectively needs to shut down scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:17,Energy Efficiency,schedul,scheduling,17,"// Calls are not scheduling boundaries before register allocation, but; // post-ra we don't gain anything by scheduling across calls since we; // don't need to worry about register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:109,Energy Efficiency,schedul,scheduling,109,"// Calls are not scheduling boundaries before register allocation, but; // post-ra we don't gain anything by scheduling across calls since we; // don't need to worry about register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Update,Update,3,// Update register kills,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Energy Efficiency,schedul,scheduling,58,/// StartBlock - Initialize register live-range state for scheduling in; /// this block.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:13,Safety,hazard,hazard,13,// Reset the hazard recognizer and anti-dep breaker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,Schedule,15,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:57,Energy Efficiency,schedul,scheduling,57,/// Schedule - Schedule the instruction range using list scheduling.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:13,Energy Efficiency,schedul,scheduling,13,// Build the scheduling graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:20,Deployability,Update,Update,20,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:76,Deployability,update,update,76,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Integrability,depend,dependency,31,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:191,Integrability,depend,dependence,191,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:215,Integrability,depend,dependence,215,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:275,Integrability,depend,dependence,275,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:297,Integrability,depend,dependence,297,"// We made changes. Update the dependency graph.; // Theoretically we could update the graph in place:; // When a live range is changed to use a different register, remove; // the def's anti-dependence *and* output-dependence edges due to; // that register, and add new anti-dependence and output-dependence; // edges based on the next live range of the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:14,Deployability,Update,Update,14,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Energy Efficiency,schedul,scheduled,105,"/// Observe - Update liveness information to account for the current; /// instruction, which will not be scheduled.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:15,Energy Efficiency,Schedul,ScheduleDAGMutation,15,/// Apply each ScheduleDAGMutation step in order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:89,Availability,Down,Down,89,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:192,Deployability,Release,ReleaseSucc,192,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:94,Energy Efficiency,Schedul,Scheduling,94,//===----------------------------------------------------------------------===//; // Top-Down Scheduling; //===----------------------------------------------------------------------===//; /// ReleaseSucc - Decrement the NumPredsLeft count of a successor. Add it to; /// the PendingQueue if the count reaches zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,Availability,redundant,redundant,521,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:266,Deployability,update,updated,266,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:12,Energy Efficiency,schedul,scheduler,12,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:234,Energy Efficiency,Schedul,ScheduleNodeTopDown,234,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:655,Energy Efficiency,schedul,scheduled,655,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:695,Energy Efficiency,schedul,scheduled,695,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,Safety,redund,redundant,521,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Deployability,Release,ReleaseSuccessors,4,/// ReleaseSuccessors - Call ReleaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:29,Deployability,Release,ReleaseSucc,29,/// ReleaseSuccessors - Call ReleaseSucc on each of SU's successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:165,Availability,Avail,Available,165,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Energy Efficiency,Schedul,ScheduleNodeTopDown,4,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,schedule,46,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:175,Performance,queue,queue,175,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:67,Availability,down,down,67,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:48,Energy Efficiency,schedul,scheduling,48,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:77,Energy Efficiency,schedul,schedulers,77,/// ListScheduleTopDown - The main loop of list scheduling for top-down; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Availability,down,down,24,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Energy Efficiency,schedul,scheduling,9,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,Safety,hazard,hazards,105,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:156,Safety,hazard,hazards,156,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Release,Release,3,// Release any successors of the special Entry node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:21,Availability,Avail,Available,21,// Add all leaves to Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Performance,queue,queue,31,// Add all leaves to Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Availability,avail,available,9,// It is available if it has no predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:31,Energy Efficiency,schedul,schedule,31,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:92,Integrability,depend,depending,92,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:9,Availability,Avail,Available,9,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:116,Energy Efficiency,Schedul,Schedule,116,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:19,Performance,queue,queue,19,"// While Available queue is not empty, grab the node with the highest; // priority. If it is not ready put it back. Schedule the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:98,Availability,avail,available,98,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:108,Performance,queue,queue,108,"// Check to see if any of the pending instructions are ready to issue. If; // so, add them to the available queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:217,Safety,hazard,hazard,217,"// If this is the first non-preferred node for this cycle, then; // record it and continue searching for a preferred node. If this; // is not the first non-preferred node, then treat it as though; // there had been a hazard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:30,Safety,hazard,hazard,30,// Remember if this is a noop hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:58,Availability,avail,available,58,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:120,Energy Efficiency,schedul,schedule,120,"// If we have a non-preferred node, push it back onto the available list.; // If we did not find a preferred node, then schedule this first; // non-preferred node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:49,Availability,avail,available,49,// Add the nodes that aren't ready back onto the available list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:25,Energy Efficiency,schedul,schedule,25,// If we found a node to schedule...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:7,Energy Efficiency,schedul,schedule,7,// ... schedule the node...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:24,Deployability,pipeline,pipeline,24,"// Otherwise, we have a pipeline stall, but no other problem,; // just advance the current cycle and try again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,Availability,fault,fault,86,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:163,Deployability,pipeline,pipeline,163,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,Safety,interlock,interlocks,172,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,Security,interlock,interlocks,172,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:43,Energy Efficiency,schedul,scheduled,43,// EmitSchedule - Emit the machine code in scheduled order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:46,Energy Efficiency,schedul,schedule,46,// Then re-insert them according to the given schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:3,Deployability,Update,Update,3,"// Update the Begin iterator, as the first instruction in the block; // may have been scheduled later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:86,Energy Efficiency,schedul,scheduled,86,"// Update the Begin iterator, as the first instruction in the block; // may have been scheduled later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:473,Performance,load,load,473,"//===- PreISelIntrinsicLowering.cpp - Pre-ISel intrinsic lowering pass ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR lowering for the llvm.memcpy, llvm.memmove,; // llvm.memset, llvm.load.relative and llvm.objc.* intrinsics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:174,Availability,avail,availability,174,"/// If this is true, assume it's preferably to leave memory intrinsic calls; /// for replacement with a library call later. Otherwise this depends on; /// TargetLoweringInfo availability of the corresponding function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:139,Integrability,depend,depends,139,"/// If this is true, assume it's preferably to leave memory intrinsic calls; /// for replacement with a library call later. Otherwise this depends on; /// TargetLoweringInfo availability of the corresponding function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:75,Performance,perform,performance,75,"// If we have Native ARC, set nonlazybind attribute for these APIs for; // performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:232,Deployability,upgrade,upgraded,232,"// Transfer the 'returned' attribute from the intrinsic to the call site.; // By applying this only to intrinsic call sites, we avoid applying it to; // non-ARC explicit calls to things like objc_retain which have not been; // auto-upgraded to use the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:128,Safety,avoid,avoid,128,"// Transfer the 'returned' attribute from the intrinsic to the call site.; // By applying this only to intrinsic call sites, we avoid applying it to; // non-ARC explicit calls to things like objc_retain which have not been; // auto-upgraded to use the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:52,Security,access,accesses,52,// TODO: Should refine based on estimated number of accesses (e.g. does it; // require splitting based on alignment),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp:3,Energy Efficiency,Drain,Drain,3,// Drain the WorkList to recursively process any new implicit defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ProcessImplicitDefs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:82,Usability,simpl,simply,82,// Frame indices in debug values are encoded in a target independent; // way with simply the frame index and offset rather than any; // target-specific addressing mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:51,Modifiability,variab,variables,51,// Calculate the MaxCallFrameSize and AdjustsStack variables for the; // function's frame information. Also eliminates call frame pseudo; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:129,Modifiability,variab,variables,129,"// Add prolog and epilog code to the function. This function is required; // to align the stack frame as necessary for any stack variables or; // called functions. Because of this, calculateCalleeSavedRegisters(); // must be called before this function in order to set the AdjustsStack; // and MaxCallFrameSize variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:311,Modifiability,variab,variables,311,"// Add prolog and epilog code to the function. This function is required; // to align the stack frame as necessary for any stack variables or; // called functions. Because of this, calculateCalleeSavedRegisters(); // must be called before this function in order to set the AdjustsStack; // and MaxCallFrameSize variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:57,Modifiability,variab,variables,57,/// Calculate the MaxCallFrameSize and AdjustsStack; /// variables for the function's frame information and eliminate call frame; /// pseudo instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:47,Availability,down,down,47,// Get the function call frame set-up and tear-down instruction opcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:183,Integrability,wrap,wrapping,183,"// Even when we do not change any CSR, we still want to insert the; // prologue and epilogue of the function.; // So set the save points for those.; // Use the points found by shrink-wrapping, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:67,Energy Efficiency,allocate,allocate,67,"// Now that we know which registers need to be saved and restored, allocate; // stack slots for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:85,Energy Efficiency,allocate,allocate,85,"// If the target has spilled this register to another register, we don't; // need to allocate a stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:23,Deployability,update,update,23,/// Helper function to update the liveness information for the callee-saved; /// registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:109,Availability,alive,alive,109,"// Visited will contain all the basic blocks that are in the region; // where the callee saved registers are alive:; // - Anything that is not Save or Restore -> LiveThrough.; // - Save -> LiveIn.; // - Restore -> LiveOut.; // The live-out is not attached to the block, so no need to keep; // Restore in this set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:28,Performance,load,loadRegFromStackSlot,28,// Insert in reverse order. loadRegFromStackSlot can insert; // multiple instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:154,Deployability,pipeline,pipeline,154,"// We can't list this requirement in getRequiredProperties because some; // targets (WebAssembly) use virtual registers past this point, and the pass; // pipeline is set up without giving the passes a chance to look at the; // TargetMachine.; // FIXME: Find a way to express this in getRequiredProperties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Deployability,Update,Update,3,// Update the live-in information of all the blocks up to the save point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:22,Availability,down,down,22,"// If the stack grows down, add the object size to find the lowest address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Safety,Avoid,Avoid,3,// Avoid undefined int64_t -> int conversion below in extreme case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Usability,clear,clear,3,// clear it to speed up later scavengeStackSlot calls to; // StackBytesFree.none(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:108,Energy Efficiency,allocate,allocated,108,"// If there are fixed sized objects that are preallocated in the local area,; // non-fixed objects can't be allocated right at the start of local area.; // Adjust 'Offset' to point to the end of last fixed sized preallocated; // object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:118,Availability,down,down,118,"// The maximum distance from the stack pointer is at lower address of; // the object -- which is given by offset. For down growing stack; // the offset is negative, so we negate the offset to get the distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:208,Performance,optimiz,optimization,208,"// FIXME: Once this is working, then enable flag will change to a target; // check for whether the frame is large enough to want to use virtual; // frame index registers. Functions which don't want/need this optimization; // will continue to use the existing code path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the local block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:61,Modifiability,variab,variables,61,// Make sure that the stack protector comes before the local variables on the; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:97,Energy Efficiency,allocate,allocate,97,"// If we need a stack protector, we need to make sure that; // LocalStackSlotPass didn't already allocate a slot for it.; // If we are told to use the LocalStackAllocationBlock, the stack protector; // is expected to be already pre-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:232,Energy Efficiency,allocate,allocated,232,"// If we need a stack protector, we need to make sure that; // LocalStackSlotPass didn't already allocate a slot for it.; // If we are told to use the LocalStackAllocationBlock, the stack protector; // is expected to be already pre-allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:59,Energy Efficiency,allocate,allocated,59,"// We expect **all** the protected stack objects to be pre-allocated by; // LocalStackSlotPass. If it turns out that PEI still has to allocate some; // of them, we may end up messing up the expected order of the objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:134,Energy Efficiency,allocate,allocate,134,"// We expect **all** the protected stack objects to be pre-allocated by; // LocalStackSlotPass. If it turns out that PEI still has to allocate some; // of them, we may end up messing up the expected order of the objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:8,Energy Efficiency,allocate,allocate,8,// Only allocate objects on the default stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:35,Energy Efficiency,allocate,allocate,35,// Add the objects that we need to allocate to our working set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the EH registration node first if one is present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:232,Performance,optimiz,optimizing,232,// Keep track of which bytes in the fixed and callee-save range are used so we; // can use the holes when allocating later stack objects. Only do this if; // stack protector isn't being used and the target requests it and we're; // optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Deployability,Update,Update,3,// Update frame info to pretend that this is part of the stack...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:113,Performance,load,loaded,113,"// Emit additional code that is required to explicitly handle the stack in; // HiPE native code (if needed) when loaded in the Erlang/OTP runtime. The; // approach is rather similar to that of Segmented Stacks, but it uses a; // different conditional check and another BIF for allocating more stack; // space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:9,Usability,clear,clear,9,// Don't clear registers that are live when leaving the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:17,Usability,clear,clear,17,// Don't need to clear registers that are used/clobbered by terminating; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:9,Usability,clear,clear,9,// Don't clear registers that must be preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:236,Modifiability,variab,variable,236,"// If we have a direct DBG_VALUE, and its location expression isn't; // currently complex, then adding an offset will morph it into a; // complex location that is interpreted as being a memory address.; // This changes a pointer-valued variable to dereference that pointer,; // which is incorrect. Fix by adding DW_OP_stack_value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:60,Deployability,PATCH,PATCHPOINT,60,// TODO: This code should be commoned with the code for; // PATCHPOINT. There's no good reason for the difference in; // implementation other than historical accident. The only; // remaining difference is the unconditional use of the stack; // pointer as the base register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:256,Deployability,update,update,256,// Some instructions (e.g. inline asm instructions) can have; // multiple frame indices and/or cause eliminateFrameIndex; // to insert more than one instruction. We need the register; // scavenger to go through all of these instructions so that; // it can update its register information. We keep the; // iterator at the point before insertion so that we can; // revisit them in full.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp:340,Testability,log,logically,340,"// Walk the block backwards, move PSEUDO_PROBE before the first real; // instruction to fix out-of-order probes. There is a problem with probes; // as the terminator of the block. During the offline counts processing,; // the samples collected on the first physical instruction following a; // probe will be counted towards the probe. This logically equals to; // treating the instruction next to a probe as if it is from the same; // block of the probe. This is accurate most of the time unless the; // instruction can be reached from multiple flows, which means it actually; // starts a new block. Samples collected on such probes may cause; // imprecision with the counts inference algorithm. Fortunately, if; // there are still other native instructions preceding the probe we can; // use them as a place holder to collect samples for the probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PseudoProbeInserter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:89,Energy Efficiency,allocate,allocates,89,"// Node allocation functions.; //; // Node allocator is like a slab memory allocator: it allocates blocks of; // memory in sizes that are multiples of the size of a node. Each block has; // the same size. Nodes are allocated from the currently active block, and; // when it becomes full, a new one is created.; // There is a mapping scheme between node id and its location in a block,; // and within that block is described in the header file.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:215,Energy Efficiency,allocate,allocated,215,"// Node allocation functions.; //; // Node allocator is like a slab memory allocator: it allocates blocks of; // memory in sizes that are multiples of the size of a node. Each block has; // the same size. Nodes are allocated from the currently active block, and; // when it becomes full, a new one is created.; // There is a mapping scheme between node id and its location in a block,; // and within that block is described in the header file.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:55,Deployability,update,update,55,"// If the member to remove happens to be the last one, update the; // LastM indicator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:27,Availability,down,down,27,// Move the stack iterator down by one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new node and set the attributes to Attrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:14,Integrability,rout,routines,14,// Allocation routines for specific node types/kinds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:16,Modifiability,Config,Config,16,// Track set in Config overrides everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Testability,Assert,Assert,3,// Assert if the register is defined in two or more unrelated defs.; // This could happen if there are two or more def operands defining it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Usability,Clear,Clear,3,// Clear all information in the graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:187,Security,access,access,187,"// Return the next reference node in the instruction node IA that is related; // to RA. Conceptually, two reference nodes are related if they refer to the; // same instance of a register access, but differ in flags or other minor; // characteristics. Specific examples of related nodes are shadow reference; // nodes.; // Return the equivalent of nullptr if there are no more related references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Safety,Avoid,Avoid,3,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:48,Safety,detect,detect,48,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:132,Usability,clear,clear,132,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:15,Availability,mask,masks,15,// Process reg-masks (as clobbers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:115,Safety,detect,detect,115,"// This will remove unused phis, i.e. phis where each def does not reach; // any uses or other defs. This will not detect or remove circular phi; // chains that are otherwise dead. Unused/dead phis are created during; // the build process and this function is intended to remove these cases; // that are easily determinable to be unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:163,Performance,queue,queue,163,"// Any phi, if it is removed, may affect other phis (make them dead).; // For each removed phi, collect the potentially affected phis and add; // them back to the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Deployability,Update,Update,3,// Update the reaching def node and remove DA from the sibling list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:40,Deployability,update,update,40,"// If DA is the first reached def, just update the RD's reached def; // to the DA's sibling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:808,Energy Efficiency,Efficient,Efficient,808,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:918,Performance,Optimiz,Optimization,918,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:1011,Performance,Perform,Performance,1011,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:15,Performance,queue,queue,15,// The initial queue should not have reaching defs for shadows. The; // whole point of a shadow is that it will have a reaching def that; // is not aliased to the reaching defs of the related shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:188,Security,expose,expose,188,"// Add phi defs even if they are covered by subsequent defs. This is; // for cases where the reached use is not covered by any of the defs; // encountered so far: the phi def is needed to expose the liveness; // of that use to the entry of the block.; // Example:; // phi d1<R3>(,d2,), ... Phi def d1 is covered by d2.; // d2<R3>(d1,,u3), ...; // ..., u3<D1>(d2) This use needs to be live on entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:37,Deployability,update,update,37,"// If it is a preserving def, do not update the set of intervening defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:15,Performance,queue,queue,15,"// Have a work queue of defs whose reached uses need to be found.; // For each def, add to the queue all reached (non-phi) defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:95,Performance,queue,queue,95,"// Have a work queue of defs whose reached uses need to be found.; // For each def, add to the queue all reached (non-phi) defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:47,Performance,queue,queue,47,"// Visit all reached defs, and add them to the queue. These defs may; // override some of the uses collected here, but that will be handled; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:17,Security,expose,exposed,17,// Calculate the exposed part of the reached use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:55,Performance,queue,queue,55,"// If this phi reaches some ""real"" uses, add it to the queue for upward; // propagation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:923,Performance,cache,cache,923,"// Propagate the reached registers up in the phi chain.; //; // The following type of situation needs careful handling:; //; // phi d1<R1:0> (1); // |; // ... d2<R1>; // |; // phi u3<R1:0> (2); // |; // ... u4<R1>; //; // The phi node (2) defines a register pair R1:0, and reaches a ""real""; // use u4 of just R1. The same phi node is also known to reach (upwards); // the phi node (1). However, the use u4 is not reached by phi (1),; // because of the intervening definition d2 of R1. The data flow between; // phis (1) and (2) is restricted to R1:0 minus R1, i.e. R0.; //; // When propagating uses up the phi chains, get the all reaching defs; // for a given phi use, and traverse the list until the propagated ref; // is covered, or until reaching the final phi. Only assume that the; // reference reaches the phi in the latter case.; // The operation ""clearIn"" can be expensive. For a given set of intervening; // defs, cache the result of subtracting these defs from a given register; // ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:855,Usability,clear,clearIn,855,"// Propagate the reached registers up in the phi chain.; //; // The following type of situation needs careful handling:; //; // phi d1<R1:0> (1); // |; // ... d2<R1>; // |; // phi u3<R1:0> (2); // |; // ... u4<R1>; //; // The phi node (2) defines a register pair R1:0, and reaches a ""real""; // use u4 of just R1. The same phi node is also known to reach (upwards); // the phi node (1). However, the use u4 is not reached by phi (1),; // because of the intervening definition d2 of R1. The data flow between; // phis (1) and (2) is restricted to R1:0 minus R1, i.e. R0.; //; // When propagating uses up the phi chains, get the all reaching defs; // for a given phi use, and traverse the list until the propagated ref; // is covered, or until reaching the final phi. Only assume that the; // reference reaches the phi in the latter case.; // The operation ""clearIn"" can be expensive. For a given set of intervening; // defs, cache the result of subtracting these defs from a given register; // ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:17,Availability,mask,mask,17,// Calculate the mask corresponding to the visited def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:238,Security,expose,exposed,238,"// The LiveIn map at this point has all defs that are live-on-exit from B,; // as if they were live-on-entry to B. First, we need to filter out all; // defs that are present in this block. Then we will add reaching defs of; // all upward-exposed uses.; // To filter out the defs, first make a copy of LiveIn, and then re-populate; // LiveIn with the defs that should remain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:207,Security,expose,exposed,207,"// DA is a non-phi def that is live-on-exit from this block, and; // that is also located in this block. LRef is a register ref; // whose use this def reaches. If DA covers LRef, then no part; // of LRef is exposed upwards.A",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:29,Security,expose,exposed,29,// Scan the block for upward-exposed uses and add them to the tracking set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp:92,Availability,mask,masks,92,"// If there is at least one register remaining, pick the first one,; // and consolidate the masks of all of its units contained in this; // aggregate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFRegisters.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:17,Usability,clear,clearances,17,// Save register clearances at end of MBB - used by enterBasicBlock().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:178,Usability,clear,clearance,178,"// While processing the basic block, we kept `Def` relative to the start; // of the basic block for convenience. However, future use of this information; // only cares about the clearance from the end of the block, so adjust; // everything to be relative to the end of the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Deployability,Update,Update,3,// Update existing reaching def from predecessor to a more recent one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Deployability,Update,Update,3,// Update reaching def at end of BB. Keep in mind that these are; // adjusted relative to the end of the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:3,Usability,Clear,Clear,3,// Clear the internal vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:10,Safety,safe,safely,10,"// Can we safely move 'From' to just before 'To'? To satisfy this, 'From' must; // not define a register that is used by any instructions, after and including,; // 'To'. These instructions also must not redefine any of Froms operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:183,Performance,queue,queue,183,"// Visit all the live registers. If they are already assigned to a physical; // register, unify them with the corresponding LiveIntervalUnion, otherwise push; // them on the priority queue for later assignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:34,Performance,queue,queue,34,// Top-level driver to manage the queue of unassigned VirtRegs and call the; // selectOrSplit implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:45,Availability,avail,available,45,// Continue assigning vregs one at a time to available physical registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:53,Availability,avail,available,53,// selectOrSplit requests the allocator to return an available physical; // register if possible and populate a list of new live intervals that; // result from splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp:34,Availability,error,error,34,// Keep going after reporting the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:39,Integrability,interface,interface,39,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:496,Integrability,interface,interface,496,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:510,Modifiability,extend,extending,510,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:834,Performance,cache,cached,834,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:914,Performance,perform,performance,914,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:616,Testability,test,test,616,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:61,Integrability,interface,interface,61,/// RegAllocBase provides the register allocation driver and interface that can; /// be extended to add interesting heuristics.; ///; /// Register allocators must override the selectOrSplit() method to implement; /// live range splitting. They must also override enqueue/dequeue to provide an; /// assignment order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:88,Modifiability,extend,extended,88,/// RegAllocBase provides the register allocation driver and interface that can; /// be extended to add interesting heuristics.; ///; /// Register allocators must override the selectOrSplit() method to implement; /// live range splitting. They must also override enqueue/dequeue to provide an; /// assignment order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:232,Availability,avail,available,232,"/// Inst which is a def of an original reg and whose defs are already all; /// dead after remat is saved in DeadRemats. The deletion of such inst is; /// postponed till all the allocations are done, so its remat expr is; /// always available for the remat of all the siblings of the original reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:43,Energy Efficiency,allocate,allocatePhysRegs,43,// A RegAlloc pass should call this before allocatePhysRegs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:60,Deployability,update,updated,60,// The top-level driver. The output is a VirtRegMap that us updated with; // physical register assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:24,Performance,optimiz,optimization,24,// Include spiller post optimization and removing dead defs left because of; // rematerialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:42,Performance,queue,queue,42,/// enqueue - Add VirtReg to the priority queue of unassigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:42,Performance,queue,queue,42,/// enqueue - Add VirtReg to the priority queue of unassigned registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:139,Availability,avail,available,139,// A RegAlloc pass should override this to provide the allocation heuristics.; // Each call must guarantee forward progess by returning an available PhysReg; // or new set of split live virtual registers. It is up to the splitter to; // converge quickly toward fully spilled live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:18,Energy Efficiency,Allocate,Allocated,18,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:36,Safety,avoid,avoid,36,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:4,Performance,Perform,Perform,4,/// Perform register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:50,Performance,queue,queue,50,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:123,Usability,clear,clear,123,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:44,Performance,queue,queue,44,"// Register is assigned, put it back on the queue for reassignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:31,Energy Efficiency,allocate,allocated,31,// Spill each interfering vreg allocated to PhysReg or an alias.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:415,Availability,avail,available,415,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:353,Testability,test,test,353,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:466,Testability,test,tests,466,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:559,Testability,test,tests,559,"// Driver for the register assignment and splitting heuristics.; // Manages iteration over the LiveIntervalUnions.; //; // This is a minimal implementation of register assignment and splitting that; // spills whenever we run out of registers.; //; // selectOrSplit can only be called once per live virtual register. We then do a; // single interference test for each register the correct class until we find an; // available register. So, the number of interference tests in the worst case is; // |vregs| * |machineregs|. And since the number of interference tests is; // minimal, there is no value in caching them outside the scope of; // selectOrSplit().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:16,Availability,avail,available,16,// Check for an available register in this class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:14,Availability,avail,available,14,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:25,Energy Efficiency,allocate,allocate,25,"// PhysReg is available, allocate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:22,Energy Efficiency,allocate,allocate,22,// Tell the caller to allocate to this newly freed physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:94,Energy Efficiency,allocate,allocate,94,"// The live virtual register requesting allocation was spilled, so tell; // the caller not to allocate anything during this round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:366,Deployability,update,update,366,/// canEvictInterferenceBasedOnCost - Return true if all interferences between; /// VirtReg and PhysReg can be evicted.; ///; /// @param VirtReg Live range that is about to be assigned.; /// @param PhysReg Desired register for assignment.; /// @param IsHint True when PhysReg is VirtReg's preferred register.; /// @param MaxCost Only look for cheaper candidates and update with new cost; /// when returning true.; /// @returns True when interference can be evicted cheaper than MaxCost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:3,Deployability,Update,Update,3,// Update eviction cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:3,Safety,Abort,Abort,3,// Abort if this would be too expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:34,Energy Efficiency,reduce,reduced,34,"// When we are just looking for a reduced cost per use, don't break any; // hints, and only evict smaller spill weights.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:60,Energy Efficiency,allocate,allocate,60,"// Live ranges pass through a number of stages as we try to allocate them.; // Some of the stages may also create new live ranges:; //; // - Region splitting.; // - Per-block splitting.; // - Local splitting.; // - Spilling.; //; // Ranges produced by one of the stages skip the previous stages when they are; // dequeued. This improves performance because we can skip interference checks; // that are unlikely to give any results. It also guarantees that the live; // range splitting algorithm terminates, something that is otherwise hard to; // ensure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:337,Performance,perform,performance,337,"// Live ranges pass through a number of stages as we try to allocate them.; // Some of the stages may also create new live ranges:; //; // - Region splitting.; // - Per-block splitting.; // - Local splitting.; // - Spilling.; //; // Ranges produced by one of the stages skip the previous stages when they are; // dequeued. This improves performance because we can skip interference checks; // that are unlikely to give any results. It also guarantees that the live; // range splitting algorithm terminates, something that is otherwise hard to; // ensure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:49,Performance,queue,queued,49,/// Newly created live range that has never been queued.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:56,Safety,Abort,Abort,56,/// There is nothing more we can do to this live range. Abort compilation; /// if it can't be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:243,Modifiability,refactor,refactored,243,"/// Cost of evicting interference - used by default advisor, and the eviction; /// chain heuristic in RegAllocGreedy.; // FIXME: this can be probably made an implementation detail of the default; // advisor, if the eviction chain logic can be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:230,Testability,log,logic,230,"/// Cost of evicting interference - used by default advisor, and the eviction; /// chain heuristic in RegAllocGreedy.; // FIXME: this can be probably made an implementation detail of the default; // advisor, if the eviction chain logic can be refactored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:4,Integrability,Interface,Interface,4,"/// Interface to the eviction advisor, which is responsible for making a; /// decision as to which live ranges should be evicted (if any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:121,Usability,learn,learning,121,"// Get the upper limit of elements in the given Order we need to analize.; // TODO: is this heuristic, we could consider learning it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:37,Energy Efficiency,allocate,allocate,37,"// Determine if it's worth trying to allocate this reg, given the; // CostPerUseLimit; // TODO: this is a heuristic component we could consider learning, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:144,Usability,learn,learning,144,"// Determine if it's worth trying to allocate this reg, given the; // CostPerUseLimit; // TODO: this is a heuristic component we could consider learning, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:162,Integrability,depend,dependencies,162,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:516,Testability,log,log,516,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:554,Testability,log,log,554,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:750,Testability,log,logger,750,"/// ImmutableAnalysis abstraction for fetching the Eviction Advisor. We model it; /// as an analysis to decouple the user from the implementation insofar as; /// dependencies on other analyses goes. The motivation for it being an; /// immutable pass is twofold:; /// - in the ML implementation case, the evaluator is stateless but (especially; /// in the development mode) expensive to set up. With an immutable pass, we set; /// it up once.; /// - in the 'development' mode ML case, we want to capture the training log; /// during allocation (this is a log of features encountered and decisions; /// made), and then measure a score, potentially a few steps after allocation; /// completes. So we need the properties of an immutable pass to keep the logger; /// state around until we can make that measurement.; ///; /// Because we need to offer additional services in 'development' mode, the; /// implementations of this analysis need to implement RTTI support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:414,Energy Efficiency,allocate,allocates,414,"//===- RegAllocFast.cpp - A fast register allocator for debug code --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This register allocator allocates registers to a basic block at a; /// time, attempting to keep values in registers and reusing registers as; /// appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:38,Testability,test,testcases,38,// FIXME: Remove this switch when all testcases are fixed!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:87,Availability,avail,available,87,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:238,Availability,avail,available,238,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:327,Availability,avail,available,327,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:592,Safety,safe,safely,592,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Energy Efficiency,allocate,allocated,32,/// Basic block currently being allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:15,Energy Efficiency,allocate,allocate,15,///< Could not allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:79,Availability,avail,available,79,/// This map contains entries for each virtual register that is currently; /// available in a physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:89,Availability,alive,alive,89,/// Has a bit set for every virtual register for which it was determined; /// that it is alive across blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:55,Energy Efficiency,allocate,allocated,55,/// A free register is not currently in use and can be allocated; /// immediately without checking aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:116,Energy Efficiency,allocate,allocated,116,"/// A register state may also be a virtual register number, indication; /// that the physical register is currently allocated to a virtual; /// register. In that case, LiveVirtRegs contains the inverse mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:90,Energy Efficiency,allocate,allocated,90,"/// Set of register units that are used in the current instruction, and so; /// cannot be allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:12,Availability,mask,masks,12,// Register masks attached to the current instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:9,Energy Efficiency,allocate,allocates,9,/// This allocates space for the specified virtual register to be held on the; /// stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:21,Energy Efficiency,allocate,allocated,21,// Already has space allocated?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new stack object for this spill location...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:38,Safety,avoid,avoid,38,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:22,Usability,simpl,simple,22,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:66,Deployability,Update,Update,66,/// Insert spill instruction for \p AssignedReg before \p Before. Update; /// DBG_VALUEs with \p VirtReg operands with the stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite unassigned dbg_values to use the stack slot.; // TODO We can potentially do this for list debug values as well if we know; // how the dbg_values are getting unassigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:156,Energy Efficiency,allocate,allocated,156,/// Mark PhysReg as reserved or free after spilling any virtregs. This is very; /// similar to defineVirtReg except the physreg is reserved instead of; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:186,Energy Efficiency,allocate,allocated,186,/// Return the cost of spilling clearing out PhysReg and aliases so it is free; /// for allocation. Returns 0 when PhysReg is free or disabled with all aliases; /// disabled - it can be allocated directly.; /// \returns spillImpossible when PhysReg or an alias can't be spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Usability,clear,clearing,32,/// Return the cost of spilling clearing out PhysReg and aliases so it is free; /// for allocation. Returns 0 when PhysReg is free or disabled with all aliases; /// disabled - it can be allocated directly.; /// \returns spillImpossible when PhysReg or an alias can't be spilled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Testability,Test,Test,3,// Test whether the physreg survives from the definition to the DBG_VALUE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:16,Deployability,update,updates,16,/// This method updates local state so that we know that PhysReg is the; /// proper container for VirtReg now. The physical register must not be used; /// for anything else when this is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a physical register for VirtReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:32,Availability,error,error,32,// Nothing we can do: Report an error and keep going with an invalid; // allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:154,Performance,perform,perform,154,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:30,Availability,avail,available,30,"// If no physical register is available for LRI, we assign one at random; // and bail out of this function immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a register for a VirtReg use.; /// \return true if MI's MachineOperands were re-arranged/invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:16,Energy Efficiency,allocate,allocate,16,// If necessary allocate a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:126,Energy Efficiency,allocate,allocateInstruction,126,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:117,Testability,log,logic,117,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:216,Usability,clear,clear,216,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:100,Energy Efficiency,allocate,allocated,100,"/// Compute \ref DefOperandIndexes so it contains the indices of ""def"" operands; /// that are to be allocated. Those are ordered in a way that small classes,; /// early clobbers and livethroughs are allocated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:199,Energy Efficiency,allocate,allocated,199,"/// Compute \ref DefOperandIndexes so it contains the indices of ""def"" operands; /// that are to be allocated. Those are ordered in a way that small classes,; /// early clobbers and livethroughs are allocated first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate early clobbers and livethrough operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:85,Energy Efficiency,Allocate,Allocate,85,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:357,Safety,avoid,avoid,357,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate virtreg defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate virtreg uses and insert reloads as necessary.; // Implicit MOs can get moved/removed by useVirtReg(), so loop multiple; // times to ensure no operand is missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:57,Energy Efficiency,allocate,allocated,57,// Populate MayLiveAcrossBlocks in case the use block is allocated before; // the def block (removing the vreg uses).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:166,Performance,perform,perform,166,"// Allocate undef operands. This is a separate step because in a situation; // like ` = OP undef %X, %X` both operands need the same register assign; // so we should perform the normal assignment first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:49,Energy Efficiency,allocate,allocated,49,// See if this virtual register has already been allocated to a physical; // register or spilled to a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:3,Deployability,Update,Update,3,// Update every use of Reg within MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:459,Performance,optimiz,optimized,459,"//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:50,Performance,queue,queue,50,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:123,Usability,clear,clear,123,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:44,Performance,queue,queue,44,"// Register is assigned, put it back on the queue for reassignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:74,Performance,queue,queue,74,"// Prioritize live ranges by size, assigning larger ranges first.; // The queue holds (size, reg) pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,Energy Efficiency,allocate,allocated,35,// Unsplit ranges that couldn't be allocated immediately are deferred until; // everything else has been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:105,Energy Efficiency,allocate,allocated,105,// Unsplit ranges that couldn't be allocated immediately are deferred until; // everything else has been allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:180,Modifiability,variab,variable,180,// Memory operand should be considered last.; // Change the priority such that Memory operand are assigned in; // the reverse order that they came in.; // TODO: Make this a member variable and probably do something about hints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate original local ranges in linear instruction order. Since they; // are singly defined, this produces optimal coloring in the absence of; // global interference and other constraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate global and split ranges in long->short order. Long ranges that; // don't fit should be spilled (or split) ASAP so they don't create; // interference. Mark a bit to prioritize global above local ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:284,Availability,mask,masking,284,// Priority bit layout:; // 31 RS_Assign priority; // 30 Preference priority; // if (RegClassPriorityTrumpsGlobalness); // 29-25 AllocPriority; // 24 GlobalBit; // else; // 29 Global bit; // 28-24 AllocPriority; // 0-23 Size/Instr distance; // Clamp the size to fit with the priority masking scheme,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:230,Availability,avail,available,230,//===----------------------------------------------------------------------===//; // Direct Assignment; //===----------------------------------------------------------------------===//; /// tryAssign - Try to assign VirtReg to an available register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:14,Availability,avail,available,14,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:78,Usability,simpl,simple,78,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,Availability,recover,recover,45,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,Safety,recover,recover,45,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:41,Performance,cache,cached,41,"// We usually have the interfering VRegs cached so collectInterferingVRegs(); // should be fast, we may need to recalculate if when different physregs; // overlap the same register unit so we had different SubRanges queried; // against it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:22,Integrability,depend,dependent,22,// Reset interference dependent info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Safety,Abort,Abort,3,// Abort if the spill cannot be inserted at the MBB' start,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:116,Availability,down,downhill,116,"// Add constraints for use-blocks. Note that these are the only constraints; // that may add a positive bias, it is downhill from here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Safety,Abort,Abort,3,// Abort if the spill cannot be inserted at the MBB' start,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:22,Modifiability,variab,variable,22,"// Providing that the variable being spilled does not look like a loop; // induction variable, which is expensive to spill around and better; // pushed into a condition inside the loop if possible, provide a strong; // negative bias on through blocks to prevent unwanted liveness on loop; // backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:85,Modifiability,variab,variable,85,"// Providing that the variable being spilled does not look like a loop; // induction variable, which is expensive to spill around and better; // pushed into a condition inside the loop if possible, provide a strong; // negative bias on through blocks to prevent unwanted liveness on loop; // backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:181,Modifiability,variab,variable,181,"// Check that the current bundle is adding a Header + start+end of; // loop-internal blocks. If the block is indeed a header, don't make; // the NewBlocks as PrefSpill to allow the variable to be live in; // Header<->Latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:51,Performance,load,load,51,// We normally only need one spill instruction - a load or a store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:286,Performance,queue,queue,286,// Sort out the new intervals created by splitting. We get four kinds:; // - Remainder intervals should not be split again.; // - Candidate intervals can be assigned to Cand.PhysReg.; // - Block-local splits are candidates for local splitting.; // - DCE leftovers should go back on the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:74,Energy Efficiency,allocate,allocate,74,"// Remainder interval. Don't try splitting again, spill if it doesn't; // allocate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Safety,safe,safe,39,// Don't allow repeated splitting as a safe guard against looping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:60,Performance,cache,cache,60,// Discard bad candidates before we run out of interference cache cursors.; // This will only affect register classes with a lot of registers (>32).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:151,Performance,optimiz,optimized,151,"// Split the VirtReg may generate COPY instructions in multiple cold basic; // blocks, and increase code size. So we avoid it when the function is; // optimized for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:117,Safety,avoid,avoid,117,"// Split the VirtReg may generate COPY instructions in multiple cold basic; // blocks, and increase code size. So we avoid it when the function is; // optimized for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Safety,safe,safe,39,// Don't allow repeated splitting as a safe guard against looping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:365,Energy Efficiency,allocate,allocate,365,"//===----------------------------------------------------------------------===//; // Per-Block Splitting; //===----------------------------------------------------------------------===//; /// tryBlockSplit - Split a global live range around every block with uses. This; /// creates a lot of local live ranges, that will be split by tryLocalSplit if; /// they don't allocate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:29,Deployability,continuous,continuous,29,"// We know that VirtReg is a continuous interval from FirstInstr to; // LastInstr, so we don't need InterferenceQuery.; //; // Interference that overlaps an instruction is counted in both gaps; // surrounding the instruction. The exception is interference before; // StartIdx and after StopIdx.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Deployability,Update,Update,3,// Update the gaps covered by IntI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:318,Deployability,continuous,continuous,318,"// Note that it is possible to have an interval that is live-in or live-out; // while only covering a single block - A phi-def can use undef values from; // predecessors, and the block could be a single-block loop.; // We don't bother doing anything clever about such a case, we simply assume; // that the interval is continuous from FirstInstr to LastInstr. We should; // make sure that we don't do anything illegal to such an interval, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:279,Usability,simpl,simply,279,"// Note that it is possible to have an interval that is live-in or live-out; // while only covering a single block - A phi-def can use undef values from; // predecessors, and the block could be a single-block loop.; // We don't bother doing anything clever about such a case, we simply assume; // that the interval is continuous from FirstInstr to LastInstr. We should; // make sure that we don't do anything illegal to such an interval, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:42,Availability,mask,mask,42,"// If VirtReg is live across any register mask operands, compute a list of; // gaps with register masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:98,Availability,mask,masks,98,"// If VirtReg is live across any register mask operands, compute a list of; // gaps with register masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:68,Safety,risk,risk,68,"// Since we allow local split results to be split again, there is a risk of; // creating infinite loops. It is tempting to require that the new live; // ranges have less instructions than the original. That would guarantee; // convergence, but it is too strict. A live range with 3 instructions can be; // split 2+3 (including the COPY), and we want to allow that.; //; // Instead we use these rules:; //; // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the; // noop split, of course).; // 2. Require progress be made for ranges with getStage() == RS_Split2. All; // the new ranges must have fewer instructions than before the split.; // 3. New ranges with the same number of instructions are marked RS_Split2,; // smaller ranges are marked RS_New.; //; // These rules allow a 3 -> 2+3 split once, which we need. They also prevent; // excessive splitting and infinite loops.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:26,Modifiability,extend,extended,26,// Should the interval be extended or shrunk?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:35,Energy Efficiency,allocate,allocate,35,"// Would this split be possible to allocate?; // Never allocate all gaps, we wouldn't be making progress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:55,Energy Efficiency,allocate,allocate,55,"// Would this split be possible to allocate?; // Never allocate all gaps, we wouldn't be making progress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:10,Modifiability,extend,extend,10,// Try to extend the interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:1004,Availability,avail,available,1004,"/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring; /// its interferences.; /// Last chance recoloring chooses a color for \p VirtReg and recolors every; /// virtual register that was using it. The recoloring process may recursively; /// use the last chance recoloring. Therefore, when a virtual register has been; /// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot; /// be last-chance-recolored again during this recoloring ""session"".; /// E.g.,; /// Let; /// vA can use {R1, R2 }; /// vB can use { R2, R3}; /// vC can use {R1 }; /// Where vA, vB, and vC cannot be split anymore (they are reloads for; /// instance) and they all interfere.; ///; /// vA is assigned R1; /// vB is assigned R2; /// vC tries to evict vA but vA is already done.; /// Regular register allocation fails.; ///; /// Last chance recoloring kicks in:; /// vC does as if vA was evicted => vC uses R1.; /// vC is marked as fixed.; /// vA needs to find a color.; /// None are available.; /// vA cannot evict vC: vC is a fixed virtual register now.; /// vA does as if vB was evicted => vA uses R2.; /// vB needs to find a color.; /// R3 is available.; /// Recoloring => vC = R1, vA = R2, vB = R3; ///; /// \p Order defines the preferred allocation order for \p VirtReg.; /// \p NewRegs will contain any new virtual register that have been created; /// (split, spill) during the process and that must be assigned.; /// \p FixedRegisters contains all the virtual registers that cannot be; /// recolored.; ///; /// \p RecolorStack tracks the original assignments of successfully recolored; /// registers.; ///; /// \p Depth gives the current depth of the last chance recoloring.; /// \return a physical register that can be used for VirtReg or ~0u if none; /// exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:1167,Availability,avail,available,1167,"/// tryLastChanceRecoloring - Try to assign a color to \p VirtReg by recoloring; /// its interferences.; /// Last chance recoloring chooses a color for \p VirtReg and recolors every; /// virtual register that was using it. The recoloring process may recursively; /// use the last chance recoloring. Therefore, when a virtual register has been; /// assigned a color by this mechanism, it is marked as Fixed, i.e., it cannot; /// be last-chance-recolored again during this recoloring ""session"".; /// E.g.,; /// Let; /// vA can use {R1, R2 }; /// vB can use { R2, R3}; /// vC can use {R1 }; /// Where vA, vB, and vC cannot be split anymore (they are reloads for; /// instance) and they all interfere.; ///; /// vA is assigned R1; /// vB is assigned R2; /// vC tries to evict vA but vA is already done.; /// Regular register allocation fails.; ///; /// Last chance recoloring kicks in:; /// vC does as if vA was evicted => vC uses R1.; /// vC is marked as fixed.; /// vA needs to find a color.; /// None are available.; /// vA cannot evict vC: vC is a fixed virtual register now.; /// vA does as if vB was evicted => vA uses R2.; /// vB needs to find a color.; /// R3 is available.; /// Recoloring => vC = R1, vA = R2, vB = R3; ///; /// \p Order defines the preferred allocation order for \p VirtReg.; /// \p NewRegs will contain any new virtual register that have been created; /// (split, spill) during the process and that must be assigned.; /// \p FixedRegisters contains all the virtual registers that cannot be; /// recolored.; ///; /// \p RecolorStack tracks the original assignments of successfully recolored; /// registers.; ///; /// \p Depth gives the current depth of the last chance recoloring.; /// \return a physical register that can be used for VirtReg or ~0u if none; /// exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:163,Performance,perform,perform,163,// RecoloringCandidates contains all the virtual registers that interfere; // with VirtReg on PhysReg (or one of its aliases). Enqueue them for; // recoloring and perform the actual recoloring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:137,Availability,avail,available,137,// Do as if VirtReg was assigned to PhysReg so that the underlying; // recoloring has the right information about the interferes and; // available colors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:12,Performance,queue,queued,12,// Push the queued vregs into the main queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,Performance,queue,queue,39,// Push the queued vregs into the main queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:34,Usability,undo,undo,34,"// The recoloring attempt failed, undo the changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:251,Performance,Perform,Perform,251,"// Roll back our unsuccessful recoloring. Also roll back any successful; // recolorings in any recursive recoloring attempts, since it's possible; // they would have introduced conflicts with assignments we will be; // restoring further up the stack. Perform all unassignments prior to; // reassigning, since sub-recolorings may have conflicted with the registers; // we are going to restore to their original assignments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Performance,Perform,Perform,3,// Perform the actual pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:98,Usability,clear,cleared,98,/// Collect the hint info for \p Reg.; /// The results are stored into \p Out.; /// \p Out is not cleared before being populated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:173,Availability,avail,available,173,"// We have a broken hint, check if it is possible to fix it by; // reusing PhysReg for the copy-related live-ranges. Indeed, we evicted; // some register and PhysReg may be available for the other live-ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:121,Security,expose,expose,121,"// At this point, the cost is either cheaper or equal. If it is; // equal, we consider this is profitable because it may expose; // more recoloring opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:58,Availability,repair,repaired,58,"/// Try to recolor broken hints.; /// Broken hints may be repaired by recoloring when an evicted variable; /// freed up a register for a larger live-range.; /// Consider the following example:; /// BB1:; /// a =; /// b =; /// BB2:; /// ...; /// = b; /// = a; /// Let us assume b gets split:; /// BB1:; /// a =; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// = a; /// Because of how the allocation work, b, c, and d may be assigned different; /// colors. Now, if a gets evicted later:; /// BB1:; /// a =; /// st a, SpillSlot; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// e = ld SpillSlot; /// = e; /// This is likely that we can assign the same register for b, c, and d,; /// getting rid of 2 copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:97,Modifiability,variab,variable,97,"/// Try to recolor broken hints.; /// Broken hints may be repaired by recoloring when an evicted variable; /// freed up a register for a larger live-range.; /// Consider the following example:; /// BB1:; /// a =; /// b =; /// BB2:; /// ...; /// = b; /// = a; /// Let us assume b gets split:; /// BB1:; /// a =; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// = a; /// Because of how the allocation work, b, c, and d may be assigned different; /// colors. Now, if a gets evicted later:; /// BB1:; /// a =; /// st a, SpillSlot; /// b =; /// BB2:; /// c = b; /// ...; /// d = c; /// = d; /// e = ld SpillSlot; /// = e; /// This is likely that we can assign the same register for b, c, and d,; /// getting rid of 2 copies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:83,Performance,queue,queue,83,"// Try to evict a less worthy live range, but only for ranges from the primary; // queue. The RS_Split ranges already failed to do this, and they should not; // get a second chance until they have been split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:156,Modifiability,variab,variable,156,"// If VirtReg has a hint and that hint is broken record this; // virtual register as a recoloring candidate for broken hint.; // Indeed, since we evicted a variable in its neighborhood it is; // likely we can at least partially recolor some of the; // copy-related live-ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:134,Energy Efficiency,allocate,allocated,134,"// The first time we see a live range, don't try to split or spill.; // Wait until the second time, when all smaller ranges have been allocated.; // This gives a better picture of the interference to split around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:18,Energy Efficiency,allocate,allocate,18,"// If we couldn't allocate a register from spilling, there is probably some; // invalid inline assembly. The base class will report it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:147,Deployability,integrat,integration,147,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:147,Integrability,integrat,integration,147,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:245,Testability,test,testing,245,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:160,Modifiability,rewrite,rewrite,160,"// Tell LiveDebugVariables about the new ranges. Ranges not being covered by; // the new regs are kept in LDV (still mapping to the old register), until; // we rewrite spilled locations in LDV at a later stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:94,Energy Efficiency,allocate,allocate,94,"// The live virtual register requesting allocation was spilled, so tell; // the caller not to allocate anything during this round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:54,Energy Efficiency,allocate,allocated,54,// Early return if there is no virtual register to be allocated to a; // physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:454,Performance,optimiz,optimized,454,"//==- RegAllocGreedy.h ------- greedy register allocator ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:3,Integrability,Interface,Interface,3,// Interface to eviction advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,Integrability,interface,interface,8,// end (interface to eviction advisers); // Interface to priority advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:44,Integrability,Interface,Interface,44,// end (interface to eviction advisers); // Interface to priority advisers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:8,Integrability,interface,interface,8,// end (interface to priority advisers),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:28,Integrability,interface,interface,28,// Shortcuts to some useful interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:201,Energy Efficiency,power,power,201,// Enum CutOffStage to keep a track whether the register allocation failed; // because of the cutoffs encountered in last chance recoloring.; // Note: This is used as bitmask. New value should be next power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Cache,Cached,4,/// Cached per-block interference maps,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Perform,Perform,4,/// Perform register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Performance,Perform,Perform,4,/// Perform region splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:719,Modifiability,variab,variables,719,"//===- RegAllocPBQP.cpp ---- PBQP Register Allocator ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a Partitioned Boolean Quadratic Programming (PBQP) based; // register allocator for LLVM. This allocator works by constructing a PBQP; // problem representing the register allocation problem under consideration,; // solving this using a PBQP solver, and mapping the solution back to a; // register assignment. If any variables are selected for spilling then spill; // code is inserted and the process repeated.; //; // The PBQP solver (pbqp.c) provided for this allocator uses a heuristic tuned; // for register allocation. For more information on PBQP for register; // allocation, see the following papers:; //; // (1) Hames, L. and Scholz, B. 2006. Nearly optimal register allocation with; // PBQP. In Proceedings of the 7th Joint Modular Languages Conference; // (JMLC'06). LNCS, vol. 4228. Springer, New York, NY, USA. 346-361.; //; // (2) Scholz, B., Eckstein, E. 2002. Register allocation for irregular; // architectures. In Proceedings of the Joint Conference on Languages,; // Compilers and Tools for Embedded Systems (LCTES'02), ACM Press, New York,; // NY, USA, 139-148.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:891,Performance,tune,tuned,891,"//===- RegAllocPBQP.cpp ---- PBQP Register Allocator ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a Partitioned Boolean Quadratic Programming (PBQP) based; // register allocator for LLVM. This allocator works by constructing a PBQP; // problem representing the register allocation problem under consideration,; // solving this using a PBQP solver, and mapping the solution back to a; // register assignment. If any variables are selected for spilling then spill; // code is inserted and the process repeated.; //; // The PBQP solver (pbqp.c) provided for this allocator uses a heuristic tuned; // for register allocation. For more information on PBQP for register; // allocation, see the following papers:; //; // (1) Hames, L. and Scholz, B. 2006. Nearly optimal register allocation with; // PBQP. In Proceedings of the 7th Joint Modular Languages Conference; // (JMLC'06). LNCS, vol. 4228. Springer, New York, NY, USA. 346-361.; //; // (2) Scholz, B., Eckstein, E. 2002. Register allocation for irregular; // architectures. In Proceedings of the Joint Conference on Languages,; // Compilers and Tools for Embedded Systems (LCTES'02), ACM Press, New York,; // NY, USA, 139-148.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:4,Performance,Perform,Perform,4,/// Perform register allocation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:232,Availability,avail,available,232,"/// Inst which is a def of an original reg and whose defs are already all; /// dead after remat is saved in DeadRemats. The deletion of such inst is; /// postponed till all the allocations are done, so its remat expr is; /// always available for the remat of all the siblings of the original reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:47,Energy Efficiency,allocate,allocate,47,/// Finds the initial set of vreg intervals to allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:74,Modifiability,variab,variables,74,"/// Postprocessing before final spilling. Sets basic block ""live in""; /// variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:39,Performance,queue,queue,39,"// Condition reversed because priority queue has the *highest* element at; // the front, rather than the lowest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:104,Performance,cache,cache,104,"// Interferenc matrices are incredibly regular - they're only a function of; // the allowed sets, so we cache them to avoid the overhead of constructing; // and uniquing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:118,Safety,avoid,avoid,118,"// Interferenc matrices are incredibly regular - they're only a function of; // the allowed sets, so we cache them to avoid the overhead of constructing; // and uniquing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:77,Performance,cache,cache,77,// Finding an edge is expensive in the worst case (O(max_clique(G))). So; // cache locally edges we have already seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:3,Performance,Cache,Cache,3,// Cache known disjoint allowed registers pairs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:11,Usability,usab,usable,11,// preg is usable for this virtual register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:71,Energy Efficiency,allocate,allocate,71,// Copy any newly inserted live intervals into the list of regs to; // allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:3,Usability,Clear,Clear,3,// Clear the existing allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:9,Energy Efficiency,allocate,allocate,9,// First allocate registers for the empty intervals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:36,Energy Efficiency,allocate,allocate,36,// If there are non-empty intervals allocate them using pbqp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:24,Energy Efficiency,allocate,allocate,24,"// Finalise allocation, allocate empty ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h:4,Integrability,Interface,Interface,4,"/// Interface to the priority advisor, which is responsible for prioritizing; /// live ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPriorityAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp:633,Performance,load,loads,633,"//===- RegAllocScore.cpp - evaluate regalloc policy quality ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h:632,Performance,load,loads,632,"//==- RegAllocScore.h - evaluate regalloc policy quality ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp:60,Availability,alive,alive,60,// There must be only one instance of a given register bank alive; // for the whole compilation.; // The RegisterBankInfo is supposed to enforce that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBank.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:39,Availability,avail,available,39,// The mapping of the registers may be available via the; // register class constraints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:38,Usability,simpl,simply,38,"// If nothing was set or the class is simply compatible, set it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:78,Availability,avail,available,78,// Before doing anything complicated check if the mapping is not; // directly available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:4,Security,Hash,Hashing,4,/// Hashing function for PartialMapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:93,Security,hash,hash,93,"// The addresses of the value mapping are unique.; // Therefore, we can use them directly to hash the operand mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:67,Security,hash,hash,67,"// Create the array of ValueMapping.; // Note: this array will not hash to this instance of operands; // mapping, because we use the pointer of the ValueMapping; // to hash and we expect them to uniquely identify an instance; // of value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:168,Security,hash,hash,168,"// Create the array of ValueMapping.; // Note: this array will not hash to this instance of operands; // mapping, because we use the pointer of the ValueMapping; // to hash and we expect them to uniquely identify an instance; // of value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:28,Availability,avail,available,28,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:210,Performance,cache,cache,210,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:86,Security,access,access,86,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:72,Security,access,accessed,72,// The original value should completely be mapped.; // Thus the maximum accessed index + 1 is the size of the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:36,Security,access,access,36,// This is the first time we try to access OpIdx.; // Create the cells that will hold all the partial values at the; // end of the list of NewVReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:559,Integrability,depend,depend,559,"//===- RegisterClassInfo.cpp - Dynamic Register Class Info ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RegisterClassInfo class which provides dynamic; // information about target register classes. Callee-saved vs. caller-saved and; // reserved registers depend on calling conventions and other dynamic; // information, so some things cannot be determined statically.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new array the first time we see a new target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:3,Testability,Test,Test,3,// Test if CSRs have changed from the previous function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:14,Performance,cache,cached,14,// Invalidate cached information from previous function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:104,Usability,simpl,simply,104,"// FIXME: Once targets reserve registers instead of removing them from the; // allocation order, we can simply use begin/end here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:29,Testability,test,test,29,// Register allocator stress test. Clip register class to N registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:96,Energy Efficiency,Power,PowerPC,96,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:109,Safety,Avoid,Avoid,109,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:59,Integrability,Interface,Interface,59,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:434,Integrability,interface,interface,434,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:476,Integrability,interface,interface,476,"//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic RegisterCoalescer interface which; // is used as the common interface used by all clients and; // implementations of register coalescing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:22,Testability,test,test,22,/// Temporary flag to test critical edge unsplitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,Performance,optimiz,optimization,39,/// Temporary flag to test global copy optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:22,Testability,test,test,22,/// Temporary flag to test global copy optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:10,Modifiability,variab,variable,10,"/// Debug variable location tracking -- for each VReg, maintain an; /// ordered-by-slot-index set of DBG_VALUEs, to help quick; /// identification of whether coalescing may change location validity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:60,Deployability,update,updated,60,/// The collection of live intervals which should have been updated; /// immediately after rematerialiation but delayed until; /// lateLiveIntervalUpdate is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:107,Deployability,update,update,107,"/// If one def has many copy like uses, and those copy uses are all; /// rematerialized, the live interval update needed for those; /// rematerializations will be delayed and done all at once instead; /// of being done multiple times. This is to save compile cost because; /// live interval update is costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:291,Deployability,update,update,291,"/// If one def has many copy like uses, and those copy uses are all; /// rematerialized, the live interval update needed for those; /// rematerializations will be delayed and done all at once instead; /// of being done multiple times. This is to save compile cost because; /// live interval update is costly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:44,Availability,failure,failure,44,"/// Attempt to join these two intervals. On failure, this; /// returns false. The output ""SrcInt"" will not have been modified, so we; /// can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:172,Deployability,update,update,172,"/// Attempt to join these two intervals. On failure, this; /// returns false. The output ""SrcInt"" will not have been modified, so we; /// can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:54,Deployability,update,update,54,"/// Replace all defs and uses of SrcReg to DstReg and update the subregister; /// number if it is not zero. If DstReg is a physical register and the; /// existing subregister number of the def / use being updated is not zero,; /// make sure to set it to the correct physical subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:205,Deployability,update,updated,205,"/// Replace all defs and uses of SrcReg to DstReg and update the subregister; /// number if it is not zero. If DstReg is a physical register and the; /// existing subregister number of the def / use being updated is not zero,; /// make sure to set it to the correct physical subregister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:562,Security,expose,exposes,562,"/// Check whether or not we should apply the terminal rule on the; /// destination (Dst) of \p Copy.; /// When the terminal rule applies, Copy is not profitable to; /// coalesce.; /// Dst is terminal if it has exactly one affinity (Dst, Src) and; /// at least one interference (Dst, Dst2). If Dst is terminal, the; /// terminal rule consists in checking that at least one of; /// interfering node, say Dst2, has an affinity of equal or greater; /// weight with Src.; /// In that case, Dst2 and Dst will not be able to be both coalesced; /// with Src. Since Dst2 exposes more coalescing opportunities than; /// Dst, we can drop \p Copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Integrability,Wrap,Wrapper,4,/// Wrapper method for \see LiveIntervals::shrinkToUses.; /// This method does the proper fixing of the live-ranges when the afore; /// mentioned method returns true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Integrability,Wrap,Wrapper,4,/// Wrapper Method to do all the necessary work when an Instruction is; /// deleted.; /// Optimizations should use this to make sure that deleted instructions; /// are always accounted for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:90,Performance,Optimiz,Optimizations,90,/// Wrapper Method to do all the necessary work when an Instruction is; /// deleted.; /// Optimizations should use this to make sure that deleted instructions; /// are always accounted for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:4,Testability,Test,Test,4,"/// Test whether, after merging, any DBG_VALUEs would refer to a; /// different value number than before merging, and whether this can; /// be resolved. If not, mark the DBG_VALUE as being undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:220,Usability,Simpl,Simple,220,"/// Return true if this block should be vacated by the coalescer to eliminate; /// branches. The important cases to handle in the coalescer are critical edges; /// split during phi elimination which contain only copies. Simple blocks that; /// contain non-branches should also be vacated, but this can be handled by an; /// earlier pass similar to early if-conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:404,Modifiability,extend,extended,404,"// We have a non-trivially-coalescable copy with IntA being the source and; // IntB being the dest, thus this defines a value number in IntB. If the; // source value number (in IntA) is defined by a copy from B, see if we can; // merge these two pieces of B into a single value number, eliminating a copy.; // For example:; //; // A3 = B0; // ...; // B1 = A3 <- this copy; //; // In this case, B0 can be extended to where the B1 copy lives, allowing the; // B1 value number to be replaced with B0 (which simplifies the B; // liveinterval).; // BValNo is a value number in B that is defined by a copy from A. 'B1' in; // the example above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:504,Usability,simpl,simplifies,504,"// We have a non-trivially-coalescable copy with IntA being the source and; // IntB being the dest, thus this defines a value number in IntB. If the; // source value number (in IntA) is defined by a copy from B, see if we can; // merge these two pieces of B into a single value number, eliminating a copy.; // For example:; //; // A3 = B0; // ...; // B1 = A3 <- this copy; //; // In this case, B0 can be extended to where the B1 copy lives, allowing the; // B1 value number to be replaced with B0 (which simplifies the B; // liveinterval).; // BValNo is a value number in B that is defined by a copy from A. 'B1' in; // the example above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:107,Deployability,Update,Update,107,"// We are about to delete CopyMI, so need to remove it as the 'instruction; // that defines this value #'. Update the valnum with the new defining; // instruction #.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:58,Modifiability,extend,extend,58,"// The subrange may have ended before FillerStart. If so, extend it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:137,Modifiability,extend,extended,137,"// If the source instruction was killing the source register before the; // merge, unset the isKill marker given the live range has been extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:132,Performance,perform,perform,132,"// If some of the uses of IntA.reg is already coalesced away, return false.; // It's not possible to determine whether it's safe to perform the coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:124,Safety,safe,safe,124,"// If some of the uses of IntA.reg is already coalesced away, return false.; // It's not possible to determine whether it's safe to perform the coalescing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Modifiability,rewrite,rewrite,42,"// If this use is tied to a def, we can't rewrite the register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:153,Deployability,Update,Update,153,"// If ALR and BLR overlaps and end of BLR extends beyond end of ALR, e.g.; // A = or A, B; // ...; // B = A; // ...; // C = killed A; // ...; // = B; // Update uses of IntA of the specific Val# with IntB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Modifiability,extend,extends,42,"// If ALR and BLR overlaps and end of BLR extends beyond end of ALR, e.g.; // A = or A, B; // ...; // B = A; // ...; // C = killed A; // ...; // = B; // Update uses of IntA of the specific Val# with IntB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:52,Usability,clear,clear,52,// FIXME These don't have an instruction index. Not clear we have enough; // info to decide whether to do this replacement or not. For now do it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:84,Deployability,update,updated,84,// Extend BValNo by merging in IntA live segments of AValNo. Val# definition; // is updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Extend,Extend,3,// Extend BValNo by merging in IntA live segments of AValNo. Val# definition; // is updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,Availability,redundant,redundant,198,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,Safety,redund,redundant,198,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:880,Safety,redund,redundancy,880,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:143,Deployability,update,updated,143,"// If CopyLeftBB is nullptr, it means every predecessor of MBB contains; // reverse copy, CopyMI can be removed trivially if only IntA/IntB is updated.; // If CopyLeftBB is not nullptr, move CopyMI from MBB to CopyLeftBB and; // update IntA/IntB.; //; // If CopyLeftBB is not nullptr, ensure CopyLeftBB has a single succ so; // MBB is hotter than CopyLeftBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:229,Deployability,update,update,229,"// If CopyLeftBB is nullptr, it means every predecessor of MBB contains; // reverse copy, CopyMI can be removed trivially if only IntA/IntB is updated.; // If CopyLeftBB is not nullptr, move CopyMI from MBB to CopyLeftBB and; // update IntA/IntB.; //; // If CopyLeftBB is not nullptr, ensure CopyLeftBB has a single succ so; // MBB is hotter than CopyLeftBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update the liveness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:127,Modifiability,extend,extending,127,"// We're introducing an undef phi def, and need to set undef on any users of; // the previously local def to avoid artifically extending the lifetime; // through the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:109,Safety,avoid,avoid,109,"// We're introducing an undef phi def, and need to set undef on any users of; // the previously local def to avoid artifically extending the lifetime; // through the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Extend,Extend,3,// Extend IntB to the EndPoints of its original live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:25,Modifiability,extend,extended,25,"// If any dead defs were extended, truncate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:12,Deployability,update,update,12,"// Finally, update the live-range of IntA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:163,Performance,perform,performance,163,"// If both SrcIdx and DstIdx are set, correct rematerialization would widen; // the register substantially (beyond both source and dest size). This is bad; // for performance since it can cascade through a function, introducing many; // extra spills and fills (e.g. ARM can easily end up copying QQQQPR registers; // around after a few subreg copies).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:185,Usability,simpl,simply,185,"// In a situation like the following:; // %0:subreg = instr ; DefMI, subreg = DstIdx; // %1 = copy %0:subreg ; CopyMI, SrcIdx = 0; // instead of widening %1 to the register class of %0 simply do:; // %1 = instr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:487,Energy Efficiency,reduce,reduced,487,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:515,Integrability,depend,depending,515,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:84,Deployability,update,updated,84,"// We're only expecting another def of the main output, so the range; // should get updated with the regular output range.; //; // FIXME: The range updating below probably needs updating to look at; // the super register if subranges are tracked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update machine operands and add flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,update,updateRegDefUses,3,"// updateRegDefUses can add an ""undef"" flag to the definition, since; // it will replace DstReg with DstReg.DstIdx. If NewIdx is 0, make; // sure that ""undef"" is not set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:267,Performance,LOAD,LOAD,267,"// Add dead subregister definitions if we are defining the whole register; // but only part of it is live.; // This could happen if the rematerialization instruction is rematerializing; // more than actually is used in the register.; // An example would be:; // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs; // ; Copying only part of the register here, but the rest is undef.; // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit; // ==>; // ; Materialize all the constants but only using one; // %2 = LOAD_CONSTANTS 5, 8; //; // at this point for the part that wasn't defined before we could have; // subranges missing the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:289,Performance,Load,Loading,289,"// Add dead subregister definitions if we are defining the whole register; // but only part of it is live.; // This could happen if the rematerialization instruction is rematerializing; // more than actually is used in the register.; // An example would be:; // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs; // ; Copying only part of the register here, but the rest is undef.; // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit; // ==>; // ; Materialize all the constants but only using one; // %2 = LOAD_CONSTANTS 5, 8; //; // at this point for the part that wasn't defined before we could have; // subranges missing the definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:109,Performance,LOAD,LOAD,109,"// Make sure that the subrange for resultant undef is removed; // For example:; // %1:sub1<def,read-undef> = LOAD CONSTANT 1; // %2 = COPY %1; // ==>; // %2:sub1<def, read-undef> = LOAD CONSTANT 1; // ; Correct but need to remove the subrange for %2:sub0; // ; as it is now undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:181,Performance,LOAD,LOAD,181,"// Make sure that the subrange for resultant undef is removed; // For example:; // %1:sub1<def,read-undef> = LOAD CONSTANT 1; // %2 = COPY %1; // ==>; // %2:sub1<def, read-undef> = LOAD CONSTANT 1; // ; Correct but need to remove the subrange for %2:sub0; // ; as it is now undef",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:129,Deployability,update,updateRegDefUses,129,"// We may not have a defined value at this point, but still need to; // clear out any empty subranges tentatively created by; // updateRegDefUses. The original subrange def may have only undefed; // some lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:72,Usability,clear,clear,72,"// We may not have a defined value at this point, but still need to; // clear out any empty subranges tentatively created by; // updateRegDefUses. The original subrange def may have only undefed; // some lanes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:154,Deployability,update,updateRegDefUses,154,"// We know that this lane is defined by this instruction,; // but at this point it may be empty because it is not used by; // anything. This happens when updateRegDefUses adds the missing; // lanes. Assign that lane a dead def so that the interferences; // are properly modeled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:110,Modifiability,variab,variables,110,"// Record small dead def live-ranges for all the subregisters; // of the destination register.; // Otherwise, variables that live through may miss some; // interferences, thus creating invalid allocation.; // E.g., i386 code:; // %1 = somedef ; %1 GR8; // %2 = remat ; %2 GR32; // CL = COPY %2.sub_8bit; // = somedef %1 ; %1 GR8; // =>; // %1 = somedef ; %1 GR8; // dead ECX = remat ; implicit-def CL; // = somedef %1 ; %1 GR8; // %1 will see the interferences with CL but not with CH since; // no live-ranges would have been created for ECX.; // Fix that!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:51,Deployability,update,update,51,"// If the virtual SrcReg is completely eliminated, update all DBG_VALUEs; // to describe DstReg instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:90,Modifiability,variab,variables,90,"// ProcessImplicitDefs may leave some copies of <undef> values, it only; // removes local variables. When we have a copy like:; //; // %1 = COPY undef %2; //; // We delete the copy and remove the corresponding value number from %1.; // Any uses of that value number are marked as <undef>.; // Note that we do not query CoalescerPair here but redo isMoveInstr as the; // CoalescerPair may have a new register class with adjusted subreg indices; // at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:15,Usability,simpl,simple,15,"// Always join simple intervals that are defined by a single copy from a; // reserved register. This doesn't increase register pressure, so it is; // always beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,Availability,failure,failure,49,"// Okay, attempt to join these two intervals. On failure, this returns false.; // Otherwise, if one of the intervals being joined is a physreg, this method; // always canonicalizes DstInt to be it. The output ""SrcInt"" will not have; // been modified, so we can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:291,Deployability,update,update,291,"// Okay, attempt to join these two intervals. On failure, this returns false.; // Otherwise, if one of the intervals being joined is a physreg, this method; // always canonicalizes DstInt to be it. The output ""SrcInt"" will not have; // been modified, so we can use this information below to update aliases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:51,Deployability,update,update,51,// Rewrite all SrcReg operands to DstReg.; // Also update DstReg operands to include DstIdx if it is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all SrcReg operands to DstReg.; // Also update DstReg operands to include DstIdx if it is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:185,Deployability,update,update,185,"// CP.getSrcReg()'s live interval has been merged into CP.getDstReg's live; // interval. Since CP.getSrcReg() is in ToBeUpdated set and its live interval; // is not up-to-date, need to update the merged live interval here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update regalloc hint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:334,Integrability,depend,depends,334,// Optimization for reserved registers like ESP. We can only merge with a; // reserved physreg if RHS has a single value that is a copy of DstReg.; // The live range of the reserved register will look like a set of dead defs; // - we don't properly track the live range of reserved registers.; // Deny any overlapping intervals. This depends on all the reserved; // register live ranges to look like dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Performance,Optimiz,Optimization,3,// Optimization for reserved registers like ESP. We can only merge with a; // reserved physreg if RHS has a single value that is a copy of DstReg.; // The live range of the reserved register will look like a set of dead defs; // - we don't properly track the live range of reserved registers.; // Deny any overlapping intervals. This depends on all the reserved; // register live ranges to look like dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Safety,Abort,Abort,3,// Abort if not all the regunits are reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:2900,Safety,abort,aborted,2900,"uld become an; // identity copy after joining SrcReg and DstReg. The copy instruction will; // be removed, and the value will be merged with the source value.; //; // There can be several copies back and forth, causing many values to be; // merged into one. We compute a list of ultimate values in the joined live; // range as well as a mappings from the old value numbers.; //; // 2. IMPLICIT_DEF. This instruction is only inserted to ensure all PHI; // predecessors have a live out value. It doesn't cause real interference,; // and can be merged into the value it overlaps. Like a coalescable copy, it; // can be erased after joining.; //; // 3. Copy of external value. The overlapping def may be a copy of a value that; // is already in the other register. This is like a coalescable copy, but; // the live range of the source register must be trimmed after erasing the; // copy instruction:; //; // %src = COPY %ext; // %dst = COPY %ext <-- Remove this COPY, trim the live range of %ext.; //; // 4. Clobbering undefined lanes. Vector registers are sometimes built by; // defining one lane at a time:; //; // %dst:ssub0<def,read-undef> = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // The live range of %src overlaps the %dst value defined by FOO, but; // merging %src into %dst:ssub1 is only going to clobber the ssub1 lane; // which was undef anyway.; //; // The value mapping is more complicated in this case. The final live range; // will have different value numbers for both FOO and BAR, but there is no; // simple mapping from old to new values. It may even be necessary to add; // new PHI values.; //; // 5. Clobbering dead lanes. A def may clobber a lane of a vector register that; // is live, but never read. This can happen because we don't compute; // individual live ranges per lane.; //; // %dst = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // This kind of interference is only resolved locally. If the clobbered; // lane value escapes the block, the join is aborted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:2433,Usability,simpl,simple,2433,"uld become an; // identity copy after joining SrcReg and DstReg. The copy instruction will; // be removed, and the value will be merged with the source value.; //; // There can be several copies back and forth, causing many values to be; // merged into one. We compute a list of ultimate values in the joined live; // range as well as a mappings from the old value numbers.; //; // 2. IMPLICIT_DEF. This instruction is only inserted to ensure all PHI; // predecessors have a live out value. It doesn't cause real interference,; // and can be merged into the value it overlaps. Like a coalescable copy, it; // can be erased after joining.; //; // 3. Copy of external value. The overlapping def may be a copy of a value that; // is already in the other register. This is like a coalescable copy, but; // the live range of the source register must be trimmed after erasing the; // copy instruction:; //; // %src = COPY %ext; // %dst = COPY %ext <-- Remove this COPY, trim the live range of %ext.; //; // 4. Clobbering undefined lanes. Vector registers are sometimes built by; // defining one lane at a time:; //; // %dst:ssub0<def,read-undef> = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // The live range of %src overlaps the %dst value defined by FOO, but; // merging %src into %dst:ssub1 is only going to clobber the ssub1 lane; // which was undef anyway.; //; // The value mapping is more complicated in this case. The final live range; // will have different value numbers for both FOO and BAR, but there is no; // simple mapping from old to new values. It may even be necessary to add; // new PHI values.; //; // 5. Clobbering dead lanes. A def may clobber a lane of a vector register that; // is live, but never read. This can happen because we don't compute; // individual live ranges per lane.; //; // %dst = FOO; // %src = BAR; // %dst:ssub1 = COPY %src; //; // This kind of interference is only resolved locally. If the clobbered; // lane value escapes the block, the join is aborted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:16,Usability,simpl,simply,16,"/// No overlap, simply keep this value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,Safety,Abort,Abort,27,/// Unresolvable conflict. Abort the join.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:40,Availability,mask,masks,40,"/// Per-value info for LI. The lane bit masks are all relative to the final; /// joined register, so they can be compared directly between SrcReg and; /// DstReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:79,Safety,safe,safe,79,/// Lanes with defined values in this register. Other lanes are undef and; /// safe to clobber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:217,Safety,safe,safely,217,/// Is this value an IMPLICIT_DEF that can be erased?; ///; /// IMPLICIT_DEF values should only exist at the end of a basic block that; /// is a predecessor to a phi-value. These IMPLICIT_DEF instructions can be; /// safely erased if they are overlapping a live value in the other live; /// interval.; ///; /// Weird control flow graphs and incomplete PHI handling in; /// ProcessImplicitDefs can very rarely create IMPLICIT_DEF values with; /// longer live ranges. Such IMPLICIT_DEF values should be treated like; /// normal values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,Availability,redundant,redundant,149,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:266,Deployability,update,updated,266,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,Safety,redund,redundant,149,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:126,Integrability,depend,depend,126,/// Compute the bitmask of lanes actually written by DefMI.; /// Set Redef if there are any partial register definitions that depend on the; /// previous value of the register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:663,Modifiability,extend,extend,663,"/// Assuming ValNo is going to clobber some valid lanes in Other.LR, compute; /// the extent of the tainted lanes in the block.; ///; /// Multiple values in Other.LR can be affected since partial redefinitions; /// can preserve previously tainted lanes.; ///; /// 1 %dst = VLOAD <-- Define all lanes in %dst; /// 2 %src = FOO <-- ValNo to be joined with %dst:ssub0; /// 3 %dst:ssub1 = BAR <-- Partial redef doesn't clear taint in ssub0; /// 4 %dst:ssub0 = COPY %src <-- Conflict resolved, ssub0 wasn't read; ///; /// For each ValNo in Other that is affected, add an (EndIndex, TaintedLanes); /// entry to TaintedVals.; ///; /// Returns false if the tainted lanes extend beyond the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:415,Usability,clear,clear,415,"/// Assuming ValNo is going to clobber some valid lanes in Other.LR, compute; /// the extent of the tainted lanes in the block.; ///; /// Multiple values in Other.LR can be affected since partial redefinitions; /// can preserve previously tainted lanes.; ///; /// 1 %dst = VLOAD <-- Define all lanes in %dst; /// 2 %src = FOO <-- ValNo to be joined with %dst:ssub0; /// 3 %dst:ssub1 = BAR <-- Partial redef doesn't clear taint in ssub0; /// 4 %dst:ssub0 = COPY %src <-- Conflict resolved, ssub0 wasn't read; ///; /// For each ValNo in Other that is affected, add an (EndIndex, TaintedLanes); /// entry to TaintedVals.; ///; /// Returns false if the tainted lanes extend beyond the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,Availability,mask,mask,27,// Transform lanemask to a mask in the joined live interval.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:178,Usability,clear,cleared,178,"// We normally expect IMPLICIT_DEF values to be live only until the end; // of their block. If the value is really live longer and gets pruned in; // another block, this flag is cleared again.; //; // Clearing the valid lanes is deferred until it is sure this can be; // erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:201,Usability,Clear,Clearing,201,"// We normally expect IMPLICIT_DEF values to be live only until the end; // of their block. If the value is really live longer and gets pruned in; // another block, this flag is cleared again.; //; // Clearing the valid lanes is deferred until it is sure this can be; // erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:65,Safety,Avoid,Avoid,65,"// Keep this value, check for conflicts when analyzing OtherVNI. Avoid; // revisiting OtherVNI->id in JoinVals::computeAssignment() below before it; // is assigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:43,Modifiability,extend,extends,43,"// Check if OtherV is an IMPLICIT_DEF that extends beyond its basic block.; // This shouldn't normally happen, but ProcessImplicitDefs can leave such; // IMPLICIT_DEF instructions behind, and there is nothing wrong with it; // technically.; //; // When it happens, treat that IMPLICIT_DEF as a normal value, and don't try; // to erase the IMPLICIT_DEF instruction.; //; // Additionally we must keep an IMPLICIT_DEF if we're redefining an incoming; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:15,Usability,clear,clearing,15,// We deferred clearing these lanes in case we needed to save them,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:13,Usability,simpl,simple,13,// Check for simple erasable conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:44,Usability,simpl,simply,44,// This may not be a real conflict if DefMI simply kills Other and defines; // VNI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:88,Safety,safe,safe,88,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:144,Usability,simpl,simple,144,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Safety,Abort,Abort,42,// OtherI is pointing to a tainted value. Abort the join if the tainted; // lanes escape the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:23,Modifiability,extend,extend,23,// Tainted lanes would extend beyond the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:183,Usability,simpl,simply,183,"// Check if we're replacing an IMPLICIT_DEF value. The IMPLICIT_DEF; // instructions are only inserted to provide a live-out value for PHI; // predecessors, so the instruction should simply go away once its value; // has been replaced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:101,Modifiability,extend,extended,101,"// Check if the segment consists of a copied live-through value (i.e. the copy; // in the block only extended the liveness, of an undef value which we may need; // to handle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,Availability,redundant,redundant,646,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1474,Availability,redundant,redundant,1474,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1753,Modifiability,extend,extended,1753,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,Safety,redund,redundant,646,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:1474,Safety,redund,redundant,1474,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:120,Integrability,message,message,120,"// We should trigger in all cases in which eraseInstrs() does something.; // match what eraseInstrs() is doing, print a message so",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:9,Integrability,message,message,9,// Print message so mismatches with eraseInstrs() can be diagnosed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:83,Usability,simpl,simply,83,"// If V is identical to V.OtherVNI (and S was live at OtherDef),; // then we can't simply prune V from S. V needs to be replaced; // with V.OtherVNI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:123,Modifiability,extend,extending,123,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:407,Modifiability,extend,extending,407,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:541,Modifiability,extend,extended,541,"// Remove value number i from LR.; // For intervals with subranges, removing a segment from the main range; // may require extending the previous segment: for each definition of; // a subregister, there will be a corresponding def in the main range.; // That def may fall in the middle of a segment from another subrange.; // In such cases, removing this def from the main range must be; // complemented by extending the main range to account for the liveness; // of the other subrange.; // The new end point of the main range segment to be extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:10,Modifiability,extend,extend,10,// Do not extend beyond the end of the segment being removed.; // The segment may have been pruned in preparation for joining; // live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:268,Availability,mask,mask,268,"// Compute NewVNInfo and resolve conflicts (see also joinVirtRegs()); // We should be able to resolve all conflicts here as we could successfully do; // it on the mainrange already. There is however a problem when multiple; // ranges get mapped to the ""overflow"" lane mask bit which creates unexpected; // interferences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:62,Safety,Detect,Detect,62,// First compute NewVNInfo and the simple value mappings.; // Detect impossible conflicts early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:35,Usability,simpl,simple,35,// First compute NewVNInfo and the simple value mappings.; // Detect impossible conflicts early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:7,Usability,clear,clear,7,"// All clear, the live ranges can be merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,Availability,mask,masks,39,// Transform lanemasks from the LHS to masks in the coalesced register and; // create initial subranges if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:85,Deployability,update,update,85,"// If the RHS covers any PHI locations that were tracked for debug-info, we; // must update tracking information to reflect the join.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:366,Testability,Test,Test,366,"// Accept two kinds of subregister movement:; // * When we merge from one register class into a larger register:; // %1:gr16 = some-inst; // ->; // %2:gr32.sub_16bit = some-inst; // * When the PHI is already in a subregister, and the larger class; // is coalesced:; // %2:gr32.sub_16bit = some-inst; // %3:gr32 = COPY %2; // ->; // %3:gr32.sub_16bit = some-inst; // Test for subregister move:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:115,Modifiability,variab,variable,115,"// If we're moving between different subregisters, ignore this join.; // The PHI will not get a location, dropping variable locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Deployability,Update,Update,3,// Update our tracking of where the PHI is.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:71,Deployability,update,update,71,"// If we merge into a sub-register of a larger class (test above),; // update SubReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:54,Testability,test,test,54,"// If we merge into a sub-register of a larger class (test above),; // update SubReg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:99,Usability,simpl,simply,99,"// Kill flags are going to be wrong if the live ranges were overlapping.; // Eventually, we should simply clear all kill flags when computing live; // ranges. They are reinserted after register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:106,Usability,clear,clear,106,"// Kill flags are going to be wrong if the live ranges were overlapping.; // Eventually, we should simply clear all kill flags when computing live; // ranges. They are reinserted after register allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:20,Deployability,update,updates,20,// Scan for unsound updates of both the source and destination register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:75,Safety,safe,safely,75,"// If the ""Other"" register is live at a slot Idx, test whether Reg can; // safely be merged with it, or should be marked undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:50,Testability,test,test,50,"// If the ""Other"" register is live at a slot Idx, test whether Reg can; // safely be merged with it, or should be marked undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:18,Performance,perform,performance,18,"// Our worst-case performance typically happens with asan, causing very; // many DBG_VALUEs of the same location. Cache a copy of the most recent; // result for this edge-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:114,Performance,Cache,Cache,114,"// Our worst-case performance typically happens with asan, causing very; // many DBG_VALUEs of the same location. Cache a copy of the most recent; // result for this edge-case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,Availability,redundant,redundant,258,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,Safety,redund,redundant,258,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:339,Safety,safe,safe,339,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:52,Testability,test,test,52,"// ""Other"" is live and there is a DBG_VALUE of Reg: test if we should; // set it undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,Safety,avoid,avoid,49,"// Mark undef, erase record of this DBG_VALUE to avoid revisiting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Usability,Clear,Clear,3,// Clear instructions not recorded in `ErasedInstrs` but erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:110,Deployability,update,update,110,"// Technically we should check if the weight of the new copy is; // interesting compared to the other one and update the weight; // of the copies accordingly. However, this would only work if; // we would gather all the copies first then coalesce, whereas; // right now we interleave both actions.; // For now, just consider the copies that are in the same block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Modifiability,Variab,Variables,3,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:142,Modifiability,variab,variable,142,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:321,Modifiability,variab,variables,321,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:288,Safety,avoid,avoid,288,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:336,Safety,predict,predictable,336,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:170,Performance,optimiz,optimization,170,// The MachineScheduler does not currently require JoinSplitEdges. This will; // either be enabled unconditionally or replaced by a more general live range; // splitting optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:21,Deployability,update,update,21,"// After coalescing, update any PHIs that are being tracked by debug-info; // with their new VReg locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h:49,Integrability,Interface,Interface,49,"//===- RegisterCoalescer.h - Register Coalescing Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the abstract interface for register coalescers,; // allowing them to interact with and query register allocators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h:415,Integrability,interface,interface,415,"//===- RegisterCoalescer.h - Register Coalescing Interface ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the abstract interface for register coalescers,; // allowing them to interact with and query register allocators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:2,Testability,assert,assert,2,"//assert((NewMask & !PrevMask) == 0 && ""Must not add bits"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:4,Usability,Clear,Clear,4,/// Clear the result so it can be used for another round of pressure tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:4,Usability,Clear,Clear,4,/// Clear the result so it can be used for another round of pressure tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:144,Deployability,update,update,144,"/// If the current top is not less than or equal to the next index, open it.; /// We happen to need the SlotIndex for the next top for pressure update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Availability,redundant,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Safety,redund,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Availability,redundant,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,Safety,redund,redundant,10,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:3,Deployability,Update,Update,3,// Update the units for this pressure set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:132,Integrability,interface,interface,132,"/// Record the upward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:700,Performance,cache,cache,700,"/// Consider the pressure increase caused by traversing this instruction; /// bottom-up. Find the pressure set with the most change beyond its pressure; /// limit based on the tracker's current pressure, and return the change in; /// number of register units of that pressure set introduced by this; /// instruction.; ///; /// This assumes that the current LiveOut set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpUpwardPressure to recompute the pressure sets based on current; /// liveness. This mainly exists to verify correctness, e.g. with; /// -verify-misched. getUpwardPressureDelta is the fast version of this query; /// that uses the per-SUnit cache of the PressureDiff.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:87,Integrability,depend,depend,87,"/// This is the fast version of querying register pressure that does not; /// directly depend on current liveness.; ///; /// @param Delta captures information needed for heuristics.; ///; /// @param CriticalPSets Are the pressure sets that are known to exceed some; /// limit within the region, not necessarily at the current position.; ///; /// @param MaxPressureLimit Is the max pressure within the region, not; /// necessarily at the current position.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:15,Availability,down,downward,15,"/// Record the downward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:134,Integrability,interface,interface,134,"/// Record the downward impact of a single instruction on current register; /// pressure. Unlike the advance/recede pressure tracking interface, this does; /// not discover live in/outs.; ///; /// This is intended for speculative queries. It leaves pressure inconsistent; /// with the current position, so must be restored by the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:100,Availability,down,down,100,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:109,Energy Efficiency,schedul,schedule,109,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:280,Energy Efficiency,schedul,scheduled,280,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:293,Safety,avoid,avoid,293,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:82,Availability,down,down,82,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the register class with the most change in its pressure limit; /// based on the tracker's current pressure, and return the number of excess; /// register units of that pressure set introduced by this instruction.; ///; /// This assumes that the current LiveIn set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpDownwardPressure to recompute the pressure sets based on current; /// liveness. We don't yet have a fast version of downward pressure tracking; /// analogous to getUpwardPressureDelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:566,Availability,down,downward,566,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the register class with the most change in its pressure limit; /// based on the tracker's current pressure, and return the number of excess; /// register units of that pressure set introduced by this instruction.; ///; /// This assumes that the current LiveIn set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpDownwardPressure to recompute the pressure sets based on current; /// liveness. We don't yet have a fast version of downward pressure tracking; /// analogous to getUpwardPressureDelta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:72,Availability,down,down,72,/// Get the pressure of each PSet after traversing this instruction top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:598,Availability,avail,available,598,"//===- RegisterScavenging.cpp - Machine register scavenging ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the machine register scavenger. It can provide; /// information, such as unused registers, at any point in a machine basic; /// block. It also provides a mechanism to make registers available by evicting; /// them to spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:27,Availability,Avail,Available,27,/// Given the bitvector \p Available of free register units at position; /// \p From. Search backwards to find a register that is part of \p; /// Candidates and not used/clobbered until the point \p To. If there is; /// multiple candidates continue searching and pick the one that is not used/; /// clobbered for the longest time.; /// Returns the register and the earliest position we know it to be free or; /// the position MBB.end() if no register is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:454,Availability,avail,available,454,/// Given the bitvector \p Available of free register units at position; /// \p From. Search backwards to find a register that is part of \p; /// Candidates and not used/clobbered until the point \p To. If there is; /// multiple candidates continue searching and pick the one that is not used/; /// clobbered for the longest time.; /// Returns the register and the earliest position we know it to be free or; /// the position MBB.end() if no register is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:11,Availability,avail,available,11,// Find an available scavenging slot with size and alignment matching; // the requirements of the class RC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Safety,Avoid,Avoid,3,"// Avoid wasting slots with large size and/or large alignment. Pick one; // that is the best fit for this register class (in street metric).; // Picking a larger slot than necessary could happen if a slot for a; // larger register is reserved before a slot for a smaller one. When; // trying to spill a smaller register, the large slot would be found; // first, thus making it impossible to spill the larger register later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:111,Testability,assert,assert,111,"// We need to scavenge a register but have no spill slot, the target; // must know how to do it (if not, we'll assert below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Safety,Avoid,Avoid,3,// Avoid infinite regress,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:12,Availability,avail,available,12,// Found an available register?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a register for the virtual register \p VReg. The last use of; /// \p VReg is around the current position of the register scavenger \p RS.; /// \p ReserveAfter controls whether the scavenged register needs to be reserved; /// after the current instruction, otherwise it will only be reserved before the; /// current instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate (scavenge) vregs inside a single basic block.; /// Returns true if the target spill callback created new vregs and a 2nd pass; /// is necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:71,Usability,simpl,simply,71,"// FIXME: Iterating over the instruction stream is unnecessary. We can simply; // iterate over the vreg use list, which at this point only contains machine; // operands for which eliminateFrameIndex need a new scratch reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:103,Testability,test,testing,103,/// This class runs register scavenging independ of the PrologEpilogInserter.; /// This is used in for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:512,Usability,simpl,simple,512,"//===-- RegUsageInfoCollector.cpp - Register Usage Information Collector --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass is simple MachineFunction pass which collects register usage; /// details by iterating through each physical registers and checking; /// MRI::isPhysRegUsed() then creates a RegMask based on this details.; /// The pass then stores this RegMask in PhysicalRegisterUsageInfo.cpp; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:115,Performance,optimiz,optimizations,115,"// TODO: Move to hook somwehere?; // Return true if it is useful to track the used registers for IPRA / no CSR; // optimizations. This is not useful for entry points, and computing the; // register usage information is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp:167,Modifiability,Rewrite,Rewrite,167,// Scan all the physical registers. When a register is defined in the current; // function set it and all the aliasing registers as defined in the regmask.; // FIXME: Rewrite to use regunits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:739,Availability,avail,available,739,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:769,Deployability,update,update,769,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp:823,Deployability,update,updated,823,"//=--- RegUsageInfoPropagate.cpp - Register Usage Informartion Propagation --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass iterates through MachineInstrs in a given MachineFunction and at; /// each callsite queries RegisterUsageInfo for RegMask (calculated based on; /// actual register allocation) of the callee function, if the RegMask detail; /// is available then this pass will update the RegMask of the call instruction.; /// This updated RegMask will be used by the register allocator while allocating; /// the current MachineFunction.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegUsageInfoPropagate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:47,Availability,Redundant,Redundant,47,"//===- RemoveRedundantDebugValues.cpp - Remove Redundant Debug Value MIs --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:47,Safety,Redund,Redundant,47,"//===- RemoveRedundantDebugValues.cpp - Remove Redundant Debug Value MIs --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,Availability,redundant,redundant,95,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,Safety,redund,redundant,95,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,Availability,redundant,redundant,11,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,Safety,redund,redundant,11,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Availability,redundant,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Safety,redund,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:27,Modifiability,variab,variable,27,"// Just stop tracking this variable, until we cover DBG_VALUE_LIST.; // 1 DBG_VALUE $rax, ""x"", DIExpression(); // ...; // 2 DBG_VALUE_LIST ""x"", DIExpression(...), $rax, $rbx; // ...; // 3 DBG_VALUE $rax, ""x"", DIExpression()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:51,Modifiability,variab,variable,51,"// If it's not a register, just stop tracking such variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:35,Modifiability,variab,variable,35,// We have found a new value for a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Availability,redundant,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:152,Modifiability,variab,variable,152,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,Safety,redund,redundant,32,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,Availability,redundant,redundant,138,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,Safety,redund,redundant,138,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:39,Modifiability,variab,variable,39,"// If we have already encountered this variable, just stop; // tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:50,Modifiability,variab,variable,50,"// We have already encountered the value for this variable,; // so this one can be deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite Machine Operands to use the new vreg belonging to their class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:108,Performance,perform,perform,108,"// Shortcut: With only 1 subrange, the normal separate component tests are; // enough and we do not need to perform the union-find on the subregister; // segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:65,Testability,test,tests,65,"// Shortcut: With only 1 subrange, the normal separate component tests are; // enough and we do not need to perform the union-find on the subregister; // segments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:85,Deployability,update,updated,85,"/// Undef use operands are not tracked in the equivalence class,; /// but need to be updated if they are tied; take care to only; /// update the tied operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp:134,Deployability,update,update,134,"/// Undef use operands are not tracked in the equivalence class,; /// but need to be updated if they are tied; take care to only; /// update the tied operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RenameIndependentSubregs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:598,Integrability,interface,interface,598,"//=== ReplaceWithVeclib.cpp - Replace vector intrinsics with veclib calls -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Replaces LLVM IR instructions with vector operands (i.e., the frem; // instruction or calls to LLVM intrinsics) with matching calls to functions; // from a vector library (e.g libmvec, SVML) using TargetLibraryInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:91,Integrability,Inject,InjectTLIMappings,91,"// Add the freshly created function to llvm.compiler.used, similar to as it; // is done in InjectTLIMappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:91,Security,Inject,InjectTLIMappings,91,"// Add the freshly created function to llvm.compiler.used, similar to as it; // is done in InjectTLIMappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:113,Availability,avail,available,113,"/// Returns true when successfully replaced \p I with a suitable function taking; /// vector arguments, based on available mappings in the \p TLI. Currently only; /// works when \p I is a call to vectorized intrinsic or the frem instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:174,Availability,mask,masked,174,"// Try to find the mapping for the scalar version of this intrinsic and the; // exact vector width of the call operands in the TargetLibraryInfo. First,; // check with a non-masked variant, and if that fails try with a masked one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:219,Availability,mask,masked,219,"// Try to find the mapping for the scalar version of this intrinsic and the; // exact vector width of the call operands in the TargetLibraryInfo. First,; // check with a non-masked variant, and if that fails try with a masked one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:2,Availability,Mask,Masked,2,/*Masked*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp:2,Availability,Mask,Masked,2,/*Masked*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReplaceWithVeclib.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp:22,Safety,abort,abort,22,/// Whether we should abort immediately instead of resetting the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:497,Energy Efficiency,allocate,allocated,497,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:7,Safety,Safe,SafeStack,7,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:23,Safety,Safe,Safe,23,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:419,Safety,safe,safe,419,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:472,Safety,unsafe,unsafe,472,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:596,Safety,Safe,SafeStack,596,"//===- SafeStack.cpp - Safe Stack Insertion -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass splits the stack into the safe stack (kept as-is for LLVM backend); // and the unsafe stack (explicitly allocated and managed through the runtime; // support library).; //; // http://clang.llvm.org/docs/SafeStack.html; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:108,Safety,safe,safe,108,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:101,Security,access,access,101,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:224,Modifiability,variab,variables,224,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:8,Safety,Safe,SafeStack,8,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:66,Safety,safe,safe,66,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:121,Safety,safe,safe,121,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:180,Safety,unsafe,unsafe,180,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:291,Safety,safe,safe,291,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:97,Security,access,accessed,97,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:243,Security,access,accessed,243,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Safety,Unsafe,Unsafe,4,/// Unsafe stack alignment. Each stack frame must ensure that the stack is; /// aligned to this value. We need to re-align the unsafe stack if the; /// alignment of any object on the stack exceeds this value.; ///; /// 16 seems like a reasonable upper bound on the alignment of objects that we; /// might expect to appear on the stack on most common targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:127,Safety,unsafe,unsafe,127,/// Unsafe stack alignment. Each stack frame must ensure that the stack is; /// aligned to this value. We need to re-align the unsafe stack if the; /// alignment of any object on the stack exceeds this value.; ///; /// 16 seems like a reasonable upper bound on the alignment of objects that we; /// might expect to appear on the stack on most common targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:34,Deployability,canary,canary,34,/// Return the value of the stack canary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Performance,Load,Load,4,/// Load stack guard from the frame and check if it has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:222,Energy Efficiency,allocate,allocated,222,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:107,Safety,unsafe,unsafe,107,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:168,Safety,unsafe,unsafe,168,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:191,Safety,unsafe,unsafe,191,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:128,Modifiability,variab,variable,128,/// Generate code to restore the stack after all stack restore points; /// in \p StackRestorePoints.; ///; /// \returns A local variable in which to maintain the dynamic top of the; /// unsafe stack if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:186,Safety,unsafe,unsafe,186,/// Generate code to restore the stack after all stack restore points; /// in \p StackRestorePoints.; ///; /// \returns A local variable in which to maintain the dynamic top of the; /// unsafe stack if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:58,Energy Efficiency,allocate,allocate,58,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:97,Safety,unsafe,unsafe,97,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:132,Safety,unsafe,unsafe,132,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:24,Safety,unsafe,unsafe,24,// Non-constant size => unsafe. FIXME: try SCEV getRange.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:56,Safety,safe,safe,56,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:173,Safety,safe,safe,173,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:152,Security,access,accessed,152,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:80,Energy Efficiency,allocate,allocated,80,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:131,Safety,safe,safe,131,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:184,Safety,safe,safe,184,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:60,Security,access,accesses,60,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:30,Safety,safe,safe,30,"// ""va-arg"" from a pointer is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:56,Safety,unsafe,unsafe,56,// Stored the pointer - conservatively assume it may be unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:234,Safety,safe,safe,234,"// LLVM 'nocapture' attribute is only set for arguments whose address; // is not stored, passed around, or used in any other non-trivial way.; // We assume that passing a pointer to an object as a 'nocapture; // readnone' argument is safe.; // FIXME: a more precise solution would require an interprocedural; // analysis here, which would look at all uses of an argument inside; // the function being called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:30,Safety,safe,safe,30,"// All uses of the alloca are safe, we can place it on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:59,Safety,safe,safe,59,"// All uses of the alloca are safe, we can place it on the safe stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:174,Modifiability,variab,variable,174,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:38,Safety,unsafe,unsafe,38,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:66,Safety,unsafe,unsafe,66,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:118,Safety,unsafe,unsafe,118,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:29,Availability,down,down,29,// Unsafe stack always grows down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Safety,Unsafe,Unsafe,3,// Unsafe stack always grows down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:28,Safety,unsafe,unsafe,28,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:60,Safety,unsafe,unsafe,60,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:88,Deployability,update,updated,88,"// PHI nodes may have multiple incoming edges from the same BB (why??),; // all must be updated at once with the same incoming value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:104,Deployability,update,update,104,// Re-align BasePointer so that our callees would see it aligned as; // expected.; // FIXME: no need to update BasePointer in leaf functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Deployability,Update,Update,3,// Update shadow stack pointer in the function epilogue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:168,Safety,unsafe,unsafe,168,"// Collect all points where stack gets unwound and needs to be restored; // This is only necessary because the runtime (setjmp and unwind code) is; // not aware of the unsafe stack and won't unwind/restore it properly.; // To work around this problem without changing the runtime, we insert; // instrumentation to restore the unsafe stack pointer when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:326,Safety,unsafe,unsafe,326,"// Collect all points where stack gets unwound and needs to be restored; // This is only necessary because the runtime (setjmp and unwind code) is; // not aware of the unsafe stack and won't unwind/restore it properly.; // To work around this problem without changing the runtime, we insert; // instrumentation to restore the unsafe stack pointer when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:81,Safety,unsafe,unsafe,81,"// Find all static and dynamic alloca instructions that must be moved to the; // unsafe stack, all return instructions and stack restore points.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:25,Safety,unsafe,unsafe,25,// This function has the unsafe stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Performance,Load,Load,3,// Load the current stack pointer (we'll also use it as a base pointer).; // FIXME: use a dedicated register for it ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:71,Energy Efficiency,allocate,allocated,71,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:18,Safety,unsafe,unsafe,18,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:41,Safety,unsafe,unsafe,41,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:69,Deployability,update,updated,69,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:132,Energy Efficiency,allocate,allocated,132,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Safety,Safe,Safe,3,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:45,Safety,unsafe,unsafe,45,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:84,Safety,unsafe,unsafe,84,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:333,Safety,unsafe,unsafe,333,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:15,Safety,unsafe,unsafe,15,// Restore the unsafe stack pointer before each return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:117,Safety,avoid,avoid,117,"// Do we already have a DominatorTree avaliable from the previous pass?; // Note that we should *NOT* require it, to avoid the case where we end up; // not needing it, but the legacy PM would have computed it for us anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:7,Safety,Safe,SafeStackLayout,7,"//===- SafeStackLayout.cpp - SafeStack frame layout -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:29,Safety,Safe,SafeStack,29,"//===- SafeStackLayout.cpp - SafeStack frame layout -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:3,Deployability,Update,Update,3,// Update live ranges for all affected regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:296,Energy Efficiency,reduce,reduce,296,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:3,Usability,Simpl,Simple,3,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:7,Safety,Safe,SafeStackLayout,7,"//===- SafeStackLayout.h - SafeStack frame layout --------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:27,Safety,Safe,SafeStack,27,"//===- SafeStackLayout.h - SafeStack frame layout --------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:29,Safety,unsafe,unsafe,29,/// Compute the layout of an unsafe stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:17,Safety,safe,safestack,17,// end namespace safestack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:7,Security,Sanitiz,SanitizerBinaryMetadata,7,"//===- SanitizerBinaryMetadata.cpp; //----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:415,Security,Sanitiz,SanitizerBinaryMetadata,415,"//===- SanitizerBinaryMetadata.cpp; //----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp:18,Deployability,update,update,18,"// Non-zero size, update metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:7,Energy Efficiency,Schedul,ScheduleDAG,7,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:39,Energy Efficiency,Schedul,ScheduleDAG,39,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:405,Energy Efficiency,Schedul,ScheduleDAG,405,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:459,Energy Efficiency,schedul,scheduling,459,"//===- ScheduleDAG.cpp - Implement the ScheduleDAG class ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is a base class used by; /// scheduling implementation classes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,Availability,redundant,redundant,57,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:33,Integrability,depend,dependence,33,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,Safety,redund,redundant,57,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:8,Performance,latency,latency,8,// Zero-latency weak edges may be added purely for heuristic ordering. Don't; // add them if another kind of edge already exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Modifiability,Extend,Extend,3,// Extend the latency if needed. Equivalent to; // removePred(PredDep) + addPred(D).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:14,Performance,latency,latency,14,// Extend the latency if needed. Equivalent to; // removePred(PredDep) + addPred(D).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the bookkeeping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the bookkeeping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:1241,Deployability,update,updates,1241,"// The idea of the algorithm is taken from; // ""Online algorithms for managing the topological order of; // a directed acyclic graph"" by David J. Pearce and Paul H.J. Kelly; // This is the MNR algorithm, which was first introduced by; // A. Marchetti-Spaccamela, U. Nanni and H. Rohnert in; // ""Maintaining a topological order under edge insertions"".; //; // Short description of the algorithm:; //; // Topological ordering, ord, of a DAG maps each node to a topological; // index so that for all edges X->Y it is the case that ord(X) < ord(Y).; //; // This means that if there is a path from the node X to the node Z,; // then ord(X) < ord(Z).; //; // This property can be used to check for reachability of nodes:; // if Z is reachable from X, then an insertion of the edge Z->X would; // create a cycle.; //; // The algorithm first computes a topological ordering for the DAG by; // initializing the Index2Node and Node2Index arrays and then tries to keep; // the ordering up-to-date after edge insertions by reordering the DAG.; //; // On insertion of the edge X->Y, the algorithm first marks by calling DFS; // the nodes reachable from Y, and then shifts them using Shift to lie; // immediately after X in Index2Node.; // Cancel pending updates, mark as valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:24,Integrability,depend,dependencies,24,// Is it a node without dependencies?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:10,Integrability,depend,dependencies,10,"// If all dependencies of the node are processed already,; // then the node can be computed now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:19,Deployability,update,updates,19,// Otherwise apply updates one-by-one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:81,Deployability,update,updates,81,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:113,Deployability,update,updates,113,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:53,Energy Efficiency,efficient,efficient,53,// Recomputing the order from scratch is likely more efficient than applying; // updates one-by-one for too many updates. The current cut-off is arbitrarily; // chosen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:3,Deployability,Update,Update,3,// Update the topological order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Energy Efficiency,Schedul,ScheduleDAGInstrs,10,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:410,Energy Efficiency,Schedul,ScheduleDAGInstrs,410,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:460,Energy Efficiency,schedul,scheduling,460,"//===---- ScheduleDAGInstrs.cpp - MachineInstr Rescheduling ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This implements the ScheduleDAGInstrs class, which implements; /// re-scheduling of MachineInstrs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:209,Performance,Load,Loads,209,"// Note: the two options below might be used in tuning compile time vs; // output quality. Setting HugeRegion so large that it will never be; // reached means best-effort, but may be slow.; // When Stores and Loads maps (or NonAliasStores and NonAliasLoads); // together hold this many SUs, a reduction of maps will be done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,Energy Efficiency,reduce,reduce,10,"// Always reduce a huge region with half of the elements, except; // when user sets this number explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:7,Integrability,depend,dependencies,7,// Add dependencies on the defs and uses of the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:90,Integrability,depend,dependencies,90,/// MO is an operand of SU's instruction that defines a physical register. Adds; /// data dependencies from SU to any uses of the physical register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:25,Performance,latency,latency,25,"// Only use any non-zero latency for real defs/uses, in contrast to; // ""fake"" operands added by regalloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp
